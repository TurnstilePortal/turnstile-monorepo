{
  "transpiled": true,
  "noir_version": "1.0.0-beta.3+0000000000000000000000000000000000000000",
  "name": "Beacon",
  "functions": [
    {
      "name": "init",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "admin",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "target",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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BQ0tDQ0LJwINBAMMOAUNDiQCAA4AABGxJQAAD48AKAcCDQA4DQUOLQ0ODAA4CwwNJwIMBAQMOAUMDiQCAA4AABHbJQAAD48uBAAIgAMoAIAEBAAFJQAAEqEuCIAFAAsAKAsCDAA4DAUOLQ4NDi0OBwEtDgsCLQ4JAy0OCgQjAAASFi0MBgUjAAAQ3CUAAAtVASgAAoBLAAMOOAIDBCQCAAQAABI+JQAADngNMIBGAAMABAsoAASARwADJAIAAwAAElslAAATwScCBAQDDDgCBAUkAgAFAAASciUAAA+PACgBAgQAOAQCBS0NBQMtCAEBJwICBAIAEAECAScDAQQBACgBAgItDAIELQ4DBCYuAYADgAYLAIAGAAKAByQAgAcAABK8IwAAEscuAIADgAUjAAATLi4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAABMaLgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAABLpKAGABQQAAQMAgAYAAoAGIwAAEy4mKACABgQAAgcAgASABoAFLgCABIAIKACACQQAAA0AgAmABYAKFwCACoAKJACACgAAE64DAIAIAAKACAEAgAOACYALLgGAC4AGAQCAA4AIgAsuAYALgAcBAIADgAmACy4CgAeACwEAgAOACIALLgKABoALAQCACQACgAkjAAATSyYqAQABBSiGkrBH3P1DPAEBAiYqAQABBfQu5YS79CHRPAEBAiY=",
      "debug_symbols": "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",
      "brillig_names": [
        "init"
      ]
    },
    {
      "name": "set_admin",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "new_admin",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9505266597993848748": {
            "error_kind": "string",
            "string": "Only admin can set admin"
          },
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "set_admin"
      ]
    },
    {
      "name": "process_log",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "parameters": [
          {
            "name": "_log_plaintext",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "_tx_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "_unique_note_hashes_in_tx",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 64,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "_first_nullifier_in_tx",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "_recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "16775516380094354375": {
            "error_kind": "fmtstring",
            "length": 40,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+Wc6XLbNhDHKZu0TcmyZPmK3Svp3bRpKYnU0dNt0/u+lM+KYz8HHyPta7Rf2qer/jFXWsHojDteTPxPMMOhpYV2f1wuARBYuBadl8nsqFV/x9V5vTrj+060XKTucXXOrla6hrqyUIw1AsYVAsZVAsaYgDEhYFwjYFwnYNwgYEwJGOsEjA0Cxk0CxiYB4xYBY4uAsU3AuB2AMQRnh4Rzx5BTj+1D8e5G1z9G9wgY9wkYDwgYbxAwHhIwHhEwPkPA+CwB43MEjM8TML5AwHiTgPEWAeOLBIwvETC+TMD4CgHjqwSMrxEwvk7A+AYB420CxjcJGN8iYLxDwPg2AeM7BIwZAWOXgLFHwNgnYMwJGAsCxgEB45CAcUTAOCZgfJeA8T0CxvcJGD8gYPyQgPEjAsZjAsaPCRg/IWD8lIDxLgHjZwSMnxMwfkHA+CUB41cEjF8TMH5DwPgtAeN3BIzfEzD+QMD4IwHjTwSMPxMw/hKAMQTnryScv5FwTgJxRvcc6JXZgY1b2BiFjUfY2IONM9iYgo0f2FiBjQvYGIDEeyS2I3G8PTuQ+IykYiTsIgkWSaZI4kSSJJIQkeSHJDokqSEJDElWSGJCktDN2XFrdiCJBEkaSIJAkgEW8bFIjkVoLPJiERWLlFgExCIbFrGwSISrwiIHFhEwSY9JcEwyYxIXk6SYhMQkHybRMEmFSSBMsmASQyYJ8JKLl0i8pOElCC8ZGMRjkIxBKAZ5GERhkIJBADpZdGLoJNAIo5FDI4KHFA8AgmsS/XeRIPmnOqfVeUXJDTfRdVPHrqX+UTa+n3quz5C/n1Y6N4LoL4aiPw3Dn8lG27vlQr++FrG7Wp0n5cKXk3KZSeo8VHUeOnXkesLc7zwP669ur+n4KFLXIrbrYWz3a449fV+0TOzXo5Cxeb4pWdsTHtc/0nY0pU654Kk5sri8eB0iS5RM7i/s3Fb13NjacGTCgiLx21S+kXKvksk9jZVOu3gtRmHjNc8eX7zm3ScxXmNHFpcXr+P/xquOLTdek2hRpC0V2ZqS/e7I1pXsj3Jhu1Acg+rvsG3yeR+snz3rPmzHw69toayXC39IDK6q7xLlv0f+0fUdWapkcblsp159jpUdrUs4Eqd+Xn1uVec19Rv5fdtjf82xv8Tt+c71S+qpn3rqI9buVH83qgMx9Jf8Jrr47OI4rj5nVyrDwtdO2ukfdH1toaH+U9HfCKK/l4n+zTD8836qGeb+DkT/Vhj+efy0wvD3RH87DP+Z6N8Owz9/j+kE0V/Mx+U7Yfjn8b8bxv9z/r0w/HP9+2H45/f3IIz+sYw7bkSL4o4zD9X3dv1/b3zZcabYrzusocaZhw6P6x89zoTsyMPa9sjcZ/TIY+fIY8ena9NQ14Ghrm1DXQ1DXfuGutqGuuqGuvYMdbUMdaWGuizvo6W/LGN111CXZaxuGeq6ru2E5fNo6fvrGqsbhrosY8IyVi39tWOoy7KNthwDNA11WfYdls/QdY2vp6H9CtEPhV0PzDLfPFhkp987D2aoPxNfS6zquW9tU64vcer/6fh5M4ife1N5J5M2SPvCN1dlabvm2Isi//us2G96eIS77pFd5R/Mno5OTsf383wwzIuifzKsOfqF1f1OzzvrPkfX970b++bVDH098q3xtJRfUWIl23JkiZIJo17j8c07WvJfxv/aftsjc8del72XnWg51vTz2IgWz3Bc2l/7cHTeljxirPQn0fIabuTYT5z6f1ef3bbuqs/I2XDaPetPz6bF9MGD/GTacfRrH8JP/wJJ9PoyCV0AAA==",
      "debug_symbols": "tZbRCoMgFIbfxWsv0szT9ipjDCsbglhYDUb07tMRW2zX/42cI0c/L/zgX1lnm+V+c6EfJna+rMwPrZndEFK3bpw10Xnv7rfjNivyIir9PjCNJuR+mk2c2VmUslac2dDluixVuqR33qZOpvpvnuQ+TPSZVLRdeQIQGlCjAScwQBdogEADJBpQogEKDajQALTJGm2yRpus0SYT2mRCm0xokwltMqFNJrTJhDaZ0CYT1OQtdQ8TnWm83RNOv4T2EHjm52h/ss8Yh9Z2S7Q5BX0DUP6NSvJK5mdne0VdcFFXCZJALw==",
      "brillig_names": [
        "process_log"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/7WTyw7CIBBFqcUo0sTEx39MU0y7dOHafyCtLHVRN+766dZkJkyI0QVwEzJMgMNcHoXwKjBKESGCHDEqjAs2Xs7tjDnEqVbBvin5HRijvvhLWH+jkFnk4QPxM50/rJBzmTyfe6F913PTrF8J/z5y+af7y+l//8OzRq9bzCvh/8P4uvfXx/M2ij/SbJGc0ptoOwAqvkT+EvmhJBvn8w+Yb4Svj6KMqNO1tnaNdfZkh8H0dhfwP+KH/QbzqHp4zgQAAA==",
      "debug_symbols": "ZY5bCoMwEEX3Mt/5MFFL61akSNRRAiGRPAolZO+diNDQ/lzmDofLSbDiHPdJmc16GMYE2i4yKGuopcxgdkprtU/1G5oSvD15f0hTqg/SBRh4+xCCAZr1vG89bWxKIzXRZfbHE37RHedftr/nZ6b6kk7JWeNls0WzVHLhfeCP5+Hsgmt0WIwrWcqR90w0NEvTHw==",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "get_target_unconstrained",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "parameters": [
          {
            "name": "source",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_target_unconstrained"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2670722443823556121": {
            "error_kind": "string",
            "string": "Only admin can set beacon target"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9505266597993848748": {
            "error_kind": "string",
            "string": "Only admin can set admin"
          },
          "10087665569532205990": {
            "error_kind": "string",
            "string": "Function get_admin_public can only be called statically"
          },
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "10979918148181134863": {
            "error_kind": "string",
            "string": "Function get_target_public can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16541607464495309456": {
            "error_kind": "fmtstring",
            "length": 16,
            "item_types": []
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "get_target_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "source",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "set_target",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "new_target",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "2670722443823556121": {
            "error_kind": "string",
            "string": "Only admin can set beacon target"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "set_target"
      ]
    },
    {
      "name": "get_admin_unconstrained",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/7WWTVODMBCGQ0s/ANGZ+ge86DlYanusHxcvHjx4jxBqR4UZwHt/ujCzkXUNTB3CzjCbQPLs5mVDsFhjFnib/TaLHWFWx70r8A74EXo+rq4t9Hk/CxwS1yR/w8OVo1mfwfyXDjCtYfhc8QfSn8+A83Bo+HgtKu68uk5Q24e23zF/yNyrdxs6iGmaX1lw3pJ/bR7ocAH9WptTaO9kefeRRe9PX5+vMse7jKrLNGRsNXXRUO+ztMxFVN7GcS6LghJGGjJrobqI+ib26WPcls8/aS8yL/ZZSmn2kbQxjJmg8XiOo7m3Bc/72Y1iT82zAx/YM6ILXtMc3TdYx9e6iqNvF8d3Sa6m95VF4ql8qD6qnusK86BdlFkudvJZihinTuWjnpad7tzEW0g3D5el6k81nC4b+Lj4kRbnSaXF8c/Y30+Hmuuz9uPAY82vgX0wv5b1hnMVdwz8CdN/JG30HI+/hL6L8lfe7pFnshZBshSJWIk4DiOxIHxGdPoGbz5z2bAJAAA=",
      "debug_symbols": "7ZjBboMwDIbfJWcOcRLHoa8yTRVt0woJQUXppKni3ZdMBFiDyqUnlgvC8OP8+czB8YOd7OF+2Zf1ubmx3ceDVc2x6MqmdtGjz9ihLauqvOznjxn3F1C/+tu1qH1464q2YzvgXOQZs/XJ37vI5TiXlXWRkH0W6Q3HQW38+0FLZkGKIkgRZ2kV9Z8ZA3yLG9TBjbfwyo2SIbHSJnKj3+Em53JQ50Cv3egRoxY6ckNvcaMguEG14sbwQUo8rpRZcoM0bhZJwPiRXyq2jnlYADTgtALBglqAoUEtBF8pK+TaBDGX+rWYIFCn+T+gl1woE2Aj8D9azyT/n0wgWEZJz0wET0wiJpCYRExEYhIxkYlJxEQlJhETTEwiJjoxiZjQdpjwiUm+wkSK0bOUMDW9LliywUmO/bSZcktcUhsI/aCRakWrx9ro2fa81tdmQ/305mqzob5+W7XpXfhVtGVxqOww6jjf6+Ns8tF9X+3TEOTaNkd7urfWj0NmkxB/UpEik+TSutQ/",
      "brillig_names": [
        "get_admin_unconstrained"
      ]
    },
    {
      "name": "get_default_target_unconstrained",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+1YTY/aMBB1wkf42HTR9o/EEArcaJceeulhD20vPRgStqu2oAJVpZ746SWSp7ydTAIIp6eOhOzYnjdvxuOJg6eO4tm2rp6Lp84Qr2Tst23btvVhvnb4Te1zdJ3oNrPrEn8cxa/agn8O+Q/aFtOrBj8i/IriHwUW5+3+iI++kN3W4XcD/VvbD0v0q+R+2NthGzBd4x9EvyzgT75lcr+vxjbhz6rBH3TtPj5YvGxvX9j+Y7p78229+Pr+5/d5usEqwbNDCZFByVDvjqj369VuYxa710mySbdbjuALyKoAtQOoX8zT6l1SxOdCtA/pZvu0XnG0+ploNbumAetRh3K2CWNT20bXiSbswD32ILTYLRYX9AlrucNcjaWM47uL9juMq+uz6TF7xIfHh/I5y7Cu7W936415TB9SkyB1hJNc42lHa/C9j0eInpvsucGeAwGnTG5V/qi2GE+f8eRj1O8J+j7DaghYGGIqvxIv0m2r/JF0mA594hqUcEX7xLUJcwHz+1RqzfbPsVCfdP8f2b9y8ZGl2HUErj1hjudtR7DTEexIWE2HWJQX/NXgOL6TUOXjSyLFssXmurAer1Rc+CUDfcowPwEuX8f5YJyJW8XnwvBYKIFXF2zzON3AHNYzLlKcyKdL44Q5g9z42aHcxHcOr8/IuXUGVlCC1RSwpLrLr+81wS/JNurxc8NrfoONc9u+MBecaVMVcOb7jmO+Kn4fFnFD7FP3BsnHUJgjvSxvKP/q++O8q7M1GkcR2a1ZfNoTLnWYx/Uf7TPWKWrrV/BcjoxeDszSDE2SxAtzx/AVxJB/lnkQJxLpToU1k/hm0lRybhFeg63/bNuMww8lY2JcZ/s8pvRZnsnUttGVQnxo//DTrF7iI62fg487xpnrT91wHnDOWC98gT/nvATOv2A96iiVr0FKnXenRr9p/a3K7yPphoId6lf8l1XfY/aUku+WZL+j8nWpirul9N0j7UNYEvOeKs7jrnJfm+KhGS3MSOtJrNNYD0/VJue1Me6n6XAcz+eHnk70v7afjidJNFmmRmvdT6L0lP0/jFD9zXwXAAA=",
      "debug_symbols": "7ZzdbuIwEIXfJddcePw3477KalXRllZICCpKV1pVvPvGLHbSxpuoTjaOsG+qGuYk429CmGMFf1RPm4f3l/vt/vnwVt39+Kh2h8f1aXvY16OP86p6OG53u+3Lffvlitk/oC/xb6/rvR2+ndbHU3UHjHGzqjb7J/t/PaqP8bzdbeoRF+dVJ56YukaTff8aixQIVdyFKtU6rMTzz1UFOEk2SrtsbAp92UjhDiw1dbKhKbIxTFyjDWB/Ntpj1Fx3sjGTZCPBZaPkQDbErqHIOpXiLJSNUl6jNHAvsqcKgGGuToZREwwYShyk8fNUYJpog4FoDoTXaM7ZwEUARpMLZkL3ByO4GmH7itEQurrIpayAfYq1BKEQHCYInobADkFeCI4kKArBkQRlITiSoCoERxLUheBIglgIjiRIheBIgiZXgqwhaAYICiA3Q8F5w1CIC0ORrSuZkGG2vmRChtk6k+8w5MbhqLHJTwwDaTAUfp2DmmMLFYomcDhIyIFY7e/KujU9G2srma1DurlKylLJG6lkto7x5iqZrXO9uUpm66BvrpLZOvmbq2RZUZi+khp8JZF9JS7L+sPcxMtqxdzEy9rG3MTLGsTcxGUhPjPx4unnJl6899zEi0eem3jxsnMTL55zZuJq6Z4TG+JDD4dL5I64RIvOTdU+PttNRAvHHLTmn6ItmKVbw2Rglu7gkoFZutFKBkYWMGEwS7ctycAs3V0kA7N0E5AMzNJ79f8IxkiXCHLVAbP0ljoVGJ1x59sPJuPOtx9Mxp1vP5iMO99+MLKACYPJuPPtB5Nv54vYgDFmIJozhs3qWjNJroJrcRq0bx5b0G20hZ5vV50Qer4dO4F/oIvEvNDzdQPpoGO+ToNUA12br192mK/TGACTr9MYADOB0wC/wY+B1g4//wBjPEYwspU9+/vRlgvLJ9++Ol0ng6VnTwC99OwJoOfbsyeEnm/Png46hffLMwKab9/WD/flRWRYjAhiRDxGJAZFijoiGSNSMSIdI8IYUfA2xhmBv36M7ohMhAgYi1JBlIpHqUSUSkapVFiF3KuQuiodpcIoFUWpTIwKWJQKvq0618Nf6+N2/bDbXPd0fX7fP7a2eD39ft182e319Xh43Dy9Hzd239fWlq82aeIrwksy9QDqGykA1Wepz/QH",
      "brillig_names": [
        "get_default_target_unconstrained"
      ]
    },
    {
      "name": "set_target_override",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "source",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "target",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "2670722443823556121": {
            "error_kind": "string",
            "string": "Only admin can set beacon target"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "set_target_override"
      ]
    },
    {
      "name": "get_target_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "source",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "10979918148181134863": {
            "error_kind": "string",
            "string": "Function get_target_public can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_target_public"
      ]
    },
    {
      "name": "get_admin_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "10087665569532205990": {
            "error_kind": "string",
            "string": "Function get_admin_public can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAACbHgIAAQAeAgACADM4AAEAAgADJwIBAQEkAgADAAAAbyUAAADEHgIAAQknAgIAAQo4AQIDJAIAAwAAAIslAAAA1icCAQAGLwwAAQACLQwCASYoAIAEBHgADQAAAIAEgAMkAIADAAAAwyoBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEFi/6WY4Tn26Y8AQECJg==",
      "debug_symbols": "5VXbioMwEP2XPPuQyWUm019ZlmLbtAiixdqFpfTfNylGrSt1KaUv+yKOnPGcmZPJXMTOb86HdVHt65NYfVxEWW/ztqirEF2umdg0RVkWh/X4s5DxQfaGPx3zKoanNm9asQKF2mTCV7v4TsjhH/ui9DHS1+w3XiqV4NKoEVrOoA0a26ENWtOjCWfAzjjuwM5KOwZ/ZsLJ18jnxAEA/Eb5L+q+dX333VL3wRIlNGr9WD5bSrUygpvIZ/1q+aDu5UcS9wYSkPgOFoBZFmBp+zRWtMBCknUHp3B0FxxUBpODCnniIAD+RdF93TFPwZN5T/Jp82Qez+VZMMlWCzj4FKd5hkQPtwMO8w4Ec+ZYTEeArFswhzSmWSQj8TE46EDZC9Gsp14a809qvYboK2+KfFP6bsPtz9V2tPDa76Of7L5jU2/97tz4uAWHBQhxgyjOtLmNQwi0zTQFjsDzAw==",
      "brillig_names": [
        "get_admin_public"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Beacon"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "target",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "overrides",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "old_admin",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "new_admin",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "Beacon::AdminChanged"
        },
        {
          "fields": [
            {
              "name": "old_target",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "new_target",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "effective_block",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "Beacon::TargetChangeScheduled"
        },
        {
          "fields": [
            {
              "name": "source",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "old_target",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "new_target",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "effective_block",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "Beacon::TargetOverrideChangeScheduled"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "source",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "target",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Beacon::set_target_override_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Beacon::set_target_override_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "source",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Beacon::get_target_private_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "Beacon::get_target_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "new_target",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Beacon::set_target_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Beacon::set_target_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "target",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Beacon::init_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Beacon::init_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "source",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Beacon::get_target_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "Beacon::get_target_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Beacon::get_admin_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "Beacon::get_admin_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "new_admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Beacon::set_admin_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Beacon::set_admin_abi"
        }
      ]
    }
  },
  "file_map": {
    "107": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "116": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/dispatch/mod.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let name = function.name();\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_struct().map(|typ: (StructDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "117": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/events/mod.nr",
      "source": "use super::utils::compute_event_selector;\nuse protocol_types::meta::generate_serialize_to_fields;\n\ncomptime fn generate_event_interface(s: StructDefinition) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let (serialization_fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let content_len = serialization_fields.len();\n\n    let event_type_id = compute_event_selector(s);\n\n    quote {\n        impl aztec::event::event_interface::EventInterface<$content_len> for $name {\n            fn get_event_type_id() -> aztec::protocol_types::abis::event_selector::EventSelector {\n                aztec::protocol_types::traits::FromField::from_field($event_type_id)\n            }\n\n            fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n                _emit(self);\n            }\n        }\n    }\n}\n\npub comptime fn event(s: StructDefinition) -> Quoted {\n    let event_interface = generate_event_interface(s);\n    s.add_attribute(\"abi(events)\");\n    quote {\n        $event_interface\n    }\n}\n"
    },
    "120": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "123": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_initializer, is_fn_internal,\n        is_fn_private, is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform note discovery, since they may need to access notes. This is slightly inefficient\n    // and could be improved by only doing it once we actually attempt to read any.\n    let note_discovery_call = if NOTES.len() > 0 {\n        create_note_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $note_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_unconstrained(f: FunctionDefinition) {\n    let context_creation = quote { let mut context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All unconstrained functions perform note discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let note_discovery_call = if NOTES.len() > 0 {\n        create_note_discovery_call()\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $note_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_return_public(true);\n    f.set_body(modified_body);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::discovery::discover_new_notes`, causing for new notes to be added to PXE and made\n/// available for the current execution.\ncomptime fn create_note_discovery_call() -> Quoted {\n    quote {\n        /// Safety: note discovery returns nothing and is performed solely for its side-effects. It is therefore always\n        /// safe to call.\n        unsafe {\n            dep::aztec::discovery::discover_new_notes(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            )\n        };\n    }\n}\n"
    },
    "124": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/mod.nr",
      "source": "pub mod dispatch;\npub mod functions;\npub mod utils;\npub mod notes;\npub mod storage;\npub mod events;\n\nuse functions::{stub_registry, utils::transform_unconstrained};\nuse notes::{generate_note_export, NOTES};\nuse storage::STORAGE_LAYOUT_NAME;\n\nuse dispatch::generate_public_dispatch;\nuse utils::{get_trait_impl_method, module_has_storage};\n\nuse crate::discovery::MAX_NOTE_PACKED_LEN;\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `process_log` and `sync_notes` functions PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n    let unconstrained_functions = m.functions().filter(|f: FunctionDefinition| {\n        f.is_unconstrained() & !f.has_named_attribute(\"test\") & !f.has_named_attribute(\"public\")\n    });\n    for f in unconstrained_functions {\n        transform_unconstrained(f);\n    }\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let process_log = generate_process_log();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $process_log\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    let mut max_note_packed_len: u32 = 0;\n    if notes.len() > 0 {\n        max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (StructDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The note discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_notes`, `do_process_log`\n            /// and `process_private_note_log`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_process_log() -> Quoted {\n    // This mandatory function processes a log emitted by the contract. This is currently used to process private logs\n    // and perform note discovery of either private notes or partial notes.\n    // The bulk of the work of this function is done by aztec::discovery::do_process_log, so all we need to do is call\n    // that function.\n\n    // We'll produce the entire body of the function in one go and then insert it into the function.\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        quote {\n            unconstrained fn process_log(\n                log_plaintext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                tx_hash: Field,\n                unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                first_nullifier_in_tx: Field,\n                recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                // Because this unconstrained function is injected after the contract is processed by the macros, it'll not\n                // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\n                // unconstrained execution context since it will not be available otherwise.\n                let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\n\n                // TODO(#10727): allow other contracts to process logs and deliver notes\n                let contract_address = context.this_address();\n\n                aztec::discovery::private_logs::do_process_log(\n                    contract_address,\n                    log_plaintext,\n                    tx_hash,\n                    unique_note_hashes_in_tx,\n                    first_nullifier_in_tx,\n                    recipient,\n                    _compute_note_hash_and_nullifier,\n                );\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            unconstrained fn process_log(\n                _log_plaintext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                _tx_hash: Field,\n                _unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                _first_nullifier_in_tx: Field,\n                _recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (StructDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    quote {\n        unconstrained fn sync_notes() {\n            aztec::oracle::note_discovery::sync_notes();\n        }\n    }\n}\n"
    },
    "126": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/storage/mod.nr",
      "source": "use std::{collections::umap::UHashMap, hash::{BuildHasherDefault, poseidon2::Poseidon2Hasher}};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: StructDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: StructDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_struct().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_struct().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_struct().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_struct().is_some() {\n        let (def, generics) = typ.as_struct().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_struct().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "147": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "148": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\n}\n\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\n    let _ = store_in_execution_cache_oracle(values);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "149": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n    traits::{Deserialize, FromField},\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "153": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\n    }\n}\n"
    },
    "158": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr",
      "source": "use crate::discovery::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them\n/// available for later querying via the `get_notes` oracle.\npub unconstrained fn sync_notes() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emtitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "161": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "163": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "171": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicMutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicMutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "173": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{ScheduledDelayChange, ScheduledValueChange, SharedMutableValues},\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u32, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, let N: u32, Context> SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Packable<N> + Eq,\n{\n\n    pub fn schedule_value_change(self, new_value: T) {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change(self, new_value: T) -> ScheduledValueChange<T> {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.block_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        SharedMutableValues::unpack_value_change(packed)\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because\n        // ScheduledValueChange and ScheduledDelayChange are packed together (sdc and svc.block_of_change are\n        // stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        SharedMutableValues::<T, INITIAL_DELAY>::unpack_delay_change(packed)\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    ) {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn get_current_value(self) -> T {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_block_number)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> SharedMutable<T, INITIAL_DELAY, UnconstrainedContext>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub unconstrained fn get_current_value(self) -> T {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::unconstrained_public_storage_read(self.context, self.storage_slot);\n\n        let block_number = self.context.block_number() as u32;\n        smv.svc.get_current_at(block_number)\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "184": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/unencrypted_logs/unencrypted_event_emission.nr",
      "source": "use crate::{context::PublicContext, event::event_interface::EventInterface};\nuse protocol_types::traits::ToField;\n\nfn emit<Event, let N: u32>(context: &mut PublicContext, event: Event)\nwhere\n    Event: EventInterface<N>,\n{\n    let selector = Event::get_event_type_id();\n\n    let serialized_event = event.serialize();\n    let mut emitted_log = [0; N + 1];\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    for i in 0..serialized_event.len() {\n        emitted_log[i] = serialized_event[i];\n    }\n\n    emitted_log[serialized_event.len()] = selector.to_field();\n\n    context.emit_public_log(emitted_log);\n}\n\npub fn encode_event<Event, let N: u32>(\n    context: &mut PublicContext,\n) -> fn[(&mut PublicContext,)](Event) -> ()\nwhere\n    Event: EventInterface<N>,\n{\n    |e: Event| { emit(context, e); }\n}\n"
    },
    "188": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "197": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UnconstrainedContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress,\n    block_header::BlockHeader,\n    hash::poseidon2_hash,\n    traits::{Packable, ToField},\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn unconstrained_public_storage_read(\n        context: UnconstrainedContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "213": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "215": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "227": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr",
      "source": "use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Empty, Serialize}};\n\npub struct MaxBlockNumber {\n    _opt: Option<u32>,\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt.is_some() as Field, self._opt.unwrap_unchecked() as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: if serialized[0] as bool {\n                Option::some(serialized[1] as u32)\n            } else {\n                Option::none()\n            },\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"
    },
    "24": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "258": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "273": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "276": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "286": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "293": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "306": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u32>,\n    pub(crate) post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), block_of_change: 0 }\n    }\n}\n"
    },
    "308": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the block of change. Note that this value\n    // might not be the current anymore since block of change might have already passed.\n    pub fn get_previous(self) -> (T, u32) {\n        (self.pre, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), block_of_change: 0 }\n    }\n}\n"
    },
    "310": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.block_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u32> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n\n    pub fn unpack_value_change(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T> {\n        let svc_pre_packed = arrays::subarray(packed, 1);\n        let svc_post_packed = arrays::subarray(packed, N + 1);\n        ScheduledValueChange::new(\n            T::unpack(svc_pre_packed),\n            T::unpack(svc_post_packed),\n            packed[0] as u32,\n        )\n    }\n\n    pub fn unpack_delay_change(packed: Field) -> ScheduledDelayChange<INITIAL_DELAY> {\n        // This function expects to be called with just the first field of the packed representation, which contains sdc\n        // and svc block_of_change. We'll discard the svc component.\n        let svc_block_of_change = packed as u32;\n\n        let mut tmp = (packed - svc_block_of_change as Field) / TWO_POW_32;\n        let sdc_block_of_change = tmp as u32;\n\n        tmp = (tmp - sdc_block_of_change as Field) / TWO_POW_32;\n        let sdc_post_is_some = tmp as bool;\n\n        tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n        let sdc_post_inner = tmp as u32;\n\n        tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n        let sdc_pre_is_some = tmp as bool;\n\n        tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n        let sdc_pre_inner = tmp as u32;\n\n        ScheduledDelayChange {\n            pre: if sdc_pre_is_some {\n                Option::some(sdc_pre_inner)\n            } else {\n                Option::none()\n            },\n            post: if sdc_post_is_some {\n                Option::some(sdc_post_inner)\n            } else {\n                Option::none()\n            },\n            block_of_change: sdc_block_of_change,\n        }\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the block_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.block_of_change and svc.block_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.block_of_change: u32 | svc.block_of_change: u32 ]\n        result[0] = self.svc.block_of_change as Field\n            + ((self.sdc.block_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = Self::unpack_value_change(fields);\n        let sdc = SharedMutableValues::<T, INITIAL_DELAY>::unpack_delay_change(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "313": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "331": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "332": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "348": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "349": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "351": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "46": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "47": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "54": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/beacon/src/main.nr",
      "source": "mod test;\n\nuse aztec::macros::aztec;\n\n#[aztec]\npub contract Beacon {\n    use aztec::{\n        context::PublicContext,\n        event::event_interface::EventInterface,\n        macros::{events::event, functions::{initializer, private, public, view}, storage::storage},\n        protocol_types::{address::AztecAddress, traits::{FromField, Serialize, ToField}},\n        state_vars::{Map, PublicMutable, SharedMutable},\n        unencrypted_logs::unencrypted_event_emission::encode_event,\n    };\n\n    use authwit::auth::assert_current_call_valid_authwit_public;\n\n    pub global CHANGE_DELAY_BLOCKS: u32 = 5;\n\n    #[storage]\n    struct Storage<Context> {\n        target: SharedMutable<AztecAddress, CHANGE_DELAY_BLOCKS, Context>,\n        overrides: Map<AztecAddress, SharedMutable<AztecAddress, CHANGE_DELAY_BLOCKS, Context>, Context>,\n        admin: PublicMutable<AztecAddress, Context>,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct TargetChangeScheduled {\n        old_target: AztecAddress,\n        new_target: AztecAddress,\n        effective_block: Field,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct TargetOverrideChangeScheduled {\n        source: AztecAddress,\n        old_target: AztecAddress,\n        new_target: AztecAddress,\n        effective_block: Field,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct AdminChanged {\n        old_admin: AztecAddress,\n        new_admin: AztecAddress,\n    }\n\n    #[public]\n    #[initializer]\n    fn init(admin: AztecAddress, target: AztecAddress) {\n        _update_admin(&mut context, storage, admin);\n        _update_target(&mut context, storage, target);\n    }\n\n    #[public]\n    fn set_target(from: AztecAddress, new_target: AztecAddress, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        assert(from == storage.admin.read(), \"Only admin can set beacon target\");\n\n        _update_target(&mut context, storage, new_target);\n    }\n\n    #[public]\n    fn set_target_override(\n        from: AztecAddress,\n        source: AztecAddress,\n        target: AztecAddress,\n        nonce: Field,\n    ) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        assert(from == storage.admin.read(), \"Only admin can set beacon target\");\n\n        _update_target_override(&mut context, storage, source, target);\n    }\n\n    #[public]\n    fn set_admin(from: AztecAddress, new_admin: AztecAddress, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        assert(from == storage.admin.read(), \"Only admin can set admin\");\n\n        _update_admin(&mut context, storage, new_admin);\n    }\n\n    #[contract_library_method]\n    fn _update_admin(\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n        new_admin: AztecAddress,\n    ) {\n        AdminChanged { old_admin: storage.admin.read(), new_admin: new_admin }.emit(encode_event(\n            context,\n        ));\n        storage.admin.write(new_admin);\n    }\n\n    #[contract_library_method]\n    fn _update_target(\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n        new_target: AztecAddress,\n    ) {\n        TargetChangeScheduled {\n            old_target: storage.target.get_current_value(),\n            new_target: new_target,\n            effective_block: context.block_number() + CHANGE_DELAY_BLOCKS.to_field(),\n        }\n            .emit(encode_event(context));\n\n        storage.target.schedule_value_change(new_target)\n    }\n\n    #[contract_library_method]\n    fn _update_target_override(\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n        source: AztecAddress,\n        new_target: AztecAddress,\n    ) {\n        TargetOverrideChangeScheduled {\n            source: source,\n            old_target: storage.overrides.at(source).get_current_value(),\n            new_target: new_target,\n            effective_block: context.block_number() + CHANGE_DELAY_BLOCKS.to_field(),\n        }\n            .emit(encode_event(context));\n\n        storage.overrides.at(source).schedule_value_change(new_target);\n    }\n\n    #[public]\n    #[view]\n    fn get_target_public(source: AztecAddress) -> pub AztecAddress {\n        let mut target = storage.overrides.at(source).get_current_value();\n        if (target.is_zero()) {\n            target = storage.target.get_current_value();\n        }\n        target\n    }\n\n    #[private]\n    fn get_target_private(source: AztecAddress) -> pub AztecAddress {\n        let mut target = storage.overrides.at(source).get_current_value();\n        if (target.is_zero()) {\n            target = storage.target.get_current_value();\n        }\n        target\n    }\n\n    #[public]\n    #[view]\n    fn get_admin_public() -> pub AztecAddress {\n        storage.admin.read()\n    }\n\n    pub unconstrained fn get_target_unconstrained(source: AztecAddress) -> pub AztecAddress {\n        let mut target = storage.overrides.at(source).get_current_value();\n        if (target.is_zero()) {\n            target = storage.target.get_current_value();\n        }\n        storage.target.get_current_value()\n    }\n\n    pub unconstrained fn get_default_target_unconstrained() -> pub AztecAddress {\n        storage.target.get_current_value()\n    }\n\n    pub unconstrained fn get_admin_unconstrained() -> pub AztecAddress {\n        storage.admin.read()\n    }\n}\n"
    },
    "59": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/authwit/src/auth.nr",
      "source": "use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\nuse dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::ToField,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\nglobal IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "75": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, FromField, Hash, ToField},\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        execution_cache::store(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            enqueue_public_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.set_public_teardown_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            set_public_teardown_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "76": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, args);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, args);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "78": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "95": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    }
  }
}
