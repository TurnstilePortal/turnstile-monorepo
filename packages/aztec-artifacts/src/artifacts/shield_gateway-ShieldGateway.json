{
  "transpiled": true,
  "noir_version": "1.0.0-beta.2+3278f71a05090dbd",
  "name": "ShieldGateway",
  "functions": [
    {
      "name": "verify_id_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "963818325383147006": {
            "error_kind": "string",
            "string": "Function verify_id_private can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "verified_id",
            "type": {
              "kind": "array",
              "length": 5,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7ZbRauMwEEX/Rc9+0GhGGim/spTiJG4xGCc4ycIS8u8r7VZ2g+0WTyi04JcgRfdEo5trj65qX20vr891+3I4qc2vq2oOu/JcH9o4uyow/747Hcs2TU/nsjurDThnClW1+zRkcyvUS91UauPicCQ2xvGb2BgfenEajsWB/JsYtYGPxeAw+L4OgkFuHE7q7SBnHtReT6nRYVYT6Dv1U6EAV2dmnKHVmRln7Ld2htAOzlD4xBkDxuVKgOyDzrjVmRlneHVmxhm/OjPjTHjYGdIhiwmM78VMaQOjv3oDeHgDQE1ZjDj4D9pNqTVw/gPiOOD7gqaC40PokxPG9ZsfXv/S201iaIoxzkHeiNF+fGav8xk8ve/M/3//8e7JiPkRZvSfeIT9u4GABvsRb09xtu3qpqlfn++uyzp9uEnvgu/vEVqPzuZIwFgB4wQMCxgvYMJyhrWAAQFjBIwgByzIAQtywIIcsCAHLMgBC3LgBTnw0zlww2tU04gxAgYFDAkYK2CcgOGlTJxBktLkqSzku4y15v49WyiyyxG3HOHliF+I3OL0d9nV5bapUrNIq5d2l3tHnJ7/HPNK7i7H7rCr9peuSn1maDEpUVYXTqfLXoq+D0Wg3ue0jFAQ5OWotTZWEKv4Cw==",
      "brillig_names": [
        "debug_log_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper"
      ],
      "verification_key": "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"
    },
    {
      "name": "compute_note_hash_and_optionally_a_nullifier",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5972837590977953198": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 36
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "contract_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "storage_slot",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "note_type_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "compute_nullifier",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "packed_note_content",
            "type": {
              "kind": "array",
              "length": 3,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 4,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "compute_note_hash_and_optionally_a_nullifier"
      ]
    },
    {
      "name": "_log_transfer",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "13434471300436635949": {
            "error_kind": "string",
            "string": "Function _log_transfer can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [
          {
            "name": "serial",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "binnedAmount",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JgACBAEnAAABBIBHJgAABAMmAgQEAyYCBQQAHxgABQAEgEQtCIBEAAEtCIBFAAItCIBGAAMkAAAAUSQAAABSJwIAAQSARyYCAgQAOg0AAQACJSQAAAEbHgIABAAeAgAFADI4AAQABQAGJgIEAQEjAgAGAAAAeyQAAAFEHgIABAEeAgAFAAo4BAUGIwIABgAAAJckAAABVigCAAQAOSPgIiYCBgQEJgIIBAMAOAYIBywIAQUAEAEHASYDBQQBACgFAgcsDgYHACgHAgcsDgYHJgIHBAMAOAUHBiwMBgcsDgEHACgHAgcsDgIHACgHAgcsDgMHACgHAgcsDgQHJgIBBAQAKAUCBCwNBAMmAgYEAgA4BAYCNg0AAgADJScAgAQEeAANAAAAgASAAyMAgAMAAAFDKQEAAQX3ofOvpa3UyjsBAQIlKQEAAQW+Hj//PqT2+jsBAQIlKQEAAQW6cNR4B7SxLTsBAQIlLQAYyhjK",
      "debug_symbols": "7VnBisIwEP2XnD0kk2Qy8VeWRapWKZRWal1YxH/fVNpYtSirdQ+zXiSRl8y891I6zezFMp3v1rOsWJVbMf3Yi7xcJHVWFmG2P0zEvMryPFvP+n8L2fyQO+K3m6Ropts6qWoxVYgwEWmxbIYOwg6rLE/FFMPwGiyl7cASbAQriQNoY4xr0cZYjGhnB8Ck49akQfXBnxPhYYTcKYJD8n+Y+xi6GxV1x3u6K4sRjcrdzt1r34G90eYidyXtqMmH/c6Sb0Io+foQ9PIQoJ8OYRC6EGHo7505B/HMkbv0DZ5nPOIjoPRv1TkuogcWGXxgkVVDi0BTxwkMydtqOdIt1nl1G0qys5l6T6dyZgBriVosKnUHS9j55eWVAyj5U7TsKTr+Lrp/4KJnT5EMf4r8XfT8XfTEnSJIzZ+iY09RAX+K/F0E9l8aAOwLONDsy3DQhj9F9gUcGP6vfsO/gLM8Xv02XjTLs3vmgUtpG6l5VHilB486YTQ98H0+zvXAtx59PRyPonM8Pd7n46THIcy+kipL5nna9pBXu2LRaynX35v0oru8qcpFutxVadNnPrWYj608aycoP5uuW5iETiTqECPE+QE=",
      "brillig_names": [
        "_log_transfer"
      ]
    },
    {
      "name": "check_transfer",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "15254204628464287903": {
            "error_kind": "string",
            "string": "Unconstrained division result is incorrect"
          },
          "15752070530033396291": {
            "error_kind": "string",
            "string": "Division by zero"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "4747832189996610921": {
            "error_kind": "string",
            "string": "U253 multiplication overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7461896932686329849": {
            "error_kind": "string",
            "string": "U253 addition overflow"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "sender",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "fields": [
                {
                  "name": "value",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "uint253::uint253::U253"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "debug_log_oracle_wrapper",
        "load",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "div_rem_unconstrained",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "directive_invert"
      ],
      "verification_key": "AAAAAAAQAAAAAAAAAAAAFAAAAAAAAAAQAAAAAAADKLEBAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAF\nAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAAAAAAAAAABGAG+0XXKOS\nCqGaG0htGkhHi964Kb1Wrg3w1rb5ASo/ALeszHoMzdznJpn195lXrIE50t241uHx6DX4eNE0U44T\nQ31u/WRMjMiFECMB3LmpmYkkEG9AfXTq6AKStD93hAVsAytQD5V6cSJGjllfWxf2djsU02S8KPpu\nGlJ+ramtGxr5XnzUjLyxkd2DG2YtxxzKgsl8wriUNsPE1cJvjJAOiGyRdVEVBVSW+ygDMS/NWCh/\nz9qsHRD/Dcj8gq8DtRlKDedU7juXHSmO/FPCmFAkuwvmh/RpqgN0wCA2Rm0LKVeFR4u+hxz0fS3Y\nCkPY7Kv4Wm/9Enz/Kjw4hAnBsGIcK0MwnGVuh89K09A4y/fI8O5I/RfEGqNWxk5hLWtA+Sbo4x7b\nbgwBcwpw405iG/e2WBtL0PUoolWvvYfVG3jGLgQygEkdkrf4V7vUTYi8X4EI7nGK3y+cUXmx4DN0\neX0c122RMBz53gYlVOn7s2ed7hXeSL/mnPKmJyiGiYWmNgRWu3AbWwtGO7zwxP5xkFUjk9CVM+Gy\nAEvYTp+KU6iPA4D05rswR3a/1Psi4gmHdBVkgemj+PCR0w2xADptqrQpjDMR/JFw+S3pQLBCqrmQ\n1TxqOyYznNprc9+SCDFBWQewX0CKYShHJZAWuSBK5L83U36xlrBcHZj6UQFqm6y7FcyT0TQcx3ie\nEmeYbILUg7a72VhGCD04OyQNcIS0hX0I12zFlYLnlJvZsIaXf6QfsfCRbpO5rgWEisDIlHuhKShg\nParpmnCV8VfwqLqXysLJQv+VDsqDhKqgVXUpAMSVDkVG4EFJw4O0Tcz03xiYlGtP9F/Kn8Hf5zgM\nWZ1mr68Aph3qx2s3DKT0L3OmZct1qevcWM1L34r35/z/o21bcS5ZeJ8Nnbs/Fa3lOEt4SQ2x2DN5\nxzvkESPev8iMn8jWK3KtwTdDjKDTNxRFpXqWkOZE9YS6+kVBJM8BrVvgsTkBGeJB7rvr/1x9fyDc\nbFrRtq943CBtf3eFPwX95+vTcigqi7NFxjweGMCclYXST/LDa4Nw6l9QCixUorH3NZwHF1fLSGSa\nWxF1sOqpeoyQ6s5Pj6df1nzYKL3Fi2Ld7q8u3r0pRBr1wIu9Fhc7gHxJC9mE09UucYFpX9x1UkAE\nPyrx9UWrh4sOz3ioA+yLbvuwbXOfIYnbOGxY067C0o5HDejS7L2nnL9BSPhfVKPof0b3yb5PV4Kk\nNjTm287LF7gFy34FPuDqbZ+sEWV0fsw9ROVUi+urDFc0By4Z1awoqhfNUZXM7qJYzP+nN/zFhObZ\n6xhMtQCxwfWVYBRkHwzbD4USsTdKqVVFEPvRVncnbZTm7nK1ZZGDdK9yBThRcxUmxPK6/Q7z8oqI\np7wJOnTZPRxnaM7y7mzu89BnEAmpywNqDuP8+SYoieHxFXOzC04wrVcac0QESOzcdOUwOYNLJQQ5\n7wDP+mvmuBSMsAPZBtppVFzRC2eeqcdq2Yy2+F8k0jLK2VWuLE617aO84yiS6ZWmE0uGtUD518dc\nG7pEFS+kT9tjcjsh8FbVkqzWZyLZN01BdfspivJiaAIT4AHhLDCsM41CyvcE8m5Ptb8FrKiz6Ove\nEqVPh7Kwpb9yp5IAjssBtyAHxdyqRusfIpJ01BzzN4wRZXHDB1tD5Q+TYRcwCA4nYY1EZcvgnKaN\nL6jbhAtT0YvLSG6v9IYeu6gxKXwOlFg8IPetDPRiUOCND8rj4jAlZQt1rsoyt+kdfWAk1OKB7/tt\nEv7wJ6YbphrbuxgCOPDBLFoieNF7Iv5S5iMMMV/3ncUikEcv27r+9c4dOGcN+CMdSuYK5G8J//zC\nAa7mRF1bSpXe7dtObkZluhWsoLauJJ5ExVzajjpdgwgK3InEjXW1cWNvW760qAb29FliAjAbauTr\nDrvq3SAzQAZvKBNXSPEZYxw/4H+p1wADTj4nRU75krS/hLl7qnRxLiV4NVHfUMAE7HzR9N2LO2Sm\nbyrEl5tl5WVoxaMbFO0Y92zwzuzLR5jedBrom2ToJY+ER3wbYlZaVZunuziDLi0pn7aGeNAVC8xb\nFtyCUjU9Q/pw6ZI5wcHGficaDurFFdOsWhmau3STOk78mMWbKBTt580n2u0AwzwShgvEsEYtONbU\nuh5HY6dOzbEcofNGloDCcOVRUVNEWS9ZGI+nZRLbOeiSgmsyYQ7gglHgBfzpF8DV3KAZR3xS9gdT\nMrYSAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAiNPwcevwZDCQFO1WKwWO8/xNQ1gFMpgmbLUETVI4iiCCOudM3XsBgkZRKgC6N0e\ngdpIFDJ+3zMarrS1Ocjwgb0Py7+dPPQCuqPu2l8Knkm1werJWyZMMC3IVObyLXMw3yg+39qJyUgF\nl/CzRC6XUt751Y/Ckgg2GUJh97Fj/vuvHViqYcZK1SIEPXnEgCIZ5Vuhl1Gt/mw2Mk0/tsLaCYkt\nfBipPD2uWICfqu7GqGp49LO8YfGdbnBpNZu/R+f5Bw=="
    },
    {
      "name": "process_log",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8861757336002045335": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 99
          },
          "9862881900111276825": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 35
          }
        },
        "parameters": [
          {
            "name": "log_plaintext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "tx_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "unique_note_hashes_in_tx",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 64,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "first_nullifier_in_tx",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "H4sIAAAAAAAA/+1dS4wc13Wtnh+nmxzOiBI/okRK1F+KKdanqz8iKfWQQ46oL+WPHMRx4P46dGQJpij/4CRtwEAAAwkQZBEkgWNk4SAwkMBeJIABI0GCBPAmGxvxIsgmyCqLIEYcw7s4/aS602dO366p4rw30yXxATNdXffVvefdd+979/2qS9576fXRXym5Xkg+DySf5v4Rb3uSvK3k099dCizy8l1hLBUA41wBMM4XAONCATAuFgDjUgEwHigAxuUCYCwXAGOlABgPFgDjoQJgXCkAxsMFwLhaAIxrBcB4lwOMLnAeKQjOuy3ixNjeFd57vNm30aMFwHisABiPFwDjiQJgvLcAGE8WAON9BcB4fwEwnioAxtMFwPhAATA+WACMZwqA8aECYHy4ABgfKQDGRwuA8bECYHy8ABifKADGJwuA8akCYPylAmD8UAEwni0AxqcLgPFcATD6BcAYFABjWACMUQEwVguAMS4AxloBMNYLgLFRAIzNAmB8pgAYzxcA44UCYLxYAIzPFgDjcwXA2CoAxvUCYLxUAIyXC4BxowAYrxQA49UCYNwsAMbnC4DxWgEwvlAAjC8WAONLBcD4cgEwvlIAjK8WAOP1AmB8rQAYP1wAjB9xgNEFzo8WBOfHCoLzdUc4vY8T6LnRnzm4ZQ5GmYNH5mCPOThjDqaYgx/mYIU5uGAOBpiN92Zju9k4vjb6MxufzaZis2HXbII1m0zNJk6zSdJsQjSb/MwmOrNJzWwCM5uszCYms0nowdHfmdGf2URiNmmYTRBmk4FZxDeL5GYR2izymkVUs0hpFgHNIptZxDKLRKZUZpHDLCKYSXozCW4mmc0krpkkNZOQZpLPTKKZSSozCWQmWcwkhkwSmEGuGUSaQZoZBJlBhgniTZBsglAT5JkgygQpJggwnazpxEwnYRph08iZRsQ4qXEAY1yve9OTGMmh5fc+y8n3OaBbPEQXlEmuTf4Nv+2XlfJZxB+VE57LTvjHdeFfdoPfl4O214Zj/lgWkTuffH5iONblJ4bbMUmeb0Ceb1AeKY+b+q423eorCFdIRx6URWRX3MiOSiQP6wVpIr/iubTN9w4lozzBw/qRtmNF8gzHeEpEWxhOlkNoi0CT+jVynoJ8bFvLRBMsJon9roBuJP1qQpM6XQCe9uw17rm116q/f/ZaDd6P9rpAtIXhZDny2ivaFtvrojdO0pYKbQlof0q0A0D75nAsOwYcF5Jrt23ye30w+p7tPuxuBT/KMunAcKwPscF5uLcI+ntXP5ifaGWgLQy3y6kk3xdADvISHIuUv5p8X00+l+AZeX5Nkb9E8rfhVu6xXspK/rKS39ja2eTaxNpiz5eHY34W6zQU/htu+FeF/xU3/CPhf3U41mVG3sFOzIX3Zn7eOybh/fzueU+Uw9iNaXe+mDRcZrx2OOH96f6tS2+81f2NV975bKd/E3sM7h3xPvbYkgzXI2Oul99689bNdvfWeq93s//228yhonD2pnCtANdfb99481qPuR28PW6v92++feOtN5nboYzcpO3b6ne8cb+G8Y74qrTHh4l/K/n0d5kEj7Rl2L+twPVhwIv5N73tONfgGZv9xhEqP8oqK3htymYdYZ2hzLkUXViss4Dr4KXk0/jrby2NZZq/u7xxmve2972et72PMX9HlPx3QR4p7yphwGfLynMuYkORtzgF6xzQMf9HUvR1t5dPX/co+e+GPHeRvtCO5dkVRTbH/ffAfYvj1Mxxv8ivKGV0UbdpejWJfe2oG/1s+f5RBc9RRT9Sl8cUmvA6nnxHu8X8R6GMmB+v5Xm810s+14inSRJ/lBTavHIPY8lfo7Jh3ZSmfApfvjdHGFE3Ur9lz6WNBRPjbGzXTHk/A/exPrC+lhXci5T/U0tjnp9N7q0qz7N9sK9Piw0Y35I31jnmmZuC72byabB8ldrBOaXMd6dgFhrGD9hWcvwg+b+QfLr1Yz1+EFmrCt5lT9eH5+l1wna9rOiBv3O/ZJL4qeYDJWv6qMWavu3xr27xP+YG/9bc8XE3/APhf8IJ//rWXOK9bvA3hP9JN/xrwv8+J/zDrXmo+93g31oLOuWmfrf0f9oN/1D4P+BGP1v8H3SDvyP8z7jB3xX+D7nh3xf+D7vRT1X4P+KG/5Z/PeqG/1b7/Jgb/lv9y+NO+McD4f+EG/vZWit+0g3/LfxPueFflRj6l7xxkthKZH8I7s9blF0ieZ6nj1lFfoWwWo4tt8asHyI8rB9cqzK0swrWNYXGMdpZRc5ZRY7G65RFXo9Y5HW3RV73W+T18IyW8SmLvO6zyOshi7yetMhrVuvRpu5t2r1N3du0iVmtx1kto037smkTJ2e0jGcs8ppV+3rCIi+btnqvRV42beJBi7xs2sSdWO790XfYjOUet8jrjEVes9oWnrDIy2ab84BFXo9Z5DWrsYnNPm1Wxx2z2qcdt8hrVtt7mz5kU19nLPK603e8P/oOm2Mrm23haYu87sxZ7Z8P2dS9zTI+apHXrI6HbOr+mEVeszof/aBFXnfaiXy8bMYTd9qJ/dP9rLYTHH8dV3hpZwUl/71KfozNV5Jr2R+I67D3ZuCVJvukkh958r5xxHUyA6802fcr+ZGH7B1dVXDJs2XluVby6e8qRVt7CxBnieTi3KfFtfx+ieSJjvAeyq8QVst4tvYWnCI8rJ850s9pN3h6JeKPeE4r+pG6fEChCa8zyXfca4z5T0MZMT9ey/N4752kwtYUnuxDDyjlwXuiX7NN+q2Er9s9lnHsdo9ireN4j2J9RdEj+zHWpT07DTPvERL5FW/SRlz48RnCM83ORHePKVjXFBrb4GOKnMcUORqvhyzyOjWjuJ60yOv0jJbxvhnFZVP3D1vkdbdFXjZ1b7OMj1rk9YhFXrOq+2MWeT01o2V80CKvO+1EPl6Pz2gZPwjthE3dz2o7IXMkEk+mnTHHMliMfeMSyZNy4D2Uv1dnzLUz0NoZ8xXSJT67RjSTNofjfEybV+7NFZgX245JreST9B52B0EU9+uxX2tX414tCnth3e9V40EQNIKwWW1E0aBbbfQaYTQI62G3rMidwju3DUid4vwV+wP2sRbtL/PYVORXCKsrf7iP8LB+2B9OKVjXFBrP02pzWacUORqvYxZ5yZn0HDa8U4r4hnaO2GLdNR3bat3xfGvsdr6y6mvnWG3Oh/I81i5sh1IUa2dYLWLv8BnWXWDv8Q0+v2pPL+P3+D7qRi81PrtqEXuonVu1iL2tnVu1yL+hnVu1yL/L51Yt6n7A51It8t5as8L+W9YPl0Z/PymN75s/WcfENQ989jTQMf//lsY8f5pcH8zBd3EK358D3y8kmWT972l4nt+LIjQP5OE97n/xeckn9XIOaDb7AMHq76Cbc6Qbyf9/SSaD/WtL28svz2D5F5TyMwbMf47ymKTpXp5dUWSXpnyKHL7H9YIYlvZITnmP5FRIjm9Rjg95Du2RnIN7JEf67lWFxu2AZtd+ihx83t+j8vD7mgOLcgLIw++CCy3KCSHPKsmJLMqJIM+RPZIzT3KqFuVUIc8BeM58j4GGPARHTcEhfVad8LeS7/7uUuY5ApFfIayW8WzNEdQJD+uH5wgaCtY1hcbnKxqKnIYiR+O1ZJGX2MaqN2krNZITK3LiFDk1RY7Y1TNAs1ePUUfq5bw3mYR2AWTjfAunefqOuE1b+ztLY76cj2WiXi8QDX3sItGwrp4lWhNozyXXq96kftn/n/G2l5HvcT3i888QBnxut22YhlmzyzqVJ69d1hU5K8pzuy2Phpnr3IYcLE+D5DQsykFbbJIc3LeK48KPzY3v43M4RsH9sFeGYzrmvwbvGv3lhGfZm/SD/WxL2DcuAo3t7FmgsW08BzTUOSetfRJdmPbp2znaJ2yrpUxSB2IHv51cGLY9qlcpH74fFd/pvkY8Jf+XqS7dxBthLc0f3NpRWMvib5pPIR7BXVFoC7vA2mj0BoN+Lw7ibhR2gib7qWDlezzu1/oUbd+f6Pq850TXkdg6/k4O+qVJC0BrEm0RaIIRfyfHbfwSRln0j/LXFBq+Iz5PXWq8jtwmryPeZPslvq316bzvIW+fjs9zW6udQTFt2KcWt8sUfAsgE98Fzn2T5P8jasOwzPZso9bgdkFkoOxnHMnO2oZNiw8Rd0Wh7aYNq7cHnWozbtTDoBfGzXpam6TFuZL/vJJfe7+h6PqCG12rbdh50KtJC0Dj9g3bMMGotWFu2uBalEX/KH9NyX8FypCnLl3ywvbABq8jt8lL2lYtPnDbBkVNrQ2SpPn8UaKhzR0nGvrTvUTDWJrnuzGWrhENY+kVorWAhr/zwkmLs0W/xq9+kCPOxviW28q9j02zz8Nx2+3GvsbzcFqcoc1ppfUzms/hO3t3678Vi7w4NtJ8O28MljZuF7tCv7LYTvTZNzFpvpl3Hk5w552H0+bMNBtqEQ3brXWiYbt1Kble9Sb1i7KRJmXke2lxOc8T4nOlKZ8ih++xHA2zZpfPUHny2qXms2kx7u2WR8Psev7yPMk5b1EO2iLPJeOYCufhfkjzNTjHo42vrgzHdMwfwjzcv9C4x008nL8tYd9oAY3tbB1obBuXgIY656S1Txh355mHw7aa26e9H/dljw9EvjY/5SI+0Ppara3R2m+eO0Ean+XQxoTnFTkar5pFXmIX2voO9yt54xCtfRS7wtjaok8P2G8xaX6bNz4Q3HnjA5sxgDZ2uZxcr3qT+uX+9FkqI99L6394rRCf223/o2HW7PI8lSevXWo++37tty9YlIO2yH3htPjg4Pz4Pj6XNT6Q/PdBfHA44el4rJG7LWHfWAdalhhAaJeBhjrntNP45du3OX5pJddu5/OirmajjAvrlud8sL3gOR+M23jOpwU0nvPBOuM5H6wznvPBOss754PrQT+4zT6F/VFrX9zG09ljOpFf8Vza1zimu0B4WD8c011UsGpjWJ7zyTvu1uYebfDa675T7Ap9zuY+dPZbTJrf5o3pBPduYrp1ouWN27Q2bSO5XvUm9csx3XNURr6XFpvweBCfK035FDl8j+VomDW7vEDlyWuXaftlXMV0+xVruZqT4/hlWkz3GsV08lzWmE7yL0BM91GK6dyMD/O3JewbGAOwnWlxm9A2gIY657TTmDNPTJc2rtR8YlbjA0dzUKnxgdbW5I0PeM5nN316zSIvsYtVb3qfXiIaykmbW9JijQ9qfGBzXidvfMBxXt74AJ/fq/ggzS45PshrlxcUOe/XuZj9jg++bik++K/FMc/fLWB8kGVeZz/jg7Txyz7MH2R+h/Cszh+Yc6xy/vzT/VvX3+m8caP7Yv9Lb6+/2bvevnnrRvuN9V7vZv/tt7E0bA1cWrYCziPXx5X7yONixlKw12J+tEzBsepNWsWzGXilydZ6K+TJb/lGXM9l4JUmu6XkRx78lm/E1aLnWkDDfBpvlp2GJw3/upIfeVxJwb+egVea7EtKfuSxMdwuuwXPX8rAK032ZSU/8jzlbZeNZb1Mz2FLjfmm8dZkr08pG2Le8PKV8YqSH3uOR6mMWI4rGXilyb6q5Eee95FsxHU1A6802ZtKfuT5BMlGXJv03CbQMN803ig7DU8a/ueV/IjjRAr+5zPwSpN9TcmPPB8n2YjrWgZeabJfUPIjz4dINuJ6gZ57AWiYbxpvlJ2GJw3/i0p+xPFkCn55NktEhTwtRjC9EsmTcuA9lL9XEVXWelghXeKzawqNR4la/b2oyNF4XbTI6zmLvJ61yKtlkdcli7wuW+S1YZHXVYu8rljktWmRl7Sh0qZhvd5PcrQY7VKKHHyeZ73wudKUT5HD91iOhnmnWYv/oVkLsUFt1gLb/kXK/2OYtfhZwlOb0RKMmp559i6vnjU50tegDVucOdk6wYMxgiShYT/3MFxz0mY5BHfeWVjU6wtEw3aG+2tsN14iGvruy8n1qjepX24TtbgX76XZ8VXCgM/t1l80zJpdcruc1y4vK3Jc+z/PoF+2KAfLs0FyNizKQVu8QnKmtWfHF8b38blp7dmDQMf8fwft2cmEZ9mb9IP9bEvYN7S4RGgvAY1t42Wgoc45ae2T6GI3q7TcPmk+UfYmbW8/VmlFfsWb9DkXY4a0+R2TeMywoWDV/Il/NUCbk9lQ5Gi8zlvkJWPJtNihRDSUk7YapsUajuODrV81w7kTSStUZnOdd5X2duMD1OvzREMfu0Y0rCv2W2wXpS3S4gO2l7zxAT6/V/FB2iotxwd57fKyIsf1Ku0HNT64niM+MOnKcEzH/H8B8cFHKD5Af57V+IDtzFV8ILrIGx/g2F7KVFYwWNRvg9tjT8GFc62bCv40XWyALq4dGPPlfCwT/ZbbY/Q10ZO2FnESrtkPs/TRJ5VypPm0237Vj7K0GSi/4rm0nXG8djWjXjU7v0o6Rxr3mdpazKYiR+PF/p02Rz9r8bbrOXot3j6p6HUv7HtaPW+k4HHT9/ih4Mm6Fmb2Kix5kzakrTEy7mvAX+5Na7Pyrt2i//Nejmk4p/Hazdot7+VAXJsZeN3uuqtJvJcDcT0/5TnOp2HJUm7t5D/e53llc82nbTcpL+quBddYnrkpGDaBjrbHZSkp+TV+aLvMj998in22fE8be12jvCaJ32Nstx/ttMivKOV20U5raz2oH2yHDpCu2Waw/rR9TeZ6XSkrt09ZMUn+l5T8WI/cPiH+lzLwSpP9spIfeXL7hLjk2TS7zGI3iIvHITZ4vWyBl8RP2h6LNW9Sby8SDcdOPOZ6RcEn/vwq3N8Pfxb5FcLqyp9fJTysH82ftXkG7m+y5HkV5Mo983c9IybJ/5qS/zrkYX/GOn4tA6802R9W8iNP9mfEJc9Kfyp95l8n8xomjvtucq3Nr0ybv0d/0OYIxR8M/++l8H+VeCD/6yn8Dyv8NX8WWZo/XyIa+jPOHaFN/S3o7R9S5D6bIreVInfdm+S/SLR/BAw/SMFwOQXDRgqGq94kf4mhtPlZpGt7b+U7ln1ajMV7gc4r+TFuFX7a3l/e99ECGvexlxQ5V5WylOj78pRysG3ZtA2WJ/ZxXJGxSHl/vDDG/XGYp8I8wsMkt6dTsvdZIn+v5gqy7u/n0zVa/SKN9/O1FDktRY7G66JFXrKfr6zQLM7DBnziCJPWB+RdM2sl13nXzGyeXuRThdifaG3Rbm0Cn28RBnyuNOVT5PC9NHu5QOXRTu+ViIbluZAiRzuNvKI8t9vyzMKJQ1dvG+NTfNPWzH5Ba2byXNY1M8n/+7BmNpdcOz4lnbstaRENxw9ZTi9qcSifgcKktU948vp299Rw+6T5hNs3iflx1n5b5Fe8SZ9z0W9rZwK1tsacbJR46dP9Wy/2v/R6+40bvfatG2+9+eH+597pv30Li4GsF5RicvUvkDjJx9OEm8PJfJj26uB4XvVJ/rQjlSZJc6GVg5vCfTDjzOHnrJqxFobIs1q3cAaup9Vf2oszbb6EE3nxFhzXL1K684Kv6QfktS7mzgu+JjHceWnr9PLM2gs8NugHrG73BR5fhjB3k8JcN33C3r3gi21jNy/wuN2XumP9cfuU9oIvR9NBmcNckb9XL/jSYr60F3xpMZ/WP/IPxuYduiOvpkVeDYu80n70TnSY9qN3KPOsIrNEmDE/6peXjOKU8jZyyk77USBzzUtGiKuZgVea7J1+cEDa1lUFF/u4yFlUcD5NNMn7BrTRX1jcLgvr+py3nfY00HyinQNaQDQfaCHRAqBFRAuBhj9Kj3lNmid8JuEw9mBy3eu/cePz/ZuvvHVr671DGnuPrst07yx99+l7bQrUNcp3jr7z70Xzb3gF9D1U8GlJcGBiLPPezknMSHT1+cR0TBf2K8lKCZqUyEV9zXvb8aCrrSg0edbw/UlpOw4JOb4C5vx7FHK0vO1llO/+7tLWDsV10A2HSSifVyiHoLuvLW3XlzyD+kqbYlhX8rcgD//+ubYCOWurGhyiYRjGIZq2m0mbieSQG1cv885StpJrU3+fzLCbHW2zRDJFBtsO+0Ws4MXQnWec/wD84lvkF+vAy4VfSF1O8wv0G8z/hyl+odn57b6ZSvMLHNbKs271VQ1XFKySNNtvEQ1tn2fo89q+tisfdcJJ8wvRUx6/+Bb5hTbtkdUvngO+v6DdIaKPb4NffJ/8Asvuwi9kd9E0v+DdvZL/r1L8Qtt1jPbEfrHTm6nYL7Q3U7nVV/7TSHzaC3eLcp+gvXWGd2Cib/GOStYJJ80vRE95/OL75Bfa29uy+sUV4Ht9il/8PfjFj/bGL3pSNqnLrH4h+f8pp1/kfWtaVr+QZx37xUy9JYF38u6VX/zIkV/I2zO0EzEYm6IOdpLp+KRUl219mv9cBTrm/7cU/7F96ifNfzZJX/vR3minkLi9+Q9FX2Kv88Px85ehPCYtDJ2Up29w/AntUsR6WwS5O9WRSXnbRN4li33yFaKhD3G7FCs88Q1dPOb/b+irSkk9zPqY/6c5x/zadDVjwPwtyPN+G/OnLb3sdtyTta9qJdd5+qoS1bOtMf/Xp/jFEvy+zomC+EUlwZnVL273TdjvR79ImwubZb844cgvXiO/kHKeAr84R37hZovL2C+E3zS/wB2lmP9Mil9ocyTab1an+RGWm/0Cl7Pl2VnbEsTzVjaW8bP4TFa/wC1IWf3iHNWzts0tq19cBL4HyS+knFXwi6vkF45OtERsw9P8gk/oSP5Gil9o7Qiuo7Ff7PSrE+wXuEzOJ0Jm5ffNuW1Hn2kSzabPZPUL/O2arH5xlepZ296Q1S8uAN8fJgYhNib6eRH84pPkF4620kRcNvSLsyCTT7VJ/ldT/ELbDlODe+wXab9/g3hWSW/47Kz9ljTbt+bn7Gvmuk60FtAaRFsHGuqEk+YX+JvQWf3ik1TPaVtRNL84q+A1LD+WGITU71HId4+3XeYxReYy3JM3rog9nIDn7dlDsPWWHvntb/Qf3D58AuiYf5DiPyeUMmJdsP/cq+THcgse0S+eTJVnHevLT9PXcgZ9fVbRlzYXdhTKY9LC0El5Am0uDG1zEeROq1PMn7dORWdrlB/rV2joQ8dIzlFFDtYH+zDS5FlTHZ9Jrl3qvd7wffEDqXOxI04LQMf8v5nYDv4eunwu7ALnoN4OBlF70I7bvV612z5C/E2SOj7oQH6/U23WO81u7Pf8ZtCM9lp+2GjUmmHHr9Z73UGvuufy+43mqOCDfjsIgrDn93eSb+z4i9COlLzJ42EmSbuI24wtxmGZjzzJvQphtYxna0vzPOFh/fCW5gUF6xrRTNocjvMxbV65N7fHvFa9yfrmtlnTzXyKHK4rk1aU59jmWKet5Lu/u5R5G73Ir3hOfSBIqz9Nr6K7RQXrGtFMYjtZVOQsKnKKwkueN6lM3y3Xla/ZpmeR/0pK2bQ9u2wTWXwN+XNfsOpNty0p+xLQbJZdypaEldt0jHhE/iLl/y7NHSyTLlqWcHLfirLKCl6LsmsrpANMK6QPzXZQJ2w7ZcKMNIxX2PYxaWNt0YWR/d0MY23NBktEW1LKIbQDSjnWvEnfWSQa+s4S0dB3hL/W1pjUSj793aWA++m9bOfS+nq0PY4N0vowrR7xeXk2rZ3j9op93UMdVIMwjIJqvVNr+I3RyKDbCPuNdhy3m3HYq/YGoR/GtUHfj5tRr1ltjm5Xg257NJjx251BEAvvssI7CJudQS/oteNqp+7Xwl6tE1er/Xo/qnWafj2qRbE/qA067dFcSdjojvjWQ7/ZjEcxelz3g77wrii8I78a1vq1arvfj/x+s9noBlG30e33u7121K6PhoH1Xqff7sVhpxsOos7A77f7jTjojKAEfjcQ3gc1nTTrUccPu3G33e5GUbPfr44Y9dqdOIjCZjMcDeRGRe/U2n69Pypdpx/3BrX6aMGoE/l+sxYK70Ma73ZjVMp+bTQEG/0bxL2GX42rzV61MRgVqdrza8GIT7PR79WDervZiaOwPahFI8Rx5NebW7hXNH0HURCPUNUag5of+WEUVv1us9apmhqoV2u1kUqiTqMeBN04HCm72giDsB3Ena4fVfvtmvA+rOHu9zpBP2xG3ajbbwadQdev9keX7fbIZkaqqgaDthldmTocjTP9qD/oBN1BO+x2oiiuD4T3asLPdr8o/NcU7GEjjLv1Zrdba8fdTqffH9R7tXbj3SoMwk40UkI7ihrVqt/uD0bgo+aoEhrdRnPkFqNiNoX3XZrOo2rQq9XjQXuk8X63H40qYWQsUbcdVUe2H3WCZqfWb9ZroV+t1Uf3qiPWYbVbHSHo9aMt/zmi6tzvtXthGPtxIxqE7ebI57qj4XO/1+8NgpGHdBpxx49GddLu1+NoMPKsoNppNNqDRtDtxFt7+e8G3tw24ryP7bk8lOd5+vhB5FcIq+W2emv8cA/hYf1wf6/NM68pNIwZkIZyjipyNF6HLPJatcjriEVeB2e0jIct8rprRstYschrZUbLuGaRV9lBGTm2sdz+VqX9wvZOkta2YYzJSRuvCG7T7v08x6/naGsD2thK1iA4TttvPXEfhknTk+DOqyesD9YT2gzr6RBhbSXf/V2l/HrS+n9Jmp4Ed149YX2wntBmWE/Ybu2nnnAczknTk+DOqyesD9YT2gzr6QDwaiWf/u5SVRsLFKkOBHfeOkCb4zrAuOMY0Q4ofN3q0O9o/qvF7yK/4k3q0kX8vkp4WD8cv68pWNcUGsfva4qcNUWOxqtskdecRV4Vi7zmLfI6aJFXySKvQxZ5rVjkJW0Ft+2eN9k+OFoDzrwmLfIr3mT9uGgf5rxJvWrje8dr9gPBs6zgOZCCp+wGT1vwVBQ8JQUP/mKctl7GbSbirgB/LJsjW5xYE9upbFnqBvGuppRdi68kH8/Dp831m88Fb3IfBeb3lHslhc8c5S15unyTnh9upy1kwDZP9xnbQgq2+R2wLSjYmO9cSjmmyUFMaevBJaJNq1fbe5Pqozn0dhQ3/W4/rrdr9b3eGxX3OqMlk9Ecc69b60VxN8/eKG29UXSlrTfyWvkyyWrdZhk4Sf1t7TcEOYhH5C9S/v6B7TjdzNXoa+Ucq+F6v7bGeGW4HeuSG6wB7yf4Krxn7UZyrdW5lG3Vm6xzbme1NfZVRS9sR27mPsbnICSGw33JiPUQ0DH/5xJF7LQvGdfMTVoYOilPVduXjOugiyAXy+V543Jjfm4/V5T8WDdSvjXKb655P4O23wl1vkT5RYdLU/ILP7bjr0AdlZe340O/PEjYsey831rbS6TtV6gA5j+mNsfReLrB87GYtPlY7hfRD7k/5blapKEd5N0jI7rIu0fGRjvEbY2rvuCD3C6ITtPaBZs+yfuX0B5F1+iTRo7MIS0NvXFZhuPnTDqQfF8AeZhf8C1S/m9CX/pnZN+LijyT7zsp+UpTPt/lodxbGG6/Vx5O5p8fTuYX2ZXhJEahHQQa2pFJh5LvqC/kJTgWKf9fQrxh0jI8I8+vKfKXSf423Mo9Xhs7qOQ/qOQ39fPnCUaxbSy77fmPd2USf7zH2L4Ddq3tF3MVQzru29T9wRgX/M2B8X2kYVyHcceV4ZiO+f8Z/PV7FPva3Jep9VW8D5DfCe15zvuqzGcERH7Fm+xXXcwBanNc2n5Mt2vL782RTusnywoeM+d22JusM8QnvHCeZGP43qdmXxzDLWXUzZo3PdbOu0+Y431tn7DWB4u9H/TS/aNE+TU/5mfxuzclP++hF/4/BL//Gfk9ryMhDXXJfs8+ijSsf45D3axjj2338A46XSEdSf5/Vca8aXGg5g+MAfNrsaHoC2PKw6Svw270tTVHsLqDvg6TviT/v6foSyv/coq+tDXSwyn6Ql3isyybdSvP7ZUt7qRbtkXJ/58Z51/KUB6TFoZOyhNr4yzsIzBGnOYvmD9L/aeNpXAPwWGiYRvPYymUe4ho2DbzuA7beGnbsC3NGr9pMaur85CMCROfN2K9cdLmNgS3KdO129wntkQ0rZ9lefL81eGYxmsni/RdO4/C38UHtRhhkfIuJYbleNyhzrOzzkpKOdPODbpYi6nG7Xq3XQ+CZjXoV4N4p7WY/wczn2X54YEBAA==",
      "debug_symbols": "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",
      "brillig_names": [
        "process_log"
      ]
    },
    {
      "name": "init",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "init"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13434471300436635949": {
            "error_kind": "string",
            "string": "Function _log_transfer can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16541607464495309456": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 16
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "H4sIAAAAAAAA/7WTyw7CIBBFqcUo0sTEx39MU0y7dOHafyCtLHVRN+766dZkJkyI0QVwEzJMgMNcHoXwKjBKESGCHDEqjAs2Xs7tjDnEqVbBvin5HRijvvhLWH+jkFnk4QPxM50/rJBzmTyfe6F913PTrF8J/z5y+af7y+l//8OzRq9bzCvh/8P4uvfXx/M2ij/SbJGc0ptoOwAqvkT+EvmhJBvn8w+Yb4Svj6KMqNO1tnaNdfZkh8H0dhfwP+KH/QbzqHp4zgQAAA==",
      "debug_symbols": "bY9JCsMwDEXvorUXVub6KqEEJ1GCwdjBcQol5O61Swd32Ai+ePro7TBSv82dMpNdQbQ7aDtIr6wJaT8Y9E5preYuXQOPA/M7vy7SxLh66TyIvGFAZgRRVOF6UppAVNnBfkDkvHmyyBHLF45F8ZfHun7zp+qDPx8hXqRTstf0eH3azJCY+OtCX1KLswONm6Ool5iF2WLJMh5qQ/UN",
      "brillig_names": [
        "sync_notes"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "U253Note"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "serial",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "binnedAmount",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::TransferEvent"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "ShieldGateway::init_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::init_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "serial",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "binnedAmount",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::_log_transfer_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::_log_transfer_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "fields": [
                        {
                          "name": "value",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "uint253::uint253::U253"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::check_transfer_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::check_transfer_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "verified_id",
                    "type": {
                      "kind": "array",
                      "length": 5,
                      "type": {
                        "kind": "field"
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::verify_id_private_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::verify_id_private_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    /// Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "106": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "115": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/note/discovery/mod.nr",
      "source": "use std::static_assert;\n\nuse crate::{\n    context::unconstrained_context::UnconstrainedContext, note::note_header::NoteHeader,\n    oracle::note_discovery::deliver_note, utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\n    hash::compute_note_hash_nonce,\n};\n\n// We reserve two fields in the note log that are not part of the note content: one for the storage slot, and one for\n// the note type id.\nglobal NOTE_LOG_RESERVED_FIELDS: u32 = 2;\npub global MAX_NOTE_SERIALIZED_LEN: u32 = PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_LOG_RESERVED_FIELDS;\n\npub struct NoteHashesAndNullifier {\n    pub note_hash: Field,\n    pub unique_note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Processes a log given its plaintext by trying to find notes encoded in it. This process involves the discovery of\n/// the nonce of any such notes, which requires knowledge of the transaction hash in which the notes would've been\n/// created, along with the list of unique note hashes in said transaction.\n///\n/// Additionally, this requires a `compute_note_hash_and_nullifier` lambda that is able to compute these values for any\n/// note in the contract given their contents. A typical implementation of such a function would look like this:\n///\n/// ```\n/// |packed_note_content, note_header, note_type_id| {\n///     let hashes = if note_type_id == MyNoteType::get_note_type_id() {\n///         assert(packed_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///         dep::aztec::note::utils::compute_note_hash_and_optionally_a_nullifier(\n///             MyNoteType::unpack_content,\n///             note_header,\n///             true,\n///             storage_slot,\n///             packed_note_content.storage(),\n///         )\n///     } else {\n///         panic(f\"Unknown note type id {note_type_id}\")\n///     };\n///\n///     Option::some(dep::aztec::oracle::management::NoteHashesAndNullifier {\n///         note_hash: hashes[0],\n///         unique_note_hash: hashes[1],\n///         inner_nullifier: hashes[3],\n///     })\n/// }\n/// ```\npub unconstrained fn do_process_log<Env>(\n    context: UnconstrainedContext,\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: fn[Env](BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>, NoteHeader, Field, Field) -> Option<NoteHashesAndNullifier>,\n) {\n    let (storage_slot, note_type_id, packed_note_content) =\n        destructure_log_plaintext(log_plaintext);\n\n    // We need to find the note's nonce, which is the one that results in one of the unique note hashes from tx_hash\n    for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            let header = NoteHeader::new(context.this_address(), candidate_nonce);\n\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes = compute_note_hash_and_nullifier(\n                packed_note_content,\n                header,\n                storage_slot,\n                note_type_id,\n            )\n                .unwrap();\n\n            if hashes.unique_note_hash == expected_unique_note_hash {\n                // TODO(#10726): push these into a vec to deliver all at once instead of having one oracle call per note\n\n                assert(\n                    deliver_note(\n                        context.this_address(), // TODO(#10727): allow other contracts to deliver notes\n                        storage_slot,\n                        candidate_nonce,\n                        packed_note_content,\n                        hashes.note_hash,\n                        hashes.inner_nullifier,\n                        tx_hash,\n                        recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n}\n\nunconstrained fn destructure_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>) {\n    assert(log_plaintext.len() >= NOTE_LOG_RESERVED_FIELDS);\n\n    // If NOTE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\n    // `storage_slot` and `note_type_id` must be updated as well.\n    static_assert(\n        NOTE_LOG_RESERVED_FIELDS == 2,\n        \"unepxected value for NOTE_LOG_RESERVED_FIELDS\",\n    );\n    let storage_slot = log_plaintext.get(0);\n    let note_type_id = log_plaintext.get(1);\n\n    let packed_note_content = array::subbvec(log_plaintext, NOTE_LOG_RESERVED_FIELDS);\n\n    (storage_slot, note_type_id, packed_note_content)\n}\n\nfn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..MaxLen {\n        if i < vec.len() {\n            f(vec.get_unchecked(i), i);\n        }\n    }\n}\n"
    },
    "126": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n    utils::array,\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    compute_unique_note_hash,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header, storage_slot);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash(storage_slot);\n    let header = note.get_header();\n    let nonce = header.nonce;\n    let counter = header.note_hash_counter;\n\n    // If same tx note, read request always uses the normal note hash\n    if counter != 0 {\n        note_hash\n    } else {\n        // If the note comes from a different tx, we need to compute the note hash that reached the tree\n        compute_unique_note_hash(\n            nonce,\n            compute_siloed_note_hash(header.contract_address, note_hash),\n        )\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if (header.note_hash_counter != 0) & (header.nonce != 0) {\n        // Non-revertible note, nullified by a revertible nullifier, we need to nullify the note hash that will reach the tree\n        let siloed_note_hash =\n            compute_siloed_note_hash(header.contract_address, note_hash_for_read_request);\n\n        compute_unique_note_hash(header.nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note, storage_slot: Field) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note, storage_slot);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    unpack_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    storage_slot: Field,\n    packed_note_content: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = unpack_content(array::subarray(packed_note_content, 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash(storage_slot);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, note_hash);\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context(storage_slot)\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"
    },
    "129": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "130": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "131": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "132": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "133": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field]) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\n}\n\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\n    let _ = store_in_execution_cache_oracle(values);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "134": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    /// Safety: The to_address function combines all values in the instance object to produce an address,\n    /// so by checking that we get the expected address we validate the entire struct.\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "139": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "140": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "143": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr",
      "source": "use crate::note::discovery::MAX_NOTE_SERIALIZED_LEN;\nuse dep::protocol_types::address::AztecAddress;\n\n/// Informs PXE of a note's existence so that it can later retrieved by the `getNotes` oracle. The note will be scoped\n/// to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The note's `content` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value is\n/// typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are the\n/// inner hashes, i.e. the raw hashes returned by `NoteInterface::compute_note_hash` and\n/// `NullifiableNote::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree at\n/// `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was sucessfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    content: BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        content,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    content: BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n"
    },
    "144": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note_content,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        packed_note_content,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note_content: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    let _ = notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    sync_notes_oracle_wrapper();\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let note_content = array::subarray(fields, read_offset + 2);\n\n            let mut note = Note::unpack_content(note_content);\n            note.set_header(NoteHeader { contract_address, nonce, note_hash_counter });\n\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_indexed_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\n/// for later querying via the `get_notes` oracle.\npub fn sync_notes() {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        sync_notes_oracle_wrapper();\n    }\n}\n\nunconstrained fn sync_notes_oracle_wrapper() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n"
    },
    "17": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "174": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/unencrypted_logs/unencrypted_event_emission.nr",
      "source": "use crate::{context::PublicContext, event::event_interface::EventInterface};\n\nfn emit<Event, let N: u32>(context: &mut PublicContext, event: Event)\nwhere\n    Event: EventInterface<N>,\n{\n    let selector = Event::get_event_type_id();\n\n    let serialized_event = event.serialize();\n    let mut emitted_log = [0; N + 1];\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    for i in 0..serialized_event.len() {\n        emitted_log[i] = serialized_event[i];\n    }\n\n    emitted_log[serialized_event.len()] = selector.to_field();\n\n    context.emit_public_log(emitted_log);\n}\n\npub fn encode_event<Event, let N: u32>(\n    context: &mut PublicContext,\n) -> fn[(&mut PublicContext,)](Event) -> ()\nwhere\n    Event: EventInterface<N>,\n{\n    |e: Event| { emit(context, e); }\n}\n"
    },
    "177": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "178": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    vec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(vec.storage(), offset), vec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    /// Safety: borrow is enforced to be boolean due to its type.\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        /// Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            /// Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        /// Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "19": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "203": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "21": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    /// Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "239": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "246": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        function_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            function_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "26": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "262": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "263": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::{constants::TWO_POW_64, utils::{arrays::array_concat, field::field_from_bytes}};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_contract_class_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_contract_class_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; N * 32];\n    for offset in 0..N {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "279": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "280": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "289": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "310": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 2;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        // We use little-endian ordering to match the order in which U128 defines its limbs.\n        // This is necessary because of how Noir handles serialization:\n        // - When calling a contract function from TypeScript, the serialization in encoder.ts gets used and then Noir\n        //   deserializes using its intrinsic serialization logic (based on the limb order in the struct).\n        // - When calling a contract function from another function, the `serialize` method is invoked on the type\n        //   first.\n        // For this reason if we didn't use the ordering of U128 limbs here and in encoder.ts we would get an arguments\n        // hash mismatch.\n        // The below warning is due to visibility in noir stdlib.\n        [self.lo, self.hi]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_u64s_le(fields[0] as u64, fields[1] as u64)\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "326": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    /// Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    /// of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    /// Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "329": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "347": {
      "path": "/home/vscode/nargo/github.com/ClarifiedLabs/aztec-uint253/aztec-packages-v0.76.4/src/uint253.nr",
      "source": "// Copyright (c) 2025 Clarified Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nuse aztec::protocol_types::traits::{Deserialize, FromField, Packable, Serialize, ToField};\nuse std::cmp::{Eq, Ord, Ordering};\nuse std::ops::{Add, Div, Mul, Rem, Sub};\n\n// Maximum value for U253 (2^253 - 1), chosen to fit within Aztec's field arithmetic bounds\npub global MAX_U253: Field = 0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\npub global U253_PACKED_LEN: u32 = 1;\n\npub struct U253 {\n    value: Field,\n}\n\nimpl U253 {\n    pub fn new(value: Field) -> Self {\n        value.assert_max_bit_size::<253>();\n        Self { value }\n    }\n\n    pub fn new_unchecked(value: Field) -> Self {\n        Self { value }\n    }\n\n    pub fn from_integer(value: Field) -> Self {\n        value.assert_max_bit_size::<253>();\n        Self { value }\n    }\n\n    pub fn to_integer(self) -> Field {\n        self.value\n    }\n\n    pub fn zero() -> Self {\n        Self { value: 0 }\n    }\n\n    pub fn one() -> Self {\n        Self { value: 1 }\n    }\n\n    pub fn max() -> Self {\n        Self { value: MAX_U253 }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.value == 0\n    }\n\n    // Performs division with remainder using binary long division algorithm\n    // Returns (quotient, remainder) tuple\n    pub unconstrained fn div_rem_unconstrained(self, other: Self) -> (Self, Self) {\n        assert(!(other.value == 0), \"Division by zero\");\n\n        self.value.assert_max_bit_size::<253>();\n        other.value.assert_max_bit_size::<253>();\n\n        let bits: [u1; 253] = self.value.to_be_bits();\n        let divisor = other.value;\n\n        let mut quotient: Field = 0;\n        let mut remainder: Field = 0;\n\n        // Process each bit from MSB to LSB, similar to paper-and-pencil division\n        for i in 0..253 {\n            // Shift remainder left by 1 bit and add next bit\n            remainder = remainder * 2 + (bits[i] as Field);\n\n            // Single comparison to determine if we should subtract divisor\n            // Changed to just !remainder.lt(divisor) which means remainder >= divisor\n            if !remainder.lt(divisor) {\n                remainder = remainder - divisor;\n                quotient = quotient * 2 + 1;\n            } else {\n                quotient = quotient * 2;\n            }\n        }\n        (Self { value: quotient }, Self { value: remainder })\n    }\n\n    // Performs division with remainder using unconstrained binary long division algorithm, then\n    // constrains the result via multiplicative properties\n    // Returns (quotient, remainder) tuple\n    pub fn div_rem(self, other: Self) -> (Self, Self) {\n        assert(!(other.value == 0), \"Division by zero\");\n\n        if self.value == other.value {\n            (Self::one(), Self::zero())\n        } else if self.is_zero() {\n            (Self::zero(), Self::zero())\n        } else if other.value == 1 {\n            (self, Self::zero())\n        } else if self.value.lt(other.value) {\n            (Self::zero(), self)\n        } else {\n            //Safety: constraining this immediately after by checking the division property\n            let (quotient, remainder) = unsafe { self.div_rem_unconstrained(other) };\n\n            // Verify quotient * other + remainder == self\n            assert(\n                quotient * other + remainder == self,\n                \"Unconstrained division result is incorrect\",\n            );\n\n            (quotient, remainder)\n        }\n    }\n\n    // Adds two U253 values without overflow checks - use with caution\n    pub fn add_unchecked(self, other: Self) -> Self {\n        Self { value: self.value + other.value }\n    }\n\n    // Subtracts two U253 values without underflow checks - use with caution\n    pub fn sub_unchecked(self, other: Self) -> Self {\n        Self { value: self.value - other.value }\n    }\n}\n\nimpl ToField for U253 {\n    fn to_field(self) -> Field {\n        self.value\n    }\n}\n\nimpl FromField for U253 {\n    fn from_field(value: Field) -> Self {\n        value.assert_max_bit_size::<253>();\n        Self { value }\n    }\n}\n\nimpl Serialize<1> for U253 {\n    fn serialize(self) -> [Field; 1] {\n        [self.value]\n    }\n}\n\nimpl Deserialize<1> for U253 {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        fields[0].assert_max_bit_size::<253>();\n        assert(fields[0].lt(MAX_U253 + 1), \"Deserialized value is too large\");\n        Self { value: fields[0] }\n    }\n}\n\nimpl Add for U253 {\n    fn add(self, other: Self) -> Self {\n        let result = self.value + other.value;\n        result.assert_max_bit_size::<253>();\n\n        assert(!MAX_U253.lt(result), \"U253 addition overflow\");\n        assert(!result.lt(self.value), \"U253 addition overflow\");\n        assert(!result.lt(other.value), \"U253 addition overflow\");\n        Self { value: result }\n    }\n}\n\nimpl Sub for U253 {\n    fn sub(self, other: Self) -> Self {\n        assert(\n            other.value.lt(self.value) | other.value.eq(self.value),\n            \"U253 subtraction underflow\",\n        );\n        let result = self.value - other.value;\n        result.assert_max_bit_size::<253>();\n        Self { value: result }\n    }\n}\n\nimpl Mul for U253 {\n    fn mul(self, other: Self) -> Self {\n        let result = self.value * other.value;\n\n        result.assert_max_bit_size::<253>();\n        // Allow multiplication by 1 without additional checks, otherwise check for overflow\n        assert(\n            (self.value == 1)\n                | (other.value == 1)\n                | (result.lt(MAX_U253 + 1) & !result.lt(self.value) & !result.lt(other.value)),\n            \"U253 multiplication overflow\",\n        );\n        Self { value: result }\n    }\n}\n\nimpl Div for U253 {\n    fn div(self, other: Self) -> Self {\n        let (quotient, _) = self.div_rem(other);\n        quotient\n    }\n}\n\nimpl Rem for U253 {\n    fn rem(self, other: Self) -> Self {\n        let (_, remainder) = self.div_rem(other);\n        remainder\n    }\n}\n\nimpl Ord for U253 {\n    fn cmp(self, other: Self) -> Ordering {\n        if self.value.lt(other.value) {\n            Ordering::less()\n        } else if self.value.eq(other.value) {\n            Ordering::equal()\n        } else {\n            Ordering::greater()\n        }\n    }\n}\n\nimpl Eq for U253 {\n    fn eq(self, other: Self) -> bool {\n        self.value.eq(other.value)\n    }\n}\n\nimpl Packable<U253_PACKED_LEN> for U253 {\n    fn pack(self) -> [Field; U253_PACKED_LEN] {\n        [self.value]\n    }\n\n    fn unpack(fields: [Field; U253_PACKED_LEN]) -> Self {\n        U253::from_integer(fields[0])\n    }\n}\n"
    },
    "348": {
      "path": "/home/vscode/nargo/github.com/ClarifiedLabs/aztec-uint253/aztec-packages-v0.76.4/src/uint253_note.nr",
      "source": "// Copyright (c) 2025 Clarified Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nuse aztec::{\n    context::PrivateContext,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::partial_note,\n    note::{\n        note_header::NoteHeader,\n        note_interface::{NoteInterface, NullifiableNote},\n        utils::compute_note_hash_for_nullify,\n    },\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n        traits::{Empty, Hash, Packable, Serialize},\n    },\n};\n\nuse crate::uint253::U253;\n\n#[partial_note(quote {value})]\n#[derive(Serialize)]\npub struct U253Note {\n    // The amount of tokens in the note\n    value: Field,\n    owner: AztecAddress,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NullifiableNote for U253Note {\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self, storage_slot: Field) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self, storage_slot);\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl U253Note {\n    pub fn new(value: U253, owner: AztecAddress) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value: value.to_field(), owner, randomness, header: NoteHeader::empty() }\n    }\n\n    pub fn get_value(self) -> U253 {\n        U253::new_unchecked(self.value)\n    }\n\n    pub fn get_field_value(self) -> Field {\n        self.value\n    }\n}\n\nimpl Eq for U253Note {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n"
    },
    "51": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "52": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "62": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/shield_gateway/src/main.nr",
      "source": "mod test;\n\nuse aztec::macros::aztec;\n\n#[aztec]\npub contract ShieldGateway {\n    use std::meta::derive;\n\n    use aztec::{\n        event::event_interface::EventInterface,\n        macros::{\n            events::event,\n            functions::{initializer, internal, private, public, view},\n        },\n        oracle::capsules,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{\n                FromField,\n                Hash,\n                ToField,\n                Serialize,\n            },\n        },\n        unencrypted_logs::unencrypted_event_emission::encode_event,\n    };\n\n    use uint253::uint253::U253;\n\n    pub global VP_SLOT: Field = 0x1dfeed;\n    pub global BIN_AMOUNT: U253 = U253::new_unchecked(1_000_000_000);\n\n    #[derive(Serialize)]\n    #[event]\n    struct TransferEvent {\n        serial: Field,\n        token: AztecAddress,\n        binnedAmount: Field,\n    }\n\n    #[public]\n    #[initializer]\n    fn init() {}\n\n    #[private]\n    fn check_transfer(\n        sender: AztecAddress,\n        recipient: AztecAddress,\n        amount: U253,\n    ) {\n        let token: AztecAddress = context.msg_sender();\n\n        aztec::oracle::debug_log::debug_log_format(\n            \"Checking transfer of {0} {1} tokens from {2} to {3}\",\n            [amount.to_field(), token.to_field(), sender.to_field(), recipient.to_field()],\n        );\n\n        // TODO: What checks should we perform here?\n        // Ensure Verified ID is provided & valid\n\n        // Safety: value constrained later\n        let mut verified_id: [Field; 5] = unsafe {\n            capsules::load(\n                context.this_address(),\n                VP_SLOT,\n            ).unwrap()\n        };\n\n        let _ = ShieldGateway::at(context.this_address()).verify_id_private(verified_id).view(\n            &mut context,\n        );\n\n        // Publicly log Verified ID Serial & Token & binned value (Amount / BIN_AMOUNT)\n        ShieldGateway::at(context.this_address())._log_transfer(\n            verified_id[0],\n            token,\n            _binned(amount).to_field(),\n        ).enqueue(\n            &mut context,\n        );\n    }\n\n    #[contract_library_method]\n    fn _binned(amount: U253) -> U253 {\n        amount / BIN_AMOUNT\n    }\n\n    #[public]\n    #[internal]\n    fn _log_transfer(\n        serial: Field,\n        token: AztecAddress,\n        binnedAmount: Field,\n    ) {\n        TransferEvent {\n            serial,\n            token,\n            binnedAmount,\n        }.emit(encode_event(&mut context));\n    }\n\n    #[private]\n    #[view]\n    fn verify_id_private(verified_id: [Field; 5]) -> bool {\n        // TODO: Implement ID verification logic\n        aztec::oracle::debug_log::debug_log_format(\"Verified ID: {}\", verified_id);\n        true\n    }\n}\n"
    },
    "67": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub gas_opts: GasOpts,\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"
    },
    "7": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "74": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        execution_cache::store(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            /// Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            /// for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        /// Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        /// execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        /// the number of side effects that took place), along with the hash of the return values. We validate these\n        /// by requesting a private kernel iteration in which the return values are constrained to hash\n        /// to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        /// WARNING: This is insecure and should be temporary!\n        /// The oracle hashes the arguments and returns a new args_hash.\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        /// We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        /// b) this is only temporary.\n        let args_hash = unsafe {\n            enqueue_public_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.set_public_teardown_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        /// WARNING: This is insecure and should be temporary!\n        /// The oracle hashes the arguments and returns a new args_hash.\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        /// We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        /// b) this is only temporary.\n        let args_hash = unsafe {\n            set_public_teardown_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "75": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, Packable, Serialize};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            /// Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            /// Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "76": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        /// Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "77": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "89": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    }
  }
}
