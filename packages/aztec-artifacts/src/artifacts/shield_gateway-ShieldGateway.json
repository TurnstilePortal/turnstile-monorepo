{
  "transpiled": true,
  "noir_version": "1.0.0-beta.1+c4e38215cedb5afb",
  "name": "ShieldGateway",
  "functions": [
    {
      "name": "get_channel_balance",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "error_types": {
          "14217640468024275109": {
            "error_kind": "string",
            "string": "Function get_channel_balance can only be called statically"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "1775037338128445371": {
            "error_kind": "string",
            "string": "Deserialized value is too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "get_storage_address",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "H4sIAAAAAAAA/7WWTVODMBCGk5Z+UERn6i/wolewdNpj/bh48eDBe4RQOyrMAN770wXdyLoNTB3CzjCbhOTJm2WTwFltHLzF/hpnRxhvabsCb4MfoPfD8tlA3etmvk3mNclfe8HS1qzPoP6FDUzeD99T/J7i702Ac7+v+Xgtat5p+Zygsgtlt2V8n9rLbxvYiGmaX5p/3qC/MgficAH1KjanUN7K4vY9Dd8ePz9eZIZ3GY0u05CxVdR5Tb1LkyITYXETRZnMc0oYaMisgTpD1FexSx6iJj3/pD3LLN+lCaVZR9KG0GeE+uMxtqZtA97rZr97eWye7bvAnpC44DVNUbvBPL7WZRz9unj+GdFqel9xMp/SQ+Oj8rnKMAfKeZFmYiufpIiwdBo+6mna6e5NvIV043BaqvpYw2mzvq8LrtHZFlrODlO+bQuescOjRo11WfP14bD6V8Lam1/7av2z9m/9wB8x/aFqofe4/yXUZ0i/8lYHnfFK+PFCxGIpoigIxZzwGYnTFxukaL3gCQAA",
      "debug_symbols": "7ZjBioMwEIbfJWcPmUwySfoqy1Jsa4sgWqxdWIrvvmbXWHcNeugtm0sx5WP4800L4zzYqTjcL/uyPjc3tnt7sKo55l3Z1MPp0Wfs0JZVVV72868Zdx8gv/nbNa/d8dblbcd2QCQyVtQn96jFUOFcVgXbEfbZAjZcjawROKFGB1AlPKoUn1CQ0L9nDNTrURT5KNqsR5FoR1SSWUShl6NYjiNrQa9HoUkgCVpE0a9HkeCjKLkRxfAR1XzZIBOMwrXw9YdnRethhLSeFgpm1yUK0WC0pwXfaClYMh7mSOuw5tLfVD37AyqUQmpfV1r7i3VW7D+1gtb/g9T8Z/tjRfBkJWAFkpWAFZGsBKxgshKwIpOVgBWVrASsULISsKIjskL2acVsWUHwczYiPuc4hGAMrnHyYWY0hmgD3rhBucES+BmbZtdzrOtOTDN2fN2JadaPrjsY0ztHZN3ph+NH3pb5oSrGpdT5Xh9nO6ru81r8WVdd2+ZYnO5t4RZXs52V6zNihmYoO5T+Ag==",
      "brillig_names": [
        "get_storage_address"
      ]
    },
    {
      "name": "get_default_channel_threshold",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "H4sIAAAAAAAA/+1bzW4jRRDuiT22xz9jb8KRB0CcZhKbJFww7IIUJBBaCQ7cJvF4WQGJlIS7HwIhEAeuSBy5c+ExkLjAAYmXIB11eT5/LredeCbsSltS1DPT1fVfNdU9TmAKCNxYN4sQmA0g8Dz7xF1E7n4H5ms3f2N3n2wHaUR8y6R/lAzfihT9SpT/IHI0g2roJ0K/IvsnTUfn/VlBH3URvq2bvy5c9911z7O+StlvfDuKgGbZ9G8g3Vshv+hm4fGsEt6J0H9SDf2DjvPjn46e9W3srp/l1+99dXH25cfffH2aX2KVYGsYxTIIlupuQfXxxfn1ZXZ2/e5kcplfXa2isK54WaptoPpF9vz8ZMLU6vej9ll+efX84pyphRtSk5hswLOxG5MtQWg3y6e933O0W6Q36oS1usxYDIifMcuxgPzbJGvZeR8QP5GH7SOZILZrK7IOlLkGXOMc8mkrfDRaTZIBY+OB/De8r/+a1cjj9V9Tsev/6b8qaPXNsr+bxEezTeThg+sFL1LWjd2Y3A32+QH7RHgj3w48LzF+RpvGs/Bvm2VfVBHPHZJnVWyI7bqKrANljmOwq/DpKnxeJloSo32FNudGQ+HT8PBpKjL3lHXBilH48DPmo8ncV2Rokz5NRZ+mh89d3y/31UeTWfhEJfJBWtKv++rLXflo9cjC2I3JlqD5pUO8MdbL3p8HptjnlUx/3ncGio9svD8FvvZPuvrQFLGM/urBPOL/YAqan7rrPuFouSN9P+LUFT+EhP+5G8V+FfWqyS7QNcQrUuQtkXcuvpN9I4LM9YE318YBzHGdeQRzEc2hzugvBt6Roi2sjf4GuownoMUI91mhoofMtRQ9tHpepzmsjSHNYV/n87WFsRuT7SDVahDyQn0s1Eh2CzuEr72XkIbUAc0HzRV8AuCDdqlgP36wyZ6rorzfeM8l/B9qz9UieVb1GvZ9JbXz6vriMnuWP82zCYqO5DTVOOUFB8/CA7NYBgJlPqT7hkLHB33iw2ZmGWrKM19rVCNadYWWZmJ+hSE+0uA0Q37hBrR8vH0lAdsWX5n10fLx1kIRafaIN8rFZRXXlZg2h1oJEeAjOfYNg/a6E7ktjTeDgi7jmRdU33rF+nIccRzUjB472qsrVOQIzGKbKs+xfd1ReIeE/50b7f23ptBL6Mr6OuB978GrKXgds9w2/wh4f7jryOh2Grv7ZDvYF1ljxVaBx1aC/5MbbQykQYG/qn5pR7osA+JzTbSg1a+Y5nAdH0fEMMdbEGmhNdr2mrcggv+zG8Vf2G5XvQUZkA4x6KC1hk9mizoI/u9utPH3i1m0mZZvmj25JcctCfsB5W6T/Xarsd+B2GjPFDaoKbLumkUbCf6vbsR4l5pXmxXrQ9DHQn1WiT5DK8cQ5LCXsp27lR/4ol7GFHojPufknoKPvhGbDQif8xPvkRbavEv4YsPGCnw8nkD839xobfNhsCgfvisekez4XoppLlL4atu0Acj8QDX8pTwaEFvc9WigjDrUJn4vSt6KHyxw3mKO1hR8ztt1eS77kIFZ9iXHN+bMgOY2zZkuzWG8iG8wZ3w1I1DoruvP5GizSr8eHiWJ8JeYkvcLQx3mEf8vd8/5JPqM7ynn9DBLpwfZNBtlk8nwLOM+woLEEP9cpeJ9Siq+wx4Fj6X/Ab4Yc/ju9vU38/1DUND81z3S6kpAc6j3Ds1pZwfacaTEYtU/D3j1KXcO3k+52ifGij/vDEWeniKP9mnZ1uvYLPsM5RNa2Gv5Pr/yfueun1+1n0AMzHLt5WP0HUUGmdPO8mQO9ZJ86hh//gWEr9UJXrtQJ4z/nCFk+lBX3nDXWg3guoI1gOsK5wTOYSxwXano0+E8duM1NuVPgoLfc8pr5wRaPmg/j2EZEB/1DslemC8x2Suuxl7zfWZ/jb1ispfgv+axl6a/71ylr+DHHnuhLXEt815Vix4qFtfZlmNR8F9XbKvtBfCnVxbqs0r0GWl7AfypTQh8V+WL9tMcn/+1fBkQPvpbq/EtmkO+3O9jbeb6r33ix1rK/SHWauwPsWfVzntFdgv8c3YLYzem0+3AkF5NRRbhy2fACcTmR+66Y8rfD+RHx5PkeJpnaZruT5J83X5gvkebFfOYK7d6uns5d2T8HdAZ8Y/g/fk25WOo8LN4Jx68YMV4S0N5Vp8tPotmy/i12TK+8G7PlmWUuQ7MYR5b6Lp7tBfSEjlCwv8AegwLLVgj6wcK/xbxX5Bbecb/fNBR8DsKvvXPO26RxC3qXnaPf8uT6OMzlu2kwrwajrLDs+wwTY+HaT5MR+vyqmz+oyzZv+F7ejpK8+z4eLqO/3+l20Wc4DYAAA==",
      "debug_symbols": "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",
      "brillig_names": [
        "get_default_channel_threshold"
      ]
    },
    {
      "name": "set_default_channel_threshold",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "4475601672736294460": {
            "error_kind": "string",
            "string": "Unauthorized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "new_threshold",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "set_default_channel_threshold"
      ]
    },
    {
      "name": "get_channel_threshold",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "1775037338128445371": {
            "error_kind": "string",
            "string": "Deserialized value is too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "3238985437272151328": {
            "error_kind": "string",
            "string": "Function get_channel_threshold can only be called statically"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          }
        },
        "parameters": [
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "uint253::uint253::U253"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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AycAgAQEAAQkAAAJXC0IgAUAEgAoEgITASgAE4BEABQsDg4ULA4SCiwOEAgsDgELLA4RDCIAAAdBADgEAQ4sDA4EIgAABAgnAIAEBHgADQAAAIAEgAMjAIADAAAHdykBAAEF96Hzr6Wt1Mo7AQECJSkBAAEFvh4//z6k9vo7AQECJSkBAAEFLPMwGCVFFSA7AQECJSkBAAEF6J0J/qERLQ47AQECJSQAAAdPHAwBAgArAgADAB//////////////////////////////////////////DjgCAwQjAgAEAAAH7yQAAAn8JSkBAAEFGKIzDfIzb7s7AQECJSQAAAdPJgIGBAEtCIBEAAUiAAAIFw0oAAWARQAHIwIABwAACIciAAAILCwNAQUsDQIGLA0DBywNBAgmAgkEBCwIAQomAgsEBQAQAQsBJgMKBAEAKAYCCyYCDAQEACgKAg0+DwALAA0sDQoGACgGAgYsDgYKLA4FASwOCgIsDgcDLA4IBCUsDQMHDDgFBwgAOAUGByMCAAgAAAiiIgAACVMsDQEILA0CCSwNAwosDQQLJgINBAQMOAUNDiMCAA4AAAjJJAAAB5wAKAkCDQA4DQUOLA0ODCYCDgQDDDgFDg8jAgAPAAAI7iQAAAecACgIAg4AOA4FDywNDw0AOAwNDiYCDQQEDDgFDQ8jAgAPAAAJGCQAAAecLQQACYADJwCABAQABSQAAAlcLQiABQAMACgMAg0AOA0FDywODg8sDggBLA4MAiwOCgMsDgsEIgAACVMsDAcFIgAACBctAYADgAYLAIAGAAKAByMAgAcAAAl3IgAACYItAIADgAUiAAAJ6S0AAAGABQEAAAGABAABAQCAA4AEgAktAIADgAotAIAFgAsLAIAKgAmADCMAgAwAAAnVLQGACoAILQKACIALAQCACgACgAoBAIALAAKACyIAAAmkJwGABQQAAQMAgAYAAoAGIgAACeklKQEAAQVFp8pxGUHkFTsBAQIlKQEAAQVaAuQbtR6pnzsBAQIlLQAYyhjK",
      "debug_symbols": "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",
      "brillig_names": [
        "get_channel_threshold"
      ]
    },
    {
      "name": "_log_channel_creation",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "10775636126596421126": {
            "error_kind": "string",
            "string": "Function _log_channel_creation can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JgACBAEnAAABBIBHJgAABAMmAgQEAyYCBQQAHxgABQAEgEQtCIBEAAEtCIBFAAItCIBGAAMkAAAAUSQAAABSJwIAAQSARyYCAgQAOg0AAQACJSQAAAEbHgIABAAeAgAFADI4AAQABQAGJgIEAQEjAgAGAAAAeyQAAAFEHgIABAEeAgAFAAo4BAUGIwIABgAAAJckAAABVigCAAQAmKkMlCYCBgQEJgIIBAMAOAYIBywIAQUAEAEHASYDBQQBACgFAgcsDgYHACgHAgcsDgYHJgIHBAMAOAUHBiwMBgcsDgEHACgHAgcsDgIHACgHAgcsDgMHACgHAgcsDgQHJgIBBAQAKAUCBCwNBAMmAgYEAgA4BAYCNg0AAgADJScAgAQEeAANAAAAgASAAyMAgAMAAAFDKQEAAQX3ofOvpa3UyjsBAQIlKQEAAQW+Hj//PqT2+jsBAQIlKQEAAQWVir/3IqVWBjsBAQIlLQAYyhjK",
      "debug_symbols": "7VnBbsIwDP2XnHuIncRx+JVpmgqUqVJVUIFJE+Lfl6I1K1ANDcoOmAtq0Ev83rNBbrxT82K6fX8r68VyrSYvO1UtZ/mmXNZxtdtnatqUVVW+v/W/Vrr9YH/Ar1d53S7Xm7zZqAkQYaaKet4+eownLMqqUBMy++wcrLXrwBpdAgP4AbS11n+jrXWU0OwGwGzS0WwQ+uDXTAUcgTsncCT/j9zH8N1C8p0u+Q6OEppaxG/cgwkdOFhjT7iDdqOSj+cdkW9DgL5/CL57CDQ3h7CEXYj4GC7VnMdUc+xP84a3Kx7xJwDmr+4cNvEVmyxdscnB0CbWxJ2m+O9xoT5M6NwC26uPQTBrSAf/pA7YDmAddyQI4AKWqeMQ9FkOSEsQ6QSI9BIy6UVkMggQyVaCSAmZDBIyGfjxRaI2EkR6ASIBJYiUkEkU8BaCKKCtQyOgQUdjJYgU0NahldAMWAltnXuUZsClS2l9dCc9cIHtuLt5DAR05sijdA6jOULPGjl1hJ6OHDviH6UVHc+RZ430HdnH1UfelPm0Kr4nz4ttPesNojefq+JkJr1qlrNivm2Kdjr9M5g+DACdy0i/trO6uIjzSzIxRozzBQ==",
      "brillig_names": [
        "_log_channel_creation"
      ]
    },
    {
      "name": "_log_channel_threshold_exceeded",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "7136678259008445534": {
            "error_kind": "string",
            "string": "Function _log_channel_threshold_exceeded can only be called internally"
          }
        },
        "parameters": [
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JgACBAEnAAABBIBHJgAABAMmAgQEAyYCBQQAHxgABQAEgEQtCIBEAAEtCIBFAAItCIBGAAMkAAAAUSQAAABSJwIAAQSARyYCAgQAOg0AAQACJSQAAAEbHgIABAAeAgAFADI4AAQABQAGJgIEAQEjAgAGAAAAeyQAAAFEHgIABAEeAgAFAAo4BAUGIwIABgAAAJckAAABVigCAAQAfG2HQyYCBgQEJgIIBAMAOAYIBywIAQUAEAEHASYDBQQBACgFAgcsDgYHACgHAgcsDgYHJgIHBAMAOAUHBiwMBgcsDgEHACgHAgcsDgIHACgHAgcsDgMHACgHAgcsDgQHJgIBBAQAKAUCBCwNBAMmAgYEAgA4BAYCNg0AAgADJScAgAQEeAANAAAAgASAAyMAgAMAAAFDKQEAAQX3ofOvpa3UyjsBAQIlKQEAAQW+Hj//PqT2+jsBAQIlKQEAAQVjCpMQmHOcXjsBAQIlLQAYyhjK",
      "debug_symbols": "7VnBbsIwDP2XnHtInNhx+JVpmgqUqVJVUIFJE+LflyKaFahWbet2wFxQg15iv/dcyY0PalnM968vZb1ab9Xs6aCq9SLfles6rg7HTM2bsqrK15f+30q3P+xP+O0mr9vldpc3OzUzRJCpol62jx7iCauyKtSM7DG7BWuNHVgDJrAxfgDtnPNntHNICc04AGabjmYLpg9+zlSACXLnBI7J/2PuU+juTNKdxnQ3SAlNLeKr3IMNHTg4665yNxonTT6ed5F8G8Lovw/Bfx4C7K9DOIIuRHwMYzXnIdUc+2vf4PeMJ3wFjP2uOqdN/INNjn6wCc3QJga2iZMdqw9E10VAGgGz7ozm3vtp2A1gkfmMJWNGsEydY0HfeEBaAkkUQNJLcNKLcDIIIMlOAkkJTgYJTga+f5KgrQSSXgBJAxJISnASBHyFAAho68AKaNDBOgkkBbR14CQ0A05CW4f30gxgupTWF3fSAxfYyN3NYyBDN4rcS+cwmSL0qJFrReihyKUi/l5a0ekUedRIX5FjXL3lTZnPq+I8eV7t60VvEL173xRXM+lNs14Uy31TtNPpz8H0aQCImJF+bmd1cRHnl2RjjBjnAw==",
      "brillig_names": [
        "_log_channel_threshold_exceeded"
      ]
    },
    {
      "name": "channel_exists",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "compute_note_hash_and_optionally_a_nullifier",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 20
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "contract_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "storage_slot",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "note_type_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "compute_nullifier",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "packed_note_content",
            "type": {
              "kind": "array",
              "length": 3,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 4,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "compute_note_hash_and_optionally_a_nullifier"
      ]
    },
    {
      "name": "process_log",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8861757336002045335": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 99
          },
          "9862881900111276825": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 35
          }
        },
        "parameters": [
          {
            "name": "log_plaintext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "tx_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "unique_note_hashes_in_tx",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 64,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "first_nullifier_in_tx",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "process_log"
      ]
    },
    {
      "name": "init",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "admin",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "shield_gateway_storage",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "default_channel_threshold",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "init"
      ]
    },
    {
      "name": "verified_id_transfer",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "fields": [
                {
                  "name": "value",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "uint253::uint253::U253"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Zrdbts8DIbvJcc5EEWKpHorH4ahP9kQoGiLtP2Aoei9T84q2WnkGFSaLh18UlQxH+bNK8Ui5bwsblZXzz+/r+9+3D8uLv57WdzeX18+re/v0uhlAbh97fHh8q4bPj5dbp4WF8Dsl4vV3U33r/jX5eLH+na1uGB8Xe4Fe8/yFuy9xhIMztWiI+lbNDoPE9HAGLUoIejjvUA1PvThIn20ai0aGXM0gduJ/rZcAM3ejHoTZm9GveEz94Yw9N5QnPDGg+esBSgc6Y3M3ox6o7M3o97E2Zsxb7w72htyMQcTeC3BSts3gFO/gT/6DQAd5WDEweyC1KIdSJ6A9H/EoaDa0tEYy9qJ+/rxi+unmn6Omte0pM9yWL+6rEdpuNu6bf5qtSAYIecnR8P8HVPdRYXKF0dIw2FNIacPceLW8HWKCy/na8vfvAfqbEvNljjbUrEF3WxLzRaYsiU4PPxpUcs+j9H3eqS2i2EpyAj62z+Q34rxx4uJFIuYwR5ZFZPcdr3zPJipP3sk4pnpoU/WIxJd1iMK8l5PODM9fLSeVKlCv0DhsB4JeTHLoLlQ3mqRz9Wi3pdiTIZaKjcQkRzrFae6IuVYyjxBnLg5af8Bkw6aiMaQg8kPbk110VDK2R0ZXF8opVSWGCaCXckMjnUY3M2jzvP4T8xjnOfxX5hHcp88jwD1eey01IunwFm/MExoCZQ3/BD6UOTwtVtW8rMzI87gWTvzF1sRotmZEWfC7MyIMzzpTKCJZj1tdVkPBTyifSX5ADHl4/ow2IKb2kXSM9MTP1nPRLsY3JnpgQ/VwzpxFuNLIYlOd0qbNLjarG9v1z+/7/x0xHV/YvU7F7Xskc7tPQ2I0sBoAxPtTHqtBYIWyLdA2AJRCxRaIG6BpAXSFqhlRUDLioCWFQEtKwJaVkT9p02R+2eKjvah0AJxCyQtkLZA0QqlEXSh9Yfinkr9wP0OwH78KfdBAs0EmYlgJthGpIHvAuuVawAsxajfq6LYjogdUTsSjUga4XbZVCcoNaH5YMH1GzWk85/RGTqMsB0RO6J2JJqR+sM69QUh3UPAjng7gnaE7EiwI2xHxI6oHYlmpH7Ep5p/LKMx7iC1Ni33ITg480SU8VO7j0vvT5seT5ueTps+nDY9nza9nDa9fmB6xb308aTpgztt+np1Xc6SIsr7+0jwdgTtCNmRYEfYjogdUTPC0YyIsyMjlXco9ae8XzDi7QjaEbIjwY6wHRE7Up399HQyI3HvWynRjKizI2BHvB1BO0JGJI1o2xJU5bHPHTwPfnv71n7UG8PDCNmRYEfYjogRSaMw95Np+P/lZn15dbvqjmO7q8931/l0Ng2ffj3kK/n89mFzf726ed6supPc/hC3W0zql9F/687I0qB7Jp6ezJSzji4gzQdqDkj9GlFp7LvLCEuCfDnAMnBpebcvsV+ydNe7r286+U5vltf/FndLchmnlIvLNI9lf00m/AY=",
      "brillig_names": [
        "debug_log_oracle_wrapper",
        "pop_capsule",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "store_in_execution_cache_oracle_wrapper"
      ],
      "verification_key": "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"
    },
    {
      "name": "initialize_channel",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "1775037338128445371": {
            "error_kind": "string",
            "string": "Deserialized value is too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "notify_created_nullifier_oracle_wrapper",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "channel_key",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3NTuMwEIDfJeceYnv8x6usVqhAQZGqFpWy0grx7huvmhRsY2tS5+LxBRHqwZ7Psf0lJOaje9o9vL/cD4fn41t39+uj2x8ft+fheBiPPj433cNp2O+Hl/uvP+5694WZ/+XfXrcHd/h23p7O3R1Tim+63eHJfav5+Bueh/2uu1PicxMUNr28lDVczEWNjhSVfCoqZT8XZcA+f286Zm9vilRTU7RJNwWEvRQFZfym8P7mptheXMpaptNNUTNAxVXQFHZ7U4BNTZGQaYrpL0V1H3QQ57c3RbO5LZrLr4VdBWLtCmDtCuTaFai1K9BrV2DWrsCuXIHo166ArV3B2iNZFBjJSolrBTYz8QOfZ37Q10mOaxYpLeZlAvh1lnNzb1CUMwuXspwzni4s50ZIrr8WdUSgEfGIyEbEI6IaEY+IbkQ8IqYR8YjYRuQ7EegbEY8Ia0Q8IrwR8Yg0Z/WJQCPiEaHprGq6KyQV84nQdNYUEZrOmiJC01nnsup7UUeEprMmiEiazpoiQtNZU0RoOmuKCE1nTRGBRsQjQtNZU0RoOmuKCE1nTRFpzuoTac7qEVHNWX0izVl9IgSc1aVJQERdmkAjTQLK6NIk4IEuTQJy59IkYGwuTQIaNqapCbiVS5OAMLk0aViQpmFBGmikScOCNA0L0jQsSNOwIE3DggwNCzI0LMhUs6BwcU0TpJ9mNVOQZtNLglwLsbiwY1LNfIVhwq5NZsr4jwXZaia3gkyqmQkLMqnm4rEgk2quNFFMtJ5+MdPWX3csNCYBk2qUoyCTai54CzKp5uq4IBOSHpthQtNjk0xYT1NkM1BommwGCk2VzUBpLhuBAg1KCKXZbARK09kIlOazEShNaCNQmtGGUBhNo7Vszs/yEApNo81AoWm0GSjVLMmin8pywSDIs5pVNpNnNQtnJs9q1sJ0nrya5S2TZzUrVibPahahTJ7V3Cnhls959jKz2Pbzyjxe7JoACjQoIZR6HjXCQGFi/ps5kyyAUo2WlYRSjcOVhFKN8JWEUo0d4qAoOUMxwUQrqlEPFBTop+2+xm+DM6We7b9LQoEGJYRC01MyUGh6iuTz6vP138NMUGh6SgYKTU/JQKHpKWko9ewJXhJKNffHSkKhabQZKDSNNgMFGpQQCk2jzUBpRhuBQtRo9ZyftDyAQtRo01CIGm0SSj07hpeEQtRo01CIGm0aClGjTUOBBiWEQlPexPURPyGCe7T17JhdEgpNectAoSlvaSj1bJ1dEgpNectAoSlvGSg05S0DBRqUEArN25EZKM1oI1Ca0UagEDVa0DMUFdy4rmcL8oJQ6tmwvCQUokabhkLUaNNQiBptGgo0KCGU9sho+MhoPZu4l4RC02gzUGgabRpKPfus/wzF5RnfIlWL6VVCDSIIiQ4iC1M1Voa1GHyIxYbw+K576ZC4jiZfpeQ/7NmWCRJLgmBJkFwSpJYE6SVBZkmQXRD0w541maAlZwRbckawJWcEW3JGsCVnBFtyRsT3xUhNJzy+xYTtp/8nYHkQwvEDPf6ifLoWwIdIfIjCh2h8+gYfgp+ABb5fBMOHcHyIwIfEe1/a65IehEh8iMKHaHyIwYdYdEj8hZJ0SK73IyH43gd878cfZE+HSHyIwofgxz7gxz7gx77Ej32JH/sS3/sS3/sS3/sS3/sS2fuf49Gf7WnYPux3b2OE+/D98HgejofL4fnv6/TJw2nY74eX+9fT8XH39H7a3e+Pj+6zrr98+cXHyxNuwMm2O2RGbJgx7tD1Czdy/FSPtY41/wM=",
      "brillig_names": [
        "channel_key"
      ]
    },
    {
      "name": "set_channel_threshold",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "1775037338128445371": {
            "error_kind": "string",
            "string": "Deserialized value is too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "4475601672736294460": {
            "error_kind": "string",
            "string": "Unauthorized"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          }
        },
        "parameters": [
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "new_threshold",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JgACBAEnAAABBIBGJgAABAMmAgMEAiYCBAQAHxgABAADgEQtCIBEAAEtCIBFAAIkAAAASyQAAABxJwIAAQSARiYCAgQAOg0AAQACKwCAQwAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACUkAAAEfR4CAAMAHgIABAAyOAADAAQABSYCAwEBIwIABQAAAJokAAAEph4CAAQBJgIFAAEuDAAFAAYKOAQGBSMCAAUAAAC8JAAABLgmAgQEBSwIAAUsDAIGABAABAAkAAAEyiwEAAAmAgQAAy4MAAQABSYCBgQAJgIIBAMAOAYIBywIAQQAEAEHASYDBAQBACgEAgcsDgYHACgHAgcsDgYHJgIHBAMAOAQHBiYCBwQBJgIJBAMAOAcJCCwIAQYAEAEIASYDBgQBACgGAggsDgcIACgIAggsDgcIJgIIBAMAOAYIBywMBwgsDgEIJgIHBAAmAggEASYCCwQMLAgADCwMBw0sDAQOLAwIDywMBhAAEAALACQAAAUMLAQAACwMDQksDA4KLA0KBAAoBAIELA4ECiYCBgQBJgIMBAMAOAYMCywIAQQAEAELASYDBAQBACgEAgssDgYLACgLAgssDgYLJgILBAMAOAQLBiwMBgssDgILJgIMBA0sCAANLAwJDiwMCg8sDAgQLAwEEQAQAAwAJAAABQwsBAAALAwOBiwMDwssDQsEACgEAgQsDgQLLA0LBAAoBAIELA4ECygCAAQAQX94rgAoBgIJLQQAC4ADJwCABAQAASQAAAYNLQiABQAKLQiABgAMLA4EDCwNCgQAKAQCBCwOBAosCAEEJgIGBAMAEAEGASYDBAQBACgEAgYsDAYLLQqAQwALACgLAgstCoBDAAsAKAQCBgAoCgINLA0NDCYCDgQCADgNDgs4A+UABgAFAAsADAANIAIABCwIAQYAKAYCCywNCwomAgwEAgA4CwwJITwABwAEAAksDAQKJgIMBAMAOAoMCwAQAQsBJgMGBAEAKAYCDCwOCgwAKAwCDCwOCgwsDAoFBigFAgUsDQYEACgEAgQsDgQGIwIADQAAA0ciAAADKwAoBgIKLA0KCSYCCwQCADgKCwQ7DQQJIgAAA0csDQYEACgEAgQsDgQGCjgFCAQjAgAEAAADaiYCCQQAOwkBCQAoBgIFLA0FBQw4BwUIIwIACAAAA4UkAAAHhyYCCAQDADgGCAUAOAUHCCwNCAQmAgUEBiwIAAYsDAQHABAABQAkAAAEyiwEAAArAgAFACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADDgEBQYjAgAGAAAD6iQAAAeZHgIAAwUmAgQABgA4AwQFKAIAAwCg2lLRJgIGBAQmAggEAwA4BggHLAgBBAAQAQcBJgMEBAEAKAQCBywOBgcAKAcCBywOBgcmAgcEAwA4BAcGLAwGBywOAgcAKAcCBywOAQcAKAcCBywOBQcAKAcCBywOAwcmAgEEBAAoBAIFLA0FAyYCBgQCADgFBgI2DQACAAMlJwCABAR4AA0AAACABIADIwCAAwAABKUpAQABBfeh86+lrdTKOwEBAiUpAQABBb4eP/8+pPb6OwEBAiUpAQABBT4ciAIzl0Y8OwEBAiUkAAAEfRwMAQIAKwIAAwAf/////////////////////////////////////////w44AgMEIwIABAAABQskAAAHqyUkAAAEfSwIAQYAAAECASwOAQYsDQIBACgBAgEsDgECLAgBAQAAAQIBLA4CASwNBAIAKAICAiwOAgQmAgIEACYCBwQBJgIIAQEsDAIFIgAABV0MOAUDAiMCAAIAAAWAIgAABW8sDQYCLA0BAywMAgEsDAMCJSMCAAIAAAWNJAAAB70AKAQCCSwNCQkMOAUJCiMCAAoAAAWoJAAAB4cmAgoEAwA4BAoJADgJBQosDQoCLA0GCSwNAQoAKAkCCy0EAAqAAycAgAQEAAEkAAAHzy0IgAUADC0IgAYADSwOAg0sDQwCACgCAgIsDgIMLA4LBiwODAEAOAUHAiwMAgUiAAAFXS0BgAOABwEAgAMAAoALLQGAC4AIAQCACwACgAstAYALgAkBAIALAAKACgEAgAiABIALDwCAC4AJgAwLAIAHAAKADSMAgAwAAAZcIgAABswjAIANAAAGaSIAAAaCLQCAA4AFAQCABQACgA4tAoALgA4iAAAGxycAgA8EAAMBAIAJgA+ADi0AAAGABQEAAAGADgABJwGABQQAAQEAgAUAAoAOLQKAC4AOAQCADgACgA4tAoAJgA4iAAAGxyIAAAcgJwCADwQAAgUAgAuAD4AOJwCAEAQAAwEAgA6AEIAPLQAAAYAFAQAAAYAPAAEnAYAFBAABAQCABQACgA8tAoALgA8BAIAPAAKADy0CgA6ADyIAAAcgJwCADQQAAwEAgAWADYAMAQCADIAEgA0DAIAIAAKADgEAgA2ADoAPAQCACoAOgBANAIAQgAqADiMAgA4AAAeALQGAEIARLQKAEYAPAwCAEAACgBADAIAPAAKADyIAAAdPLQCADIAGJSkBAAEF6J0J/qERLQ47AQECJSkBAAEFGKIzDfIzb7s7AQECJSkBAAEFWgLkG7UeqZ87AQECJSkBAAEFxWvEWg4QAAI7AQECJS0BgAOABwEAgAMAAoALLQGAC4AIAQCACwACgAstAYALgAkBAIALAAKACgEAgAiABIALDwCAC4AJgAwLAIAHAAKADSMAgAwAAAgeIgAACI4jAIANAAAIKyIAAAhELQCAA4AFAQCABQACgA4tAoALgA4iAAAIiScAgA8EAAMBAIAJgA+ADi0AAAGABQEAAAGADgABJwGABQQAAQEAgAUAAoAOLQKAC4AOAQCADgACgA4tAoAJgA4iAAAIiSIAAAjiJwCADwQAAgUAgAuAD4AOJwCAEAQAAwEAgA6AEIAPLQAAAYAFAQAAAYAPAAEnAYAFBAABAQCABQACgA8tAoALgA8BAIAPAAKADy0CgA6ADyIAAAjiJwCADQQAAwEAgAWADYAMCwCAA4AFgA0jAIANAAAJRgEAgAqACIAPLQCACoAQLQCADIARCwCAEIAPgBIjAIASAAAJRi0BgBCADi0CgA6AEQEAgBAAAoAQAQCAEQACgBEiAAAJFQEAgAyACIAGJS0AGMoYyg==",
      "debug_symbols": "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",
      "brillig_names": [
        "set_channel_threshold"
      ]
    },
    {
      "name": "channel_transfer",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "16049994897275280777": {
            "error_kind": "string",
            "string": "Non-zero delay change for zero hash"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "1775037338128445371": {
            "error_kind": "string",
            "string": "Deserialized value is too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2435529361475140548": {
            "error_kind": "string",
            "string": "Non-zero value change for zero hash"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7461896932686329849": {
            "error_kind": "string",
            "string": "U253 addition overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "get_public_storage_hints",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "H4sIAAAAAAAA/7WTyw7CIBBFqcUo0sTEx39MU0y7dOHafyCtLHVRN+766dZkJkyI0QVwEzJMgMNcHoXwKjBKESGCHDEqjAs2Xs7tjDnEqVbBvin5HRijvvhLWH+jkFnk4QPxM50/rJBzmTyfe6F913PTrF8J/z5y+af7y+l//8OzRq9bzCvh/8P4uvfXx/M2ij/SbJGc0ptoOwAqvkT+EvmhJBvn8w+Yb4Svj6KMqNO1tnaNdfZkh8H0dhfwP+KH/QbzqHp4zgQAAA==",
      "debug_symbols": "dY/RCoMwDEX/Jc99aCoO9FdkSNUohdJKrYMh/felQ7ZuYy/h3nByyT1gomFfeuNmv0HbHWD9qKPxjt2RBAzBWGuWvlyDzAOrJ7+t2mW7RR0itDUKIDexaPh6NpagvVRJ/IAoUaqTZa3eONZ/+AZfvEL5wV8T25sORg+Wztfn3Y1Fk3hf6avUGvxI0x4o1yua8eywFkpyLEc/AA==",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "10775636126596421126": {
            "error_kind": "string",
            "string": "Function _log_channel_creation can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16541607464495309456": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 16
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "1775037338128445371": {
            "error_kind": "string",
            "string": "Deserialized value is too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "3238985437272151328": {
            "error_kind": "string",
            "string": "Function get_channel_threshold can only be called statically"
          },
          "4475601672736294460": {
            "error_kind": "string",
            "string": "Unauthorized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7136678259008445534": {
            "error_kind": "string",
            "string": "Function _log_channel_threshold_exceeded can only be called internally"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JgACBAEnAAABBIBMJgAABAMmAgIEASYCAwQAHxgAAwACgEstCIBLAAEkAAAARSQAAACsJwIAAQSATCYCAgQAOg0AAQACJwCAQwQABSgAgEQAO5rKACsAgEUAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAnAIBGBAAAJwCARwQAAScAgEgEAAInAIBJBAADKgCASgAAAAAAAAAAAQAAAAAAAAAAJSQAABenKAIAAgD50QHYCjgBAgMmAgQEACYCBgQDADgEBgUsCAECABABBQEmAwIEAQAoAgIFLA4EBQAoBQIFLA4EBSYCBQQDADgCBQQmAgQABCYCBQACJgIGAAMmAgcAASYCCAEBJgIJAAAmAgoBACMCAAMAAAEoIgAABqcsCAEMJgINBAQAEAENASYDDAQBACgMAg0fJIBHgEkADSwNDA0AKA0CDSwODQwsCAENAAABAgEsDgwNLAgBDAAAAQIBLQqARgAMJgIPBBAsCAAQLAwNESwMDBIsDAQTABAADwAkAAAX0CwEAAAsDBEOJgIQBBEsCAARLAwNEiwMDBMsDAQUABAAEAAkAAAX0CwEAAAsDBIPJgIRBBIsCAASLAwNEywMDBQAEAARACQAABhSLAQAACwMExAAKBACDQEoAA2ARgARLA0RDCwIAQ0AAAECASwOCg0sCAEQAAABAgEsDgkQLAgBEQAAAQIBJgISALksDhIRHgIAEgA1OAASABMAFAAjAgAUAAACRyIAAAI6LAwKAywMCQsiAAACVCwMCAMsDBMLIgAAAlQjAgADAAACZSYCFQQAOwkBFTU4ABIAAwAVAiMCABUAAAKIIgAAAnssDAoTLAwJFCIAAAKVLAwIEywMAxQiAAAClSMCABMAAAKmJgISBAA7CQESLAgBEiYCEwQCABABEwEmAxIEAQAoEgITHySARoBHABMAKBICFQEoABWARgAWLA0WEyYCFQQWLAgAFiwMExcAEAAVACQAABjLLAQAACwMFxIsCAETJgIVBAQAEAEVASYDEwQBACgTAhUfJIBHgEkAFSwNExUAKBUCFSwOFRMAKBMCFgEoABaARgAXLA0XFQAoEwIXASgAF4BHABgsDRgWACgTAhgBKAAYgEgAGSwNGRcmAhMALCwIARgmAhkEBQAQARkBJgMYBAEAKBgCGSwMGRosDhMaACgaAhosDhUaACgaAhosDhYaACgaAhosDhcaLA0YEwAoEwITLA4TGCoCABMAAAAAAAAAAAQAAAAAAAAAACYCGgQbLAgAGywMExwAEAAaACQAABjgLAQAACwMHBUsDB0WLAweFywMHxksDRUTACgTAhMsDhMVLAgBEwAAAQIBLA4VEywNFhUAKBUCFSwOFRYsCAEVAAABAgEsDhYVLAgBFgAAAQIBLA4XFiwIARcAAAECASwOGRcmAhkEBC0IgEYAAyIAAARBDDgDGRojAgAaAAAXNCIAAARTJgIZBBosCAAaLAwTGywMFRwsDBYdLAwXHgAQABkAJAAAGXwsBAAALAwbGBwMEhMAJgISAA0sCAEVJgIWBAQAEAEWASYDFQQBACgVAhYsDBYXLA4SFwAoFwIXLA4TFwAoFwIXLA4YFywNFRIAKBICEiwOEhUqAgASAAAAAAAAAAADAAAAAAAAAAAmAhkEGiwIABosDBIbABAAGQAkAAAY4CwEAAAsDBsTLAwcFiwMHRcsDB4YLA0TEgAoEgISLA4SEywIARIAAAECASwOExIsDRYTACgTAhMsDhMWLAgBEwAAAQIBLA4WEywIARYAAAECASwOFxYsCAEXAAABAgEsDhgXLQiARgADIgAABWANKAADgEkAGCMCABgAABbBIgAABXUmAhUEGCwIABgsDBIZLAwTGiwMFhssDBccABAAFQAkAAAZfCwEAAAsDBkDCjgUAxIjAgASAAAFsiQAABn6CjgLCQMeAgASAQo4CxITEjgDEwsjAgALAAAF0yQAABoMJgIDBBIsCAASLAwNEywMEBQsDBEVLAwHFiwMDhcAEAADACQAABoeLAQAACYCAwQSLAgAEiwMDRMsDBAULAwRFSwMBhYsDA8XABAAAwAkAAAaHiwEAAAmAgMEEiwIABIsDA0TLAwQFCwMERUsDA0WLAwQFywMERgsDAcZLAwNGiwMEBssDBEcLAwFHSwMDR4sDBAfLAwRICwMBiEsDAwiABAAAwAkAAAaXCwEAAAeAgADADMCAAMAKAICDCwNDAsmAg0EAgA4DA0DOg0AAwALIgAABqcoAgADAGOIKNMKOAEDCywNAgwAKAwCDCwODAIjAgALAAAGzyIAAArzLAgBCyYCDAQCABABDAEmAwsEAQAoCwIMHySAR4BHAAwsDQsMACgMAgwsDgwLLAgBDAAAAQIBLA4LDCwIAQsAAAECAS0KgEYACyYCDgQPLAgADywMDBAsDAsRABAADgAkAAAldywEAAAsDBANACgNAgwBKAAMgEYADiwNDgssCAEMAAABAgEsDgoMLAgBDQAAAQIBLA4JDSwIAQ4AAAECASYCDwCwLA4PDiYCDwQQLAgAECwMDBEsDA0SLAwOEwAQAA8AJAAAJfAsBAAAHgIADwkKOA8HECMCABAAAAeyJAAAJhomAhAEESwIABEsDAwSLAwNEywMDhQsDAYVABAAEAAkAAAmLCwEAAAsDBIPLA0CEAAoEAIQLA4QAiYCEQQBJgITBAMAOBETEiwIARAAEAESASYDEAQBACgQAhIsDhESACgSAhIsDhESJgISBAMAOBASESwMERIsDgsSJgISBBMsCAATLQiARgAULAwCFS0IgEcAFiwMEBcAEAASACQAACY8LAQAACwMFAssDBURLA0REAAoEAIQLA4QESYCEgQTLAgAEywMAxQAEAASACQAABjLLAQAACwMFBAsDREDACgDAgMsDgMRHAwQAwAAKAsCEC0EABGAAycAgAQEAAEkAAAnOC0IgAUAEi0IgAYAEywOAxMsDRIDACgDAgMsDgMSLAgBAyYCCwQDABABCwEmAwMEAQAoAwILLAwLES0KgEUAEQAoEQIRLQqARQARACgDAgsAKBICFCwNFBMmAhUEAgA4FBUROQPlAAsADwARABMAFCACAAMsCAEPACgPAhIsDRIRJgITBAIAOBITECE0gEYAAwAQLAwDESYCEwQDADgRExIAEAESASYDDwQBACgPAhMsDhETACgTAhMsDhETLAwRCwYoCwILLA0PAwAoAwIDLA4DDyMCABQAAAmuIgAACZIAKA8CESwNERAmAhIEAgA4ERIDOw0DECIAAAmuLA0PAwAoAwIDLA4DDyYCEAQRLAgAESwMCxIsDA8TABAAEAAkAAAosiwEAAAsDBIDJgIPBBAsCAAQLAwDEQAQAA8AJAAAKSksBAAALAwRCywIAQMAAAECASwOCwMKOAsJDyMCAA8AAAocIgAACpAeAgAPBRwMDxEEHAwREAAcDBAPBCYCEwQULAgAFCwMDBUsDA0WLAwOFywMBRgAEAATACQAACmbLAQAACwMFRAsDBYRLAwXEgw4DxIMIwIADAAACn4iAAAKdSwMEQsiAAAKhywMEAsiAAAKhywOCwMi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CCwOCAksCAEIAAABAgEsDgkILAgBCQAAAQIBLA4KCSwIAQoAAAECASwOCwotCIBGAAUiAAAqZw0oAAWASAABIwIAAQAAK/UiAAAqfCYCAwQLLAgACywMBAwsDAgNLAwJDiwMCg8AEAADACQAABl8LAQAACwMDAIsCAEDJgIEBAQAEAEEASYDAwQBACgDAgQsDAQFLA4GBQAoBQIFLA4GBQAoBQIFLA4GBSwIAQQAAAECASwOAwQtCIBGAAEiAAAq8Q0oAAGASQADIwIAAwAAK48iAAArBiwNBAEAKAECAwEoAAOARgAELA0EAiYCAwQELAgABCwMAgUAEAADACQAACzzLAQAAAAoAQIEASgABIBHAAUsDQUDJgIEBAUsCAAFLAwDBgAQAAQAJAAALPMsBAAAACgBAgUBKAAFgEgABiwNBgQcDAQFBBwMBQEAHAwBBAQsDAIBLAwDAiwMBAMlLA0EAxwMAQUAADgCBQYuDAAGAAUmAgcEAww4AQcIIwIACAAAK7okAAAueC0EAAOAAycAgAQEAAQkAAAz6C0IgAUABgAoBgIHADgHAQgsDgUILA4GBAEoAAGARwADLAwDASIAACrxIwIAAQAALAIiAAAsVyYCAgQCDDgFAgMjAgADAAAsGSQAAC54ACgHAgIAOAIFAywNAwEmAgIECywIAAssDAQMLAwIDSwMCQ4sDAoPLAwBEAAQAAIAJAAALoosBAAAIgAALFcBKAAFgEcAASwMAQUiAAAqZykBAAEFPhyIAjOXRjw7AQECJSQAABenLA0BAywNAgQmAgYEAgw4BAYHIwIABwAALJ4kAAAueAAoAwIGADgGBAcsDQcFLAgBBiYCBwQCABABBwEmAwYEAQAoBgIHLAwHCCwOBQgBKAAEgEcABQ44BAUHIwIABwAALOYkAAAvtywOAwEsDgUCLAwGASUkAAAXpxwMAQIAKwIAAwAf/////////////////////////////////////////w44AgMEIwIABAAALTQkAAAxMyUkAAAXpxwMAQMEHAwDAgAcDAIBBCUkAAAXpwAoBAIGASgABoBGAAcsDQcFACgEAgcBKAAHgEcACCwNCAYAKAQCCAEoAAiASAAJLA0JBwAoBAIJASgACYBJAAosDQoIJgIJBAQmAgsEAwA4CQsKLAgBBAAQAQoBJgMEBAEAKAQC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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "verify_id_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "963818325383147006": {
            "error_kind": "string",
            "string": "Function verify_id_private can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "verified_id",
            "type": {
              "kind": "array",
              "length": 5,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7ZbRauMwEEX/Rc9+0EgjzSi/spTiJG4xGCc4ycIS8u9rlcpOiNzgCYUW/BKs6B57dH2t0Vltq/Xp/bVu33YHtfpzVs1uUx7rXduPzgrMx3+HfdnG4eFYdke1Au9Noap2Gy/JXAr1VjeVWnl7Ke7Exnj6FBvDYRCD1jl1QP5UW23ggRq8DTxUgjDqDUFW70Y50ahmzqmtt0mNoG/UL4UCu3gz6Q0u3kx64364N2jd6A2GB94YMD7VAuie9MYv3kx6Q4s3k97w4s2kN+Fpb1CHJEYwPIgZ4wOM/u4HwNMPAKsxia29ertAObUGSi+gvw72uqBcdDiEITvhvn7zy+ufe9KJDOYYYkzLoAD89ZpZpzUwXndo/XH/57soWZu+YbL8wCM77A4IONqP5vLSj9Zd3TT1++vN4VnHH5/1IfBwntD6bm3eCRgvYEjAsIAJ8xnSAgYEjBEwVsAIckCCHJAgByTIAQlyQIIcsCAHLMgB53Pgx21U4x1jBQwKGCdgvIAhAcNzmX4EUYrZVTlIZxnnzO0+Wyj08xGaj/B8JMxELv3wb9nV5bqpYrOIs6d2k3pHPzz+26eZ1F323W5TbU9dFfvM2GJiCp0uvI6Hvfi5BF0EN/gcpy0UCGnaQeF8X0FfxX8=",
      "brillig_names": [
        "debug_log_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper"
      ],
      "verification_key": "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"
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "U253Note"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "U253Note"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "U253Note"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Beacon"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "target",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "overrides",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "ShieldGatewayStorage"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "authorized_caller",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "channel_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "channel_thresholds",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "minter",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "shield_gateway_beacon",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "private_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "shielded_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "ShieldGateway"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "default_channel_threshold",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "shield_gateway_storage",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "from",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "to",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::ChannelThresholdExceeded"
        },
        {
          "fields": [
            {
              "name": "new",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "effective_block",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::ChannelThresholdChanged"
        },
        {
          "fields": [
            {
              "name": "from",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "to",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::ChannelCreation"
        },
        {
          "fields": [
            {
              "name": "new_threshold",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "effective_block",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::DefaultChannelThresholdChanged"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::channel_exists_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::channel_exists_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::_log_channel_creation_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::_log_channel_creation_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::get_channel_threshold_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "uint253::uint253::U253"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::get_channel_threshold_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "new_threshold",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::set_channel_threshold_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::set_channel_threshold_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::get_channel_balance_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::get_channel_balance_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "new_threshold",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::set_default_channel_threshold_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::set_default_channel_threshold_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "shield_gateway_storage",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "default_channel_threshold",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::init_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::init_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::initialize_channel_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::initialize_channel_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::channel_transfer_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::channel_transfer_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "verified_id",
                    "type": {
                      "kind": "array",
                      "length": 5,
                      "type": {
                        "kind": "field"
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::verify_id_private_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::verify_id_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "fields": [
                        {
                          "name": "value",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "uint253::uint253::U253"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::verified_id_transfer_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::verified_id_transfer_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::_log_channel_threshold_exceeded_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::_log_channel_threshold_exceeded_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "107": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        /// Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "111": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    /// Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "117": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "126": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/note/discovery/mod.nr",
      "source": "use std::static_assert;\n\nuse crate::{\n    context::unconstrained_context::UnconstrainedContext, note::note_header::NoteHeader,\n    oracle::note_discovery::deliver_note, utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\n    hash::compute_note_hash_nonce,\n};\n\n// We reserve two fields in the note log that are not part of the note content: one for the storage slot, and one for\n// the note type id.\nglobal NOTE_LOG_RESERVED_FIELDS: u32 = 2;\npub global MAX_NOTE_SERIALIZED_LEN: u32 = PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_LOG_RESERVED_FIELDS;\n\npub struct NoteHashesAndNullifier {\n    pub note_hash: Field,\n    pub unique_note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Processes a log given its plaintext by trying to find notes encoded in it. This process involves the discovery of\n/// the nonce of any such notes, which requires knowledge of the transaction hash in which the notes would've been\n/// created, along with the list of unique note hashes in said transaction.\n///\n/// Additionally, this requires a `compute_note_hash_and_nullifier` lambda that is able to compute these values for any\n/// note in the contract given their contents. A typical implementation of such a function would look like this:\n///\n/// ```\n/// |packed_note_content, note_header, note_type_id| {\n///     let hashes = if note_type_id == MyNoteType::get_note_type_id() {\n///         assert(packed_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///         dep::aztec::note::utils::compute_note_hash_and_optionally_a_nullifier(\n///             MyNoteType::unpack_content,\n///             note_header,\n///             true,\n///             packed_note_content.storage(),\n///         )\n///     } else {\n///         panic(f\"Unknown note type id {note_type_id}\")\n///     };\n///\n///     Option::some(dep::aztec::oracle::management::NoteHashesAndNullifier {\n///         note_hash: hashes[0],\n///         unique_note_hash: hashes[1],\n///         inner_nullifier: hashes[3],\n///     })\n/// }\n/// ```\npub unconstrained fn do_process_log<Env>(\n    context: UnconstrainedContext,\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: fn[Env](BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>, NoteHeader, Field) -> Option<NoteHashesAndNullifier>,\n) {\n    let (storage_slot, note_type_id, packed_note_content) =\n        destructure_log_plaintext(log_plaintext);\n\n    // We need to find the note's nonce, which is the one that results in one of the unique note hashes from tx_hash\n    for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            let header = NoteHeader::new(context.this_address(), candidate_nonce, storage_slot);\n\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes =\n                compute_note_hash_and_nullifier(packed_note_content, header, note_type_id).unwrap();\n\n            if hashes.unique_note_hash == expected_unique_note_hash {\n                // TODO(#10726): push these into a vec to deliver all at once instead of having one oracle call per note\n\n                assert(\n                    deliver_note(\n                        context.this_address(), // TODO(#10727): allow other contracts to deliver notes\n                        storage_slot,\n                        candidate_nonce,\n                        packed_note_content,\n                        hashes.note_hash,\n                        hashes.inner_nullifier,\n                        tx_hash,\n                        recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n}\n\nunconstrained fn destructure_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>) {\n    assert(log_plaintext.len() >= NOTE_LOG_RESERVED_FIELDS);\n\n    // If NOTE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\n    // `storage_slot` and `note_type_id` must be updated as well.\n    static_assert(\n        NOTE_LOG_RESERVED_FIELDS == 2,\n        \"unepxected value for NOTE_LOG_RESERVED_FIELDS\",\n    );\n    let storage_slot = log_plaintext.get(0);\n    let note_type_id = log_plaintext.get(1);\n\n    let packed_note_content = array::subbvec(log_plaintext, NOTE_LOG_RESERVED_FIELDS);\n\n    (storage_slot, note_type_id, packed_note_content)\n}\n\nfn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..MaxLen {\n        if i < vec.len() {\n            f(vec.get_unchecked(i), i);\n        }\n    }\n}\n"
    },
    "137": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n    utils::array,\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    compute_unique_note_hash,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let header = note.get_header();\n    let nonce = header.nonce;\n    let counter = header.note_hash_counter;\n\n    // If same tx note, read request always uses the normal note hash\n    if counter != 0 {\n        note_hash\n    } else {\n        // If the note comes from a different tx, we need to compute the note hash that reached the tree\n        compute_unique_note_hash(\n            nonce,\n            compute_siloed_note_hash(header.contract_address, note_hash),\n        )\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if (header.note_hash_counter != 0) & (header.nonce != 0) {\n        // Non-revertible note, nullified by a revertible nullifier, we need to nullify the note hash that will reach the tree\n        let siloed_note_hash =\n            compute_siloed_note_hash(header.contract_address, note_hash_for_read_request);\n\n        compute_unique_note_hash(header.nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    unpack_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    packed_note_content: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = unpack_content(array::subarray(packed_note_content, 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, note_hash);\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"
    },
    "139": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "140": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "141": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "142": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field]) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\n}\n\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\n    let _ = store_in_execution_cache_oracle(values);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "143": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    /// Safety: The to_address function combines all values in the instance object to produce an address,\n    /// so by checking that we get the expected address we validate the entire struct.\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "147": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\n    }\n}\n"
    },
    "148": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "149": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "152": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr",
      "source": "use crate::note::discovery::MAX_NOTE_SERIALIZED_LEN;\nuse dep::protocol_types::address::AztecAddress;\n\n/// Informs PXE of a note's existence so that it can later retrieved by the `getNotes` oracle. The note will be scoped\n/// to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The note's `content` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value is\n/// typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are the\n/// inner hashes, i.e. the raw hashes returned by `NoteInterface::compute_note_hash` and\n/// `NullifiableNote::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree at\n/// `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was sucessfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    content: BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        content,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    content: BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n"
    },
    "153": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note_content,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        packed_note_content,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note_content: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    let _ = notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    sync_notes_oracle_wrapper();\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let note_content = array::subarray(fields, read_offset + 2);\n\n            let mut note = Note::unpack_content(note_content);\n            note.set_header(NoteHeader { contract_address, nonce, storage_slot, note_hash_counter });\n\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_indexed_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\n/// for later querying via the `get_notes` oracle.\npub fn sync_notes() {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        sync_notes_oracle_wrapper();\n    }\n}\n\nunconstrained fn sync_notes_oracle_wrapper() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n"
    },
    "156": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::Packable};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "166": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    state_vars::storage::Storage,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    pub fn read(self) -> T {\n        let header = self.context.get_block_header();\n        let mut fields = [0; T_PACKED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] = header.public_storage_historical_read(\n                self.storage_slot + i as Field,\n                (*self.context).this_address(),\n            );\n        }\n        T::unpack(fields)\n    }\n}\n"
    },
    "169": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_delay_change.nr",
      "source": "use dep::protocol_types::traits::Packable;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub(crate) struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pre: Option<u32>,\n    post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub(crate) fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub(crate) fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub(crate) fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub(crate) fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior contraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub(crate) fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Packable<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn pack(self) -> [Field; 1] {\n        // We pack all three u32 values into a single U128, which is made up of two u64 limbs.\n        // Low limb: [ pre_inner: u32 | post_inner: u32 ]\n        // High limb: [ empty | pre_is_some: u8 |  post_is_some: u8 | block_of_change: u32 ]\n        let lo = ((self.pre.unwrap_unchecked() as u64) * (1 << 32))\n            + (self.post.unwrap_unchecked() as u64);\n\n        let hi = (self.pre.is_some() as u64) * (1 << 33)\n            + (self.post.is_some() as u64 * (1 << 32))\n            + self.block_of_change as u64;\n\n        let packed = U128::from_u64s_le(lo, hi);\n\n        [packed.to_integer()]\n    }\n\n    fn unpack(input: [Field; 1]) -> Self {\n        let packed = U128::from_integer(input[0]);\n\n        // We use division and modulo to clear the bits that correspond to other values when unpacking.\n        let pre_is_some = ((packed.hi as u64) / (1 << 33)) as bool;\n        let pre_inner = ((packed.lo as u64) / (1 << 32)) as u32;\n\n        let post_is_some = (((packed.hi as u64) / (1 << 32)) % (1 << 1)) as bool;\n        let post_inner = ((packed.lo as u64) % (1 << 32)) as u32;\n\n        let block_of_change = ((packed.hi as u64) % (1 << 32)) as u32;\n\n        Self {\n            pre: if pre_is_some {\n                Option::some(pre_inner)\n            } else {\n                Option::none()\n            },\n            post: if post_is_some {\n                Option::some(post_inner)\n            } else {\n                Option::none()\n            },\n            block_of_change,\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n"
    },
    "17": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "171": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_value_change.nr",
      "source": "use dep::protocol_types::traits::{FromField, Packable, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub(crate) struct ScheduledValueChange<T> {\n    pre: T,\n    post: T,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub(crate) fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub(crate) fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub(crate) fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub(crate) fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub(crate) fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Packable<3> for ScheduledValueChange<T>\nwhere\n    T: ToField + FromField,\n{\n    fn pack(self) -> [Field; 3] {\n        [self.pre.to_field(), self.post.to_field(), self.block_of_change.to_field()]\n    }\n\n    fn unpack(input: [Field; 3]) -> Self {\n        Self {\n            pre: FromField::from_field(input[0]),\n            post: FromField::from_field(input[1]),\n            block_of_change: FromField::from_field(input[2]),\n        }\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n"
    },
    "173": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    hash::{poseidon2_hash, poseidon2_hash_with_separator},\n    traits::{FromField, Packable, ToField},\n    utils::arrays::array_concat,\n};\n\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse crate::state_vars::{\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    storage::Storage,\n};\nuse dep::std::mem::zeroed;\n\npub(crate) mod scheduled_delay_change;\npub(crate) mod scheduled_value_change;\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// Separators separating storage slot of different values within the same state variable\nglobal VALUE_CHANGE_SEPARATOR: u32 = 0;\nglobal DELAY_CHANGE_SEPARATOR: u32 = 1;\nglobal HASH_SEPARATOR: u32 = 2;\n\n// This will make the Aztec macros require that T implements the Serialize<N> trait, and allocate N storage slots to\n// this state variable. This is incorrect, since what we actually store is:\n//  - a ScheduledValueChange<T>, which requires 1 + 2 * M storage slots, where M is the serialization length of T\n//  - a ScheduledDelayChange, which requires another storage slot\n//\n// TODO https://github.com/AztecProtocol/aztec-packages/issues/5736: change the storage allocation scheme so that we\n// can actually use it here\nimpl<T, let INITIAL_DELAY: u32, Context, let N: u32> Storage<N> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    T: ToField + FromField + Eq,\n{\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    // Since we can't rely on the native storage allocation scheme, we hash the storage slot to get a unique location in\n    // which we can safely store as much data as we need.\n    // See https://github.com/AztecProtocol/aztec-packages/issues/5492 and\n    // https://github.com/AztecProtocol/aztec-packages/issues/5736\n    // We store three things in public storage:\n    //  - a ScheduledValueChange\n    //  - a ScheduledDelaChange\n    //  - the hash of both of these (via `hash_scheduled_data`)\n    fn get_value_change_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], VALUE_CHANGE_SEPARATOR)\n    }\n\n    fn get_delay_change_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], DELAY_CHANGE_SEPARATOR)\n    }\n\n    fn get_hash_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], HASH_SEPARATOR)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: ToField + FromField + Eq,\n{\n\n    pub fn schedule_value_change(self, new_value: T) {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        self.context.storage_read(self.get_delay_change_storage_slot())\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    ) {\n        // Whenever we write to public storage, we write both the value change and delay change as well as the hash of\n        // them both. This guarantees that the hash is always kept up to date.\n        // While this makes for more costly writes, it also makes private proofs much simpler because they only need to\n        // produce a historical proof for the hash, which results in a single inclusion proof (as opposed to 4 in the\n        // best case scenario in which T is a single field). Private shared mutable reads are assumed to be much more\n        // frequent than public writes, so this tradeoff makes sense.\n        self.context.storage_write(self.get_value_change_storage_slot(), value_change);\n        self.context.storage_write(self.get_delay_change_storage_slot(), delay_change);\n        self.context.storage_write(\n            self.get_hash_storage_slot(),\n            SharedMutable::hash_scheduled_data(value_change, delay_change),\n        );\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: ToField + FromField + Eq,\n{\n    pub fn get_current_value(self) -> T {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for both the ScheduledValueChange and\n        // ScheduledDelayChange, but that'd require one full sibling path per storage slot (since due to kernel siloing\n        // the storage is not contiguous), and in the best case in which T is a single field that'd be 4 slots.\n        // Instead, we get an oracle to provide us the correct values for both the value and delay changes, and instead\n        // prove inclusion of their hash, which is both a much smaller proof (a single slot), and also independent of\n        // the size of T.\n        /// Safety: The hints are checked to be a preimage of a hash obtained from constrained context.\n        let (value_change_hint, delay_change_hint) = unsafe {\n            get_public_storage_hints(address, self.storage_slot, historical_block_number)\n        };\n\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let hash = header.public_storage_historical_read(self.get_hash_storage_slot(), address);\n\n        if hash != 0 {\n            assert_eq(\n                hash,\n                SharedMutable::hash_scheduled_data(value_change_hint, delay_change_hint),\n                \"Hint values do not match hash\",\n            );\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized, meaning no value or delay change was ever\n            // scheduled. Therefore, the hints must then correspond to uninitialized scheduled changes.\n            assert_eq(\n                value_change_hint,\n                ScheduledValueChange::unpack(zeroed()),\n                \"Non-zero value change for zero hash\",\n            );\n            assert_eq(\n                delay_change_hint,\n                ScheduledDelayChange::unpack(zeroed()),\n                \"Non-zero delay change for zero hash\",\n            );\n        };\n\n        (value_change_hint, delay_change_hint, historical_block_number)\n    }\n\n    fn hash_scheduled_data(\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    ) -> Field {\n        let concatenated: [Field; 4] = array_concat(value_change.pack(), delay_change.pack());\n        poseidon2_hash(concatenated)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UnconstrainedContext>\nwhere\n    T: ToField + FromField + Eq,\n{\n    pub unconstrained fn get_current_value(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    unconstrained fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n}\n\nunconstrained fn get_public_storage_hints<T, let INITIAL_DELAY: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>)\nwhere\n    T: ToField + FromField + Eq,\n{\n    // This function cannot be part of the &mut PrivateContext impl because that'd mean that by passing `self` we'd also\n    // be passing a mutable reference to an unconstrained function, which is not allowed. We therefore create a dummy\n    // state variable here so that we can access the methods to compute storage slots. This will all be removed in the\n    // future once we do proper storage slot allocation (#5492).\n    let dummy: SharedMutable<T, INITIAL_DELAY, ()> = SharedMutable::new((), storage_slot);\n\n    (\n        storage_read(address, dummy.get_value_change_storage_slot(), block_number),\n        storage_read(address, dummy.get_delay_change_storage_slot(), block_number),\n    )\n}\n"
    },
    "18": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    /// Safety: borrow is enforced to be boolean due to its type.\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        /*@safety: borrow is enforced to be boolean due to its type.\n            if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n            if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n        */\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        /// Safety: decomposition is properly checked below\n        unsafe {\n            /*@safety: decomposition is properly checked below*/\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            /// Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unsafe in unconstrained\n        unsafe {\n            //@safety: unsafe in unconstrained\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        /// Safety: Take a hint of the comparison and verify it\n        unsafe {\n            //@safety: Take a hint of the comparison and verify it\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "184": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/unencrypted_logs/unencrypted_event_emission.nr",
      "source": "use crate::{context::PublicContext, event::event_interface::EventInterface};\n\nfn emit<Event, let N: u32>(context: &mut PublicContext, event: Event)\nwhere\n    Event: EventInterface<N>,\n{\n    let selector = Event::get_event_type_id();\n\n    let serialized_event = event.serialize();\n    let mut emitted_log = [0; N + 1];\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    for i in 0..serialized_event.len() {\n        emitted_log[i] = serialized_event[i];\n    }\n\n    emitted_log[serialized_event.len()] = selector.to_field();\n\n    context.emit_public_log(emitted_log);\n}\n\npub fn encode_event<Event, let N: u32>(\n    context: &mut PublicContext,\n) -> fn[(&mut PublicContext,)](Event) -> ()\nwhere\n    Event: EventInterface<N>,\n{\n    |e: Event| { emit(context, e); }\n}\n"
    },
    "187": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "188": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    vec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(vec.storage(), offset), vec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "19": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    // #[test]\n    // fn test_to_le_radix_brillig_1() {\n    //     // this test should only fail in constrained mode\n    //     if runtime::is_unconstrained() {\n    //         let field = 1;\n    //         let out: [u8; 8] = field.to_le_radix(1);\n    //         crate::println(out);\n    //         let expected = [0; 8];\n    //         assert(out == expected, \"unexpected result\");\n    //     }\n    // }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    // #[test]\n    // fn test_to_le_radix_brillig_512() {\n    //     // this test should only fail in constrained mode\n    //     if runtime::is_unconstrained() {\n    //         let field = 1;\n    //         let out: [u8; 8] = field.to_le_radix(512);\n    //         let mut expected = [0; 8];\n    //         expected[0] = 1;\n    //         assert(out == expected, \"unexpected result\");\n    //     }\n    // }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "21": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    /// Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "210": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "212": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "247": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "254": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        function_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            function_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "26": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "269": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "270": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "271": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::{constants::TWO_POW_64, utils::{arrays::array_concat, field::field_from_bytes}};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_contract_class_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_contract_class_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; N * 32];\n    for offset in 0..N {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "281": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "287": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "288": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "297": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "313": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "317": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::{Packable, ToField};\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for U128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self.to_field()]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "318": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 2;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        // We use little-endian ordering to match the order in which U128 defines its limbs.\n        // This is necessary because of how Noir handles serialization:\n        // - When calling a contract function from TypeScript, the serialization in encoder.ts gets used and then Noir\n        //   deserializes using its intrinsic serialization logic (based on the limb order in the struct).\n        // - When calling a contract function from another function, the `serialize` method is invoked on the type\n        //   first.\n        // For this reason if we didn't use the ordering of U128 limbs here and in encoder.ts we would get an arguments\n        // hash mismatch.\n        [self.lo, self.hi]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_u64s_le(fields[0] as u64, fields[1] as u64)\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "334": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    /// Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    /// of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "335": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "337": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "354": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/shield_gateway_storage/src/main.nr",
      "source": "mod test;\n\nuse aztec::macros::aztec;\n\n#[aztec]\npub contract ShieldGatewayStorage {\n\n    use aztec::{\n        context::PrivateContext,\n        encrypted_logs::log_assembly_strategies::default_aes128::note::encode_and_encrypt_note,\n        macros::{functions::{initializer, private, public, view}, storage::storage},\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Hash, Serialize},\n        },\n        state_vars::{Map, PrivateMutable, PublicImmutable, SharedMutable},\n    };\n\n    use uint253::{uint253::U253, uint253_note::U253Note};\n\n    pub global CHANGE_DELAY_BLOCKS: u32 = 5;\n\n    #[storage]\n    struct Storage<Context> {\n        admin: PublicImmutable<AztecAddress, Context>,\n        authorized_caller: SharedMutable<AztecAddress, CHANGE_DELAY_BLOCKS, Context>,\n        channel_balances: Map<Field, PrivateMutable<U253Note, Context>, Context>,\n        channel_thresholds: Map<AztecAddress, SharedMutable<U253, CHANGE_DELAY_BLOCKS, Context>, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn init(admin: AztecAddress) {\n        storage.admin.initialize(admin);\n    }\n\n    #[public]\n    fn set_authorized_caller(caller: AztecAddress) {\n        assert(context.msg_sender() == storage.admin.read(), \"Only the admin can set the authorized caller\");\n        storage.authorized_caller.schedule_value_change(caller);\n    }\n\n    #[contract_library_method]\n    fn _assert_caller_is_authorized(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n    ) {\n        assert(context.msg_sender() == storage.authorized_caller.get_current_value(), \"Unauthorized\");\n    }\n\n    pub unconstrained fn is_channel_initialized_unconstrained(key: Field) -> bool {\n        storage.channel_balances.at(key).is_initialized()\n    }\n\n    #[private]\n    #[view]\n    fn is_channel_initialized(key: Field) -> bool {\n        _assert_caller_is_authorized(&mut context, storage);\n        // Safety: `initialize` must be called if the key is uninitialized, so the caller\n        // must attempt initialization for uninitialized keys to constrain this value\n        unsafe {\n            is_channel_initialized_unconstrained(key)\n        }\n    }\n\n    #[private]\n    fn get_channel_balance(key: Field) -> U253 {\n        _assert_caller_is_authorized(&mut context, storage);\n        storage.channel_balances.at(key).get_note().note.get_value()\n    }\n\n    #[private]\n    fn initialize_channel_balance(key: Field, value: U253, owner: AztecAddress) -> U253 {\n        _assert_caller_is_authorized(&mut context, storage);\n        let mut note = U253Note::new(value, owner);\n        storage.channel_balances.at(key).initialize(&mut note).emit(encode_and_encrypt_note(\n            &mut context,\n            owner,\n            owner,\n        ));\n        value\n    }\n\n    #[private]\n    fn set_channel_balance(key: Field, value: U253, owner: AztecAddress) -> U253 {\n        _assert_caller_is_authorized(&mut context, storage);\n        let mut note = U253Note::new(value, owner);\n        storage.channel_balances.at(key).replace(&mut note).emit(encode_and_encrypt_note(\n            &mut context,\n            owner,\n            owner,\n        ));\n        value\n    }\n\n    #[public]\n    #[view]\n    fn get_channel_threshold(key: AztecAddress) -> U253 {\n        storage.channel_thresholds.at(key).get_current_value()\n    }\n\n    #[private]\n    #[view]\n    fn get_channel_threshold_private(key: AztecAddress) -> U253 {\n        storage.channel_thresholds.at(key).get_current_value()\n    }\n\n    #[public]\n    fn set_channel_threshold(key: AztecAddress, value: U253) -> U253 {\n        assert(context.msg_sender() == storage.authorized_caller.get_current_value(), \"Unauthorized\");\n        storage.channel_thresholds.at(key).schedule_value_change(value);\n        value\n    }\n\n    unconstrained pub fn get_authorized_caller_unconstrained() -> AztecAddress {\n        storage.authorized_caller.get_current_value()\n    }\n\n    unconstrained pub fn get_admin_unconstrained() -> AztecAddress {\n        storage.admin.read()\n    }\n}\n"
    },
    "363": {
      "path": "/home/vscode/nargo/github.com/ClarifiedLabs/aztec-uint253/aztec-packages-v0.74.0/src/uint253.nr",
      "source": "// Copyright (c) 2025 Clarified Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nuse aztec::protocol_types::traits::{Deserialize, FromField, Packable, Serialize, ToField};\nuse std::cmp::{Eq, Ord, Ordering};\nuse std::ops::{Add, Div, Mul, Rem, Sub};\n\n// Maximum value for U253 (2^253 - 1), chosen to fit within Aztec's field arithmetic bounds\npub global MAX_U253: Field = 0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\npub global U253_PACKED_LEN: u32 = 1;\n\npub struct U253 {\n    value: Field,\n}\n\nimpl U253 {\n    pub fn new(value: Field) -> Self {\n        value.assert_max_bit_size::<253>();\n        Self { value }\n    }\n\n    pub fn new_unchecked(value: Field) -> Self {\n        Self { value }\n    }\n\n    pub fn from_integer(value: Field) -> Self {\n        value.assert_max_bit_size::<253>();\n        Self { value }\n    }\n\n    pub fn to_integer(self) -> Field {\n        self.value\n    }\n\n    pub fn zero() -> Self {\n        Self { value: 0 }\n    }\n\n    pub fn one() -> Self {\n        Self { value: 1 }\n    }\n\n    pub fn max() -> Self {\n        Self { value: MAX_U253 }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.value == 0\n    }\n\n    // Performs division with remainder using binary long division algorithm\n    // Returns (quotient, remainder) tuple\n    pub unconstrained fn div_rem_unconstrained(self, other: Self) -> (Self, Self) {\n        assert(!(other.value == 0), \"Division by zero\");\n\n        self.value.assert_max_bit_size::<253>();\n        other.value.assert_max_bit_size::<253>();\n\n        let bits: [u1; 253] = self.value.to_be_bits();\n        let divisor = other.value;\n\n        let mut quotient: Field = 0;\n        let mut remainder: Field = 0;\n\n        // Process each bit from MSB to LSB, similar to paper-and-pencil division\n        for i in 0..253 {\n            // Shift remainder left by 1 bit and add next bit\n            remainder = remainder * 2 + (bits[i] as Field);\n\n            // Single comparison to determine if we should subtract divisor\n            // Changed to just !remainder.lt(divisor) which means remainder >= divisor\n            if !remainder.lt(divisor) {\n                remainder = remainder - divisor;\n                quotient = quotient * 2 + 1;\n            } else {\n                quotient = quotient * 2;\n            }\n        }\n        (Self { value: quotient }, Self { value: remainder })\n    }\n\n    // Performs division with remainder using unconstrained binary long division algorithm, then\n    // constrains the result via multiplicative properties\n    // Returns (quotient, remainder) tuple\n    pub fn div_rem(self, other: Self) -> (Self, Self) {\n        assert(!(other.value == 0), \"Division by zero\");\n\n        if self.value == other.value {\n            (Self::one(), Self::zero())\n        } else if self.is_zero() {\n            (Self::zero(), Self::zero())\n        } else if other.value == 1 {\n            (self, Self::zero())\n        } else if self.value.lt(other.value) {\n            (Self::zero(), self)\n        } else {\n            //Safety: constraining this immediately after by checking the division property\n            let (quotient, remainder) = unsafe { self.div_rem_unconstrained(other) };\n\n            // Verify quotient * other + remainder == self\n            assert(\n                quotient * other + remainder == self,\n                \"Unconstrained division result is incorrect\",\n            );\n\n            (quotient, remainder)\n        }\n    }\n\n    // Adds two U253 values without overflow checks - use with caution\n    pub fn add_unchecked(self, other: Self) -> Self {\n        Self { value: self.value + other.value }\n    }\n\n    // Subtracts two U253 values without underflow checks - use with caution\n    pub fn sub_unchecked(self, other: Self) -> Self {\n        Self { value: self.value - other.value }\n    }\n}\n\nimpl ToField for U253 {\n    fn to_field(self) -> Field {\n        self.value\n    }\n}\n\nimpl FromField for U253 {\n    fn from_field(value: Field) -> Self {\n        value.assert_max_bit_size::<253>();\n        Self { value }\n    }\n}\n\nimpl Serialize<1> for U253 {\n    fn serialize(self) -> [Field; 1] {\n        [self.value]\n    }\n}\n\nimpl Deserialize<1> for U253 {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        fields[0].assert_max_bit_size::<253>();\n        assert(fields[0].lt(MAX_U253 + 1), \"Deserialized value is too large\");\n        Self { value: fields[0] }\n    }\n}\n\nimpl Add for U253 {\n    fn add(self, other: Self) -> Self {\n        let result = self.value + other.value;\n        result.assert_max_bit_size::<253>();\n\n        assert(!MAX_U253.lt(result), \"U253 addition overflow\");\n        assert(!result.lt(self.value), \"U253 addition overflow\");\n        assert(!result.lt(other.value), \"U253 addition overflow\");\n        Self { value: result }\n    }\n}\n\nimpl Sub for U253 {\n    fn sub(self, other: Self) -> Self {\n        assert(\n            other.value.lt(self.value) | other.value.eq(self.value),\n            \"U253 subtraction underflow\",\n        );\n        let result = self.value - other.value;\n        result.assert_max_bit_size::<253>();\n        Self { value: result }\n    }\n}\n\nimpl Mul for U253 {\n    fn mul(self, other: Self) -> Self {\n        let result = self.value * other.value;\n\n        result.assert_max_bit_size::<253>();\n        // Allow multiplication by 1 without additional checks, otherwise check for overflow\n        assert(\n            (self.value == 1)\n                | (other.value == 1)\n                | (result.lt(MAX_U253 + 1) & !result.lt(self.value) & !result.lt(other.value)),\n            \"U253 multiplication overflow\",\n        );\n        Self { value: result }\n    }\n}\n\nimpl Div for U253 {\n    fn div(self, other: Self) -> Self {\n        let (quotient, _) = self.div_rem(other);\n        quotient\n    }\n}\n\nimpl Rem for U253 {\n    fn rem(self, other: Self) -> Self {\n        let (_, remainder) = self.div_rem(other);\n        remainder\n    }\n}\n\nimpl Ord for U253 {\n    fn cmp(self, other: Self) -> Ordering {\n        if self.value.lt(other.value) {\n            Ordering::less()\n        } else if self.value.eq(other.value) {\n            Ordering::equal()\n        } else {\n            Ordering::greater()\n        }\n    }\n}\n\nimpl Eq for U253 {\n    fn eq(self, other: Self) -> bool {\n        self.value.eq(other.value)\n    }\n}\n\nimpl Packable<U253_PACKED_LEN> for U253 {\n    fn pack(self) -> [Field; U253_PACKED_LEN] {\n        [self.value]\n    }\n\n    fn unpack(fields: [Field; U253_PACKED_LEN]) -> Self {\n        U253::from_integer(fields[0])\n    }\n}\n"
    },
    "364": {
      "path": "/home/vscode/nargo/github.com/ClarifiedLabs/aztec-uint253/aztec-packages-v0.74.0/src/uint253_note.nr",
      "source": "// Copyright (c) 2025 Clarified Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nuse aztec::{\n    context::PrivateContext,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::partial_note,\n    note::{\n        note_header::NoteHeader,\n        note_interface::{NoteInterface, NullifiableNote},\n        utils::compute_note_hash_for_nullify,\n    },\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n        traits::{Empty, Hash, Packable, Serialize},\n    },\n};\n\nuse crate::uint253::U253;\n\n#[partial_note(quote {value})]\n#[derive(Serialize)]\npub struct U253Note {\n    // The amount of tokens in the note\n    value: Field,\n    owner: AztecAddress,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NullifiableNote for U253Note {\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl U253Note {\n    pub fn new(value: U253, owner: AztecAddress) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value: value.to_field(), owner, randomness, header: NoteHeader::empty() }\n    }\n\n    pub fn get_value(self) -> U253 {\n        U253::new_unchecked(self.value)\n    }\n\n    pub fn get_field_value(self) -> Field {\n        self.value\n    }\n}\n\nimpl Eq for U253Note {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n"
    },
    "365": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/token/src/main.nr",
      "source": "mod types;\nmod test;\n\nuse aztec::macros::aztec;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n#[aztec]\npub contract Token {\n    // Libs\n    use std::meta::derive;\n\n    use compressed_string::FieldCompressedString;\n\n    use aztec::{\n        context::{PrivateCallInterface, PrivateContext},\n        encrypted_logs::log_assembly_strategies::default_aes128::note::encode_and_encrypt_note,\n        macros::{\n            events::event,\n            functions::{initializer, internal, private, public, view},\n            storage::storage,\n        },\n        oracle::random::random,\n        prelude::{\n            AztecAddress, FunctionSelector, Map, PublicContext, PublicImmutable, PublicMutable,\n        },\n        protocol_types::{point::Point, traits::Serialize},\n        unencrypted_logs::unencrypted_event_emission::encode_event,\n    };\n\n    use authwit::auth::{\n        assert_current_call_valid_authwit, assert_current_call_valid_authwit_public,\n        compute_authwit_nullifier,\n    };\n\n    use beacon::Beacon;\n    use uint253::{uint253::U253, uint253_note::U253Note};\n\n    use crate::types::balance_set::BalanceSet;\n\n    // In the first transfer iteration we are computing a lot of additional information (validating inputs, retrieving\n    // keys, etc.), so the gate count is already relatively high. We therefore only read a few notes to keep the happy\n    // case with few constraints.\n    global INITIAL_TRANSFER_CALL_MAX_NOTES: u32 = 2;\n    // All the recursive call does is nullify notes, meaning the gate count is low, but it is all constant overhead. We\n    // therefore read more notes than in the base case to increase the efficiency of the overhead, since this results in\n    // an overall small circuit regardless.\n    global RECURSIVE_TRANSFER_CALL_MAX_NOTES: u32 = 8;\n\n    #[derive(Serialize)]\n    #[event]\n    struct Mint {\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Burn {\n        from: AztecAddress,\n        amount: Field,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Shield {\n        from: AztecAddress,\n        amount: Field,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Unshield {\n        from: AztecAddress,\n        amount: Field,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    #[storage]\n    struct Storage<Context> {\n        minter: PublicImmutable<AztecAddress, Context>,\n        shield_gateway_beacon: PublicImmutable<AztecAddress, Context>,\n        private_balances: Map<AztecAddress, BalanceSet<Context>, Context>,\n        public_balances: Map<AztecAddress, PublicMutable<U253, Context>, Context>,\n\n        total_supply: PublicMutable<U253, Context>,\n        shielded_supply: PublicMutable<U253, Context>,\n\n        name: PublicImmutable<FieldCompressedString, Context>,\n        symbol: PublicImmutable<FieldCompressedString, Context>,\n        decimals: PublicImmutable<u8, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn init(\n        minter: AztecAddress,\n        name: str<31>,\n        symbol: str<31>,\n        decimals: u8,\n    ) {\n        assert(!minter.is_zero(), \"invalid minter\");\n        assert(name.as_bytes().len() > 0, \"Name cannot be empty\");\n        assert(symbol.as_bytes().len() > 0, \"Symbol cannot be empty\");\n\n        storage.minter.initialize(minter);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        storage.decimals.initialize(decimals);\n    }\n\n    #[public]\n    fn set_shield_gateway_beacon(beacon: AztecAddress) {\n        assert(storage.minter.read().eq(context.msg_sender()), \"caller is not minter\");\n        storage.shield_gateway_beacon.initialize(beacon);\n    }\n\n    #[public]\n    #[view]\n    fn public_get_name() -> FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_name() -> FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_decimals() -> pub u8 {\n        storage.decimals.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_decimals() -> pub u8 {\n        storage.decimals.read()\n    }\n\n    #[public]\n    #[view]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n\n    #[public]\n    #[view]\n    fn shielded_supply() -> Field {\n        storage.shielded_supply.read().to_integer()\n    }\n\n    #[public]\n    #[view]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n\n    #[public]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        assert(storage.minter.read().eq(context.msg_sender()), \"caller is not minter\");\n\n        let amount = U253::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n\n        // Emit the mint event\n        Mint { to, amount: amount.to_field() }.emit(encode_event(&mut context));\n    }\n\n    #[public]\n    fn transfer_public_to_public(\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n        nonce: Field,\n    ) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let amount = U253::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n\n    #[public]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U253::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n\n        Burn { from, amount: amount.to_field() }.emit(encode_event(&mut context));\n    }\n\n    #[private]\n    fn transfer_private_to_public(\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n        nonce: Field,\n    ) {\n        assert_from_shield_gateway(&mut context, storage);\n        assert_current_call_valid_authwit(&mut context, from);\n\n        let amount = U253::from_integer(amount);\n\n        storage.private_balances.at(from).sub(from, amount).emit(\n            encode_and_encrypt_note(&mut context, from, from),\n        );\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n\n    #[contract_library_method]\n    fn assert_from_shield_gateway(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n    ) {\n        let from = context.msg_sender();\n        assert(\n            from.eq(get_shield_gateway(context, storage)),\n            \"Private transfer must be initiated from the shield gateway\",\n        );\n    }\n\n    #[contract_library_method]\n    fn subtract_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        account: AztecAddress,\n        amount: U253,\n        max_notes: u32,\n    ) -> U253 {\n        let subtracted = storage.private_balances.at(account).try_sub(amount, max_notes);\n        // Failing to subtract any amount means that the owner was unable to produce more notes that could be nullified.\n        // We could in some cases fail early inside try_sub if we detected that fewer notes than the maximum were\n        // returned and we were still unable to reach the target amount, but that'd make the code more complicated, and\n        // optimizing for the failure scenario is not as important.\n        assert(subtracted > U253::from_integer(0), \"Balance too low\");\n        if subtracted >= amount {\n            // We have achieved our goal of nullifying notes that add up to more than amount, so we return the change\n            subtracted - amount\n        } else {\n            // try_sub failed to nullify enough notes to reach the target amount, so we compute the amount remaining\n            // and try again.\n            let remaining = amount - subtracted;\n            compute_recurse_subtract_balance_call(*context, account, remaining).call(context)\n        }\n    }\n\n    // TODO(#7729): apply no_predicates to the contract interface method directly instead of having to use a wrapper\n    // like we do here.\n    #[no_predicates]\n    #[contract_library_method]\n    fn compute_recurse_subtract_balance_call(\n        context: PrivateContext,\n        account: AztecAddress,\n        remaining: U253,\n    ) -> PrivateCallInterface<25, U253> {\n        Token::at(context.this_address())._recurse_subtract_balance(account, remaining.to_field())\n    }\n\n    // TODO(#7728): even though the amount should be a U253, we can't have that type in a contract interface due to\n    // serialization issues.\n    #[internal]\n    #[private]\n    fn _recurse_subtract_balance(account: AztecAddress, amount: Field) -> U253 {\n        subtract_balance(\n            &mut context,\n            storage,\n            account,\n            U253::from_integer(amount),\n            RECURSIVE_TRANSFER_CALL_MAX_NOTES,\n        )\n    }\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n\n    #[private]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n\n    #[private]\n    fn transfer_private_to_private(\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n        nonce: Field,\n    ) {\n        assert_from_shield_gateway(&mut context, storage);\n        assert_current_call_valid_authwit(&mut context, from);\n\n        let amount = U253::from_integer(amount);\n\n        storage.private_balances.at(from).sub(from, amount).emit(\n            encode_and_encrypt_note(&mut context, from, from),\n        );\n\n        storage.private_balances.at(to).add(to, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            to,\n            from,\n        ));\n    }\n\n    #[private]\n    fn burn_private(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U253::from_integer(amount);\n\n        storage.private_balances.at(from).sub(from, amount).emit(\n            encode_and_encrypt_note(&mut context, from, from),\n        );\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n\n    // Moves token `amount` from the user's public balance to their private balance.\n    #[private]\n    fn shield(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U253::from_integer(amount);\n\n        Token::at(context.this_address())._transfer_public_to_private(from, from, amount).call(\n            &mut context,\n        );\n\n        Token::at(context.this_address())._log_shield(from, amount).enqueue(&mut context);\n    }\n\n    #[private]\n    fn unshield(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U253::from_integer(amount);\n\n        storage.private_balances.at(from).sub(from, amount).emit(\n            encode_and_encrypt_note(&mut context, from, from),\n        );\n        Token::at(context.this_address())._increase_public_balance(from, amount).enqueue(\n            &mut context,\n        );\n        Token::at(context.this_address())._log_unshield(from, amount).enqueue(&mut context);\n    }\n\n    // Transfers token `amount` from public balance of message sender to a private balance of `to`.\n    // Requires a shield gateway check.\n    #[private]\n    fn transfer_public_to_private(\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n        nonce: Field,\n    ) {\n        assert_from_shield_gateway(&mut context, storage);\n        assert_current_call_valid_authwit(&mut context, from);\n\n        let amount = U253::from_integer(amount);\n\n        Token::at(context.this_address())._transfer_public_to_private(from, to, amount).call(\n            &mut context,\n        );\n    }\n\n    #[private]\n    #[internal]\n    fn _transfer_public_to_private(from: AztecAddress, to: AztecAddress, amount: U253) {\n        let token = Token::at(context.this_address());\n\n        // We prepare the private balance increase (the partial note).\n        let hiding_point_slot = _prepare_private_balance_increase(from, to, &mut context, storage);\n\n        // At last we finalize the transfer. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that he can transfer only his own tokens.\n        token._finalize_transfer_public_to_private_unsafe(from, amount, hiding_point_slot).enqueue(\n            &mut context,\n        );\n    }\n\n    /// Prepares an increase of private balance of `to` (partial note). The increase needs to be finalized by calling\n    /// some of the finalization functions (`finalize_transfer_public_to_private`, `finalize_mint_shielded`).\n    /// Returns a hiding point slot.\n    #[private]\n    fn prepare_private_balance_increase(to: AztecAddress, from: AztecAddress) -> Field {\n        // TODO(#9887): ideally we'd not have `from` here, but we do need a `from` address to produce a tagging secret\n        // with `to`.\n        _prepare_private_balance_increase(from, to, &mut context, storage)\n    }\n\n    /// This function exists separately from `prepare_private_balance_increase` solely as an optimization as it allows\n    /// us to have it inlined in the `transfer_public_to_private` function which results in one less kernel iteration.\n    ///\n    /// TODO(#9180): Consider adding macro support for functions callable both as an entrypoint and as an internal\n    /// function.\n    #[contract_library_method]\n    fn _prepare_private_balance_increase(\n        from: AztecAddress, // recipient of the outgoing: TODO(#9887): this is not great?\n        to: AztecAddress,\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n    ) -> Field {\n        let to_note_slot = storage.private_balances.at(to).set.storage_slot;\n\n        // We create a setup payload with unpopulated/zero `amount` for 'to'\n        // TODO(#7775): Manually fetching the randomness here is not great. If we decide to include randomness in all\n        // notes we could just inject it in macros.\n        let note_randomness = unsafe { random() };\n        let note_setup_payload = U253Note::setup_payload().new(to, note_randomness, to_note_slot);\n\n        // We get the keys and encrypt the log of the note\n        let setup_log = note_setup_payload.encrypt_log(context, to, from);\n\n        // Using the x-coordinate as a hiding point slot is safe against someone else interfering with it because\n        // we have a guarantee that the public functions of the transaction are executed right after the private ones\n        // and for this reason the protocol guarantees that nobody can front-run us in consuming the hiding point.\n        // This guarantee would break if `finalize_transfer_public_to_private` was not called in the same transaction. This\n        // however is not the flow we are currently concerned with. To support the multi-transaction flow we could\n        // introduce a `from` function argument, hash the x-coordinate with it and then repeat the hashing in\n        // `finalize_transfer_public_to_private`.\n        //\n        // We can also be sure that the `hiding_point_slot` will not overwrite any other value in the storage because\n        // in our state variables we derive slots using a different hash function from multi scalar multiplication\n        // (MSM).\n        let hiding_point_slot = note_setup_payload.hiding_point.x;\n\n        // We don't need to perform a check that the value overwritten by `_store_point_in_transient_storage_unsafe`\n        // is zero because the slot is the x-coordinate of the hiding point and hence we could only overwrite\n        // the value in the slot with the same value. This makes usage of the `unsafe` method safe.\n        Token::at(context.this_address())\n            ._store_payload_in_transient_storage_unsafe(\n                hiding_point_slot,\n                note_setup_payload.hiding_point,\n                setup_log,\n            )\n            .enqueue(context);\n\n        hiding_point_slot\n    }\n\n    /// Finalizes a transfer of token `amount` from public balance of `from` to a private balance of `to`.\n    /// The transfer must be prepared by calling `prepare_private_balance_increase` first and the resulting\n    /// `hiding_point_slot` must be passed as an argument to this function.\n    #[public]\n    fn finalize_transfer_public_to_private(amount: Field, hiding_point_slot: Field) {\n        let from = context.msg_sender();\n        let amount = U253::from_integer(amount);\n        _finalize_transfer_public_to_private(\n            from,\n            amount,\n            hiding_point_slot,\n            &mut context,\n            storage,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _finalize_transfer_public_to_private_unsafe(\n        from: AztecAddress,\n        amount: U253,\n        hiding_point_slot: Field,\n    ) {\n        _finalize_transfer_public_to_private(\n            from,\n            amount,\n            hiding_point_slot,\n            &mut context,\n            storage,\n        );\n    }\n\n    #[contract_library_method]\n    fn _finalize_transfer_public_to_private(\n        from: AztecAddress,\n        amount: U253,\n        hiding_point_slot: Field,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        // First we subtract the `amount` from the public balance of `from`\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        // Increase the shielded supply by the `amount`\n        storage.shielded_supply.write(storage.shielded_supply.read().add(amount));\n\n        // Then we finalize the partial note with the `amount`\n        let finalization_payload =\n            U253Note::finalization_payload().new(context, hiding_point_slot, amount.to_field());\n\n        // At last we emit the note hash and the final log\n        finalization_payload.emit();\n    }\n\n    /// Mints token `amount` to a private balance of `to`. Message sender has to have minter permissions (checked\n    /// in the enqueud call).\n    #[private]\n    fn mint_shielded(to: AztecAddress, amount: Field) {\n        let token = Token::at(context.this_address());\n\n        // We prepare the partial note to which we'll \"send\" the minted amount.\n        let hiding_point_slot =\n            _prepare_private_balance_increase(context.msg_sender(), to, &mut context, storage);\n\n        // At last we finalize the mint. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that only a message sender with minter permissions\n        // can successfully execute the function.\n        token\n            ._finalize_mint_shielded_unsafe(context.msg_sender(), to, amount, hiding_point_slot)\n            .enqueue(&mut context);\n    }\n\n    /// Finalizes a mint of token `amount` to a private balance of `to`. The mint must be prepared by calling\n    /// `prepare_private_balance_increase` first and the resulting\n    /// `hiding_point_slot` must be passed as an argument to this function.\n    ///\n    /// Note: This function is only an optimization as it could be replaced by a combination of `mint_public`\n    /// and `finalize_transfer_public_to_private`. It is however used very commonly so it makes sense to optimize it\n    /// (e.g. used during token bridging, in AMM liquidity token etc.).\n    #[public]\n    fn finalize_mint_shielded(to: AztecAddress, amount: Field, hiding_point_slot: Field) {\n        assert(storage.minter.read().eq(context.msg_sender()), \"caller is not minter\");\n        _finalize_mint_shielded(to, amount, hiding_point_slot, &mut context, storage);\n    }\n\n    #[public]\n    #[internal]\n    fn _finalize_mint_shielded_unsafe(\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n        hiding_point_slot: Field,\n    ) {\n        // We check the minter permissions as it was not done in `mint_shielded` function.\n        assert(storage.minter.read().eq(from), \"caller is not minter\");\n        _finalize_mint_shielded(to, amount, hiding_point_slot, &mut context, storage);\n    }\n\n    #[contract_library_method]\n    fn _finalize_mint_shielded(\n        to: AztecAddress,\n        amount: Field,\n        hiding_point_slot: Field,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        let amount = U253::from_integer(amount);\n\n        // Increase the total supply by the `amount`\n        storage.total_supply.write(storage.total_supply.read().add(amount));\n        // Increase the shielded supply by the `amount`\n        storage.shielded_supply.write(storage.shielded_supply.read().add(amount));\n\n        // Finalize the partial note with the `amount`\n        let finalization_payload =\n            U253Note::finalization_payload().new(context, hiding_point_slot, amount.to_field());\n\n        // emit the note hash and the final log\n        finalization_payload.emit();\n\n        // Emit the mint event\n        Mint { to, amount: amount.to_field() }.emit(encode_event(context));\n    }\n\n    #[contract_library_method]\n    fn get_shield_gateway(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n    ) -> AztecAddress {\n        Beacon::at(storage.shield_gateway_beacon.read())\n            .get_target_private(context.this_address())\n            .view(context)\n    }\n\n    unconstrained fn get_shield_gateway_beacon_unconstrained() -> AztecAddress {\n        storage.shield_gateway_beacon.read()\n    }\n\n    #[public]\n    #[view]\n    fn get_shield_gateway_beacon_public() -> AztecAddress {\n        storage.shield_gateway_beacon.read()\n    }\n\n    #[public]\n    #[view]\n    fn get_shield_gateway_public() -> AztecAddress {\n        Beacon::at(storage.shield_gateway_beacon.read())\n            .get_target_public(context.this_address())\n            .view(&mut context)\n    }\n\n    #[private]\n    #[view]\n    fn get_shield_gateway_private() -> AztecAddress {\n        get_shield_gateway(&mut context, storage)\n    }\n\n    #[private]\n    #[view]\n    fn get_shield_gateway_beacon_private() -> AztecAddress {\n        storage.shield_gateway_beacon.read()\n    }\n\n    #[private]\n    fn setup_refund(\n        fee_payer: AztecAddress, // Address of the entity which will receive the fee note.\n        user: AztecAddress, // A user for which we are setting up the fee refund.\n        funded_amount: Field, // The amount the user funded the fee payer with (represents fee limit).\n        nonce: Field, // A nonce to make authwitness unique.\n    ) {\n        // 1. This function is called by fee paying contract (fee_payer) when setting up a refund so we need to support\n        // the authwit flow here and check that the user really permitted fee_payer to set up a refund on their behalf.\n        assert_current_call_valid_authwit(&mut context, user);\n\n        // 2. Deduct the funded amount from the user's balance - this is a maximum fee a user is willing to pay\n        // (called fee limit in aztec spec). The difference between fee limit and the actual tx fee will be refunded\n        // to the user in the `complete_refund(...)` function.\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            user,\n            U253::from_integer(funded_amount),\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.private_balances.at(user).add(user, change).emit(\n            encode_and_encrypt_note(&mut context, user, user),\n        );\n\n        // 4. We prepare the partial notes\n        // TODO(#9887): In each `_prepare_private_balance_increase` call we fetch the user's ovpk_m 2 more times. This is\n        // very inefficient.\n        let fee_payer_point_slot =\n            _prepare_private_balance_increase(user, fee_payer, &mut context, storage);\n        let user_point_slot = _prepare_private_balance_increase(user, user, &mut context, storage);\n\n        // 5. Set the public teardown function to `complete_refund(...)`. Public teardown is the only time when a public\n        // function has access to the final transaction fee, which is needed to compute the actual refund amount.\n        context.set_public_teardown_function(\n            context.this_address(),\n            comptime { FunctionSelector::from_signature(\"complete_refund(Field,Field,Field)\") },\n            [fee_payer_point_slot, user_point_slot, funded_amount],\n        );\n    }\n\n    // TODO(#9375): Having to define the note log length here is very unfortunate as it's basically impossible for\n    // users to derive manually. This will however go away once we have a real transient storage since we will not need\n    // the public call and instead we would do something like `context.transient_storage_write(slot, payload)` and that\n    // will allow us to use generics and hence user will not need to define it explicitly. We cannot use generics here\n    // as it is an entrypoint function.\n    #[public]\n    #[internal]\n    fn _store_payload_in_transient_storage_unsafe(\n        slot: Field,\n        point: Point,\n        setup_log: [Field; 9],\n    ) {\n        context.storage_write(slot, point);\n        context.storage_write(slot + aztec::protocol_types::point::POINT_LENGTH as Field, setup_log);\n    }\n\n    // TODO(#7728): even though the funded_amount should be a U253, we can't have that type in a contract interface due\n    // to serialization issues.\n\n    #[public]\n    #[internal]\n    fn complete_refund(fee_payer_slot: Field, user_slot: Field, funded_amount: Field) {\n        // TODO(#7728): Remove the next line\n        let funded_amount = U253::from_integer(funded_amount);\n        let tx_fee = U253::from_integer(context.transaction_fee());\n\n        // 1. We check that user funded the fee payer contract with at least the transaction fee.\n        // TODO(#7796): we should try to prevent reverts here\n        assert(funded_amount >= tx_fee, \"funded amount not enough to cover tx fee\");\n\n        // 2. We compute the refund amount as the difference between funded amount and tx fee.\n        let refund_amount = funded_amount - tx_fee;\n\n        // 3. We construct the note finalization payloads with the correct amounts and hiding points to get the note\n        // hashes and unencrypted logs.\n        let fee_payer_finalization_payload =\n            U253Note::finalization_payload().new(&mut context, fee_payer_slot, tx_fee.to_field());\n        let user_finalization_payload =\n            U253Note::finalization_payload().new(&mut context, user_slot, refund_amount.to_field());\n\n        // 4. At last we emit the note hashes and the final note logs.\n        fee_payer_finalization_payload.emit();\n        user_finalization_payload.emit();\n        // --> Once the tx is settled user and fee recipient can add the notes to their pixies.\n    }\n\n    /// Internal ///\n\n    #[public]\n    #[internal]\n    fn _increase_public_balance(to: AztecAddress, amount: U253) {\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(new_balance);\n\n        // Decrease the shielded supply by the `amount`\n        let new_shielded_supply = storage.shielded_supply.read().sub(amount);\n        storage.shielded_supply.write(new_shielded_supply);\n    }\n\n    #[public]\n    #[internal]\n    fn _reduce_total_supply(amount: U253) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n\n        // Decrease the shielded supply by the `amount`\n        let new_shielded_supply = storage.shielded_supply.read().sub(amount);\n        storage.shielded_supply.write(new_shielded_supply);\n    }\n\n    #[public]\n    #[internal]\n    fn _log_shield(from: AztecAddress, amount: U253) {\n        Shield { from, amount: amount.to_field() }.emit(encode_event(&mut context));\n    }\n\n    #[public]\n    #[internal]\n    fn _log_unshield(from: AztecAddress, amount: U253) {\n        Unshield { from, amount: amount.to_field() }.emit(encode_event(&mut context));\n    }\n\n    /// Unconstrained ///\n\n    pub(crate) unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.private_balances.at(owner).balance_of().to_field()\n    }\n}\n"
    },
    "48": {
      "path": "std/ops/arith.nr",
      "source": "// docs:start:add-trait\npub trait Add {\n    fn add(self, other: Self) -> Self;\n}\n// docs:end:add-trait\n\nimpl Add for Field {\n    fn add(self, other: Field) -> Field {\n        self + other\n    }\n}\n\nimpl Add for u64 {\n    fn add(self, other: u64) -> u64 {\n        self + other\n    }\n}\nimpl Add for u32 {\n    fn add(self, other: u32) -> u32 {\n        self + other\n    }\n}\nimpl Add for u16 {\n    fn add(self, other: u16) -> u16 {\n        self + other\n    }\n}\nimpl Add for u8 {\n    fn add(self, other: u8) -> u8 {\n        self + other\n    }\n}\nimpl Add for u1 {\n    fn add(self, other: u1) -> u1 {\n        self + other\n    }\n}\n\nimpl Add for i8 {\n    fn add(self, other: i8) -> i8 {\n        self + other\n    }\n}\nimpl Add for i16 {\n    fn add(self, other: i16) -> i16 {\n        self + other\n    }\n}\nimpl Add for i32 {\n    fn add(self, other: i32) -> i32 {\n        self + other\n    }\n}\nimpl Add for i64 {\n    fn add(self, other: i64) -> i64 {\n        self + other\n    }\n}\n\n// docs:start:sub-trait\npub trait Sub {\n    fn sub(self, other: Self) -> Self;\n}\n// docs:end:sub-trait\n\nimpl Sub for Field {\n    fn sub(self, other: Field) -> Field {\n        self - other\n    }\n}\n\nimpl Sub for u64 {\n    fn sub(self, other: u64) -> u64 {\n        self - other\n    }\n}\nimpl Sub for u32 {\n    fn sub(self, other: u32) -> u32 {\n        self - other\n    }\n}\nimpl Sub for u16 {\n    fn sub(self, other: u16) -> u16 {\n        self - other\n    }\n}\nimpl Sub for u8 {\n    fn sub(self, other: u8) -> u8 {\n        self - other\n    }\n}\nimpl Sub for u1 {\n    fn sub(self, other: u1) -> u1 {\n        self - other\n    }\n}\n\nimpl Sub for i8 {\n    fn sub(self, other: i8) -> i8 {\n        self - other\n    }\n}\nimpl Sub for i16 {\n    fn sub(self, other: i16) -> i16 {\n        self - other\n    }\n}\nimpl Sub for i32 {\n    fn sub(self, other: i32) -> i32 {\n        self - other\n    }\n}\nimpl Sub for i64 {\n    fn sub(self, other: i64) -> i64 {\n        self - other\n    }\n}\n\n// docs:start:mul-trait\npub trait Mul {\n    fn mul(self, other: Self) -> Self;\n}\n// docs:end:mul-trait\n\nimpl Mul for Field {\n    fn mul(self, other: Field) -> Field {\n        self * other\n    }\n}\n\nimpl Mul for u64 {\n    fn mul(self, other: u64) -> u64 {\n        self * other\n    }\n}\nimpl Mul for u32 {\n    fn mul(self, other: u32) -> u32 {\n        self * other\n    }\n}\nimpl Mul for u16 {\n    fn mul(self, other: u16) -> u16 {\n        self * other\n    }\n}\nimpl Mul for u8 {\n    fn mul(self, other: u8) -> u8 {\n        self * other\n    }\n}\nimpl Mul for u1 {\n    fn mul(self, other: u1) -> u1 {\n        self * other\n    }\n}\n\nimpl Mul for i8 {\n    fn mul(self, other: i8) -> i8 {\n        self * other\n    }\n}\nimpl Mul for i16 {\n    fn mul(self, other: i16) -> i16 {\n        self * other\n    }\n}\nimpl Mul for i32 {\n    fn mul(self, other: i32) -> i32 {\n        self * other\n    }\n}\nimpl Mul for i64 {\n    fn mul(self, other: i64) -> i64 {\n        self * other\n    }\n}\n\n// docs:start:div-trait\npub trait Div {\n    fn div(self, other: Self) -> Self;\n}\n// docs:end:div-trait\n\nimpl Div for Field {\n    fn div(self, other: Field) -> Field {\n        self / other\n    }\n}\n\nimpl Div for u64 {\n    fn div(self, other: u64) -> u64 {\n        self / other\n    }\n}\nimpl Div for u32 {\n    fn div(self, other: u32) -> u32 {\n        self / other\n    }\n}\nimpl Div for u16 {\n    fn div(self, other: u16) -> u16 {\n        self / other\n    }\n}\nimpl Div for u8 {\n    fn div(self, other: u8) -> u8 {\n        self / other\n    }\n}\nimpl Div for u1 {\n    fn div(self, other: u1) -> u1 {\n        self / other\n    }\n}\n\nimpl Div for i8 {\n    fn div(self, other: i8) -> i8 {\n        self / other\n    }\n}\nimpl Div for i16 {\n    fn div(self, other: i16) -> i16 {\n        self / other\n    }\n}\nimpl Div for i32 {\n    fn div(self, other: i32) -> i32 {\n        self / other\n    }\n}\nimpl Div for i64 {\n    fn div(self, other: i64) -> i64 {\n        self / other\n    }\n}\n\n// docs:start:rem-trait\npub trait Rem {\n    fn rem(self, other: Self) -> Self;\n}\n// docs:end:rem-trait\n\nimpl Rem for u64 {\n    fn rem(self, other: u64) -> u64 {\n        self % other\n    }\n}\nimpl Rem for u32 {\n    fn rem(self, other: u32) -> u32 {\n        self % other\n    }\n}\nimpl Rem for u16 {\n    fn rem(self, other: u16) -> u16 {\n        self % other\n    }\n}\nimpl Rem for u8 {\n    fn rem(self, other: u8) -> u8 {\n        self % other\n    }\n}\nimpl Rem for u1 {\n    fn rem(self, other: u1) -> u1 {\n        self % other\n    }\n}\n\nimpl Rem for i8 {\n    fn rem(self, other: i8) -> i8 {\n        self % other\n    }\n}\nimpl Rem for i16 {\n    fn rem(self, other: i16) -> i16 {\n        self % other\n    }\n}\nimpl Rem for i32 {\n    fn rem(self, other: i32) -> i32 {\n        self % other\n    }\n}\nimpl Rem for i64 {\n    fn rem(self, other: i64) -> i64 {\n        self % other\n    }\n}\n\n// docs:start:neg-trait\npub trait Neg {\n    fn neg(self) -> Self;\n}\n// docs:end:neg-trait\n\n// docs:start:neg-trait-impls\nimpl Neg for Field {\n    fn neg(self) -> Field {\n        -self\n    }\n}\n\nimpl Neg for i8 {\n    fn neg(self) -> i8 {\n        -self\n    }\n}\nimpl Neg for i16 {\n    fn neg(self) -> i16 {\n        -self\n    }\n}\nimpl Neg for i32 {\n    fn neg(self) -> i32 {\n        -self\n    }\n}\nimpl Neg for i64 {\n    fn neg(self) -> i64 {\n        -self\n    }\n}\n// docs:end:neg-trait-impls\n\n"
    },
    "51": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "52": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "57": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"
    },
    "6": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "60": {
      "path": "std/uint128.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::ops::{Add, BitAnd, BitOr, BitXor, Div, Mul, Not, Rem, Shl, Shr, Sub};\nuse crate::static_assert;\nuse super::{convert::AsPrimitive, default::Default};\n\nglobal pow64: Field = 18446744073709551616; //2^64;\nglobal pow63: Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    pub(crate) lo: Field,\n    pub(crate) hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i + 8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i + 8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        static_assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N - i]) * base;\n                base = base * 16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn unconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (\n            if ascii < 58 {\n                ascii - 48\n            } else {\n                /// Safety: optionally adds 32 and then check (below) the result is in 'a..f' range\n                let ascii =\n                    ascii + 32 * (unsafe { U128::unconstrained_check_is_upper_ascii(ascii) as u8 });\n                assert(ascii >= 97); // enforce >= 'a'\n                assert(ascii <= 102); // enforce <= 'f'\n                ascii - 87\n            }\n        ) as Field\n    }\n\n    // TODO: Replace with a faster version.\n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q, r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128\n    where\n        T: AsPrimitive<Field>,\n    {\n        let f = i.as_();\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size::<128>();\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T\n    where\n        Field: AsPrimitive<T>,\n    {\n        AsPrimitive::as_(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        /// Safety: euclidian division is asserted to be correct: assert(a == b * q + r); and assert(r < b);\n        /// Furthermore, U128 addition and multiplication ensures that b * q + r does not overflow\n        unsafe {\n            /*@safety : euclidian division is asserted to be correct: assert(a == b * q + r); and assert(r < b);\n                Furthermore, U128 addition and multiplication ensures that b * q + r does not overflow\n            */\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        /// Safety: cf div() above\n        unsafe {\n            //@safety : cf div() above\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nimpl Default for U128 {\n    fn default() -> Self {\n        U128::zero()\n    }\n}\n\nmod tests {\n    use crate::default::Default;\n    use crate::ops::Not;\n    use crate::uint128::{pow63, pow64, U128};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a = a.to_le_bytes();\n        let be_bytes_a = a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b = U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c = U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d = U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e = U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f = U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded = U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b: Field = a.to_integer();\n        let c: [u8; 17] = b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a = U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b = U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c = U128::one();\n        let d = U128::from_u64s_le(0x0, 0x1);\n        /// Safety: testing context\n        unsafe {\n            //@safety: testing context\n            let (q, r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        /// Safety: testing context\n        unsafe {\n            //@safety: testing context\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        /// Safety: testing context\n        unsafe {\n            //@safety: testing context\n            let (c, d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        /// Safety: testing context\n        unsafe {\n            //@safety: testing context\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        /// Safety: testing context\n        unsafe {\n            //@safety: testing context\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start: Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start: Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start: Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start: Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(),\n            U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(\n                U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff),\n            ),\n        );\n    }\n\n    #[test]\n    fn test_default() {\n        assert_eq(U128::default(), U128::zero());\n    }\n}\n"
    },
    "62": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/shield_gateway/src/capsule.nr",
      "source": "#[oracle(popCapsule)]\nunconstrained fn pop_capsule_oracle<let N: u32>() -> [Field; N] {}\n\n// A capsule is a \"blob\" of data that is passed to the contract through an oracle.\npub unconstrained fn pop_capsule<let N: u32>() -> [Field; N] {\n    pop_capsule_oracle()\n}\n"
    },
    "63": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/shield_gateway/src/main.nr",
      "source": "mod capsule;\nmod test;\n\nuse aztec::macros::aztec;\n\n#[aztec]\npub contract ShieldGateway {\n    use std::meta::derive;\n    use std::ops::arith::Add;\n\n    use aztec::{\n        context::{PrivateContext, PublicContext},\n        event::event_interface::EventInterface,\n        macros::{\n            events::event,\n            functions::{initializer, internal, private, public, view},\n            storage::storage,\n        },\n        protocol_types::{\n            address::AztecAddress,\n            hash::poseidon2_hash,\n            traits::{\n                FromField,\n                Hash,\n                ToField,\n                Serialize,\n            },\n        },\n        state_vars::{PublicImmutable, SharedMutable},\n        unencrypted_logs::unencrypted_event_emission::encode_event,\n    };\n\n    use authwit::auth::assert_current_call_valid_authwit;\n\n    use shield_gateway_storage::ShieldGatewayStorage;\n    use token::Token;\n    use uint253::uint253::U253;\n\n    use crate::capsule::pop_capsule;\n\n    pub global CHANGE_DELAY_BLOCKS: u32 = 5;\n\n    #[storage]\n    struct Storage<Context> {\n        admin: PublicImmutable<AztecAddress, Context>,\n        default_channel_threshold: SharedMutable<U253, CHANGE_DELAY_BLOCKS, Context>,\n        // External contract to hold the channel balances\n        shield_gateway_storage: PublicImmutable<AztecAddress, Context>,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct ChannelCreation {\n        from: AztecAddress,\n        to: AztecAddress,\n        token: AztecAddress,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct ChannelThresholdExceeded {\n        from: AztecAddress,\n        to: AztecAddress,\n        token: AztecAddress,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct DefaultChannelThresholdChanged {\n        new_threshold: Field,\n        effective_block: Field,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct ChannelThresholdChanged {\n        new: Field,\n        token: AztecAddress,\n        effective_block: Field,\n    }\n\n    #[public]\n    #[initializer]\n    fn init(admin: AztecAddress, shield_gateway_storage: AztecAddress, default_channel_threshold: Field) {\n        storage.admin.initialize(admin);\n        storage.shield_gateway_storage.initialize(shield_gateway_storage);\n        _set_default_channel_threshold(&mut context, storage, default_channel_threshold);\n    }\n\n    pub unconstrained fn get_default_channel_threshold() -> Field {\n        storage.default_channel_threshold.get_current_value().to_field()\n    }\n\n    #[public]\n    #[view]\n    fn get_channel_threshold(token: AztecAddress) -> U253 {\n        let mut threshold = ShieldGatewayStorage::at(storage.shield_gateway_storage.read()).get_channel_threshold(token).view(&mut context);\n        if threshold.is_zero() {\n            threshold = storage.default_channel_threshold.get_current_value();\n        }\n        threshold\n    }\n\n    #[contract_library_method]\n    fn _assert_only_admin(context: &mut PublicContext, storage: Storage<&mut PublicContext>) {\n        assert(\n            context.msg_sender().eq(storage.admin.read()),\n            \"Unauthorized\",\n        );\n    }\n\n    #[public]\n    fn set_default_channel_threshold(new_threshold: Field) {\n        _assert_only_admin(&mut context, storage);\n        _set_default_channel_threshold(&mut context, storage, new_threshold);\n    }\n\n    #[public]\n    fn set_channel_threshold(token: AztecAddress, new_threshold: Field) {\n        _assert_only_admin(&mut context, storage);\n\n        let new_threshold = U253::from_field(new_threshold);\n\n        let _ = ShieldGatewayStorage::at(storage.shield_gateway_storage.read()).set_channel_threshold(token, new_threshold).call(&mut context);\n\n        ChannelThresholdChanged {\n            new: new_threshold.to_field(),\n            token,\n            // Change will be effective after `CHANGE_DELAY_BLOCKS` in public context and `CHANGE_DELAY_BLOCKS + 1` in private context\n            effective_block: context.block_number().add(ShieldGatewayStorage::CHANGE_DELAY_BLOCKS.to_field() + 1),\n        }\n            .emit(encode_event(&mut context));\n    }\n\n    #[private]\n    fn channel_exists(from: AztecAddress, to: AztecAddress, token: AztecAddress) -> bool {\n        _channel_exists(&mut context, storage, from, to, token)\n    }\n\n    #[contract_library_method]\n    fn _channel_exists(context: &mut PrivateContext, storage: Storage<&mut PrivateContext>, from: AztecAddress, to: AztecAddress, token: AztecAddress) -> bool {\n        let key = _channel_key(from, to, token);\n        ShieldGatewayStorage::at(storage.shield_gateway_storage.read()).is_channel_initialized(key).view(context)\n    }\n\n    #[private]\n    fn initialize_channel(\n        from: AztecAddress,\n        to: AztecAddress,\n        token: AztecAddress,\n        nonce: Field,\n    ) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let key = _channel_key(from, to, token);\n        let _ = ShieldGatewayStorage::at(storage.shield_gateway_storage.read())\n            .initialize_channel_balance(key, U253::zero(), from)\n            .call(&mut context);\n\n        // Publicly log new channel creation\n        ShieldGateway::at(context.this_address())\n            ._log_channel_creation(from, to, token)\n            .enqueue(&mut context);\n    }\n\n    #[private]\n    #[view]\n    fn get_channel_balance(\n        from: AztecAddress,\n        to: AztecAddress,\n        token: AztecAddress,\n    ) -> Field {\n        _get_channel_balance(&mut context, storage, from, to, token).to_field()\n    }\n\n    #[private]\n    fn channel_transfer(\n        token: AztecAddress,\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n        nonce: Field,\n    ) {\n        let amount = U253::from_field(amount);\n        let threshold = _get_channel_threshold_private(&mut context, storage, token);\n        let current_balance = _get_channel_balance(&mut context, storage, from, to, token);\n\n        let mut new_balance = current_balance + amount;\n        // Check if the threshold is exceeded\n        if new_balance > threshold {\n            // Log the channel threshold exceeded\n            ShieldGateway::at(context.this_address())\n                ._log_channel_threshold_exceeded(from, to, token)\n                .enqueue(&mut context);\n            // Once the threshold is exceeded, reset the balance to 0\n            new_balance = U253::zero();\n        }\n\n        // Update the channel balance\n        let _ = _set_channel_balance(&mut context, storage, from, to, token, new_balance);\n\n        // Finally, execute the transfer\n        Token::at(token).transfer_private_to_private(from, to, amount.to_field(), nonce).call(&mut context);\n    }\n\n    #[private]\n    fn verified_id_transfer(\n        token: AztecAddress,\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: U253,\n        nonce: Field,\n    ) {\n        aztec::oracle::debug_log::debug_log_format(\n            \"Checking transfer of {0} tokens from {1} to {2}\",\n            [amount.to_field(), from.to_field(), to.to_field()],\n        );\n\n        // TODO: What checks should we perform here?\n        // Ensure Verified ID is provided & valid\n\n        // Safety: pop_capsule will eventually be verified\n        unsafe {\n            let verified_id: [Field; 5] = pop_capsule();\n            let _ = ShieldGateway::at(context.this_address()).verify_id_private(verified_id).view(\n                &mut context,\n            );\n        }\n\n        Token::at(token).transfer_private_to_private(from, to, amount.to_field(), nonce).call(\n            &mut context,\n        );\n    }\n\n    #[private]\n    #[view]\n    fn verify_id_private(verified_id: [Field; 5]) -> bool {\n        // TODO: Implement ID verification logic\n        aztec::oracle::debug_log::debug_log_format(\"Verified ID: {}\", verified_id);\n        true\n    }\n\n    #[public]\n    #[internal]\n    fn _log_channel_creation(from: AztecAddress, to: AztecAddress, token: AztecAddress) {\n        ChannelCreation { from, to, token }.emit(encode_event(&mut context));\n    }\n\n    #[public]\n    #[internal]\n    fn _log_channel_threshold_exceeded(from: AztecAddress, to: AztecAddress, token: AztecAddress) {\n        ChannelThresholdExceeded { from, to, token }.emit(encode_event(&mut context));\n    }\n\n    #[contract_library_method]\n    fn _set_default_channel_threshold(context: &mut PublicContext, storage: Storage<&mut PublicContext>, new_threshold: Field) {\n        storage.default_channel_threshold.schedule_value_change(U253::from_field(new_threshold));\n\n        DefaultChannelThresholdChanged {\n            new_threshold,\n            // Change will be effective after `CHANGE_DELAY_BLOCKS` in public context and `CHANGE_DELAY_BLOCKS + 1` in private context\n            effective_block: context.block_number().add(CHANGE_DELAY_BLOCKS.to_field() + 1),\n        }\n            .emit(encode_event(context));\n    }\n\n\n\n    #[contract_library_method]\n    fn _get_channel_threshold_private(context: &mut PrivateContext, storage: Storage<&mut PrivateContext>, token: AztecAddress) -> U253 {\n        let threshold = ShieldGatewayStorage::at(storage.shield_gateway_storage.read()).get_channel_threshold_private(token).view(context);\n\n        if threshold.is_zero() {\n            // If the threshold is not set for the token, use the default threshold\n            storage.default_channel_threshold.get_current_value()\n        } else {\n            threshold\n        }\n    }\n\n    #[contract_library_method]\n    fn _channel_key(from: AztecAddress, to: AztecAddress, token: AztecAddress) -> Field {\n        poseidon2_hash([from.to_field(), to.to_field(), token.to_field()])\n    }\n\n    #[contract_library_method]\n    fn _get_channel_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        from: AztecAddress,\n        to: AztecAddress,\n        token: AztecAddress,\n    ) -> U253 {\n        let key = _channel_key(from, to, token);\n         ShieldGatewayStorage::at(storage.shield_gateway_storage.read())\n            .get_channel_balance(key)\n            .call(context)\n    }\n\n    #[contract_library_method]\n    fn _set_channel_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        from: AztecAddress,\n        to: AztecAddress,\n        token: AztecAddress,\n        amount: U253,\n    ) -> U253 {\n        let key = _channel_key(from, to, token);\n        ShieldGatewayStorage::at(storage.shield_gateway_storage.read())\n            .set_channel_balance(key, amount, from)\n            .call(context)\n    }\n\n    pub unconstrained fn get_storage_address() -> AztecAddress {\n        storage.shield_gateway_storage.read()\n    }\n\n    pub unconstrained fn channel_key(from: AztecAddress, to: AztecAddress, token: AztecAddress) -> Field {\n        _channel_key(from, to, token)\n    }\n}\n"
    },
    "69": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/authwit/src/auth.nr",
      "source": "use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\nuse dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\nglobal IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "7": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "77": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub gas_opts: GasOpts,\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"
    },
    "84": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        execution_cache::store(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            /// Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            /// for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        /// Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        /// execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        /// the number of side effects that took place), along with the hash of the return values. We validate these\n        /// by requesting a private kernel iteration in which the return values are constrained to hash\n        /// to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        /// WARNING: This is insecure and should be temporary!\n        /// The oracle hashes the arguments and returns a new args_hash.\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        /// We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        /// b) this is only temporary.\n        let args_hash = unsafe {\n            enqueue_public_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.set_public_teardown_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        /// WARNING: This is insecure and should be temporary!\n        /// The oracle hashes the arguments and returns a new args_hash.\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        /// We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        /// b) this is only temporary.\n        let args_hash = unsafe {\n            set_public_teardown_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "85": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, Packable, Serialize};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            /// Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            /// Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "86": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        /// Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "87": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.74.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    }
  }
}
