{
  "transpiled": true,
  "noir_version": "1.0.0-beta.11+5b65f9637e85a4177692c3190cb35ea678fb15e9-aztec",
  "name": "ShieldGateway",
  "functions": [
    {
      "name": "_log_transfer",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "serial",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "binnedAmount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13434471300436635949": {
            "error_kind": "string",
            "string": "Function _log_transfer can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBHJwAABAMnAgQEAycCBQQAHwoABAAFgEQdAIBGgEYGLgiARAABLgiARQACLgiARgADJQAAAFglAAAAWSgCAAEEgEcnAgIEADsOAAIAASYlAAABAx4CAAQBHgIABQAKKgQFBiQCAAYAAAB6JQAAASwcCgMEACkCAAMARzWU8ycCBgQEJwIIBAMAKgYIBy0IAQUACAEHAScDBQQBACIFAgctDgYHACIHAgctDgYHJwIHBAMAKgUHBi0KBgctDgEHACIHAgctDgIHACIHAgctDgQHACIHAgctDgMHJwIBBAQAIgUCBC0LBAMnAgYEAgAqBAYCNwsAAgADJigAgAQEeAANAAAAgASAAyQAgAMAAAErKgEAAQX3ofOvpa3UyjwEAgEmKgEAAQW6cNR4B7SxLTwEAgEm",
      "debug_symbols": "nZTBjusgDEX/hXUWYGPA+ZVRVaVtOooUpVUmedJTlX8f6OCmWRCNZlMuphy4xvFDXdrT/HnshuvtS9UfD3Uau77vPo/97dxM3W2I0YfS6YetqrFSzKp2lTI6Tn0a+Wc0/mcEULUxScSAiRsMuiysESERkghRFk6LkIiXiLciOIuAIkIWLBHOp4M2IvKhYLQIEpGBAFZEAlIUiCIkYkGEz4KekWWplGTtOI1tm5L2lsaY3HsztsOk6mHu+0r9a/r5+aevezM8x6kZ46quVDtc4hiB165vk1qqdbcub43ZDyFvN4DavRBGhw3E7ECYEATCZNd7eNgwoMxAQE+ZETUXGbtm0MBqBqFoxu5APAcnEM9MpYvQrhkdVjNg/2Rm8zJoi2Z2IGAcZkYs1RVB2wIJZUJgLeUV2LwlgzYELhMcWZ8Jzun1XRFxW2B7PsD5l4/wxnD4WyMcv+eMYAAuGTE7NWqRpLwsBld61H0EuhXBRcROgSISv74UdLC9xyHOmnM3bvrxkmhj15z6Nk+v83B+W53+32VF+vl9vJ3byzy2ibQ29dQLP8hU5A6ph6eJr4gPSzr6Gw=="
    },
    {
      "name": "binned",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "TL3LkjW7jpz5Lnvcg0WQBIjzKj2QtfoiK7MylVlLGtXLKwNO0H1S+/M6f9IZDMJXrAhk5H/+8//8v//1f/23//Jv//3/+4//8c+//s///Oe//v//9u///m//7b/8+3/83//X//y3//jvf//f//zn9/2fNf751/w//ln2z7/87z/zn3+dv/+sf/41fn//3X//tb//+t9/199/4++/3z8797+J/+7f/e+4/7X733n/u+5/9/2v3//e8fYdb9/x/I7ndzy/4/kdz+94fsfzO57f8fyO53e8uOPFHS/ueHHHizte3PHijhd3vLjjxR3v3PHOHe/c8c4d79zxzh3v3PHOHe/c8c4dL+94ecfLO17e8fKOl3e8vOPlHS/veHnHG79fw2iwhtmwGnaDN0TDaeiRR488euTRI48eefTIo0cePfLokUePPHpk65GtR7Ye2Xpk+xvZfh/sBm+IhtOQF+avYTRYw2zokWePPL+RxwfRcBrywvo1jAZr+EZeH3wjnw92gzdEw2nIC19JTftgNFjDbPgbec4PdoM3fCN/K/aVFiAvfMU184PRYA2zYTXsBm+IhtOQF6JHjh45euTokb9SW9/6fLUG8IZoOA154Ss4wGiwhtnQI58e+fTIp0c+PfLpkbNHzh45e+TskbNHzh45e+TskbNHzjuy/X4No+EbeX4wG1bDbvCGaDgNeeGrQcBo6JFHjzx65NEjjx559MijRx49svXI1iNbj2w9svXI1iNbj2w9svXI1iPPHnn2yLNHnj3y7JFnjzx75Nkjzx559sirR1498uqRV4+8euTVI68eefXIq0dePfLukXePvHvk3SPvHnn3yLtH3j3y7pF3j+w9svfI3iN7j+w9svfI3iN7j/zV4PIP8sJXg4DRYA2zYTXsBm+Ihh45euTTI58euWowP5gNq+Fv5L0+8IZoOA154atBwGiwhtmwGnrk7JGzR84eOW8izd+vYTRYw2xYDbvBG6LhNPTIo0cePfLokb8a3PHBatgN3hANpyEvfDUIGA3W0CNbj2w9svXI1iN/NbjPB3nhq0HAaLCG2bAadoM3REOPPHvk1SOvHrkuKPcHs2E17AZviIbTkBe+GgSMhh5598i7R9498u6Rd4+8e+TdI3uP7D2y98jeI3uP7D2y98jeI3uP7D1y9MjRI0ePHD1y9MjRI0ePHD1y9MjRI58e+fTI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DqIRJ3ERN9GJQTxEug26DboNug26DboNug26DboNug26Gd2MbkY3o5vRjVmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWVMPg+F6nNKplsHERN9GJQTzEvGjVP9g4iEacxEXcxHLDy0qCeIj5sLLk4iAacRIXcRPpNug26DboZnQzuhndjG5GN6Ob0c3oZnQzuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptujndnG5ON6eb062yZOxCJwax3E5hPqwsuTiIRpzERdxEJwaRbkG3Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7ekW9It6ZZ0S7ol3ZJuSbekWz43vDDs4iAacRIXcROdGMRDpNug26DboNug26DboNug26DboNugm9HN6GZ0M7oZ3YxuRjejm9HN6DbpNuk26TbpNuk26TbpNuk26Tbptui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26eZ0c7o53ZxuTjenm9PN6cYsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcwSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJJqxhzfq0utujEbN9GJQTzEfFhZcnEQjUi3RbdFt0W3yhKzwkPMh5UlFwfRiJO4iJvoRLptum26Od2cbk43p5vTzenmdHO6Od2cbkG3oFvQLegWdAu6Bd2CbkG3oNuh26Hboduh26Hboduh26HboduhW9It6ZZ0S7ol3ZJuSbekW9Itn1v1czYOohEncRE30YlBPES6DboNug26DboNug26DboNug26DboZ3YxulSXfS3+t2jwbF7HcstCJQTzEfFhZcnEQjTiJi0i3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt003p5vTzenmdHO6Od2cbk43p5vTLegWdAu6Bd2CbkG3oFvQLegWdDt0O3Q7dDt0O3Q7dDt0O3Q7dDt0S7ol3ZJuSbekW9It6ZZ0S7rlc9u/H3EQjTiJi7iJTgziIdJt0G3QbdBt0G3QbdBt0G3QbdBt0M3oZnQzuhndjG7Mks0s2cySzSzZzJLNLNnMks0s2cySzSzZzJLNLNnMks0s2cySzSzZzJLNLNnMks0s2cySzSzZzJLNLNnMks0s2cySzSzZzJLNLNnMks0s2cySzSzZzJLNLNnMks0s2cySzSzZzJLNLNnMks0s2cySzSzZzJLNLNnMks0s2cySzSzZzJLNLNnMks0s2cySzSzZzJLNLNnMks0s2cySzSzZzJLNLNnMks0s2cySzSzZzJLNLNnMks0s2cwSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4sCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS9D3+v2JE0PfK7Cy5OIgGnESF3ETnRhEuhndJt0m3SpLphdO4iJuohODeIj5sLLk4iDSbdFt0W3RbdFt0W3RbdFt023TrbJk7sJJXMRNdGIQDzEfVpZcHES6Od2cbk43p5vTzenmdAu6Bd2CbkG3oFvQLegWdAu6Bd0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3ZJuSbekW9It6ZZ0S7ol3ZJu+dzQ93pxEI04iYu4iU4M4iHSbdBt0G3QbdBt0G3QbdBt0G3QbdDN6GZ0M7oZ3YxuRjejm9HN6GZ0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023RjlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJeh7nVE4iEacxEXcRCcG8RDz4aLbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbppvTzenmdHO6Od2cbk43p5vTzekWdAu6Bd2CbkG3oFvQLegWdAu6Hboduh26Hboduh26Hboduh26Hbol3SpL6q/doe/14iR+bvXHy9D3etGJQTzEvDjR93pxEI04iYu4iU4M4iHSbdBt0G3QbdBt0G3QbdBt0G3QbdDN6GZ0M7oZ3YxuRjejm9HN6GZ0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNt0c7o53ZxuTjenm9PN6eZ0c7o53YJuQbegW9At6BZ0C7oF3YJuQbdDt0O3Q7dDt0O3Q7dDt0O3Q7dDt6Rb0i3plnRLuiXdkm5Jt6Qbs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5ag7/X7a74Tfa8XN7HcTmEQDzEfIkuAg2jESVzETaRb0A1ZYoX5EFkCHEQjTuIibqITg0i3Q7ekW9It6ZZ0S7ol3ZJuSbekWz439L1eHEQjTuIibqITg3iIdBt0G3QbdBt0G3QbdBt0G3QbdBt0M7oZ3YxuRjejm9HN6GZ0M7oZ3SbdKkvqbyOj7/XiJH5u9+8hb6ITyy0LDzEfIkuAg2jESVzETXQi3RbdFt023TbdNt023TbdNt023TbdNt023ZxuTjenm9PN6eZ0c7o53ZxuTregW9At6BZ0C7oF3YJuQbegW9Dt0O3Q7dDt0O3Q7dDt0O3Q7dDt0C3plnRLuiXdkm5Jt6Rb0i3pls8Nfa8XB9GIk7iIm+jEIB4i3QbdBt0G3QbdBt0G3QbdBt0G3QbdjG5GN6Ob0c3oZnQzuhndcO91FeZD3HsFDqIRJ3ERN9GJQaTbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab083p5nRzujndnG5ON6eb083pFnQLugXdgm5Bt6Bb0C3oFnQLuh26Hboduh26Hboduh26Hboduh26Jd2Sbkm3pFvSLemWdEu6Jd3yuaHv9eIgGnESF3ETnRjEQ6TboNug26DboNug26DboNug26BbZYmPDytLLg7i5+azcBIXcROdGMRDzIeVJRcHkW6TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25ON6eb083p5nRzujndnG5ON6db0C3oFnQLugXdgm5Bt6Bb0C3oduh26Hboduh26Hboduh26HboduiWdEu6Jd2Sbkm3pFvSLemWdMvnhr7Xi4NoxElcxE10YhAPkW6DboNug26DboNug26DboNug26DbkY3oxuzxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZgr7X70/pTvS9XnRiEA8xHyJLgINoxEmk26TbpFtlyfcG7Ym+14v5EFlihYNoxElcxE10YhAPMR9uum26bbptum26bbptum26bbptujndnG5ON6eb083p5nRzujndnG5Bt6Bb0C3oFnQLugXdgm5Bt6Dboduh26Hboduh26Hboduh26HboVvSLemWdEu6Jd2Sbkm3pFvSLZ8b+l4vDqIRJ3ERN9GJQTxEug26DboNug26DboNug26DboNug26Gd2MbkY3o5vRzehmdDO6Gd2MbpNuk26TbpNuk26TbpNuk26TbpNuzJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMEvS9nlloxEn83M4q3EQnfm4nCw8xH1aW5K9wEI04iYu4iU4M4iHmw0O3Q7dDt0O3ypL0wk104p/b34PWwkPMh1+W2K/W4cuSRiP+udn3WrpZfa+Nm+gf1rn4sqTxED+38U2n+l4bB9GIk7iIm+jEIB4i3QbdBt0G3QbdBt0G3QbdBt0G3QbdjG5GN6Ob0c3oZnQzuhndjG5Gt0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNN6eb083p5nRzujndnG5ON6eb0y3oFnQLugXdgm5Bt6Bb0C3oFnQ7dDt0O3Q7dDt0O3Q7dDt0O3Q7dEu6Jd2Sbkm3pFvSLemWdEu6vSxZv5cl6/eyZP1elqzfy5L1e1myfi9L1u9lyfq9LFm/lyXr96PboNug26DboNug26DboNug26DboJvRzehmdDO6Gd2MbkY3o5vRzeg26TbpNuk26TbpNuk26TbpNuk26bbotui26Lbotui26Lbotui26Lbotum26bbptum26bbpVlliszCIh/i52fmwsuTiIH5u369yrup7bVzEz22WW2XJxSB+bl9H+aq+14uVJRc/t7UKjTiJn9vahZvoxM9t1wFVllzMh5UluwarLLloxM/Nf4WLuImfm9d8K0suHuLn5rVmlSUXB/Fzi5pvZcnFRfzcotassuRiED+3qFWvLCmsvtfGQTTiJC7iJjoxiIdIt0G3QbdBt0G3QbdBt0G3QbdBt0E3o5vRzehmdDO6Gd2MbkY3o5vRrbLku65e1ffaaMTP7fubVqv6Xhs30YlBPMR8WFlycRCNSLdFt0W3RbfKku/vMq3qe23Mh5UlaYWDaMTPLeswK0subqITg3iI+bCy5OIgGpFuTrcvS+av5vtlSWMQz4c13y9LLn5Z0jg+PIVGnMT1YZ3u2ERvrPbI741aq7oj5/d29VV9kPP7RrCqD7LRiUE8xHz47a3GQTTiJNJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt083p5nRzujndnG5ON6eb083p5nQLugXdgm5Bt6Bb0C3oFuW2Cw8xH54fcRCNWG61Uc8ibqITPzer/ft9TjV+bvXhX32QjYNoxElcxE10YhAP8blVH2TjIBqx3FbhIm6iE4N4iOX2FW/1QTYOYrll4SQu4iY6MYif26z5fp9TF7/QaBzEz23WzL7PqcZF/NzWr9CJQfzcFgbLh5UlF+soovAbty6YqrdxrjriyodVU698AFY+XBxEI07iN25dRlVvY6MTg/i51RVV9TZerHzYNcnKh4tGnMRF3MTP7WviWNXb2HiI+bDy4bu/tqq3sfFz85pk5cPFRdzEcivjyoeLh5gPKx8uDuLnFjWdyoeLi7iJn1vUJCsfLh5iuX3lX72NjYPoxBqhjqKquy4cqzPxb8TCmkOd2Krji04M4iF+c/juSa7qQWwcRCNO4iJ+bicKnRjEQyy3b77Vg9g4iOWWhZO4iJ9bXflUD+Ksa5zqQZx1qVE9iI35sOr44iAa8XPLsqg6vriJTgziIebDquOLg2hEuk26TbpNuk26TbpNun01v351Lr6abzTiJC7iJp4Pd2E+3D/iIBpxPvRCL1zEsqgz/xXDqiu1as5rPMR8eH7EQTTiJC7iJtLt0O3Q7dAt6ZZ0S7pljVtL/RXOqivHarhb383mVQ13jYP4jVCXB9Vw17iIm+jEIB5iPhw/4iDSbdBt0G3QbdBt0G3QzWrcWVgjrMJaB/wDJwbxEPPh/BFr3F1oxJqvFy7iJtbMvm1UjXHrexf2qsa4xtoPteq1wesyqRrjGp0YxG/cuniqxriLte0vfm5W49a2vziJdNt023TbdNuHyLPpPJvOs+k8m86z6TybzrPpPJvOs+k8m063oFvQLegWdAu6Bd2qYrE1qjaxNVCb9Q9Qm8BF5N453DuHe6dqE/uhahNYtYlNULV50Yj7bQ3UZu0H1OaH1cCGreGozSw04iQu4u5NUA1sjUE8vQmqge1i1eZFug26DboNuo23d6oLbNVlc3WBNW5iTWcXBvEQ82F9MlwcRCNO4iKWW02nCudiEA8xH6JwgJ9bXStXF1jjJC7i51aXzdUF1hjEz23WzKpwgFU4F8vNC404iYtYblFY49YuqRIBVolcHMRv3Lp0r36vteocV4l8v7e0qt+r0YlB/Nzq2r76vS7WR93FQSy3OraqoVXzrRpaNZ2qoV3TqRra+LFDzIdVQxcH0YiT+LnVtX01eTWWWxlnEA8xG6vJq3EQP7e6Xq8mr8ZF3MTPra7Xq8mr8RA/N/9mVk1ejYNYbl5YbjWHqreLm+jEIB7i5xY17ncR2TiIRpzERdxEJwbxEOk26TbpNulWoVDfA6qdqzEeVvFGFAax3OrYqniBVbwXB9GIk1jHloXfHM6v0IlBPMR8WMV7cRCNOImLSDenm9PN6eZ0C7oF3ap4zyisEWr3VZnW96xqpbpYZXpxEI04iTUucBNrvnXeqmIvnodVm3XPt9qj/i5hCzexzmZNsqoQJ6Cq8GI2VntUY40bhUacxNUnttqjGp0YHOwQ6TboVlUIrGo5wEE0YuXOLlzETXRiEA/xm0N9A6w2psZBNOIkLuImOjGIh0i3RbdFt0W3+gjNWejEIB5iPqwqvDiIRpzERaTbptum26bbppvTzenmdHO6Od2cbk43p5vTzekWdAu6Bd2CbkG3oFvQLegWdAu6Hboduh26Hboduh26Hboduh26Hbol3ZJuSbekW9It6ZZ0S7ol3fK5VcNS4yAacRIXcROdGMRDpNug26DboNug26DboNug26DboNugm9HN6GZ0M7oZ3YxuRjejm9HN6DbpNuk26TbpNuk26TbpNuk26Tbptui26Lbotui26MYsSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLElmyCoN4iPkQWQIcxLL4FS7iJjoxiIeYDxEgwEE0It2CbkG3oFvQLegWdDt0O3Q7dDt0O3Q7dDt0O3Q7dDt0S7ol3ZJuSbekW9It6ZZ0S7plu+3f70ccRCNO4iJuohODeIh0G3QbdBt0G3QbdBt0G3QbdBt0G3QzuhndjG5GN6Ob0c3oZnQzuhndJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdnG5ON6eb083p5nRDlkRhEA+x3M6HyBLgIBpxEhfxz+1vbxc6MYjlloX5EFkCHEQjTuL6BpuFm+jEIB5iPvyypHEQjTiJdEu6Jd2SblluVpiN1aXUOIhGnMRy24Wb6MRy88JDzIfjR6xxo7BGOIVBPMRvhO++/a7Oo8ZB/Ob73bff1XnUuIib+LmNOqAvHxoPMR/OGncW1gir0IlBrPmWxcyH60ccRCNO4iKWW63OcmIQa761kisf7h9xEI04iYu4iU4MIt023bzc6gx9Nb+tpv7VfOMkLuImOjGIh5gPv5pvpFvQLegWdAu6Bd2CbkG3KLc68+dHHEQjTuIi1kpmoRODWG61YarmgVXzFz+3WYNVzV+cxM9t1p6smr/oxM9tllvV/MVsrLfo7a8NYddb9BqN+Ll9dy13vUWvcRM/t22FQTzEz+27KbnrLXqNg/i5fS2cu96i17iIn9vXOfCHTgzi5/bd5Nv1Fr2LlQ8XPzevI658uDiJn1vUEVc+XHTi53bKrfLhYj78rh/2qSP+rh8ajfi5nXL7rh8aN/Fzqw/A6h5rPMTPrT4Aq3uscRA/t/p8q+6xxkX8c/MK3eoeawzi+RCD5cMvSxr/3LxisLrHGidxETfRiUE8xHz4ZUkj3ZxuTjen25clbrVQX5Y0BvFzq+qu7rGLX5Y0fm5WC/VlSeMkfm5WJys20YmfW9VmdY815sMvS3zWSn5Z0mjEz22W25cljZv4uX09RLu6xxoP8XP7Hjns6h5rHMTPDcX7ZUnjIn5uuwb7sqQxiJ/bxmDZWN1jjZ9b1WZ1jzVO4uf2PSXY1T3W6MSXiNURtr9HZrs6whoXcROdGMRDzIdfPrgDa75eaMRJXMRNdGIQDzEfzh+RbpNuk26TbrPcotCJQTzEfLh+xPr0r9NS+XBxEsvtFNa4WXiI+bCS4OIgGnESF3ETnUi3TbdNN6eb083p5nRzujndnG5ON6eb0y3oFnQLugXdgm5Bt6Bb0C3oFnQ7dDt0O3Q7dDt0O3Q7dDt0O3Q7dEu6Jd2Sbkm3pFvSLemWdEu65XOr/rPGQTTiJC7iJjoxiIdIt0G3QbdBt0G3QbdBt0G3QbdBt0E3o5vRzehmdDO6Gd2MbkY3o5vRbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0Y1Zspgli1mymCWLWbKYJYtZspgl9Q48/56e7XoHXmMQDzEfVpZcHEQjTuIi0s3p5nRzujndgm6VJd8DxV3vwGucxEXcRCeW26/wEPNhZcnFQTTiJC7iJjqRboduh26VJd/vQ+1qs2s04udWF731DrzGTfzcTh1bpUb9WLXZ+fdAfFebXWONEIWb6MQgHmI+rHz4Gk13tdk1GnESP7fvwd+uNrtGJ35u3031XW12jfmw8iFr6pUPF404ieVWB1/5UFfx1Xzndb1ezXcXKwkuDmKNm4V/40bdu6rmu6gbNdV8F3XXp95g1xjEQ8wPa2ZfEjQOohHLzQvLoqazyqKm85V/1G2W6s6LgR/Lh1/5Nw6iESdxET+3unCp7rzG87bR5o7yH3EQjTiJi7iJTgwi3ZxuQbegW9At6oDqHMcibmIdUK1kBPEQ8+H5EQfRiJO4iJtIt0O3r+ajvg9V+97Fr+YbB9GIk/i5WR3xV/ONTgxiudU2ymysVr/GcjuF5ZaFk/i5zV/hJn5ucxQG8RDz4ZcPjYNoxElcxE2k26DboNugm9HN6GZ0M7oZ3YxuRjejm9HN6DbpNuk26TbpNuk26TbpNuk26Tbptui26Lbotui26Lbotui26Lbotui26bbpVgFSX7arS7FxETfR+yOpuhQbDzEfVpZcHEQjTuIi1lF88Vr9iPjUq37E+Hoid/UjNk7iIm6iE+NhJcHXP7nrnXJ3HQ6P+PCIq+YvBrHWt+qtah5YNX9xEHk2k27Js5k8m8mzmTybybNZNV9zqHbDxkE04uw5BGoeuInPLVjzwZoP1nyw5oM1H6z5GG/vxFjETXRivDmMQ3wrGaz5YM0Haz5Y88GaD9Z8sObD3nkL1DyQKzm5kvOdt0DNA7mSrPlgzQdrPljzwZoP1nyw5oM1H4vnbXElF1dycSUXVxI1H4WHWG7fZ0Cg5oGDaMTPbdUcquYvbqITg3iI+fCr+cbPbdUkv5pvrOuHWkn3rsJqY4yv/3dXG2NjPowfkWcoeIaCZyi414N7HUkA5O4LnqHgGTo8Q4dn6HD3MTXicD8c7ofD/VD5UDca6z1xjYNYq1PrUPlQjxGqEbJxE50YxEPMxmqEbBzEd+/q4O4B0IlBPMR8iLsHwEE04iTSbdBt0G3QbdBt0M3oZnQzuhndjG5GN6Ob0c3oZnSbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt04z3Hs+i26Lbotui26Lbptum26bbptum26bbptum26bbp5nRzujndnG5ON6eb083p5nRzugXdgm5Bt6Bb0C3oFnQLugXdgm6Hboduh26Hboduh26Hboduh26Hbkm3pFvSLemWdEu6Jd2Sbkm3fG75+xEH0YiTuIib6MQgHiLdmCXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJfmyxH8vS/z3ssR/L0v897LEfy9L/PeyxKvXMr5nrF69lo2HmA/rG8rFQTTiJC7iJtJt0G3QbdDN6GZ0M7oZ3YxuRrfqlfge2Hr1WjYeYj6cP+IgllsWTuIifm7f78p59Vo2BvE7tj0K82F9Q7k4iEacxEXcRCcGkW6Lbptum26bbptum26bbptum26bbvUN5Wuu8eq1jF3LV99QLhpxEhdxE50YxEPMh0G36N4kr17Lxkns3iRHr+VFJ1ZvUh1Q9V1dzIfVd3VxEI04iYu4iU6k26FbfW/5Wha8+idj11aubyi7Kra+oVwM4mmsTsn42pS8eiLja2/w6olsdGIQDzEfVs1/HQleb25rNOIkLuImOjGINd8szIdV8xcHsdxW4SRWt4UXbqITg3iIdWzf+lanZHj9f6tiLx5i/dvvBFSnZOMgGnESF3ETnRjEQ6Tbptum26bbptum26bbptum26bbppvTzenmdHO6Od2qYr3OUFXsxSAeYj6sir34uX2PJL06JRs/t6hzXHcaLm6iE4N4iPmw7jRcHEQj0q3uNERtjbrTcNFva6KjU/LiIebDutMQtXeqYqMWKrsf0dH9ePEQux/R0f14cRC/hKmkRffjxUXcRCcG8RDzIbofgYNIt0G3quPvlza9Ohrj+0VXr47GOPUPqmIvGnESvxFOHVBV4fe7qV5dio2DaMRJXMRvfb9fXvXqUmwM4iHmw6rji4NoxHKzwkXcRCeWWxQeYrl9+6G6FBsH0YiTuIib6MQgHiLdquO5LuuqS7HRiN1d6tWl2LiJ1ctaR1EdzxcPMR9Wx/PFQTTiJC7iJtIt6FYVm7W5qjazlrpqM2vvVG1edGI8rLuA3zNsr27CyDqx9Wl6cROdGMRD/Nb3e7Lt1U3YOIhGnMRF3EQnltsqPMR8WJ+8F8stC43453a+x+ReLYTn+y0HrxbCxkG0D71wErvF2OdrMfb5Woy9Wggvzho3CmuEOgq0DY/CTXRi3G5jr7bAxnxYbcOVJWgLvGjESVzETXRiEA8xH266bbp9pXd+tahfkZ1RU/+K7Iya5FdkF78iaxzEb4RRJ8trhFp1P8R8GD/iIBrxW99RSx2LuIlODOIh5sPzI5ZbbZhjxElcxHKrc3yc+LlZrdn3AdiYD7/SaxxEI07iIm6iE+lWH5aVctXUB6ymvsZqOf8VGnESa++cwk10YhAPMR/Wh+XFQTTiJNJt0G3Umn2bqxr1ztf069Wod+r7ZjXqNS7iJtYIX0FW8935XuLo1XzXOImLuIlOrPWt5ZuHmA/XjziIRpzERSy3XejEIB7i5zbrDH212fi51Ze2aqg7sw6+avPiIebDqs2Lg2jESVzETaRbfQBmLVR9AF7Mh/UBWGFeDXWNRqzdVyerPgAvbqITg3iI+bC+el4cRCPS7dCtKnbWUldtzpp61easSVZtXpzERfxG+N5O5PUuuvM9fPR6F12jESdxETfxW9/vMaNXk1zjIebD8SMOohEnseabhZvoxCCW2yrMh/W5+T3B82qSazTiJNaxncJNdGIQDzEf1qfpxUE04iTSbfYvlHi1zjUGsX+hxKt17uL6EevXV2od6tb1xUlcxE10YhAPMR/WreuLdNt027VmwG916vtFNcmd+j5UTXKNg2jEb4S661ONb6ful1Tj28X6jL04iEacxG996zZLNb41OjGIh5gP6zP24iCWW23P+oy9uIibWG51jqtigVWxdSen2taO18HXJ+TFIB5iNlbbWuMgGnESF3ET+5eyvNrWGg+xfynLq22tcRC/M1+XodW21riIm+jEIB5iPqyHTRcHkW5Gt6rNuvNUrWinbgBVK9qpWz3VitZoxEmsEU5hjfDt32ovaxxEI07iIn7r+73I16u9rDGIh5gP6xPy4iAasdxq1eua9uImOrHc6hxXFV4st6+yqr2scRCN+LnVt4NqL2vcRCcG8RDzYVXsxUE0It3wS291LvBLb0AnViLWUtdDoYv5sB4K1VVQvRqv0YiTuIib6MQgHmI+TLol3eozNoC1OjWzquP6WlKtaMBqRWscxG+E+hpV7WWn7q1Ue1ljPqxP04uDaMRvfb93hHm1lzVuohODeIj5sD5NL5bbKDTiJC5iuXmhE2vc78RWI1njIBpxEhexxs1CJ35HUd8OqpGs8XPLmk5V98XPrW5FVCNZ4+dWNx2qkazxc6tv7tVI1lhutSRV3RfLrQ6zqvtiuUWhEcutDqiq+2K51QFVdV/8c8tfHdBX3Y35YR3QV92N48M6oK+6G+eHdUBfdTfuD+uAvupuLLc6ID/EuiaoH6tHvhcH0YiTuIjlVksSTgxiudURRz48P+IgGnESF3ETnRhEuh26fVfQOWp9v0/prLsH1UiWdXOgGskaDzEbq5Gs8c233qjXOImLuIlODOIhvvlWe1kj3Qbdxu4DqpYxHFC1jN1JGuf7VXejESeR8zXO1zhf43yN8zXOd3K+k/OdnO/k6ky6TbrN8w5ojXdAi/NdnO9Xx42b6ETOd3G+i/PdnO/mfDfnuznfzfluzndzdTbdNt2qYnFAVZs4IOd8nfP1IB4iz2bwbEaNOwuN+NXmxD9YxE10Yo37hUK1a2Xd0UK7Vn31RLvWxU2sEU5hEA/xy5KvpdTRrnVxEI04iYu4iU4M4iE+N7RrXaxdAqz1PYW1vll4iPmw6u3iN0J9Eau2qvxey+HVVtV4iPmw6u3iIH7rW7eFqq2qcRE30YlBPMR8WPVWXyerrarRiJNYbrtwE8stCoN4iPlw/YiDaMRJXMRNpFt9N63v82irupgP67vpqknWd9OLRvz2Tt1TQFvVxU10YhAPMR9WW9XFQTQi3ZxuVbF1IVutUln3xKpVKqtHoFqlGidxEb8Rqqeh2p+y7mhV+1OjESdxETfxW19UQH0WXjzEfJg/4iAacRLLrbZyfW5edGIQy63OcX1ufhjV/pTfjaWo9qfGz+1rho9qf8pvUQPtTws/tolODOIh5sP6dntxEI04iXQbdKua//ZZVPtT4yHmw6r5i4NoxElcxE0sNy8M4iHmw6r5i4P4/duvjymqeeliVezFQTTiJH4z23VaqmKB9Vm46wzVZ+HFRax/uwqdGMTvDF3Mh1VvF78ztGsdqt4uTuJ3hnZtjWpjvOjEIB5iPqxr2ouDaMRJpFvQra5eMZ2qzV27pGrzuwEU1U7UuIib+I3gtdRVb17rW/V2cRIXcROd+K2v18yq3i5mY72OrXEQjTiJi1jzzUInBvEQy+07hdV61FhuUVhu9W/r0/TiIm6iE4N4iPmw6u3iININrcujcBE3sRo3rTCIh1iNm9/JGmhdBg6iESdxETfRiUE8RLotulVtBvBbnaiZ1TVt1Mmqa9qL+bCuaS/WCLuwRvDCIB5iPqzvmxcH8Vvfr6kkqsmocRE30YlBPMR8WJ+bUXunPjcvGnESy63OcX3fBKLVr/5B1eapc1y1eXESF3ETnRjEQ8yH9bl5kW5Jt6Rb0i3plnRLuiXd8rlVk1HjIJbbr7DcZuEibqITg3iI+bDq+OIgGpFu9dy0PnzwirWLTvyek9WnKV6xdjEf1ivW6gMQr1i7aMRJXMRNdGIQDzEfTrpNutVV8demFNWQlKemXp+mpyZZn6bA+jS9OIg1QhZ+I2SdlqrNi/mwavPiIBrxW9/vhlVUk1HjJjoxiIeYD6uOL9Z8T6ERJ3ERy63OcdXxxXKrNas6vpgPq44vDqIRJ3ERN9GJdKtnrJWI9Sq0i1XzF6ulqeqinrFenMRqvqszVO29F50YxEPMh/VaxYuDaMRJpFvSrar7u2MY1ZCU3w3BqIak/O4CRjUkNS7iJv6N8Pex/h1RdRn9sRWb8BRewlvYhaN4FR/hJH9V+ngIm/AUXsLw/RW7cAgfYfh+5726mB7Dt5ZvLuEtjPFrXWcIY/xaw5nk9ROu8UfNYZnwFF7CW9iFQ/gIJ3n/hMV3i+8W3y2+W3y3+G7x3eK7xdfF18XXxdfF18XX4Vt7z104hI9wkuMn/FWM1SmNze0cLhzCsuUDQ9a2PbLlj2z5I1v+YMqz2IVDGFOurXqSP5s/YSm1FN8U3xTflFJLKbUM4SNM3+qMeozl38Vb2IVxLFF8hJM8fsI47afYhKfwEoZvFtf4362kWIgHMOLhco3/3TSLhXi4PIWX8BZ24RCGb60J4gGMeLg8hE14Ci/hLYwxvz2wUPq1PxdK//IS3sIuHMKYc605Sh+M0r88hE14Ci/hLQzfOkco/ctHOMko/ctD2HjuUPqXl/AWxn774nahrLFuMYRNeApjzNpLIWuFGr+c5FPjz/I9Q9iEa/xZ++TIOTpyjo6coyO+R3yP+KL2Lw9h2RspeyPFN8UL1/Df4W5cwwMH0Yg4Div2vhistqvGQ6zJfncMY6O4Lw9hLNIqnu9H66v3xU2k46DjoON4F7DVetU4iEakm9ECRfz1tsVGEYNRxJcx/yg24Sm8hOskf48cYuOz/3IIH2H41oKj0FfNDYV+eQnX+HWfcqPQL4fwEU4yCv3yEIZvnWgU+uUlvIVdOISPcJJRxKvOOz6n61vORuFePsJJRkFfHsKYc605CvryEt7CLhzCRzjJKPRV5wiFftmEp/AS3sLOc4dCv3yEk4zi/u5vx0YRY93wAX7ZhUMYY357yX9cq+rWejyFa/y6z+r4ML/swjV+3XX135Gf5Tny8RMW3yG+Q3zxYX55C7twCIuviZe9G0n1VrHGTXQijuPbj9W1hdtH1bXVaMSabN1idRT35S2MRVrFwR89xHfvqrq8Gum46Ii7asBF3EQn0m3RAkVc94IdRXx5CWP+UezCIXyE6yTXjWLHp/XlIWzC8K0NiEKv78KOQr98hGv8+jrsKPTLQ9iEp/AS3sLwrRONQr98hJOMQr88hE14CmPMOu/4VPZaWxTuZROewkt4C2POteYo6MtHOB9XM9fjIWzCUxi+p3gLu3AIH+Eko9Dr3AUK/bIJT2HsNy8+b90CV+pgFPTlIYwxs5hrFbgivxzCNX7dmA58mIPxYX65xv86HSMmz1HMKbyExXeK7xRffJhfTvL6CQ9h8V3iVVWNZVuHmA/rLt1FHIcVv4cy1cjV6MSabN16DxT35SSjuOtuNpq58KNuxEmko9PR6Vg35S4eYj6sm3IX6Ra0QBFXcgeK+PIRxvxrg6OILw9hE66TXHf3A5/Wl7ewC8O3NiAKvW5tBwr9sgnX+HUnPFDol7ewC4fwEc7HB4X+NWjGQaFfNuEpvIS3sAsHGUVcN5oPPpW/lss4KNzLLhzCRzjJKOi6C31Q0JdNeAov4S3swiEM31OcZBT65SFswlN4vXN3UOiXXTiEsd++MDsoYqwbrtQvL+EtjDGzWNYKV+SXh3CNX99SDj7MLy/hGj9rn2w5R1vO0ZZztMXXxdfFFx/ml6ew7A2XveHi6+KFVpNZaMRJXEQcR+3Hep5dXxDRBwZ8HShxUNx17/+guC9PYSwS/v3mjzoxiHQ8dEw65iAacRIXkW75LBJFXI8NEkV82YQx/yhewlvYhesk1+36xKf15STj0/oyfLP4G3/Ure16TddjF47iUXyEk1yF3jyETXgKw9eKt7ALh/ARTvL8CQ9hjFlrPvGztbYzyesnPIRNeApjzrXmawu7cAgf4STvn/AQhm+doz2Fl/AWduEQPjx3O8n+Ex7C2G9e7Fw3D+EjnOTAmLWXQtYqlvAWrvHrln31lT0+wjV+3Y6vhrP+2SPn6Mg5OuJ7xPeI73HhEJa9cWRvpPimeFVV121f9JZdDOIh4jj+9uNBG5kBJ3ERa7LfTf9TfWSPQxiLtIrz/ej4EQeRjoOOg451f+2iE4N4iHQzWqCIvxv954civuzCmH8UH+Eko4gv10n+bu6femHW4ym8hOGbxTX+dyP4/FDoYBT65Rr/O0Hnh0K/PIWX8BZ24RCGb60JCh2MQr88hE14Ci/hLYwx67w7frbW1qfwEt7CLhzCmHOtOQoajIK+PIRNeAov4S0M3zpHKPTLRzjJKPTLQ9h47lDol5fwFsZ+849RxFi3HMImPIUxZu2llLXKI5yPq4PtrzR/xUPYhGv87wHAqS6297Nb2IVD+AiL7/gJD2ETnsLiO8QLH+DfTf0z8AH+XYWdgQ/wyyY8hZfwFnbhamYvq2oUvZgP6+bbxUE04iQuYo1by4uS/66tzkDJg1Hyl4cwDqeGQclfXsJb2IVD+AjXAdUZru/lFwfRiJO4iJvoxHhYfTI4YpejQRhcnsJLWI7G5WhcjsblaBAGYITB5SHMAwoeUPCAggcUPKDgAcUhcvkOl68a4nDER44GpX7ZhUNYjubI0aQcTcrRpOyJlD2RsieSB5Q8oOQBJQ8o3wGhN+7iIBpxEr2P2H48GvsdYe5wGz9hHo0NE57CS3gLu3AIvwOywQMyHpDxgIwHZDwgW8RNdGLe3zg9hl/FBA6iEXEoXuz390xPdcQ1HiLW6fsgspsE4CGMdTrF8/1o/eblxU2k46LjomP95iWwfvPy4iAakW6bFrhq/x7+HcMHPhhX7Zdr/qsWD7V/eQov4TrPqxYQtX85hI9w+a6aDz7wV+0vfOBfXsIYv/YLPvAvh/ARTjI+8C8PYfjWicYH/uUlvIVdOISPcJJR4avOe+Jna23xgX/5COfjiQ/8y0O45vw9GDsTH/iXl/AWduEQPsJJRq1/D6wOGuuaTXgKL+Et7O/cobGu+QgnGRcC38PIg6Y5rBua5ppdOIRxLN9eQnPcXStc1F+ewphz+eKi/rILY6128ZGflXO05Bwt8V3iu8QXn/yXt7ALh7D4bvHC2xLq0PG2BOAmOhHH8e1HvALMa4h6McJFI+LERvES3sJYpBq8Xo5wf/QQ82HQMegYdKyXI1xcxE10It2CFijiDZ7CS7jm77XBUcSXQ/gI10n22sj4KL88hE24fL02IArdaxOh0C8fYYz/ba6FQr88hE14Ci/hLQxfLw7hI5xkFPrlIWzCUxhjfucdbW6j1h9tbs0mPIWX8BauOX8Pxg7a3JqPcJLx7f3yEDbhKVy+3wOrgza3ZhcO4SOcZBR6nbuFQr9swlMYx/grPlw3fGMHo6AvD2EcyyyWtcItuMshjDmXLz7Mwfgwv4y1qn3ico5czpHLOXLxdfF18cWH+eUkh+yNkL0R4hvihZcU1TTxkiJgPsRLioA4jtqPeB9RHRLeRwR0Ik5sFB/hJKO4oxa+3i2GH613i12cRDomHZOO9TaUi4eYjXgP2cVBnERszCwO4SNc8/8e1B20vDUPYROuk1yXthuf1pe3sAuXb10pbhT69zDpbBT6ZRPG+DV/FPrlLezCIXyEk4xC/3795KAVrtmEp/AS3sIuHGQU8fdA7qDNbZxaWxTuZRcO4SOcZBR01pqjoC+b8BRewlvYhUO4fLPOEQodjEK/PIRNeAovnjsU+mUXDmEc4xdmaH+764Yr9ctLeAvjWGovhawVrsgvD2HMuXzxYX55CWOtap8cOUdHztGRc3TEN8U3xRcf5pensOyNlL2R4pv0wrvK6iIW7yq7OImLiOPw4i8u6ouU40WChXiRIBAnNopNeApjkU7x5o86MYh0HHQ0OuJlgkAjTuIi0s1ogSLOWhgU8WUT/uZvP/z7JbyFXTiKrfgIJ7k+rZtH8SzG+Kt4C7swxt/FRzjJ+yc8hE14CsO3TvTewi4cwkc4yf4THsIYs86742drbT3J8RMewiY8hWvOde8EbW7NLhzCRzjJVejNQ7h864EV2tyal/AWduEQPjx3J8n5Ex7COMYqwHSuW4bwEc7HaH+zej6GNjesFdrcmrcw5ryKQ/gIY62+fYI2t/uzYwibsPgO8R3iO1w4hI8w9wZa4ZrFC6/v9UInBvEQcRzF762+J95bfU+8t/oe9LfZALtwCGORauHxZt/6f+PNvsBBpOOi46Ij3uwLdGIQD5FumxYo4nr4Fyjiyy5c868HdWh5a04yivhyneR68FY9b4+n8BIuX6sNiEKvh0mBQgej0C9j/NpcKPTLU3gJb2EXDmH41olGoYNR6JeHsAlP4SW8hTFmnffEz9baonAvL+Et7MIhXHOuB2NocwOjza15CJvwFF7CW7h86+EW2tyaj3CSUeiXh7C9c3dQ6JeX8BbGMX5hhvY3rBva35pNeArjWGYx1wptbs1Jnphz+c4hbMJYq1285Ge3sAuL7xTfKb74ML88hE14CovvEq+q6src6n5rHEQj4ji8+IuLyueDV+wDDxEn9gsJ9Lc1D2EsUi18vXwUP4qX7wM3kY5OR6fjeyX/Oe+V/Oe8V/Kf817Jf07QLWiBIq4b/QdFDEYRX67515UcWt6ap/ASrpNcN/cPPq0vh/ARLt96AHBQ6HUj+KDQLy9hjF/zR6FfDuEjnI/RCtc8hOHrxVN4CW9hFw7hI5xkFHHdpEabm9UNXLS5NR/hJKOgLw/hmnPdrEebW/MS3sIuHMJHOMko9LqJjza3ZhOewkt4C/s7d4lCv3yEk4zirq9GaH+764Yr9csuHMI4lm8voc3trhWuyC9PYcy5fPFhftmFsVa1T7acoy3nyOUcufi6+Lr44sP88haWveGyN1x8Q7zwAV439dH+ZnVvHu1vzS4cwkc4yaj9y1+W1EVvdb81TuIibqITg3ge4kq87smj1a15Ci/hLezCIXyEszl/qPnLQ9iEp/AS3sIuHMJHWHyH+OLv3+xCI07iIpbnd8848YclvzsDiT8sCaw/WXWxDuh7WJE/BMLlKVwH9D2gSPxxyfujTgwiHY2Ok471J64uGnESF5Fukxb4JP8ekiRa45pNGPOvBUEIXN7CLlwnxDH+EU4yvq5fhm8UY/xTvIVdGOPXyUQIXE4yQuDyEDbhKVy+UScaIXDZhUP4CCcZgXB5CGPMOu8o9qi1RbGDUeyXh7AJT2HMudYcH/SXXTiEj3CS8bX88hCGb50jhMHlJbyFXTiED88dwqAY7XPNQxjnZRX7Wze0xjUf4SSj0L/nCIkWOKwVWuCatzDGL19cAFw+whj/2ydok7s/a0PYhMXXxNfEFxcAl0P4CHNvjCm+U7zwh+uATgziIdZ43z3jxN+aPLXE+Bt1wEWsyX4PKxJNcM0hXJM9tfD4O3X1o/g7dcBBpOOm46Yj/k4d0IlBPES6OS1QxDhYFPFlF8b8d/ERTjKK+HKd5O8BRQ58Xb88hZcwfGsDotBPbSIUOhiFfhnj1+ZCoV+ewkt4C7twCJdv1olGoYNR6JeHsAlP4SW8hTHmd94Nn9zfw4Q0FO7lJbyFXTiEMeddnGQU9OUhbMJTeAlvYfh6cQgf4SSj0C8PYXvnzlDol5fwFsZ5+fanoYixbriKv2zCUxjHEsWyVrhav5xkfJhn+eLD/LIJY/wslnO05BwtOUdLfJf4LvHFh/nlISx7Y8ve2OK7xas+wOd3HzjR9ja/5wuJtrdmE57CS3gLu3Dcv6Ka1fXWmA/rr8leHEQjTuIifuPWRWJ1uzXmw/orlBdxLHV+v7quv4yc+DOUF50Y9Y9rcaqom5OcWKjaYPXnnvGj9cdjL04iHZOOScf6s5UXDzEb8WcrLw7iJGLBd3EIH2HM/1s89LY1D2ETxok+xUt4C7swfL9NjpfDza+vNtHP1mzCNf6o+VchN29hFw7hI5zkCV8rHsImPIWX8BZ24SAvjLmK8bO1tmsLu3AIH+Ekb8y51nwPYROewkt4C7twCMO3zhGKHYxivzyETXgKL547FPtlFw5h7LcvwKvPrdctpvAS3sIYs/ZSyFqdn/AQrvGtfOtDvHkJ1/hW++TIOTpyjo6coyO+Kb4pvmnCU1j2RsreSPFNeuFvX37P0xJ/+/IijsSKl/AWduEQPsJJRuV/d80TzW7NJgzfmhkq//IWhm/NE5V/+Qjndyg1ZL3T9eIgGnESF3ETnRjE87De3lrRVV1wjTgWL17CW9iFQ/gIJ3lhDU/xEDZh+GbxEt7C8K15IikuH+FvDStgq0+ucRCNOImLuIlODOJ5iBz4fokq0R7XPIXraL7nPYn2uGYXrqOZtePqgr+5VnHW7qgL/uYhDN86p8iKy0t4C7twCB9h+NbORYZcHsImPIWX8J/vqu8c1Ui36itZ9dGt+vZRbXSNg2jESVzETfw7nFXfgauLrvEQs7G66FZ9FawuukYjTuIibqITg3geIiO+J0CJXrrmKYwViuIt7MI4MzVtZMRlnJmvHtBj1zyEy/e7IZ7osWtewlvYhUP4CJfv98Am0WPXPIRNeAov4W8t6wOy3iq3KrnrpXKrPnbqL3c2DqIRJ3ERN/E7R/W5Vd13jYeYD7+MWJWH1XnXaMRJXMRNdGIQz0OXHeGyI1x2hMuOcNkRLjvCZUe47AiXHRGyI0J2RMiOCNkRITsiZEeE7IiQHRGyI0J2xJEdcWRHHNkRR3bEkR1xuCMOd8ThjkjuiOSOSO6I5I5I7ojkjkjuiOSOSO6IfDui/n4ozlz15DUacRIXcROdGMS3I9CSN7+HmYmWvOYpvIRxZmaxC4fwEf6Opi4qqy2vcRCNOImLuIlOjIc3Arx4CJvwFF7CW7gOZ2PMED7CScalxK4zhUuJyyZcvruWDpcSl7cwfOt04FLie16X6Nybu+aGLx1gfOm4PIRNeArjZ7/CRfddM372FJswfjaL/+aMGqsGvUYnBvEQ8yHK3cF11PW1t3rw7h6JIB5ijVEr9JV04yAacRIXEXZgF65Frmc1aL1rTjK+HdQ99XrbHAIC3XZ3bTKEj3A+RrfdrMc8eNlcswlP+fdLeAu7MH3RYTfrURA67JqncI35/S5JosOu2YVD+AgnGR/x9agDL5trNuEpDF8v3sIuDN9TXL4HXklGfV8ewiY8hZfwFnbh8q3LJDTpNcP32wJ4CV3zEDZh+NaxoL4vb2EXDuEjnGTU92X41nlEfV/G+a11w02FA97CLhzCh4w8qLvgaORrNuHyqjvZaORr3sLlVXdhAxcHl8ur7laiwe8yLg4ul+/XFp9o8Guewkt4C7twCMO39iEuDsC4OLg8hE14CsO39syNjTreGxv4N0lOqfeUek+pd9xsuLyE98vguDkDDuEjDN9vbufmDHgIm/AUXsJb2IWDjFsPdUcfzX7NJjyFlzDOVxa7cAgf4SQjcy5/vqtu4qIhsHkKL+FdvIpdOIRP8S5OcmVOM3yjGL6nGL41t7mEt7ALh/Ah11eLWuX6ZgGaj9aj/cibqsZxHYR31zUf4e+DtJy+ar80Htmj+Wg9wpjlVTW76mZq9emt+hdfxV6aj+r7atF+5I/i0XmUTQcudQarQptr5euiFd17zUsYs62zlhindmAO4W++dS4To4CX8BZ24RA+vULZq1v9eZfGI3s0H/lbU/TZYU3xyjl8+8Ar55px5PWzYwrXnOtbRb2KbuNf+6N4dB5lU93VA9WY9Y0DfXarbjdWn53jX5xH2VR/Qy2KxiN7NB+tR/sRXGZxCNeurRuZ6Kq7XJ/EzZjtLsY4XhzC33xByTXaP+EhbMIYvWa5l/AWdp6DW3PgIyy+Lr4uvi6+Lr4uvi6+Lr4uvi6+Lr4hviG+Ib4xhdetDHTgYaejA685hI9wkg9mULNBDV4ewl8N1hmvr8ug9Wg/8kfx6DxK0PeXhn7EQTTiJC7iJjqxjvK7GfqJoyJFoFwnfgb12qIW+Lub8ompYqnYKlxFqDgqUoT9VAwVOgPTGZjOwHQGKP3v/s4nQsVRkSLwMdliqMAMDsRUsVR8ZwD+Xyg0BvEQ82HdmLuIsROijuH74vmJOoaFs1UX20+kCMRCizqGuxEQDC2miqViq/iOYgHhf8VRkSIQD/dokA8tTAX8sWyIiBbwxwogJFqEiu9D4Frmwy8kGgfRiJNYY2+sLmp+Y9nwof3dzvjEUGEqpoo6hjt0fVV/wlWEiqPiOwrstvpjbhcH8TsKrF79MbeLi7iJTgwi/DZEUqAX74mpArN3iFDxnYH7j/LhlyONWLkDYSqmilo5/0FsFeXtAyJU1JG4QdSReO1YdOgtXxA1A8d0kCItpgr44LCQCF5rjr675ZgoEsETokYLTBSJEJgbLgcCM8D1QIsjor6Dr8AM6sv2Csygvm2vwPEgA1pgNMwNGRCYGzLgCmRAi6ECs8YhIANaLBVbhasIFUdFikCtH6wOKvpgdfCRfnDm8Jl+cHD4UG9hKqYKV4HRsKIo2xYYDcuL4jxYXnykHywiPtNbDBWYAdYNF9ctlootPri+7v8lVBwVSWEoPaxOvSWOwlRMFbIGaKO7h40+uidkddAxd/cbWubWSYg6nvxBbBWuIlQcFSkCBdiijicxaxRgi6kCMzAIzAAHh9JMHAI+xhOHgI9xlIyhaK9A0baAzxVLxVaB46lTj+a5lTg/1SqLo6lW2YsYCQtYBbt/939xFaHiqMgSOP4q2CeGClMxVSwVW4WrgA+W1jEaltbxz7C0jn+GpY2fiqHCVFTXF3ARN9GJQTzEfIgeOeAgGpFuh26Hboduh26HboduSbekW9It6ZZ0S7rlc0NP3AIOohEncRE30YlBPMR8OOg26DboNug26DboNug26DboNuhmdDO6Gd2MbobNHhBHRYqo8tzDILC7DkTtrjEhaksPDL3wM1jvVb/2AjTiJC7iJjoxiIeYD1F2AxNGcQ3MsX739GIQDzEf1rvdLg6iESdxEeGHmaBKW4QIVKn9ICoabEBUNBhWuL79PuEqQsVRkSLOT8VQYSqmCp3B0RkcncHBDHDCz1GRIvKnYqgwFVPFUrFVuAqdQeoMUmaAF8I9MVSYCsxgQywVW4WrCBVHxICPQ2C0gNjfS1SBTgzi3zj4CK7Wt4v19taLg2jEScQcE6LWYuJ/Qf22GCpqLXBDAe1uTywVW4WrCBVHRYpAGrQYKnQGS2ewMAOcJ3xgt3AVmAFOAD6wW2AGOBv4wMbNAbwpbuM7O14V98RUUTPAN3O8Re6JmsEyiJoBvn/fv5eK1cUfbQHjj7ZcHsImPIXhsCDqSBYOCymycCT4rG9hKupI8BUd/W9PbBWuIkQgRfDlHU1tG1+90dW28dUbfxj1CVcRKo6KFIGsaDFUmArMAEuOrGixVWAGOBnIihZHRVJsZAW+1W9kRQtTUafn8hLewp/97w4bwkc4yfevrYKHMIw3xFSxVGwVR4ThMBzCVGC0gFgqtoo6ksshfISTfP9UG3gIm/AUXsJbWHyn+E7xneK7xHeJ7xLfJb5LfJf4LvFd4rvEF4mCuyB4U90TQ0UtN26J4GV1TywVtdy4JYL31T1R+xb3OvDGuidSRGXKE0MFZoAT7lMFZoDjwXULbpagv27jZgka7J44KmoG+FKFHrsnhopvBuPyFF7CW9iFg4wUwo0atM3twCIhhXCfBa+ze8JVhIo6EnylxivtWiCFWgwVpqIOBbNBCOHeDt5rt3ExihfbPVETwH0Ax6/QGhi9KmA8SQKH8BGu+eLmAP5s6xNDhamYKpaKrcJVhIqjQmdgOgPTGZjOAHGD2y2OuGmxVbiKUHFEoBcHa4ZenMsmjGeU4CW8hWHnEKHiqEgRuIhpMVTggA/EVIEDxsRwEdPCVeBxB/gIJxn3CC8PYROewkt4C7uw+G7x3eLr4uvi6+Lr4uvi6+Lr4uvii3TBnS28ba8F0qVFLTiuddHU98RUsVTUguMKGy/d27hlhbfu4ckG3rrXnGRED25r4bV7T5iKqWKp2CpcRag4KlJE6gxSZ5A6A9zrRIHgVuflLezCIXyE83Hc5wtg3OMEm/AUxoEviK3CVYQKHPg1SRFItxZTBUYLCIyGGSCpWqQIJFWLbzTHVTZaAR033tAL+MRRkSIqgp4YKqzEhJgqloqtwlWEiqMiRSCIcCsTnYFPmIqpAjPAwq+tAjPA8q5QcVTUDHCgFUXNQ9iEp/AShkOVGNr/HFdX6P9z3FlCA+ATU8VSUUeCawU0AT4RKo6KFBE4FCxsDBWmYqpYKrYKzADHE6HiqEgRBzPA8ZyhwlTUDHDzCG2BjptHePHfEzUDXGGgY/CJmgHue6BnsEXFzBNDhamYKpaKrcJVhAqdQcoM0D74xFBhKqaKpWKrcBWh4qjQGQydwdAZDJ3B0BkMncHQGQydwdAZDJ3B0BmYzsB0BqYzMJ2B6QxMZ2A6A9MZmM7AdAZINlsQQ4WpmCq+GeCRDBoPm104hI9wkivTmoewCeMANwQO4/4vKQLphBtv+MO8T5iKqWKp2CpcBXyqIvE+wl4710VBRLXYKlwFTktCHBUpAhHVQjdG6AxCN0boxgjdGKEbI3RjIKLu3BBRVxzdGEc3BiLqzu1G1BVLhc7g6AyOzkAj6mhEHY2ooxF1Urdm6llIPQupZ+FGFOaWehZSz4JGVGpEpUZUakSlRlRqRKVGVGpE5Y2oBXFUyFnI8VMxVNQMcE8XLZpP1AxwRxV/L/gJVxEqagbzDp0iEFEthgpTMVUsFVsFZrAhQoWUGV6l6LiNi3cpPmEqpgrZfHif4hOuIlQcFVKAaP98Qk/90lO/9NQvPfVLT/3SU79CxVGhmw/Bhe+36BF9YqnA8mLdEFy4lY0+0SeOihSB67EWQ4WpmCqWivJBAxwaQ59IEYi0FuWDL+ZoDn1iqlgqcAWLw0aktQgVR0WKOD8VQ4WpgA8miuBqESqOChxpXXXhBY33CwLe0PjEUlE++EaMlzQ+ESqwoqif5LeSgRc1PjFUmIqpYqnYKlxFqDgqdAZDTXGrqb6zDTSaPuEqcHAOcVRgEU8J5E6LoQLbJSGmiqWiDm5jbsidFqHiqKgZ1GOFgUbTJ4YKU1EzqMcK44eoqYcH44eoaXFUwAcLgqhpMVSYiqliqdgqMAOsKKKmxVGRInD11GKoMBVTBYbGKUGGbCw8MqSFqZgqloqtog7BcUqQLi2OihSBdGkxVJiKqaJm4DiNSJcWriJUHBUpAulyTzDSpYWpmCpw2D+IIyuKQLkCV0IthgocHDZf6iIiUFqEChwCZoBAgUCD6RNYxA0hpxGtp08sFVuFqwgVR0WKGD8VQ4XOYKjpfZk7+AgnGW+Kc/AQNmHsjSuWiq3CVYSKowILGyUQJS2GipoADuS+Vg68hLewC4fwEU7yfd0ceAiL7xLfJb5LfJf4LvFd4rvEd4vvFt8tvlt8cU1Tj6UGOlufcBV4soO1w1OyFniyg8XHU7IWQwVu2w+IqaJmUI+yBrphn6gZxP1noeKoqN8hxH7D75peHsImPIWXMBwgkCr1KGugXdYD9YlUaTFVLBU4Ehw9rmZahIqjIkUgfA6WAuHTwlRMFUvFVlEzOJgbYqnFUZEUaL71eho00Hz7hKnADAKiZlDPBAbebflEzaAeEAy05T5RM6inBQNtuS0QSy2GClMxVSwVW4WrCBU6g6EzMJ2B6QxMZ2A6A9MZmM7AdAamMzCdgekMps5g6gymzmDqDKbOYOoMps5g6gymzmDqDJbOYOkMls5g6QyWzmDpDHChVI9TBlqAnzgqUgQulHAhixbgJ0zFVLFUbBWuIlQcEbieqvthA6/Q9MQmR0q1wGgHIlQcFSkCV00thgpTAZ+E0PMTujrIqhZDhan4Vid+qMbKqie2ClehO+ToDI7ukNQdkrpDUndI6g5J3SHIqjvR1B2SukNSd0jKGuCvTwe+EeHPTz9hJQxiqlgqtgqswYYIFUdFihg/FUOFqZgqMAOH2CqCpx5/gjrqa/LA36BuYT8VQ4XxNOIdnk8sFVuFqwgVR4Wc+qnxNDWepsbT1HiaGk9T42lqPE2NJzQ5Rz2KGni/5xOmAkeKdasQioFZVwg94SpCxVGRIiqEnhgqTAV8sPm2qwgVRwV8cKT+UzFUmApcemD734uoK7YKVxEqjooUET8VQ0W1FGHSaCm67MLVUoQNjj9wfznJB8eIQc9QYSqmiqViqyh3LAv+qOblI4wlrisb9Ew/MVRULxX20v27muAlvIVdOISPcD6+fzz78hA24Sm8hLewC4fwERbfIb5DfIf4IppwhtBS/cRWgT0dEKECe/qOliKQUy3qe8kAm/AUXsJb2IXhULWO9uqoZ7YD7dVx/1mlzRNbhauoI6mbwAPt1U+kCORQi6ECM1gQU8VS8c2g7p2P+2bRyyH82U8s930dWPF9HRh4CJvwFF7CW9iFQ1h8t/gikuwKHDTOJSKpxVSxVGwVriJUHBUpIn4qdAahMwidQegMQmcQOoPQGYTOIDADbDBEVouhwlRMFUsFZoAzjKusFqGiZjCxkZFaVyC1WkwV+EVAcAgf4XyMLuzmIWzCU7iOo55ZDfRgRz1YGmjCfiJUHBUpAldKLYYKUzFVLBU6g6EzGDqDoTNAHGE/4w2mTwwVpmKqWCowA4NwFaGi6gkTuG8yLb6vMQQPYROewvA+EFuFq4A3zhkirEWKQIS1GCpMBY7eIZaKraJmUM+XBrq5nzgqagYLWwgXTPd/wduOgUHED2O5cX10BcKoxVBhKqaKmv7dzQijFq4iVNQM7nQQRlcgjFrUDPAgA63YT0wVNQM8u0A39hOuIlRgBhMCM8DxIHLwSACt2k8sFVsFfAICPtg3iBzH8SBycKserdpPDBWmomaAG/Lo1X5iq3AVNQPc9K4Xof6JmigatwM3ah3f5aohfji+y+EWHXq6n1gqtgpXESqOipoBLnPR8f2EbFY0eT+xVGwVriJUwHRDpAiEUos6bNwKRJP3E1PFUrFVuIpQcVSkiPlToTOYOgNcXQVOCaKpxVbhKkLFUVEzOFhrRFOLocJU1AxwmxJ9309sFTWDg1kjmnCbEo3fT2AGVQto/X4CM8BEEVotpoqlYqtwFaHiqEgRyLcWOgPXGbjOwHUGrjNwnYHrDFxn4DqD0BmEziB0BqEzCJ1B6AxCZxA6g9AZhM7g6AyOzuDoDI7O4OgMjs7g6AyOzuDoDI7OIHUGqTNInUHqDFJnkDqD1Bkg+XBbHE3hTyQF2sKfQAyCTXgKL+Et7MIhfISTjMDDzfm4sXZFjYQ7MugIf+KoSBGItRZDhakoH9zNQ0f4XS50hPc6TF0URFQLU1HLUr3vAx3hT2wVrkI2BjrCn5CNEeunYqgwFVPFkrkholq4ilBxZG6IqCsQUS10BhpRoREVGlGhERUaUaERhZfH9nS2ngXXs+B6FhBRd26uZ8H1LGhEhUZUaESFRlRoRIVGVGhEoZe8p4OIaqFnIfQshO4DRFQLPQsaUaERFRpRoREVGlGhERUaUaERhV7yntvRs3D0LKSehdSzgIjCcwz0kj+BNUChI6JauIpQgRlgbjeiSpwbUVcMFaZiqlgqtopvBgc3mdFL/gRuPxfjCyOCAg3jB3f60TD+xFKxVcjJPiNUHBVScsd+KoYKUyEnGw3jT2wVriJUHBWy3dAw/sRQgSM1iK3CVWBBsW4Vb+eHWVe8tah4e2KoMBVTxVKxVbgKuZmBzvEnhgpTMVUsFfBxCFcRKnCkAZEi/KcCR3ogTMVUsVRsFa4iVBwVKSJ+KnQGoTMInUHoDEJnEDqD0BmEziB0BkdncHQGBzPAFqsQO7i/j27zJ7YKVxEqjooUUSH2xFBhKnQG97eBwVvYhfGLpuAjnI/RZ45vx2gzbzbhKbyEt7ALh/ARTvIQ3yG+yCw8sECf+MFjCfSJH9yAR594C/upGCowWkBgNBy3HRUpYv5UDBWmos4GbrajAfyJrcJVhIqjIkUgf1pgBlgd5E+LqWKpwAwGhKuoU3P5CCcZbxq4PITLHF1t6OM+uO2PPu4nhgr0cYOn8BLewi4cwkc4yXhMd3kIi2+Ib4hviG+Ib4hviG+I7xHfI75HfI/4HvE94nvE94gvwgJPG9Dh3QJh0WKoMBVTBbYnNm5uFbU58HGC3u8njop8wtD7/cRQYSqmiqViq3AVmMGAOCrQlVWMlqjLQ9iE4WEQGGlC1LFkMZLj8hCuXwPDnOqCpnkJlwPc6mqmOYSPcJKRMZeHsAlP4SUsvlN8ESF1t9zQvn3q9rShffvUL20Y2ref2CpcBUbDcqDyF467LkeeWCq2ClcRKmpRFk4NcuQK5EiLocJUTBVLxVaB48Hq4HKkxVGRInA5srBTcDnSAjPYEFPFUrFVuIpQcVSkCFyOtBgqdAZfuNhAbXzh8ngL+8dYjC9cHh/h/Bgn5ouWx0PYhKfwEt7CLhzCR5i+1fv9GCvrEFi/A4H1S4ijIkWMn4oarT6/DG8LPvVcwdC5/cRRkSIQEC2Gijob1Uxv6N9+YqnYKlxFqDgqUgSiYmN1kBUtTMVUgRlsiK2iTg1WFxlR14qGRuwnlgr8PE4CMqLFd27rg96qGftxkr+LicfwwKlBPjgmvGskjLqPcJK9RsIPf9nw2IS/3WmY9xcMj7ewC4fwEU5y/ISHsAmLb4gvat6x/1DZjrVAZTvOMSq7xVSxVGA0nD1cBzh8cB3QwlRMFUvFVoGzgVXEdUCLoyIp0Bv9xFBhKqYKzGBDbBWuIlTUDOrWh6E3ugVqvZ5eGXqjnzAVU8VSsVW4ilBxVKQI0xl8+WD4zK3W6MdT+Nsd+IytvujHLvztyomD/4LhcZK/WHg8hE14Ci/hLezC4jvFF19B6lGgoav5xP1fsH44NGRDi1BxRGyMdiAwGjYHrh9auIpQcVSkCFw/1C9VGHqXnzAVU8VSsVW4ilCBGeBs4frhClw/tBgqMAPsFFw/tMAMFgSuErFUSIwWQ4WpmCqWiq3CVYSKo0JnUJcEC1OrS4JmE/62GS5LqqP58Rb+thmupKqd+fERzsfVy/x4CJvwFF7CW9iF6YtO5VMPPw39yAeX/uhHPrjGRz/yE64iRNyvEQZRoyV8cC3QYqtwFaHiqMC3lVpFNBo/MVSYiqliqdgqXAVmMCCOihSBWxMtMAOHMBWYwYFYKrYKV/HNIH9Y0UqMJ1JE3Z14YqgwFVPFUrFVuAqdQV2G4NOxepOb6zKk+duZ+MJZjcmPp/C3M/GZXV3Jj104hI9wkusypHkIm/AUFt8Q38DK4gwerB+22sH6LYipYqnYKjAahk6MhrVJUzFVLBVbhavA2UBV5lGRFOgmfmKoMBVTxVKBGWwIVxEqjoqaAb6yoK/4ifLBlys0A2fdvzQ0A7ewn4qhwlRMFUvFVuEqQoXOoK4fqpXK6iXNj4fwt53w1aNaiB8v4W874WtQ9Q8/DuEjnOT1Ex7CJjyFl7D4LvFFPgycGqRA3fI1NAJn3bE1dAI/sVW4ihrNcDrruiHr5qmht/eJpWKrcBWhos4Gvg2ht7dFXTc8MVSYiqliqdgqcDzY3xEqjooUcTADnGHkQgvMwCGmiqViq8AaYEVPqDgqUkT+VAwVpmKqWCq2Cp1BXXLgmrUagh/n42oINlyjVkPwYxP+dmb9dqtVQ/DjLezCIXyEkzx+wkPYhMV3iO/AytYZREdv4n4pOnoT9z/R0fvEVLFU1Gi4g4j+3MQ3ADToPmEqpoqlYquos4HvN+jRfeKoSBF4R1eLocJUTBWYwYTYKlxFqMAMDkSKQJbgtiXerPzEUrFVuIpQUT4L5wcpc0V9b0nctkQ77xOYASaK/GmBGeBkIX9aYAZYeORPC8wAexn5cwXyZ2ERkT8tMAMsCPKnBWaAzYf8aVEzwM0otPM+UTPADTm087ZA/iDRN/KnRc0An09o9H2iZoBPJTT6PoEZ4LCRPy0wAxw28ucK5A/ueqHR94m6xsIR1Led5iW8hV04hOGN5cNVDAT6fZ8ob9w1Qr/vE1PFUrFVuIpQcVSkCFzFtNAZDJ3BgI9BYLQJgdFq/dHI+8RQYSqmCj0e0+MxPR7T4zE9HtPjmXo8U49n6vFMXdGpM5g6g/seQRz2fWEgDnvp8Sw9HmRRi63CVejxLD2epcez9Xi2Hs/W49l6PFuPZ+vxbF3RrTPYOgNk0T1sJM49bNfjcT0eJE6Lo0J3SOjxhB5P6PGEHk/o8YQeT+jxhB5P6PGErujRGRydAXLlHjbS4x720eM5ejypOz51x6fukNQdgqsX3OZEs+wTdRGR4BA+wvk4bko4BEYKiG8k3FyqztfHR/gbqV5lYfUu5MdD+MvA6j23ekXy4yW8hV04hI9wku0nPITF18T3ZsKBqDOBu8Loj816M4qhP/YJUzFV1Gi4xYle18QlFnpdnxgqTMVUsVTU2cAFJHpdnwgVR0WKQOW3GCpMBWZgEEvFVuEqMAPsFFR+C8wAuwvXJy2GClMxVSwVW4WrCBVHhc6g7n7gtlO1uj424W934CZc9bk+3sLfrsRdu2pyfXyEk3x+wkPYhKfwEt7C4nvEF6lxrqj1w11hdKnm3ezIhhauIijQi5ooWHScJu7jouP0ia3CVYSKo6LOBloN8PbiJ4YKUzFVLBVbhavADBbEUZEicH3RAjNICFNRM8CtVDSjPlEzyDtAzQB3QqsZ1fp/OMJJrrsnzUPYhKfwEt7CLiy+U3yRRvWmFbvvLW4xVJiKqWKp2CpcRag4KjADnCCkUYuhwlRMFUtE3TT9VUeuVZspxVSxVGwVriJK4KTWvdMWgZ/BIoarCBX4GezyKv0WVftP/M164q5p9YU+nsLrY8zrK/7HLhwf/8BHOMlfKDwewiY8hZfwFnZh8U36Vs/n13cFgTVPiFq/cf+ZqwgVR0RdMPxw97NaOf/EhNgqXEWoOCpSRF0f/HCTr5o8KUzFVLFUbBWuIlRgBgMiRcyfiqECM3CIqQIzwIpW5f/s/oyrCBVHRYqom6dPDBWmYqpYKnQGq7bHAYfwEa5tienvn/AQrm2JHbSn8BLewi4cwkc4yf4THsLi6+KLfDBsQsf6Va1Xt+jXuAcxVJiKqQKjYWjkA24qJvKhxVBhKqaKpaLOBlofqxOUIlQcFSmins4+MVSYCswAOzKXiq3CVWAG2Cl5npj3nb4GrsHqPtr8ITBauIpQcVSkiPFTMVSYiqlCZzB0BkNnMHQGQ2cwdAamMzCdgekMTGdgOgOEzMTqIGTqDuj8IWRaHBUpAiHTYqgwFVPFUrFV6AzwiBfzxBPey0nG890FHsImjNZi8BLewi4cwkc4yfsnPIRNWHy3+G6srJdwrN+BwPolhKmYKpaKGm1hryMwFnwQGC1MxVSxVGwVdTYWVhEXIS2OihSBkGkxVJiKqQIz+EFsFa4iVGAG2CkImSsQMnU3eKIt9AlTMVUsFVuFqwgVR0VSoD/0CZxTsAlPYdiDt7AL4yMXfISTjEC6PIRNeAov4S3swuI7xBdpU7fW50Cm1D3zOZApdZt8DmRKi1BxRCA5NpYD+bBx3MiHFq4iVBwVKQIXIXXPfA5chLQwFVPFUrFVuIpQgRlgdVaK2D8VQwVmgJ2ypwrMAMuLxGhxVJSPY+GRJS3Kx7G8yJIWU0X54OMRbadPuIpQcVSkCORPi6HCVEwVOoPQGYTOIHQGoTMIncHRGRydwdEZHJ3B0RkcncHRGRydAfLHsWGRP1cgf1oMFaZiqqjfTMOJQ67cUkCuQBhypcVQgZEXhFSM/VxFqMARbIgUgRhpgSNwCJMBkCQtlgqdwdAZDJ3BOCqkZg3XNS2GCp2BqSnCpe4iT7ShPpEicMFS7b0TnahPmIqponzqdu1EN+oTriJU1Azqdu00xE7dxJyG2GkxVcAH5xSx08JVhIqjIkUgdlpgBlgqxE6LqWKp2CpcRag4IpA0ge2CPAksPPKkRag4KlIE8qQFDgGnBHnSYqpYKrYKVxEqjoqawcFpRJ60GCpMxVSxVGw5wciTFqHiiLgRciCmrCguVFpsFa6ihq7u34ne1LuIaE59wlTgEAxiqdgqygeX32hRfQMcFXIa59AZDJ3B0BkgUFosFVuFq9AZDDVFUuDCeOIbUIulYqvAwS0IXNPhsOdPxVCBfbAhpoqlAovoEK4DhIqjQmewdAZLZ7BMxVSxVGwVOoOlpkiKg0VEUrSYKnBwCbFVuIpQUT71KGGiSbUFLl1aDBU1g8T5QaAkJopAaREq4IM9ikC5AoHSYqgwFVPFUoEZYIcgUFqEiqMiRSBQWgwVpgJDY7vg+iKx8AiHFkOFqZgqlgocAk4JYqNFqDgqkmIhUFoMFaYCv3r3g1gqtgpXESqOiuQJXgiUFkOFqcAePRDBFV249GiRInDp0QK/VTggZBEXYqOFq8AhYAZ2VKSIiV8inBByGtHS+sRUoTOYOoOpM0CgtDgqZCOhtfUJncFS08UbinPh0qPFUZEiNg5uQfCG4lx7qdgqsA82RKg4KrCIOD/+kwF8qDAVOgPXGbjO4N6IvSJUHBUpInQGoaaBTY4FCVcRKnBwKJlIEeenYqioX3AdKIz7m7VXLBVbRc1gYCvjt2gHdiJ+jbbFUAEf7FH8Jm2LpWKrcBWh4qjADGqHoJX1iaHCVEwVS8VW4SIGhnYIDBAQS8VW4SpCxVGBQ6hTUs2sFEOFqZgqloqtwlXgV6F/EEdFikCgtBgqTMXkCa4GWIqtwlVgj9a+rs7Wt6LLVEwVS0UNXc9xZvWvvkVcKQKx0QKHgBlsUzFVlE81ks/qbOUAehq3nsatM9g6A9cZ+FBhKnQjuW4k1xm4miIp7orGUGEqpgocHLZy8MHj3HFUpAjERj0Nmhux0cJUYBFxfs7SAbYKV6EzODqDozPAFUqLocJUTBU6g1RTJAU+WBxJ0WKowMElxFSxVGwVtUPqqdN0XHq0OCpSBAIFz5YcgYLHJ45AabFVwGdChIqjIkUgUFoMFaYCM1gQS8VW4SpCxVGRIhAoLTC0Q2AALDzCoUWKWD8VQ4WpwCHglCA2WmwVriJUHBUpAoHSomaA5weOQGkxVSwVW4WrCDnBCJQWKQKB0gJ79EBsWVF3FaHiqKih8WW1+k7fIsZUsVTgEDADXIe0CBXls7CrQk/j0dN49DQencHRGRydAa5DWrgK3UhHN9LRGaSa3kazDbFVuIpQgYOrrYz3sqJPbN5G1BZTBfbBhtgqXAUW8f7M0QFSxG1Bu0JnMHQGQ2cwloqtwlWECp2BqSmSAk+lAknRYqvAwSVEqDgqUgSSAvevA5ceLUzFVFEzwOOfQKDgoUggUFqkCAQK7nkHAqWFqZgqloqtwlVgBtghCJQWKQKB0mKoMBVTxVKBoXFKcIGBJz6BcGgxVSwVW4WrwCHglCA2WqSI+KkYKkzFVLFU1AzwmAkNqk+EiqMiRSBQWgw5wQiUFlPFUoE9eiBSVhTfZVoMFaaihsYjsEhdRHxjaXFU4BBqBgfXIS2GivLBc53zk9N4fkvFVuEqQsVRkSJwHdJiqDAVOoOhpkgKPB64zapXIDZaDBU4uAWxX9f4vC2pLUIF9sGGSBGIjRZYRIcwGWBOFUuFzmDqDKbOAL8M0yJFSLP8PNIsP8/SGSw1RVLgadJBUrRIEUgKPEA6SIoWpmKqqB2CB0gHlx4tXEWoqBngORN6VQeeIqBX9YmpAj44pwiUFq4iVBwVKQKB0gIzwFIhUFpMFUvFVuEqQsURgaTA446DCwzc9z8Ihxah4qhIEYiNFjgEnBLERoupYqnYKlxFqDgqagZ4TJQIlBZDhamYKpaKzROM9tcnQsURgQzBc6ZEUmBF0Qv7xFbhKmpoPGdCx+tdRHS8PmEqcAiYAa5DWmwV5YPnTOh4fQMcFXIa0fH6hM5g6gxwHdJiqdgqXIXOYKopLj3wzAitrANXnWhlfWKrcBWh4qhIEfcX6mB6f6HuClMxVSwVW4WrCBH45Rl8miUCBVeQiUBpMVUsFTjSO5qrCBVHRYpAoLQYKnCk2BT3V+2uWCq2ClcRKo6KFHF/1e6KKQty9EiROy1cRajQIz16pKlHmnqkyJ0WU8VSoUeaeqSpR5p6pMkjXXg56hNDhamYKvwtyEKvLI50oVf2iRSBqGnBI13olX1iqlgqtgpXESqOTHTokZoeqemRmh6p6ZHaUrFVuIqUBZl6pHOoMBVThR7p1COdeqRTj3QeFSli/VTokS490qVHuvRIlx7p0iNdoULXeulaI5Hq1tFCH+wTS8VWgSM9EHitwS6BRGoxVGBFE2KqWCpqReuB8sJrVt8AoeKo0BmEziB0BkikFlPFUrFV6AxCTfFlqB52LzTMPjFV1MEl1hoh1MJVhIraLom1RghdgRBqMVRgBpgbLnESGxaXOC1CBXyw+XCJA3Ffm9piqDAVU8VSgRkcCFcRKo6KFIEQajFUmIpvaKvnzqter/q9LrJEXeI8MVSYiqliqdglJoSrCBVHRYqYPxVDhanADBbEUrFVuIpQcVQkTzD6aZ8YKkwFzpxBhKwoXr3aIkXg5astcHAbQhdxbxWuAj6YAV7M2iJF4NWsP+wq19PoehpdT6PrDFxn4DoDvKG1xVGhGyl0I4XOINQUSWFYEFy7tDgqUsTB0NjK9/VHGO2+/uiKrQKHkBCh4qioQxjwua8/wgD39UdXmAqdQeoMUmdwX390Rag4KpICL3R9wlTU+RlXuIpQUQdXz5kWWmBbVFI8MVTUDqmnywstsE8sFVsFZrAh4FM7EY2uTwwV8AmIqWKp2CpcRag4KjCD2iHoh31iqDAVU8VSsVW4iEoKw7ZEo6vd81Ph8MRW4SpCxVFRh2A4JYiNFkOFqZgqloqtwlVgBjiNCJQWKQKB0mKoMBVTTjACpcVW4Spw5ipH0QLbK4oXOreYKpYKHBw2X+giRopAbLSAD2ZwTMVUAR/sqqOn8ehpPHoaj87g6AxSZ5BDhanQjZS6kVJnkGI670sXHWKoMBVTBYY+EJVI+MSY99WKV6QIxEY9XV5odH3CVNQh1APlhRe4vgG2ClehMxg6g6EzwLecFkOFqZgqdAampkiKiUVEUrQYKurg6on0QgvsE0vFVlE7BNf+aIF94qhIEQgUXCuj0RWvqV5odH1iq4APjue+Af6KoyJF3JfAXzFUmArMADsEgdJiq3AVoeKoSBEIlBY19MJ2wQXGwsIjHFqkCFxgtBgqTEUdwsIpQWy02CpcRag4KlIEAqUFZoDTiEBpMVUsFVuFqwg5wQiUFikCgdICZ84gtqxouopQcVTg4GrzodH1LiIaXZ9YKuDjEK4iVMAnIOQ0otH1iaFCZzB0BkNngOuQFq4iVBwVOgNT0/t6aIPYKlxFqMDQtZXXfQn0hDAVUwUOISG2CldRh1APlNe6L4G+A6SI+xLoK3QGS2ewdAb3JdBXbBWuIlToDLaaIik2FhFJ0WKrqIPb92dCxVGRIpAU9XR5oQX2CVMxVWAG2MoIlI2diEBpkSIQKBt7FIHSwlRMFUvFVuEqMAPsEARKixSBQGkxVJiKqWKpqKEd2wUXGI6FRzi0mCqWiq3CVdQh4O4XGl2fSAo0uj4xVJiKqWKpwAwWhKsIFUdFikCgtBg8wXh/6xNTxVKBM2cQyRVFC+wTQ4WpwMFtCFlENLo+cVTABzPAdUiLoQI+ASGnEY2uT2wVOoOpM5g6A1yHXIHrkBZDhanQGSw1vX9g4kCkCMRGi6ECQ19RiVQPEteWPz2xtvzpiYVGV/MrUgRio0UdQuD84E9P3AHwpydaLBU6A9cZuM7g/umJK1LE/dMTVwwVOoNQUyRFYBGRFC1SBJIiUDJIihamYqqoHRIoDFx6tHAVoQIzwFZGoAR2IgKlxVQBH+xRBEoLVxEqjoqkQD/sE5jBgTAVU8VSsVW4ilBxRCAp6rnzQqOr1SPghUbXJ0LFUZEiEBst6hDqqe9Co+sTU8VSsVW4ilBxVGAGdRrR6PrEUGEqpoqlYvMEOwKlRag4IpAh9SB+oQW2VxTfZVpsFa4CB1ebD42uvYj4xtLCVMAHM8B1SIutAj7YVVtP49bTuPU0us7AdQauM8B1SIulQjeS60ZynYGrKZIC6Y9Xrz6xVGwVGBpbGX++Bp8Yfv/g1RVDBQ4hIaaKpaIOAc+ZHH++pgcIFUeFziB1BqkzkD+StVz+SNZy+SNZy+WPZC1PnUGKaSAp8DQpkBQtpoo6OFzDogX2CVcRKmqH4AESXtTaApceLYYKzGBDwMchXEWogA+OB4FyBQKlxVBhKqaKpQIzOBCuIlQcFSkCgdJiqDAV39B4sd1CoyvezLfQ6PrEUGEqpoqlYpfAKVmuIlQcFSli/1QMFaYCM8Bp3EvFVuEqQsVRkXKC79/Pu2KoMBU4cwYRsqJ+VKSI+KnAwWHzhS5ibBWuAj6YQRwVKeLAB7vq6Gk8ehqPnsajMzg6g6MzOKHiqNCNlLqRUmeQapoYGtsyMXRCHBVJgRbYJ4YKUzFVIKt+EFuFqwgVR0WKwB/FajFU1CLiKQ+6Xp9wFaHiqEgRFShPDBWmYqrQGZjOwHQGpjMwnYHpDKbOYOoMps5g6gzuH9W8YqtwFaECM6hiQj8s/nzoOvePb14xVeBIJ8RW4SpwpAvi6AApAt9/WugMts5g6wzwcrUWW4WrCBU6A1dTxyJuiKViq8DBBUSoOCpSBHIHT8fQKfuEqZgqMAPUD3IHD3bQD/tEikDu4NnHQe60MBVTxVKxVbgKzABLhdxpkSKQOy2GClMxVaz/3dvX7c5z21i+i69zoS9SUl5lEASejGdhwHACx1lgMci7b3WxS2J3u06zS+y5memT5H9+Kok6kkiK0kCod3ORfNgsISzJhx0ga1A0IA1YA/mEKqBp0BWIQYOoQdIga1A0kBY0AaxB1aBp0BUQ3TlAnAMsCbUDZA2KBmKjLKCrHhVBOUDUIGkg1F2A7kR5e/MATYP970hwSyrADhA12P+OBJAkbfYgKHoYix7GoltQdAuKboFsZO5ANjIH0IZE2pBIt4D0HxWlyNIH8nznHYhsHCBqIB+XBOyKJFGELp6SA1QN9k+Q6Jjkwx5AZOMA0okyPvdHvoXg/sj3HRQNdAuqbkHVLbg/8n0HXYH7I993EDXQLWj6j4pSSLBOUmAH6AqIUkhETVJgB0gaZA12C5HomNSEHYA1qBpIC27jQ0EEZW8oBRGUA2QN9r+zxz5IysUOwBpUDZoGXQERlANIC5KApEHWoGhAGrAGVYOmgCjFHjcjqfaa9xAWSbXXAaoGTYOugMjGAeQTqoCkQdagaEAasAZVg6aBtKDtQATlAFGDpEHWoGhAaoBFUA5QNWgKiIbsgUQKohT3HpUjzwFIA9ZAqMX4WHciRw2SBvvfIWmB7EMOQBrsf4fEqlgPI+thZD2MVbeg6hZU3QLZhxygaKANqWpDqroFVf9R2XqQmKVsPfYQFkk66wCkAWtQNWgadAXEh5LvIGqQNMgaFA1IA9agThDlOfF9Z0dRnhM/QNIgayBfWgTsbPs2j6Kccg7QFRDZ2IN1JEmrAyQNpEdZQNEEpAFroFsQdQuiboE8F3yAqEHSIGugW5D0H72/Ci4dcn8W/A6iBvJxXUDWoGhAGuzmsp8BSdJZB2gadAVEUPa4DEkR2Lwn8pNksA5AGsjfETsQ2ThA06ArIBpygKhB0kBaIBYi6nIA0oA1qBo0DboCojsHEGoxF5ENlo4X2ThAV0Bk4wBRg6SBfIIMicjGAUgD1qBq0DToCsjB5gB7C6oMo6jLAbIGRQPSgDWoaoBFXQ7QFZDtygHERsWuZR9y71HZhxygatA02Kn3qBVJEdd7JybZhxygaCCfkASwBlWD/e/swS2S3NaDIAYNoga6BVG3IOoWyD7kAKxB1aBpoFuQ9B+VE8seUSNJZx2ANagayMeRgK6ACMoBogY3rar7yYj2dNYJigakAWtQNWgadAVkH7JHeUiyXgcoGpAG8qXSISIoB2gadAV2TwndR3v3lAyQNMgaFA1IA9agKiCysYf+SHJbB0gaZA2KBqSBfM8+gyWdNTfpN9GQJnNBNOQARYOdrUnbREMOsPdbE4sXDTlAV0A0pIkhiYYcIGmQNSgakAasgbRA7E005ABdAdGQA0QNkgb7yMmKLuVdj34TQTmA7lERlD2MR1L4dYCoQdIgayBfWgWQBqxB1UC+tAvoCojUHGBvwR5aIsmHHSBrsLdgd+iTFH4dgDWQFjQBewv2CBRJFdi8h5Yoiw9lDy1RFt05QNJA/o70gejOAaoGTQP5O9IHsl0RU5YU2AGKBqRBVWBPUiM5IuzlXSdIGohR3P9N0YA0YA2qBk2DroAIygGiBjIk0teyDzkAa1A1kK6SVss+5A5EUA4QNZAvlSHZU08GKBqQBqxB1aBp0BWoQYP97yRpwe42GeD2pSVIH+xSM0DVoGnQdyCmvEvNAFGDpEHWoGiwf2kW6j2gPEDVoGnQFdgPQwNEDZIGWYOigXypzLneNOgTSEnYAeRLs4CkQdagaLB/6e45pT1TdoKqQdOgK7AHgwaIGiQNZEyLANagaiBfSgK6AiloEDVIGmQN9h7dffgkabMDsAZVg6ZBVyDL32EB8j3ycZk1qBpIv0UBXQHRnQNEDZIGWYOiAWnAGlQNdAuKbgHpFpBuAekWkG4B6RaQbgHJyDUBXQEOGkQNpEelezlrUDQgDViDqkHToCuwH6DKfn+OJId2gKRB1mBvQZSPE0U6AGtQNWhq6O+KJOCuSHcQNUgaZA2KBtremra3fYtTokhADxpEDeRLZdZ3+VKZc71oQBqwBvKlMrNEkQ7QJ5BU2wGkBVWAtKALyBoUDUgD1qBq0DToCsSgQdRAt+C2+ZEd355oe/yk+XP727I724vRHj/b/Ln9VdmB7jm4x884f6b5M8+fZf6k+ZPnzzp/tvlz/rU8/9q+5SlyBJKc2rJH8khyast+n44kp3aArsDuhxlA2OT7i7DJt5aqQdOgK0BBg6jB3vd7UI2kkuwARQPSgDWoGjQNugKiNkl6R9TmAEmDrIG0QOxC1OYAewv2aBlJWdkibkgStTlAV0DU5gBRg6RB1qBoQBqwBroFN7WRXfCehXv/eVOa4+f2t2VXuOffHj/z/Ln9VdlU75m3x0+eP+v82ebPPn7e9Ob4GefPNH/m+XP+tT7/mijJHlcjyaQt4vCXTNqyh55IMmkHKBqQBsK2Dx7L3JdYgiTPDpA1KBqQBqzB3vcS3pG02gG6ArJPOUDUIGmQNSgayPc0AaxB1aBpIC3Y7ULSageQFkiPyg7mAFmDogFpwBpUDZoG0gLpeNGUA0QNkgZZg6IBacAa3PY2skvf68+O333+3jc2x++ofif1e/8Lcs6S7NpC9/+mK7CHmkk86Ht27QRJg6xB0YA0YA2qBk0B0QyJ2Ei12SIxFqk2O0DRgDRgDaoGTQP5Upl6skM5QNQgaSAtIAFFA9KANagaNA26ArJ3Eb+LlJ4tEpNg2bscIGtQNCANWIOqxrTr0e5qtKvsXQ4QNUgaZA2KBqSB0iLJyD2A7FAOEDWQv9MEKC2qWovqXYvuQL7nTtAVEC06wP53JPpSk1LDmrIGRQPdgqRbkHQLRIsO0BW4a9EdRA10C7L+oyIyEhmSorQDdAVEZCR8I7m6AyQNsgb735FQjOTqDsAaVA2kBbuNSkZukSiCZOQOkDWQv1MFkAasQdWgadAVkC3NAaQFYiGypTlA1qBoQBqwBlWDpoDojgRpJCO3SLxEMnIHqBo0DboCoi4H2D9BQiSSkTtA1qBoQBqwBlWDpoG0QIZR1OUAUYOkQdagaEBqgEVdDlA1aBNIrm6RqJVk5N57VIrSDkAasAbycbvxSenZeydK6dkBkgbyd6QFsrk5AGkgf6cKqJqgaaCGUTJyB9AtSLoFIigHKBqQBqyBbkHSf1SUQg4lLWcNigakgVA3AeqE0krQIGogn9AFZA2KBvvfEe9x02ekps9ITZ+Rmj4jNX1GavqM1O5npDvIGhQNSAPdAtJ/VJRCwjdSlHaArMFOLUEaSbUdgDWoGux/R46gkmp7ADn8HCBqIC2Q8RFBkXO0lJ4doGogf0dsVATlDkRQDhA1SBpkDYoG0gKxEBGUA1QNmgZdARGUA0QNkgY7dRdzkd2GBFyk9OwAUYOkQdagaLB/gkRfJNV2gKpB06ArIIJygKhB0kBaUAQUDUgD1qBq0DToc4Al1XaAqEHSQEYuCaizR6Uo7QBdAdl6HEA+jgToThTZOABrIH9HWiD7kAN0BURQ5MgtqbYHQdHDWPQwFt2ColtQdAtEUA7QNNCGRNqQSLeA9B8VpZCjf5eth8R/usjGAboCsvU4QNbgxkYSfZECswO0Hcgf3SWAJECxp8BuQKyqVg2aBn0HYi77RB8gapDU39kn+vhvigakAWuwn8Duf1RiOQfoCkgs5wC6D3pRn91JA907e/E0sRDeC79u/w0JkO9hAUmDrEHRgDRgDaoG0qP3P9oViEEDaUETIC3oAvYW7N5wlnxY2t3cvOfDRjEk3vNhJ6gK7OlrshPivfDrRpAE7H9n90XzXvh1gqIBacAaVA2aBvuX7i5rlrTZAaIG0gIZhSwtkIZmaYH0TpYWyPfsSSmyDec9bXaCpsAey5EzLUvh1wGyBvvfSdK9uwQMsH9pkq7aJWCApsH+pUk+e5eAAaIG+5cm+aO7HgxQNCANWANpgfQBNQ26Ahw0iBokDbIGRQP5O2J8e6RYfAEs+bASGGXJhx2ANNhbncVGRV0OsLc6S7+JutyBqMsB9lZn6TdRlwNkDYoGpAFrUDWQFojxta5ADxpEDZIGWYOieqfL35HB6k2DPoFUgR1A/g4LSBpkDYoG+6zffRu8V4GdoGrQNOgKxKBB1CBpID1aBbAGVYOmgXzpbkhSLHaAqEHSYJ+Nu8+BJW12ANKANagaNA26AjloID3aBRQNSIP9S49/UzVoGuxfWqSr9q3HAPuX7k5klpKwA2QN9hbs3mGW7NoBWIOqQdOgKyC6cwBpQRGQNMgaFA1IA9Zg7+skxrf7YUuSL939sCXJ0O9+2AGyBkUD0oA1qBrsYxplSPbclQOIIh0gaiAtkO6tWYOiAWnAGlQNmgZdgRY02P+OLMiSait5NSyptgOwBlWDpkFXQBTpADKmMgqiSAfIGhQN9i+VtV4KzA5QNWga9AmkwOwAUYOkQdZAvrQKqBo0DeRLdwmQjNwBogbypV1A1mD/0j1wwJKROwBrsLdAJE0ycgfoCohWHSBqkDTIGkgL5LNlj3QA1qBq0DToCohWyeZH0nPvViXVZu92INVmB2ANqgZNA2VVqQQNlFWlkjTIGhQNlFXtibsTVA2aBtqqSFsVaasibVV0t6p///tPP/zy97/9+PvPf//1r7//9tNPP/z5f8Z/8M8f/vwf//PDP3787adff//hz7/+65df/vTD//3xl3/t/6N//uPHX/f///uPv23/7WYQP/36X9v/3wj/++dffrr9+vef5r8O5/90W/Ju++f9n28rXuqDYltnH0jiOcleEHCn2E6+k6DyA0ECrQg3i5BGBOZTCvQhod62eXeOzWd7+iEFfEg6mrG59AZBLQ//ns7/Pd92P/u/3+J6swFkbwAfBJv/6awB9fzf19vpY//3NfOVBvTbKec+lHTWgH7+73cR2//95h2/1AA6CHpNZw2IyBiHPW9Ot0stuJ2j73YU42kTMhiFPswoptMmIGMuoR8Dude3Pp+VwBrFHbWT3E7jkyMGM0feb9HsHLmo3ogxP3IAo4z1mJjbgjoY8nMrGhjTUP5gXr4wALvc38oUs+oXGXiMyOZIOadAnUnt4Lg9EHzamQlIpVRolN7MWRlGflLbjAb1sIvc5yTftqb2L+E0vyTX8y8BHLc8kkMrOM/e4CcKRvOkH2pxy187pUCKWYdc6LWL2MywX4sXBo7nDMC0tj3jGNNt/RscJT1Q5IBU75hjrdfTRmSgm6nWoy/TFuWcBn51POr5eCCrqCGOFST0M4pckO61PHSvxFMKWh3TzOtjWpfHtKFNEY8Nxe33bMZNOsyfsj/QfP8UimefUoB57mX9RC7CKQEWi87DLGI+G9OSlgUcUdze6hvK2c9Xw1LQHOE05ojqjPTcDtQb7RiQzUc6GbbpYreM1qdldDWqz5ZRgIX2PQYpyyqplmR++paGdCeMiVKT0gzzqNxetLsz3J7POR0VQjuuOvad2ylILYrxcVEkoKD7+4Rj1xbVerR5DB9Z0rp9UF61D/gtZa+id/+WrHegz9+CdqD7e6R35WhdfcvjzCdeto/qoYK4RzjPPTmrr3npEbTUMx06lrZWqR6pDxwMbDUHHioUWPcqPXKgr2l1nLhby+ccCZ2WDytrJZ4zIDsdx/4tmHTOgNR0fzlCviOxmnHtA/OwSiHzuhRyXTV1OKw9DhnraFA66tIphQmYVw2rA1vj8sDCeRKHRyhvx4PzZsCjUj2MPOcObBS1Y39bRDhSA+0ASnor6HX0aAjng4IVrA3x2St3nSpYBUbK+2OKsrjkdL7GVbDm356MHCt2bNc4Kh9meqtBecrRwMhsFMfI1Jr1nvBxpWygV+t+W0Y4inLavXCgfSXNDcxcnTY3+iNDRivt8DndHvU75wBauofGxcRyuMYwXGdbdO2UAVpXHo3gEs93Ha2is8KYb7eLE+frNJortyTvsQ1rwM4bktItVpand72GE0nvYXVRgDOljaXpVqbw9Et6Wp8pPa/PlF5WZ0qn9ZnSeXWmQAbTTIEWymVu4XiLkJ+Pa189KSDrupUUOzrj9pcvzbYaaGzBagB76xiQbzRPT7P2bKZnZ3XIq/MNt2O/4i0UpYTTdqAD6RYGHt8Sazw9kMbAyE3bjxmXq/Kcx6cZB0nKXvRc5lzWYa0XkrZ+qo1h2Vhxr7Y5+bWxPh/zEcf+OOKdA41MTMsxERRlMgZFYlmNiuDOaGO2bDEB0BkMHScjdFuKduDUJ5KKdupp2HrW4d9PSG7vrI/1hTog6Q62nsJXbZ2HEzvxQ4d8YOs8RibVwufDi8JNRltPZdnWkQfZwdYrDT94B+IRUbQohTqd6Vk7GumJpKHd2PiYWqldI2k8sx2Y4jlJDg62jkJPNlvHElLUBiKC2Z/R0p9H+sQtKQiQFOhJHmK2DY4ieU4goNVNCDTWnoejsVe+Nvv7GJgcUjs3eBhpsM3+3JdnPwpArc/+HHIfXhx1AnrpDBSqiGl6onPWc44/IOllSEhoAZAgM73dSRszt8fz41hEkagZ8dBGljN90pIeVUtSBy1Bbtxex+QNIZ63BYaO4+iUp/3h0+QtaP3nmocEcFVe/qfxgXNvv8Fz1yIq5y2B56oZx966p513LDkc/SM5nP0jLR/+Izmc/iMtH/8xhen8D2VA3sa6nzIj0BLy2Kvy8l4Vm3ubPvKgQgYv5o4CUryXfbs7D1U2T+8fcNSR7MC1Ag5kpyGMo0goKhbUn6SIkbLGOKQ1Ke/OKwmjuTumzLZnjOfTDoWliEYU91byaZJ8sLPiee6uAeysYGDqdrF2LhRq3/tk8BVu4rMytHTeEhScKmnEt8o2CydJfm4JXsbH/A1qy8rPmZUoPDUkoITzFKFYgbEyjd0Ecwinwc+IwlOb2yalGUNVE/g5/glVIMexXuUUwPKLQgiJxh4rQZuvzWHRq91h0UMxKuOih0JU5kUPxaiMix6ksC16WNCM49LIY1x4fVyqx7i09XFp392MlDiOedTBmaQjP0AZGSW3ipvnstodZLWvy2r3kNX+vyCradh7fliunmW1Q2NNM5erl/NJ0z1ktTvIagrLspqCg6ymsCyrmMIoq2jHGsd9k5uxnG42UyDoUihqf1YRjYPEp1A9bKSt20h3sJEYlm0EUhhtBPkByohIVlLC2p+bAdOpjh7N6lz0lA2aUMiKpm/lVlhtcpT2RIKur4RxTS0HlZXxTIL7I/Z5tor9vD/g1agRKY76tHlLs38kQcv3OG1SCYCir59YEwpZWU+sKcX1E2tCl6RsJ9Y37TCqEApbmVUo0bIKJXZQIRS5MqoQpDCpELZU60oFo1b2lSp72EhODjaC/CtGG8Gub6ONoLiV0UYghdFG4HXRcYtaDe2LIKKoldWJkFDcymwfKHJlto8Sl+0DnvCs9lHysn1ACqN9oFWXRzM2J1A8t5DCcMnksWR2ROLgq0qleZiZx6GK1g9V5HGoovVDFTkcqmDgbGSo15rON4goXpV7zcMVod0Iz+sUweSIqG4uza954UCWmmcxAR1tSr08kSBV3V+Mu5PobIDy3BJgqdzbsWfefp7f1sFLxLgi/FDk4WXyclz3iCR2iK4mdoiuJl6OriZ2iK4mXo6uYgrbGgHlPc7U2aSvl7xYSHewkOpwSSVVh1sqqS5fU0nV4Z5KqssXVTCFzUKwmJWRK1JUsYMXMUPBKvNxF6bg2467uB1GI2seW9W2vlVtHlvVtr5VbetbVbjslhnNYLViviy7zcOj2jw8qm3do9o8PKp93aPaw3cHd94o35aRej64KFZFoQz3X9AuRLbvMsvMbSyBgPuvw5opx9g2qudqCG9FjWQk0qtlfu4ODzPt62baHcw0h2UzxRRGM0XWMW94le0MeWodGV2rsmpQDg7+1ByW/ak5sMfg1vXBXfenwro640r47fmx02g5Mo9MIxmq6JJ7T7fdMqral8O4jJDjQ0Ex+oBkDwkevuEESNBtFVtNsYyCVLaiYpDCWIEqOpSgius1qCIs8GMrLGYflQpGBZlHLDN0AC68ZBQXst1FyCg6ZbuLgClstaxwd9BwT2WG3YFSqepwpGw/la0/pexgkjaqCW4cHZDU9XkL71XZ5i28VWWbtyg6ZZ23OS7PWxSYMs9b86iAeQvNo4+sgdrV1vLFPOCNKmNRQFQIzzq21WFs2/rYolRqe2FATGMtnZRRdMpaOynD+JTpytwbHeIhZq1fFLMW+xSRep4bngtMpSrzEqE69j/XaMUC38dOdwsjgD1VcZDVsi6rZV1WyUFWaV1WyUNWi4OsYvMYdzK20BKfmwc6G1rNA4WnjOZB68oM3blW8+jL5sHBwTzMo3LZPOY5OYR27URWwrjaWUIBNoYCU8ZC0Zkd7JTX7ZTX7ZQd7JTX7bR62Ck72Cm2jnUPRh33Dsr2WeceDHiPKo0L91wyWPcrvPSntlPhdNmHD3rQGNz40KnpacpVeJl6uGO2uOVsCIVPBqbOgWkXB9dYDRxFpVIJM04XyzlHXJcPFJUyygeiMMoHKtFnlQ90f8pamJwd5MM8KkA+oHXM2kNJ+4M/4qAxW27v8Z1y4HDSKGBCnftFjhFPghx4ttjOybDQn83SEYXR0mGhP6Olo4CU0dJRQOr2XuexLjzE1l56FC36lvr5sBm312xHM3S1j+cK+iF4nPdLcDjvl7B+3selII0PG5SvjkwdrhjSd0BeDcRM0i+StHGJc/t5mWS8GET6BabPSHoYwbGeykVrjWXkxdx+Z2CtwcNX9oamjg3i9pvjZZo+r4Q2dTD7bArWNN/ZUuW1X6egmaRfJZmvx9VO10i2KIgao9AQDezcmW4bY4jl6hg1dW236Wj3hzTqWbyWz+33gxX99PhcEsxSnVEecOSEpwHjAy5l3ZuASebDFtsxrQESuH0dVURSLeBr1j2rZT1gVdYDVsUhYFXWA1bFI2BVHAJWb6yD59aklUscOY6PybHXqxxhmSPPDU5WLonPOMbgbnTnHCjUZDwfveEwnY/wt5SR9ZsLt3WOizaW08j92QIn52MLK++pjc3mAgP6gRpSR/pPrnwuhYXXBxdzOAxujfNbwMSF1f9Cnf43lZX1YafOW64NWBlBB76liEmBb1FRnyXmA9iGo3aU4dMs+jGGl+6Aa/Z86yPrwOzzmg1L/9n8gIXWH5wstPziJKQwrtm0/uZk4eVHJws7vDppHxWgp9A6bH5AzGHzAxamdRmj9VyXwutWyutWyg5WWtetFD5G9cFricnB71WX36fAvWr0e6FIlcnvhTvV7p55MzbGU/IbGvPRH9OYnUWYxuwsekNjdRZBu7U6i+wk/SqJ0VkEC2/anUVvDM/q5bGL9flWr7VF9wzeYZUyd2n63a3nHRaKP9lyowsqAWjLjX7zKbM4a0EOHtgO62PBqCF9lqqKIYGG0Hqf8nKfQgqH7qCYhgcwFtQd/ZuWTmWcJWjbYZ02gwI804yzlSrskMLz+wzL8SvcirFG6JPVayuQjc7XHEvS1TLtFPuiO3WQwjWSTnMV7zqP5yOSURoiRp3T+Emnjk1J6Who+1cpbiv3XKNaPP+U7jEy3WNk+vrI4JnL6mik34h7eQMVpZwZn2ehuPwmNW5HH3fVYn+IZZRPPmYE9WPXh5sXkuXXVSitv64CKWwrDOwO6+sdBF+r4jpiz9tvFQbnj0hMT4BQgu4E2xMghDyJ1idAKDlUhyAYqzJe3t3vxZ46NU2XdwlGq4yXdwk+WWW6vIspbE+AQgsxvppBqPCf8cULyrCgqq1+KKHrVdb6oZQdCqpQXi6oAofG+pQBFZhYaCsPR8WhSiUVhyqVVJarVFJxqFJJZblKJaawTd7sIarFQ1TLuqiSh6jSuqjSd0XVWi2fCNqprfIXIdeQ2ULg7SqrhaCAk9VCmoeF9HUL6eszF2q7rQYxMYytWmsQEzvUVSF2qKtCvFxXhdihrgrxcl0VTGG0EdSlturwhCJX1urwhNzUturwBOv+WXd3KG5l3t2hS1bm3R0KXRl3d7gdxllXHUpVUV0uVUXVoVQVteVSVZjCNuugpVqVGZXt+0CZm4eNeDxVRetPVZHHU1W0/lQVrT9VBQXRVh2eUHTIfC7rDpV/qTtU/qW+XPmXukPlX+rLlX8xhdE+0KprrA5PHT+oYqoOz8Hh+M/B4fjPweH4z2H5+M/B4fjPYfn4jykcNoi26vAMH6gyVodnGJuxVYfniG/RmqrDMyoWYa0OzxG932usDo+XCFt1eI4OHgCODh4Ajg4eAI7LHgCODh4AjsseAExhm7wdv0Jkqg7PKTlYSHI4/7PHO1W8/k4Ve7xTxevvVPH6O1VvxMxWHZ5zWD/uMowzmY67b9phNLLssFXlvLxV5eywVeW8vFXFFEYjg1c7bdXh2eOVKvZ4pYrXX6lij1eqeP2VKl5/pQoPrrE6PMNbUbbq8HCXaa0Oz7iAn6U6PKMwla06PJOHmdK6mZKHmdK6mdK6mULrMFaHZ3J4oYKpegxuWx9cB38q87I/FVPY9rm4MloY6aE19/NYKCThkfhbajnPUmMUorJlqTEKUNmy1DCFQx70NhijIFCsqAABJJmDm0u5SJKH+2CbWOcVwLkuJ/1zXU76xxQeA0OjHcwRdQfKQaY+/Mu367NnmX/vSLKKQFA7JQGayjzf6w6cwOcATS1pXqZ4SIbIzy0Bmrodbsc2NcTTu+qMglS228yM4ktMZcwZ1t6yJ9cQN3xPTN366Srp7vnyEKaJ8zX17TfXUxposnV/NEHGOBdgsrAkoK2YCbf1+qrcluurQgrblVNu6/VVuS3XV+XuUF/VPioVjAq0DlMxE8hhLGbyjiMsc9gKkXC31pmgdLEdpqIqb9phqplh/xbAAb+ljHT5vK0WZxw1xG+3w1SYxc5xcb4YC7NUFF6yFmbBDbEVZqn4gSmTkb3hcBhcW2GWGnHlPFNhljcNMRVmqShEZdvKVPgckrEwC2yHrTDL240qq41qOdmoVhSfsu52IYntIiPeptZRqXX7eW7ssS/vgyq6CmXbB0EK2z6owuiUbR9UUXDKtg+qqazvg+yjAnQdH2LaLInez+U0eUhhWA9wQ5I6KylWfSL7iIRnzdmt5/JFkukY5lbz5UOZrs/S+fKhbKZCbAc0AjSwX0YZoE0809XOnc6IFs7LiMBDs1Xh8XEoTBlol6bO5kMYtZUiWL3z8vm/ohiVedHM612Kh3YEZLduSxdNPoas6tWUy36ISGpXVC/PnJiC2lyBmYMKE41+Ua9VledLd/ja7Qh33a7dnt1VryhSZb27C0mMdRXSuq8Z3/7tI3M/9nT59q8tC6HCSBOPICKx2hg9jS68uJvyjKsoXf3s9m8dK9/m9zqPrFTiL5PEPXhzmFm7SFJn1araEyBB024swbXwNYo+LiLr/ftHFDEoxyqfB6wqulVV9mqDMu9KV8GVT/p0Fp/fJg2yM1Ssos0yMz2AW9XodLVxDCXafvfTpQJf8C4jiMclX2sK87wkzsrO+vPYNNSOPihmK24R0k+aEWYz8mkz8K2qNktv1FbPt9AVlv9qo6D5Fu/Vy296+h545X2svv1h8X0KntfqIK3wwvtIV99OrXyJYk9TvLdCP9nwCYXpQ8hjjSCPNQLeqvIgMa8RkMS6RsDXq2xrREvLa0RLDmsEiopY1wjYp9Y1At/dNW6s2vqkgddurZOGPfZE8GKVB4l50kAS66TpZXnSIArjpOnFYdKgF3mskwb2qcfGqs7A+RbgqGdbgIYuVuXxoHhWTp6YnhhQxGqeEUmbRyztiQTeqx47ohxqOCV5c6/atoVooSyLCL5VbdpCQArbFgJT2D6kO6ihx+rfYvgyiVUNMYlRDVvMq2oIKWxqCCmsathgtMmmhrhPrWrYHAoiNHghyjZp4P1w66SBJFZ7h3ErDxLzpIEk1kmTaHnSQEeibdIgCvOkQQUArZMG9ql10sCSKKzqiCof/uPdvZZh6d00XxFTJfRflm5cAcA4efP66R9e3rdOXkhinXeZv0xinrzZwbHa8rJjFVIYJ292cKy2su5YxX3qMXnny+Sd6HzywuJ9scxK5LoG8NPkfXM12zh5S12dvPhWtXHyYhLrvPNwm0ES8+Qlj+0qrW9XaX27Sh7bVXLYrpLHdhXdm0+TJOkueZm+KFBUwsgELlFd0nqZvrgsinH6clyevrCiiXX6QhLrzONvk5inLySxTl/4gJVt+iIK4/RFFObpiyJW1ukL+9Rj+uaZyJMjn5e9aMhhVdp4w6N0ncvzPH2Tg+u8rTuLcMUK6/RNHrve2r5MYp6+OI/WOH1RRpFx+iIK4/TFiYXG6dvK+vTF2ae26YsrPeVxETdm5W9+9hQ3GAcY36Ld3sx2ChrzX+fifkZRjwg+Nb5Gse8OJJMghnUKukgx+oKv9gWPvuCrfVHHh9SrfaEpLvaFftvpYl/U0Rf1al+08SHtal9oiot90YZktHq1FXXUuWwXW9FDGKGlsE5xtRXjkZsOJAdWhTPnu8PScsb7wx3dhqpxDEtNqQES5Enl+gci/FIJBX6MNUkdkxhvAEAS6w0AXOTKEn3EFKbo4xsK04YyO/hiMYlxL9hj/TKJdUOJSYwbyg5vVZk2lJDCtqGEFNYNZUeHH+OGEvepdUOJS4fZTmEdnX6MkwZW/bJOmuIQOOypf5nEPGmSQ9Zfz8tZf5DCOGmyQ9Zfz+tZf7hPrZMG13WjWbRPXVV7ruvWUapsjiOHOUedw8RPHNBC1H1X1a3b/uiBA92p4lEpnylfYxjXKlld7/yMIYy93Wkb3lTJS+Oae3g4ODy1Ap3yadwML1w8OPoZh7lsYA3npZg7ikvFMlPkS27nH4PS/cO4x8xR7blfOJCJxkTDZRFz6B4sMZ12LPae9NknoE42LGE4/RY9nm7cOwoIGff+5LFcksdy6XGRqntcpOoeF6n6+kWqvn6RqntcpOoOF6m6x0WqN9VH24z2hfP6kh2+TTVO7kVdpXxhQG+ojJNu0S/L8kdFLo27ZV5O98f1Kc3T32OjW+OXSczTvzqk+/e6nO4PKYzTvzqk+/e6nu6P+9QacjQ/cVvOn7jt6MZ9bLPATCvza55qmbx5RtU4e9H9JWOyXnFIGMAk1onX6Msk5tkLSayzt7Xl2YsojLMXUZhnL7poY529jRxmLzkkyfW+fjmFHJLkMInV3nv9Mol50nQHr2oMYdmtijls0wZzWOdNDMHBs9rrl5e9nOf7YQ/55c+FtxFJCTNY/1gBuDz3Sf02CzcqM8pzVpjlDccsrcw91Ysc02PVCXAgex3OkZ4u2/yoqtorrc8bwIE1LY8CMZtExoskaT7clQNSEoc7VZjk5iQanp7SLjYlxjE6MTa6yqIcRrlfbgvNykqkqud/ysKzAl7rl79oSltO6IvScmI15rAuGckhtXr7333dbPN8cTZTvdopRl2CHEZdMg4O4MA7adOnYArTl1j380hg4UnLKrD4zGcV2OxhqdlFYLOLwGYXgc0uAptdBDa7CGxxENjiILDFRWDL183WLLDFQWCLg8CWdYGFjkabwEIKm8Aa3Z2AAjuijQL7xiVuFVjysFRyEVhyEVhyEVhyEVhyEVhyEVh2EFh2EFh2EVj+utmaBZYdBJYdBJbXBRYGcm0CCylsAmsMJ0OBTR4CmzwEtnpYanUR2OoisNVFYKuLwFYXga0uAtscBLY5CGxzEdj2dbM1C2xzENjmILBtXWBhYqlNYCGFTWCN6a1IYIuHwBYXge0eltpdBLa7CGx3EdjuIrDdRWC7h8DGsC6wkMMosJDDLLAxfN1srQKLO8UmsJjDJrDWwUHSlpbDXJjCJrBpOciFr0NZBRZfzDIKbPQIckWXIFd0CXJFlyBXdAlyRZcgV3QJckWHIFd0CHJFlyBXTF83W7PAOgS5okOQK64Hud5cF511yFgleXx043Q+0KhfVfjoEq/xOSJMYnuuChfsMA0tpjCNrLVsCBpYWNDFuuDg0jLWBacEh5kLX84yLziYxbrgQBbzgoPfArMuOJjFuuDgL7IuOKWuLzilri84xaHiVYz0dbM1LziwU4wLDuQwLjjGwUHSxsufgilsAsvLH4IL3lkFNnhkVUT2sFR2EVh2EVh2EVh2EVh2EVh2EVh2EFh2EFh2Edj6dbM1Cyw7CCw7COy6LuGCrzaBpeWzibXsLBLY6JAX/KY0sVVgm4elNheBbS4C21wEtrkIbHMR2OYisM1BYJuDwDYXge1fN1uzwDYHgW0OAtvWBTYvZ1VgCpvA5uWsCvxcgjUvuHv4pFNwsFRIYhbYNyxGgcUsVoHFLFaBfcNiFNg3X2QU2BTWBRZyGAUWcpgFNsWvm61VYHGn2AQWc9gE1jo4SNrgY0E2gcUPl6flVtgEFj4mZRVY/KyVVWCTh6UmF4FNLgKbXAQ2uQhschHY5CKwyUFgk4PAJheBzV83W7PAJgeBTQ4Cm9YFNq67COK6iyAuuwjwE5dWga0eFy+SR5AruQS5kkuQK7kEuZJLkCu5BLmSS5ArOQS5kkOQK7kEuRJ93WzNAusQ5EoOQa60HuR68wSwJaviDYUlqwK/7Rx5FPBI7fyB6M1CUE2iYe5zYMtjK/Dr4aZhxRSmUbW+YY4GlR0yKt68c29dbLg4zFr4HJN5scEs1sUGspgXG8hiXmwwi3WxwV9kXWxqXF9salxfbKrDI0Qby9fN1rzY1Li+2NS4vtjU5Uyv2pYvoWAKm8C25UsoBB/vNBcCCh4C2zwstbkIbHMR2OYisM1FYJuLwDYXge0OAtsdBLa7CGz/utmaBbY7CGx3ENi+LLCU2/JuHlNYdvN1/TJ3Xb/MXdcvc1P2kPnsIfPZ49IWJDHL/BsWo8xjFqvMYxarzL9hMcr8my8yynyO61dhcly/CgM5zDKf49fN1irzed2V/IbDJvPZwZkMH9cIvY9qtDGEScMfkGz/sE8S1SdP1T0zvjHVW1BNucZSYj+eSi4p1tPPKR59Ulz6pLr0SV3tk1LRSafTfAxSF5Tm8AnJNNiubzw9k6CiDrdeoCEnQa0aH9HY6uJiClNZ3DcUlqq4JUSHkcEkxpGJzWVkEI1xZCCFbWQwhWVkMipITX28frD9VC+ocP6EJM2ni0o4J4F3qMuoap1KnDvxJw5ZHU+Ht/S5tVHl4F9JUGH68TZVy7Md267pA45WDklsHBEHSjAJfTwGF5WsPr1MsZEAG2l8yGrrFTUEvudSx56+qofY8vWxqadjg40kj1ViMxK+xkHjddtEOZ/bCEqjpz7PjZ37VRI1+c5JMipeaTPWDN/6i6XOI04Bz+ximtDieDMwtHyZple1s1FK8CFNzeNdt1A5Xqbp82DQwvmjzBk9ENNr6mMbzOdr1wck/SpJn5v6fr78vRtqdVxqOYHOhZLfhsOB1AH9ZRIxfDlrvgx/qpEZJRTWXscjkV2LZH4WSfT41sOLmQUoAneH9Qtd37KuX4jDun6hrbR5/ap5ff2qxWP9Mo9NBWMDraSPJ03jdoIDA1yX1413LRmul6SfvX9tCeiTPEa4BDQ66B6L9aF43JISxxt8nEFLUJdsBhumwbZr/ZpiHFuU2MA+Frn6zf2KHmmiPkyNQwFWDwNupn6F+trieNm0RTXAz/qK1y3jEfINie0ICUnsR8jN0/u/wGN8PQdz2F7PecNhOY0mmFpVZzynnZ8QisMpEr7SZF2Fe1tfhRGHcRUu6BaLdRWGvhfjKlxC8liFzWNTr9mI8RBZ1s+QBTn6rWfINyS2M+SyvwNFUT84QTaXI1vzOLHBXFPjgc3O0S9y2I5rOCHZutDgfrWey2FbzJaCv8jqasAsLl9ktto3LEarRWdhq9XaOfpFDpvVsk8Mpbp4Ksq6o6KktuioQGWcc+VD6rejkHpoPD43AyVo5DRWv5z1DukTjjwyCHJu9ZwjLQf8UH/wOK5tB0xC/QHGtoUyVj9l7TE8c6ArqaPAYe+XOcbgbtaeTkmQh902LChswemwUU4qMSR0O8PYsrJO6HhmgFmIIw0pkn4j9YOe2Gbi3CWmfMoRCzKw2NMY2O23GtqnIHtcjvWjc2Lu40yz/U5q4qeXr6H1iQ85jBO/LEf6CZ8k6jhJqCeOnxjyqp1DBpOdo6+w2jnkMNs5+hazncNyI2EcqpKy0RSTnYNGpyYiwIFmSynjrLr9Vt/yOluors8WyGGcLdS/qh8PPULan/jUI/AVNE5jfDlrS6sXOeo6h36t/YkDveBUxoG3NDV3I5kZaLi6HtIwP2Gow1lWwjkDmPttOEQb1WsMZfhldeLkNQbOpwzoOmXJI8mw5HbOwRHpxlwPONIpR4SZXzHR0NKkDj5/wLJsW5jDZl1vOEz29a5H2khaTj25sPBVlhzGOS6HdpmFZxp2zVdZaHofqFzulzw9mSWQC0u/ylLSOGuXHC+z8EgELczXWeYX1cu2W4Y8xtIuj3Tp41RGIVydi9RGWKNc5WhpuHnzZY4wOMoyB4fL7RiBAMYzGe2/43iYIPf1dgCNhJVyTWqPGGxaDxlsO4m+rvN2Dr7GYdR4zGFTeMhh1He4r+ljT1J6a5c4Mg+34/bz3MrxfplGQJTr+X55k7fVJCvCKaRj295CRs1ALlSqx8BULWGxPZOgnJXc5qlMRzOfW4IKDKaZx5O1u+6VBJ3MYigzGKKvHT19EOzZNlwAqT0cmj84VLXhfNx+8jkHPGZOI9l+o4M3RYKxg+EHjYqkPl3JBGZSSjxaUnQSwHNDEAflcZWLtI48c6AKgdv6MvLiq74O9gkHD0N7yIn4iKPnsQHp6p7sy/k/Qm/VOHjfPFd8lWXeFdp+t4ssSSUBbIIPTC0VtJepYx9Cpz48zGHzJL7hMPkSG0zhbuoOVg+nWUCEIlQ9ju1Mj+f+KsyRxhreU2pX/FXU1Ka780VL4zB9mqwTX15tBIWpjH5AzGHzA1IuX/UDPvZIvN6vNFlSusgSx5Wh7XdBMxglJZhHp62PDiwy6DA6Dz1C9fLoFMVyrq+9r2oaZLBFR+CX1DSttfYELKTwaqwIc2yymMfYVFabrM9Y6sj32n5zvMoylb7qPLpPbK3VaSU9g4giSuiLNagPCq1fo0lp5CmnHPQZOF8kiekiCY304EQcr5Fsn5DGyeDB8fRMwsvJAPjh4xDHCVSXv4gvLx8jkjiOoJvGlXMSQucLq0xDDqNM83IwHndIGlJQHmo3vnQIjED1MApF6PoMf8CC9q8jfW3b4JwfhnFDZsWKro85H37OPOiE1K6zjPTvQNe7to+s2sABmD06QeaRclEyJFleRjGFaR2Fn2JNM8Ak1jwDQvewrHkGER0wGo1Eg6abEp9dv1R5XZEgh1GRoKvCpki4Q1gFgivokLacFkiQYewGctbnghdBQuUKjel41FDNGVs6HuYwrsAlOHCgTVach+FUdK8+mxnyAOXprVTRo/qStuUwd3FqXx3ivDVY1RjLz8KKaVqeHoJW+nWaKY06geGVBt2zC2WwhIf075dYFNh6hrFYpI0PkMAPmjeZt9/6gttH/bJF9ubxIKit4wsNdf4+z8ONysznfYNZUh4nhKSOcH/A8sbRNv1s6SpLnlczi76a+RmLyusilfbywsLovGKtWYY7d0bdUm6wc2Gw3XTBGr06atxzQQrbngt+iXXPhbvDuOdiWPfMqtsdnvRttQ0YRruMtyr3yP5pBNB2qxJyGG9Vbm5JpNe2W5WMQl3GW5UcsX/LdqvSPjZg6kEjMZY24NhhqMpU2gAV2+VZj44frornD0hqiIelVV0e4SMSc2kDSNJGkHjz2yESuEmZx+Lbb7WKPl82hzTbxmGuf0VF3j6liWXSFHD1HXfvuIXLtaSrYzT0kVtgQAIrOpqqT3RcLcVUfAJyGGtPMIxW2WpPcM5wJ2qrPcH4ipitV+HoDm/sNtDp4uSJIauLonp7/pnVR5qTJ9bLczDOKsAbJZg8cJtDY6ekU7c/2ymN/Dmd1/i6U4Jb4dGOWzWhy1vhMK84pOixLUcsb05PYQbyHpaO5y01O1zXYofrWlzqdzmMXq43Z9tZ8JZ1ldnXbqXlSC3muPkcZlOAzWIWjjPAqX1dn7E0Gjbb6HJb+ggIphDiRRazEwO3ReWRPUr2C0t1OKhjFutBHbOYD+rs8CLcm84d5h8f/G8fdotRtN90i1G07UOEWNL65Wvoh680dthbcF/H9OgDZ36cN6pyKled+UbN5uWLhxGVCWg89udNv8/x8jE5Lnt0IIXNo5ODg0cHkpg9Oigr3B5FQ/5mGgHoxBkMDaNChGa/UG0OfiFU/s/qF0IcVr9Qiw5+IRgDM/qFUPzK7hcyjw1yyUIrsTqG2nqdq3ctsdW85NbWz8coX9fsooIsZh8VbovVSYVZrF4qzEJj+dv2QgGwdPw4hir60xM4r7/jsTrNMI/da/aOx+o2ezPiRr/ZGxaj4wzOJqOPB05rq+sMkxh9ZzXkZW2ooTj4zmBLrP2KR9joPHtjtWbv2Rses/vsHY/VfwY3lTb/Gd6XmvxnsawfXCIsdZJHxmoinVFVPyCp4yJr7g/FuD4g2Y7YZcwf6uckNa7ndkWHUHRaD0Wn9VB09AhFR49QdE0O5bQijCwUlXMe67mJZJjMNF20veijevmApI4r+fHh2YBnkv0iw+le35bvVtFhzpjvhjmsuWrITLjO98S4xvMBRhed6vAKlZr7tbEpPC6PlFrQ2OT1XMSa13MRMYdxbBBHorFepW3TB6Q1O1hrdrDW7GCt+Jb/LHp+23OdPaEXq0tAvMBA53BWb243bfPPW74Cy+LlcX2llvNzdi153RtTUbDG6I2BHEZvTIWXv4zemIqCV0ZvTEWvcJm9MfaxqWhsoJWMdPGtKeUaSY7je7bwW71MEtZJMs/Nnso8fCGhYnQuUbrakplknfvllthqwts/B5HAzyljLc86rvLakv71loxnvvMWSXMguTp3tpNFHSQNWCy6oLSFXeYONkFFgcWgR9w3VwZiz+RgbZjEY4xrnJ+DVIlx6X/lIKDLPTtuXOSGzA0VZbI6gmr0cATBElVGRxDeKc0S95vNnB6pa8V+LXVrQz/V/QmLMSxZHbKZa3V4I6bW9TdiIId1n9Qc3oipbf2NmNo83oixjw3Seods5tpcpNEhVFQ9spmrRzZz9chmrj7ZzNUnDbl6pCFXjzTkuu70rw5pyNUhDbmih56sK2hvHitor+u96pGGXH3SkKtPGnL1SUN+4zOc1ycZVEVpgSDLKHF2Y6FLLMa9BTlc+YXlWfp02feEbk2ii1I86t9ue2Zw0bahMofE+VhJiXV26VND4MMA6t6lLqaZ+gckdaxfm5crnJO0mL/NIlmah6m1qyx1vj2lqxv9AQuqyzkW06oDRB9xqDcxqV3kiEElXKjZ9wcsKOXQmOGKO7bPGERPoGNRXXtqI4Fy8xLPhaN/wBE3jplry9rX/RI/BzQ8a08xK0N5bkrDFQZNkeY37QizHRm0A1avajPyVvVrpS990lC0KrY+I4lRL4TPeXYo6Xeug/1hGez03JS+LJGM6nPSqDazHSX5EsWMNm8/yzUK04egMhNmrYckZpXO9G0Wu9ZDFrPWozqFVq1HHFatxw9BWrUevaJs1nrYsUatT7i2tXWnhMJVttmT0FV96+zBJGa7L/XbLPbZA1nMswdtzK2zB27ujbMHXsAxzx70Ypd59sCOtc4elKJkX0SJl2cPyi6yLaKYwrSIvqGwfQg7yAAkMU9gTt9mscsAZDHLANrzWWUA7huNMsDkIQPcHGQAdqxVBlAqq30RRREv4+yBT/VaZw8kMdt9/TqLffZAFvPsQYEV6+xBHNbZAwM85tnTHC7U4o61zp6IHpvgGSZS7aD4/DVoS5CHO7ZkfdmytCfD7x7TGIa9bNMYZilZp3FxWb5a+zaLfRpDFvM07nF9GiMO6zRGHPZpjO5zmKcx7FiPadxHHLATgWmMgk0UR54SbfGX82nMLs7/vuzZSuzg/Mck1gnYQ/o2i3kaYxbrNO5hfS8LOYzTGHKYp3EPDntZ3LHWaQyzhidJ0r3yMpE7Kqm3Ra3Hevzw2MrzREZ5w+aJ3FFIxDiRUUzSPJEhiXkKRv42i30iR/aYyCjuZZ3IiMM6keE1L/NETg4FZXHHekzkPPNQctSvhL1MZFQbprRRj6h0nYryPJFRFqZ9IqflEE1CKULmiVw9AukdlUPxYbFPZMhinsjokpV1IsPLXsaJDC9JmicyuuxlnsiwY60TGbmHY55vQWX1JPSzj7lnmF2gnlyZH8P8AQcNKdB5pR9yjAepSL0Z/BkHj+o9Dy+/XOagqxyjP/hyf/DoD77cH3V8S73cH5rjan/od3Kv9sd8sKxe7o82vqVd7g/NcbU/2lCQVi+3ox6CuDmdLnL0EEaQKjhwXG7HuDLegQYlcij6A0nMdXY6bEocQ1P1W5+vLLCuIdc/0OWcywefY8zAfkNiS2/HJMb09gTfHraFMiGFLZSJKUybzebhxW0ujhvu32axbzYhi3mzibLsrZtNxGHdbMKbMubNJkonN282YcdaN5vNIx+oe8wej3yg5mL3LX6bxT57IIt59rSyPnsQh3X2tOIxe1DOpHn2tOhxVEOZY3P2JFYXs1J/qrzSO7o+G0eacI5F77aeSaChqHueqmufK5509KQCj4pUrEtjfUQxbhKyfvD+M4ow9nynrUjohQoKaT6L+XCueG4G8gjQuBpddEWqBZJ+RvLGysbFys3tFpGV4VcDRjJ6ye20JSGgGl1hXOLlqAtSvZAgU427/0OaEnPoLjQxnXcu9Lb02S1q3jx5WxIaZOXk6PF8Ux/gdSzbwaB7LKHdYQndvqZ9m8W6hL5hMS6hKcTlNALMYVtCMYd1Cd1Y1tMI3nSseQlFdh/ajBwqKXhOqU0BFmQcJ/yiLiK+UqBKx+NAXJL2mjxyZFSG1LqZTiEtX0PMwSGrFpOY53DK32axK0HKHkqQeF0JEq8rQWIPJUjdQQmSxzVE+KBKG52S9X3v5zKGKWR4EXHWXWnqFdbX6h4e8zgvX5KJzSERIXocZ7evqd9msc/jXD3mcQnr87iE9Xlcgsc8LtlhHmeHSzKxu8yesn5JJnik8QSX2VP6t1nss6d0j9lDaX32UFqfPZQ8Zg+Rw+wp/curYM4jHJIfMtufi/nCd9/CDP8HTmApReEdHxZuVGaQ6KziyRuOWbyWe6oXOaZzqxPgQAY7XCg9XTb6UZG0V1qfOJAD6VoedVc2mYwXSXZv/J0kwCvJzWHywXKIMc8CPaVdbEqMY3RibHSVRfmUcr/cFpolh0iV9f6UhWd5uNYvf9GUtpzQF9XlHG7MYV0zqkMOdwr162abhyrFTPVqpxh1CXIYdck4OJADbqmN3wI5jN9i3NpXunjyMmrsmzOgVWObh7E2F41tLhrbXDS2uWhsc9HY5qKx3UFju4PGdheN7V83W7PGdgeN7Q4a2x00Frofjd8COYzfYnSDAg7spTZq7Bt/uVFjo8OlLkxi1tg3LEaNxSxWjcUsVo19w2LU2DdfZNTYGNc1FnIYNRZymDU2xq+brVVjcafYdAlz2HTJOjj4fB3XNRZyGDXWGHRGHDAnwOorwNkJVo1NHsaaXDQ2uWhsctHY5KKxyUVjk4vGZgeNzQ4am100Nn/dbM0amx00NjtobF7W2Dc5qaZvecNh+hZzbizqj+ahsc1FY4uHsRYXjS0uGltcNLa4aGxx0djiorHkoLHkoLHkorH0dbM1ayw5aCw5aCw5aGxN6xpb07rG1vWYF7xcZdbY5KGxHjGv6BLzii4xr+gS84ouMa/oEvOKLjGv6BDzig4xr+gS84r162Zr1liHmFd0iHlFh5gXvj43y6Cxyvn46P7qfNxQv3rw0ZVg27M9b0iMLzvhsiDGNQe/I21bc4zlSeDYZoc1B9exsa45PTlMXkRiX3Mwi3XNgSzmNQeymNcczGJdc/AXWdec3tfXnN7X15zuUGIrpfB1szWvObBTjGsO5DCuOcbBgdoW+7rGxr6usXH5W3CpPavGkkeexeakWzdWSGLW2DcsRo3FLFaNxSxWjX3DYtTYN19k1Ni0XsYQcxg1NkUXjU1fN1urxqZ1XXrDYdPYFB00NtC6xgZa19iwfkaBdYmtGosrJFs1NnsYa3bR2OyisdlFY7OLxmYXjc0uGpsdNDY7aGx20djydbM1a2x20NjsoLF5XWNxbX6bxmIOm8Za3whA/VE8/NPFwz+dyMNYyUVjyUVjyUVjyUVjyUVjyUVjyUFjyUFjyUVj+etma9ZYctBYctBYctBY+IyRUWMhh1Fjjc8pof6Ar11ZNRa/u2XV2OphrNVFY6uLxlYXja0uGltdNLa6aGx10NjqoLHVRWPb183WrLHVQWOrg8ZWB43ldV8B5jBqLK/7CpLDnYw3L4NaNdYj5pVcYl7JJeaVXGJeySXmlVxiXskl5pUcYl7JIeaVXGJeOXzdbM0a6xDzSg4xr7Qe83rzXrEpzwJTmPIs0OWSHHlU+Egqz+L17cqIqhcNc58DW55LS1FYX28orK83tHzPGj8Db65l4ZE7neP6MzKYxLzevGExrjeYxbreYBbrevOGxbjevPki43qT0/LrR5jDuN5ADvt6k75uttb1BneKbb3BHLb1xjo4UNvQtR+rxkIOo8ZCDqsPaF1jMYlZY7OHsWYXjc0uGptdNDa7aGx20djsorHFQWOLg8YWF40tXzdbs8YWB40tDhpb1jWW6+qe/g2FZU8fW+R1pY+8rvRxuaIGvDRkVnryyPTIHle6IIld6cnjlgxmMSs9edySecNiVXryuCWTef2WTDY6LulqO+xKz183W7PSr3uV33AYlX7dqxxRXXym8fwmz+rg25n+A4rSB0U5pwh9uRWQwtgKlORB7XjsOT3M3Zg/IOE+6iNzzxdJ2hT6HugaybZCjBeQQgKfQ+gplxyGUyyHli+y2OrVvuEw1at9x2GpV4vHpqqHg0q4OMAPJOUqSZok+XxoUkaF3HLq44nzHMtJl7zhyGPVy7mdlgHO8MEuB44Sx7eUFC8O73gzKFVdDvyzkRkPdm0hzqtKoltymaSNbfj28zLJ2ElAkr4s8X1d4QlVe+l7EOG+dAMNwRyjAv72s59zlOUFD3OY+gN5jqiO3qCqXy9L4QOOYaXbz4scbb4s19SofMbR5qPo+mXkjzjmmVU/vfsZx5grG93FdvR4WNj282p/dJoc5+MCL6bT3HJv55p1jlqucfA4PBemcJGjjqWhIhtD4cE5bTerB49wlIhfLxw9wkF5RvijloyzHXwOpMTlF2YbvENtew2keTxmVVL8Nov5MRDMYn0MpKTl92Uxh/H4DjnMx/eS1t+XfdOxxsdAUAKHfRLnsD6J37TEOIlzWp3EndYnMeQwT7/8dRb7JIYs5kmMgoTWSWwMNMJJjDjsk7hEh0kMO9Y4iWFllhDmW8TpfJe1fQ56TC6NZzIpqZemY3smAZ/DNc0KL8oT/kSCv2Y4AynUjr6menxN++7XxPFu6Pbz2q6R9jQt4cgpX+NIsx2JPDjqRY6W/nBcPuKo40SQ6uU+5dmn6SJHmhwlAEtdz+B4w2Hzn5f1DI7uENbrHlG94nFJC5KYo3pvWIxRPcxijephFmtU7w2LMar35ouMUb3C6znZkMO6o2CPnOxSv2621qge7hSjKvF6TrZ1cPCd57L+Lamsf0taruHcHEq9NY9Kb8XjihYksStsc1HY5qKwzUVhm4vCNheFbQ4K2xwUtrkobP+62ZoVtjkobHNQ2LassHDxy30YWnkI0NNFjn6No4zISSw5XuSY7pLCfJVjfksNFzmGO2xTxnyRow873XwEpxwVuPaI2vCnlWsM88DX80WGcfztZZFhC55cY6gjvhjaJQaOw5eQ+2obCrCqvDqakME0mpjBMpo2BjSakME0mojBNprGNoDRxBmwZewGtU8nxfSo/4Sq0BlTXjCHLV2FUDjDg8OW8oJTk8dymPKDdj/3Kdrp0/CWcwxnbkPYjDJzZvQ+5Q+awetOUEKxKqMTFH4NpWGom+fw9GswB40eIT7vkW3hRFf+qYTBQuEiizGBrzgk8JX1BD5CMmZKvYEMpsQbGDMwtQEymNrA6FJDH9ut3nX08SmCiTnmTrrr6vZPHNs2FV2/CYHHLjYEdZ79jMdqo8nBRtOyjeJoXVNHv5bP3w14wzLyiG4s+ZQFhZWsdoI5rHYSnewkOthJdLCTeM1O/rKBH//2829//eXvf/vx95///us/t3/37xvVbz//+J+//HSH//2vX/+m/tvf/98/jv/mP3/7+Zdffv4/f/3Hb3//20//9a/ffrox3f67H8L9//zH5kPa1srIOcS//OmHvP8nt/oZ2/+NaftP4v1/tMnx9n/59j+KUf5Xkff/VfvLv29N/f8="
    },
    {
      "name": "check_transfer",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "note_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 5,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 2,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                          "fields": [
                            {
                              "name": "log",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log::Log",
                                "fields": [
                                  {
                                    "name": "fields",
                                    "type": {
                                      "kind": "array",
                                      "length": 18,
                                      "type": {
                                        "kind": "field"
                                      }
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "note_hash_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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ui26Lbptum26bbptum26ZZbMX6ITD/ESozGz5OEgTuIibiLdjG5GN6Ob0c3p5nRzujndnG5ON6eb083p5nQ7dDt0O3Q7dDt0O3Q7dDt0O3Q7dLt0u3S7dLt0u3S7dLt0u3S7dLt0C7oF3YJuQbegW9At6BZ0C7pFu2XXZ+EgTuIibqIRnXiIl0i3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNN2bJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWTJTNxEIzrxEC8xGpElwEGcRLotui26Lbotui26Lbptum26bbptum26bbptum26bbptuhndjG5GN6Ob0c3oZnQzuhndjG5ON6eb083p5nRzujndnG5ON6fboduh26Hboduh26Hboduh26Hbodul26XbpdulG7LEE43oxHS7iZcYjcgS4CBO4iJuohGdSLegW5Tb+v1+xEGcxEXcRCM68RAvkW6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bbkY3o5vRzehmdDO6Gd2MbkY3o5vTzenmdHO6Od2cbk43p5vTzel26Hboduh26Hboduh26Hboduh26Hbpdul26Xbpdul26Xbpdul26XbpFnQLugXdgm5Bt6Bb0C3oFnRjlgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklqDv9fursgt9rw8v8XNb68PMkoeDOImLuIlGdOIhXiLdDt2QJSdxEhdxE43oxEO8xGhElgDpdul26Xbpdul26Xbpdul26RZ0C7oF3YJuQbegW9At6BZ0i3ZD3+vDQZzERdxEIzrxEC+RboNug26DboNug26DboNug26DboNuk26TbpNuk26ZJfk3etH3+tCJn9v7C7uXGI2ZJd8fWl7oe304iYu4iUZ04iFeYjRuum26bbptum26bbptum26bbptuhndjG5GN6Ob0c3oZnQzuhndjG5ON6eb083p5nRzujndnG5ON6fboduh26Hboduh26Hboduh26Hbodul26Xbpdul26Xbpdul26XbpdulW9At6BZ0C7oF3YJuQbegW9At2g19rw8HcRIXcRON6MRDvES6DboNug26DboNug26DboNug26DbpNuuEz4UicxEXcRCM68RAvMRrRXwKk26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptumm9HN6GZ0M7oZ3YxuRjejm9HN6OZ0c7o53ZxuTjenm9PN6eZ0c7oduh26Hboduh26Hboduh26Hbodul26Xbpdul26Xbpdul26Xbpdul26Bd2CbkG3oFvQLegWdAu6Bd2i3V7fK3AQJ3ERN9GITjzES6TboNugW2bJ9sRF3MS8U7iJTjzES4zGzJKHgziJi7iJdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdDO6Gd2MbkY3o5vRzehmdDO6Gd2cbk43p5vTzenmdHO6Od2cbk63Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7dLt0u3S7dLt0u3S7dLt0u3S7dLt6Bb0C3oFnQLugXdgm5Bt6BbtBv6Xh8O4iQu4iYa0YmHeIl0G3QbdBt0G3QbdGOWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZag7/X7k64Lfa8PozGz5OEgTuIibqIRnUi3SbdJt8yS7wudF/peH05iXttJ3EQjOvEQLzEakSXAQZxEum26bbptum26bbptuhndjG5GN6Ob0c3oZnQzuhndjG5ON6eb083p5nRzujndnG5ON6fboduh26Hboduh26Hboduh26Hbodul26Xbpdul26Xbpdul26XbpdulW9At6BZ0C7oF3YJuQbegW9At2g19rw8HcRIXcRON6MRDvES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26LbotujFLLrPkMksus+QySy6z5DJLLrPkMksus+QySy6z5DJLLrPkMksus+QySy6z5DJLLrPkMkvQ9+o30YhO/Nw8Ei8xGjNLzk4cxEn83I4lbqIRnXiIlxiNmSUPB3ES6Xboduh26JZZckfiJUZjZsnNdcgseTiJn9vNdcgseWjEz+37WrqFvteHl/i5Re5FZsnDQfxz+/vUNnERN9GITjzES4zC7HstHMRJXMRNNKITD/ES6TboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNum26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbpZnQzuhndjG5GN6Ob0c3oZnQzujndnG5ON6eb083p5nRzujndnG6Hboduh26Hboduh26Hboduh26Hbpdul26Xbpdul26Xbpdul26XbpduQbegG7MkmCXBLAlmSTBLglkSzJLoLNm/zpL96yzZv86S/ess2b/Okv3rLNm/zpL96yzZv86S/fvRbdBt0G3Q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",
      "verification_key": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJpAAAAAAAAAAAAAAAAAAAAfrdY\nAc4JkrVMhv6AnelxmBsAAAAAAAAAAAAAAAAAAAAAACEhWTiD200wu6AqaPgwLwAAAAAAAAAAAAAA\nAAAAAJD8mQXD+5vydEs5tmshrGcXAAAAAAAAAAAAAAAAAAAAAAAqWteETAnplY9KAiorIksAAAAA\nAAAAAAAAAAAAAADkPFCYYrrb7SW4CHEMLdtNzQAAAAAAAAAAAAAAAAAAAAAAFF2kIk71pLcNNwWp\nHIaUAAAAAAAAAAAAAAAAAAAAH80mLqBSGV0kNNPsk4jNgecAAAAAAAAAAAAAAAAAAAAAAA67Igd5\nM44cujDuizf9lAAAAAAAAAAAAAAAAAAAACnlqGO6APlWoT6N8JXYdNF1AAAAAAAAAAAAAAAAAAAA\nAAAIsM/f0dcYuJcJkzkOVjwAAAAAAAAAAAAAAAAAAAAlD3U/kHFPjIICTdYbY7CkqgAAAAAAAAAA\nAAAAAAAAAAAAB9uOu86iJrgNImrmjSMJAAAAAAAAAAAAAAAAAAAA6xLdX9L70deV2l6L3idxIHwA\nAAAAAAAAAAAAAAAAAAAAAAw3+KexDU/Yk3nZao4C8gAAAAAAAAAAAAAAAAAAAMFBtbD8uQ/4Ffov\nPaIkkZ/VAAAAAAAAAAAAAAAAAAAAAAAf+AIZmNYepeVZYKy5OgkAAAAAAAAAAAAAAAAAAABwyGeh\nIOrTJgYUeUUlstlcIwAAAAAAAAAAAAAAAAAAAAAAKwalS+Dbf0IJNtAtX7toAAAAAAAAAAAAAAAA\nAAAAI1koCAebY9rjled8jAlhQGgAAAAAAAAAAAAAAAAAAAAAAB01+1H2C7Ncut0XPDnOGQAAAAAA\nAAAAAAAAAAAAAMPnxtzhFxJBd+nNpzLV1utBAAAAAAAAAAAAAAAAAAAAAAAYghjugd438AKju5uO\nKaAAAAAAAAAAAAAAAAAAAAB9REOh7C6kvg0cR79R46p9lgAAAAAAAAAAAAAAAAAAAAAAJIOV5knW\nGgNvfiXt/f0+AAAAAAAAAAAAAAAAAAAAmgwq91f09SFJVigyejeFCvQAAAAAAAAAAAAAAAAAAAAA\nAAixVKJ/wMLrF0uVfVziuwAAAAAAAAAAAAAAAAAAAO0Qp7bTwCDWKpI7W9OWGR0TAAAAAAAAAAAA\nAAAAAAAAAAAiqKqwFC76lCbUvzIesCEAAAAAAAAAAAAAAAAAAACpYO0E7RgiavfiNMUPto6zLAAA\nAAAAAAAAAAAAAAAAAAAAH5TAAP1cwiS/0+cpUCw4AAAAAAAAAAAAAAAAAAAAf2bfOy4Wx90Wkg6C\np3acxZEAAAAAAAAAAAAAAAAAAAAAAAhRWG4qQOBJrmhi9vWEmgAAAAAAAAAAAAAAAAAAAIpCo1Qj\n9Zz8qKT9T0INeWQbAAAAAAAAAAAAAAAAAAAAAAATej0LRtDBCrzLJzRh8ngAAAAAAAAAAAAAAAAA\nAADIYSDnE4ymqGeVwEZrdfuRTQAAAAAAAAAAAAAAAAAAAAAALZ4vQZQjYBz49ukroZ17AAAAAAAA\nAAAAAAAAAAAAQLcBCzMjOr736XVyrdH2sB0AAAAAAAAAAAAAAAAAAAAAADBGfHeSetBaUC8vxlVZ\nzAAAAAAAAAAAAAAAAAAAANgKRUoi4jt05yjmEIrg064xAAAAAAAAAAAAAAAAAAAAAAAvTyFWW8hq\nRF+Y6RWejQQAAAAAAAAAAAAAAAAAAAD823syZBzNWnGGjnzT1yMg5AAAAAAAAAAAAAAAAAAAAAAA\nATDBDUq0HRHSx0+PInBuAAAAAAAAAAAAAAAAAAAAbGP6UV+RTMDMVJE9AtswcMAAAAAAAAAAAAAA\nAAAAAAAAAC8fAcvKUFeoLDHLV9S0EgAAAAAAAAAAAAAAAAAAACrCljqPxfDWxGjF4PGy/xrkAAAA\nAAAAAAAAAAAAAAAAAAAB+kqemFNv8lr9ZUhc1wsAAAAAAAAAAAAAAAAAAAA7RkR36Oe65E/1gWtv\nf7smZQAAAAAAAAAAAAAAAAAAAAAAHNq8fTDuve6Z/iP8f+D/AAAAAAAAAAAAAAAAAAAAu40KrxWt\nUHMUKc6dUA+L7eAAAAAAAAAAAAAAAAAAAAAAAAPZA6T2tVbVMvVGftb3XQAAAAAAAAAAAAAAAAAA\nAPxWP3hhvjWZAnc1CUBivFIAAAAAAAAAAAAAAAAAAAAAAAAfgzJHCuZ1H66fvaGxUxUAAAAAAAAA\nAAAAAAAAAAAMY7IjfOvtVyjeTIDniT72LgAAAAAAAAAAAAAAAAAAAAAAHFU92ldQqa8bpqenUn0n\nAAAAAAAAAAAAAAAAAAAA2s7dDzhaLYxjgvBMcskSqPoAAAAAAAAAAAAAAAAAAAAAACwkSwEk+X7A\nn66frBtBtQAAAAAAAAAAAAAAAAAAAAJIVtJiJAvWahQLKIzi79yHAAAAAAAAAAAAAAAAAAAAAAAL\nabvJPF5AB/U93yLX7r4AAAAAAAAAAAAAAAAAAABoUPj5QoYdXjbSZj8AnZmYQwAAAAAAAAAAAAAA\nAAAAAAAAAFka3hphCnd1Rr+yOHPpAAAAAAAAAAAAAAAAAAAAPEORwOvcUGyszhhyLD7GxJQAAAAA\nAAAAAAAAAAAAAAAAAAZyJNqOjF5vGhNh4t5vqwAAAAAAAAAAAAAAAAAAAKIEF+aKTl0ml3j+emTc\nghmIAAAAAAAAAAAAAAAAAAAAAAAQDjM8Cx8tYbt7hFYZqbYAAAAAAAAAAAAAAAAAAACSgjpAR3jK\nG+OrEnbR3G2gAgAAAAAAAAAAAAAAAAAAAAAAGQnpkZiaJ62ao7Qjaba5AAAAAAAAAAAAAAAAAAAA\nL6HF+LiESJdVZjTF3imKn1IAAAAAAAAAAAAAAAAAAAAAACGGdh8T950oo+6XT2w1FwAAAAAAAAAA\nAAAAAAAAANZvKzaUIyluDj+Rz57Ie0hDAAAAAAAAAAAAAAAAAAAAAAAV/lVB31Ysr7/AIVVfn6wA\nAAAAAAAAAAAAAAAAAACXlOeGum5lbuFLDbEptApO8wAAAAAAAAAAAAAAAAAAAAAAEUcJYow6NzlC\nRYA6wwHfAAAAAAAAAAAAAAAAAAAAg1XjUushtu7XbXBWAy17qZAAAAAAAAAAAAAAAAAAAAAAAAhW\ntBSfwOCxr8izvQOEYAAAAAAAAAAAAAAAAAAAAECby/V/2PRggsvuPxmr8dBqAAAAAAAAAAAAAAAA\nAAAAAAAABwgFoHMGXvCjNgqsVGYAAAAAAAAAAAAAAAAAAAAuxulxRTKgN8CIDKY5CQcYCQAAAAAA\nAAAAAAAAAAAAAAAABipixGGXoC5ZMjRtTa8OAAAAAAAAAAAAAAAAAAAARVW2bVDmIazQ4aHfCofy\n/QgAAAAAAAAAAAAAAAAAAAAAABXR7a8fopQZMLViWVUdOwAAAAAAAAAAAAAAAAAAAOJJjtvsd2/O\n6cm+bw+csTFpAAAAAAAAAAAAAAAAAAAAAAASykzNIS3eP1lQ44O+s1cAAAAAAAAAAAAAAAAAAADQ\njXQVcq1lVf4BzWXMWPY+PQAAAAAAAAAAAAAAAAAAAAAACqBIr/6AWBkKfdN/Ti1iAAAAAAAAAAAA\nAAAAAAAAh/Q32ep0myUJ7wuDzZvaE6MAAAAAAAAAAAAAAAAAAAAAABIQtybr6VkmFCwcyI/kXAAA\nAAAAAAAAAAAAAAAAANGEC5zhrL0kP3tfgSbjW6O3AAAAAAAAAAAAAAAAAAAAAAAYu8GVgnL1lFLZ\n0JVlZHIAAAAAAAAAAAAAAAAAAACttiWSF2W7gjiL0XAhEuMbagAAAAAAAAAAAAAAAAAAAAAAKj/e\nimCSKqiuKwgEKDcEAAAAAAAAAAAAAAAAAAAAGzOweqRnxLZwF7jNjHlsf9UAAAAAAAAAAAAAAAAA\nAAAAABALS4M9z+tiHsrN87GCeAAAAAAAAAAAAAAAAAAAAFizPZI63otdBEhBnUg0Xl+BAAAAAAAA\nAAAAAAAAAAAAAAAorT+MiWPqoo2xOyPO9TIAAAAAAAAAAAAAAAAAAACe1XxR9U4oXDTtSWep/t/5\nwAAAAAAAAAAAAAAAAAAAAAAAHhXa0jS1bGGnpVJQqKzmAAAAAAAAAAAAAAAAAAAAYx8/ayUS6OK6\nwi4J3r8TDiwAAAAAAAAAAAAAAAAAAAAAACGqgNoJupA1TkV9PQbJGAAAAAAAAAAAAAAAAAAAAHTR\n02JqV4LjEinXD7AjqxONAAAAAAAAAAAAAAAAAAAAAAAgveQqOWlou79Of2EQxiYAAAAAAAAAAAAA\nAAAAAAC/cOMgV5JmbRB4Lfgky4mDBQAAAAAAAAAAAAAAAAAAAAAALT7USRibmwMGX6XBt0h+AAAA\nAAAAAAAAAAAAAAAA70JLLYunou4TQHZUN+vS/1cAAAAAAAAAAAAAAAAAAAAAACKwd3QIwJ0gm8XB\nZkrCzQAAAAAAAAAAAAAAAAAAAGBSsDFWpMNlG2T75KQkCAAIAAAAAAAAAAAAAAAAAAAAAAAXpSn4\nAHnnpj3rkDGPgS8AAAAAAAAAAAAAAAAAAAAUkC2e5eP8MdkMvIKIdhOBegAAAAAAAAAAAAAAAAAA\nAAAAAZxwvhZxJTvWaKHUbFbrAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkXCH0nULMptGe\nJpq+0TRHtAAAAAAAAAAAAAAAAAAAAAAAHvHE8S35WyMpZ23B2K6qAAAAAAAAAAAAAAAAAAAAH00y\nD6RLMFzngRJ4Zcx9VXEAAAAAAAAAAAAAAAAAAAAAAATgmWlfYqWJw3cu4+eSEQAAAAAAAAAAAAAA\nAAAAAGvMegX/lalrKJQkxfczZw2WAAAAAAAAAAAAAAAAAAAAAAAAxDcm91tv2g3iLODg36sAAAAA\nAAAAAAAAAAAAAAAdCgnXF47JO614WPluZPC0jQAAAAAAAAAAAAAAAAAAAAAAL5tuC04sAZaN5cMk\ngqp9AAAAAAAAAAAAAAAAAAAAs8PPbbWlw3xztOqrx8K9tdUAAAAAAAAAAAAAAAAAAAAAAAGaqh23\nOphDKX3dUwWgOQAAAAAAAAAAAAAAAAAAAPMofO4kQhdTybsV1xRQMcptAAAAAAAAAAAAAAAAAAAA\nAAAFiSRi70jt/BTMpcaOrm4="
    },
    {
      "name": "process_message",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext",
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "TL3LsjS7jpz5LnvcgyRAXHhepQeyVl9kZVamMmtJo3p5rQAIuk+0P1edn45gBDwjI5G5/vOf/+f//a//67/9l3/77//ff/yPf/71f/7nP//1//+3f//3f/tv/+Xf/+P//r/+57/9x3//+//9z39+3/8T559/6f/xT/4J//vP+udf+fcf+edf6/f3X/37r/z9d//9d//91/751/cf7/9E/yf//o/fvz393/O7/133v3L/q/e/+/7X7n/9/jfuf+965663fr+BNSADOrAHbMAHYiAHZuU1K69Zec3Ka1Zes/KaldesvGblNSuvWVlmZZmVZVaWWVlmZZmVZVaWWVlmZZmVdVbWWVlnZZ2VdVbWWVlnZZ2VdVbWWXnPyntW3rPynpX3rLxn5T0r71l5z8p7VrZZ2WZlm5VtVrZZ2WZlm5VtVrZZ2WZln5V9VvZZ2Wdln5X9b2X5feADMZAD50L8BtaADOjAHpiVY1aOb+X1QQ6cC1+vNawBGdCBb+X9wbdyfuADMZAD58LXeg1/K6t8IAM6sAf+Vlb9wAdi4Fv527GvBz+QrwcbvpXPBzKgA3vABnwgBnLgXPh6sGFWXrPympXXrPz14F4f+EAM5MC58PVgwxqQAR3YA7OyzMoyK8usLLOyzso6K+usrLOyzso6K+usrLOyzso6K+9Zec/Ke1b+enDrB3vABnwgBnLgXPh6sGENyMCsbLOyzco2K9usbLOyzco+K/us7LOyz8o+K/us7LOyz8o+K/usHLNyzMoxK8esHLNyzMoxK8esHLNyzMo5K+esnLNyzso5K+esnLNyzso5K+esfGblMyufWfnMymdWPrPymZXPrHxm5XNX1t9vYA3IgA7sARvwgRjIgW/lv6bWrwcb1oAM6MAesAEfiIEcmJVlVpZZWWbl6sHzwR6wgb+VbX8QAzlwLnw92LAGZEAH9oANzMo6K+usrLPyvomkew3IgA7sARvwgRjIgZt1arOyzco2K9us/PWgxQc24AMxkAPnwteDDWtABnRgVvZZ2Wdln5V9Vv560P5eSvTrwYY1IAM6sAdswAdiIAdm5ZyVc1bOWfnrQbcP9oAN+EAM5MC58PVgwxqQgVn5zMpnVj6z8pmVz6x87sr79xtYAzKgA3vABnwgBnJgVl6z8pqV16y8ZuU1K69Zec3Ka1Zes/KalWVWlllZZmWZlWVWlllZZmWZlWVWlllZZ2WdlXVW1llZZ2WdlXVW1llZZ2WdlfesvGflPSvvWXnPyntW3rPynpX3rLxnZZuVbVa2WdlmZZuVbVa2WdlmZZuVbVb2WdlnZZ+VfVb2WdlnZZ+VfVb2Wdln5ZiVY1aOWTlm5ZiVY1aOWTlm5ZiVY1bOWTln5ZyVpwf39OCeHtzTg3t6cE8P7unBPT24pwf39OCeHtzTg3t6cE8P7unBPT24pwdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6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"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "10492081608786484886": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "13434471300436635949": {
            "error_kind": "string",
            "string": "Function _log_transfer can only be called internally"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBHJwAABAMnAgIEAScCAwQAHwoAAgADgEYuCIBGAAElAAAARSUAAABbKAIAAQSARycCAgQAOw4AAgABKACAQwQAAygAgEQBAAEoAIBFBAABJiUAAAQbKQIAAgD20deRCioBAgMkAgADAAAAeyMAAAJHLQgBAicCAwQEAAgBAwEnAwIEAQAiAgIDHzCAQ4BFAAMtCAEDAAABAgEtDgIDLQgBAgAAAQIBJwIEBAAtDgQCJwIGBActCAAHLQoDCC0KAgkACAAGACUAAARELQIAAC0KCAUBIgAFgEUABy0LBwYnAgcECC0IAAgtCgMJLQoCCgAIAAcAJQAABEQtAgAALQoJBQEiAAWARQAILQsIBycCCAQJLQgACS0KAwotCgILAAgACAAlAAAERC0CAAAtCgoFASIABYBFAAMtCwMCHAoCBQYcCgUDAB4CAAIBHgIABQAKKgIFCCQCAAgAAAFtJQAABLspAgACAEc1lPMnAggEBCcCCgQDACoICgktCAEFAAgBCQEnAwUEAQAiBQIJLQ4ICQAiCQIJLQ4ICScCCQQDACoFCQgtCggJLQ4GCQAiCQIJLQ4HCQAiCQIJLQ4DCQAiCQIJLQ4CCScCAgQEACIFAgctCwcGJwIIBAIAKgcIAzcLAAMABicCAwQAJwIGBAMAKgMGBS0IAQIACAEFAScDAgQBACICAgUtDgMFACIFAgUtDgMFJwIFBAMAKgIFAwAiAgIGLQsGBScCBwQCACoGBwM7DgAFAAMjAAACRycCAgJVJwIDAm4nAgQCaycCBQJvJwIGAncnAgcCICcCCAJzJwIJAmUnAgoCbCcCCwJjJwIMAnQnAg0CcicCDgJ7JwIPAn0tCAEQJwIRBBwACAERAScDEAQBACIQAhEtChESLQ4CEgAiEgISLQ4DEgAiEgISLQ4EEgAiEgISLQ4DEgAiEgISLQ4FEgAiEgISLQ4GEgAiEgISLQ4DEgAiEgISLQ4HEgAiEgISLQ4IEgAiEgISLQ4JEgAiEgISLQ4KEgAiEgISLQ4JEgAiEgISLQ4LEgAiEgISLQ4MEgAiEgISLQ4FEgAiEgISLQ4NEgAiEgISLQ4HEgAiEgISLQ4OEgAiEgISLQ4IEgAiEgISLQ4JEgAiEgISLQ4KEgAiEgISLQ4JEgAiEgISLQ4LEgAiEgISLQ4MEgAiEgISLQ4FEgAiEgISLQ4NEgAiEgISLQ4PEicCAgEAJwIDAAELIgACgEQABCQCAAQAAAQbJwIFBB4tCAEGJwIHBB4ACAEHAS0KBgcqAwAHBZGbXKI+IJ6WACIHAgcAIhACCCcCCQQbLgIACIADLgIAB4AELgIACYAFJQAABM0nAggEGwAqBwgHLQ4DBwAiBwIHLQ4BBwAiBwIHPA4FBigAgAQEeAANAAAAgASAAyQAgAMAAARDKgEAAQX3ofOvpa3UyjwEAgEmJQAABBstCwIDLQsBBA0iAAOAQwAFJAIABQAABGYlAAAFEwAiBAIGACoGAwctCwcFLQgBBicCBwQCAAgBBwEnAwYEAQAiBgIHLQoHCC0OBQgBIgADgEUABQ4qAwUHJAIABwAABK4lAAAFJS0OBAEtDgUCLQoGASYqAQABBbpw1HgHtLEtPAQCASYBAIADgAWABy4AgAOACC4AgASACQsAgAiAB4AKJACACgAABRIuAYAIgAYuBIAGgAkBAIAIAAKACAEAgAkAAoAJIwAABOEmKgEAAQXFa8RaDhAAAjwEAgEmKgEAAQVFp8pxGUHkFTwEAgEm",
      "debug_symbols": "tZjRbuM4DEX/Jc95kEhJpPorg6JI23QQIEiLTLvAosi/r2jxKsksbGSzmJfy6Nq+oihFcv29et0+f/182h3e3n+tHn58r56Pu/1+9/Np//6y+dy9H5r6vQr2p5bVQ1yvYsg9Eq8e2KL0yOTR28nbydu5PZcs1h5L8qg9CnmUHtXb2votLdboMXusU6TAHrXH6O0oPVJ7Ti3WHtmvs99veU6x90M5eOz9UPG25TvF9lwMDaQ4qN+h/oR6ZtV7qj0TDuTR2zF6tIq2krKVtEO7I1IDK2oHU+xmSzdWg6ZQ654zOVimHZohtZqzJEB1UCgKxbLsoB1SYACUSABxsKp2KA4MhTPAu0gpAWCY0UWGYUEXxQxzA4kAKFboDtmhQrHVSa0+OUQAlAjF6jwBBQAUhsIJUB0SA9RhSl4N1GFKfgJxEChqN4uBOlQo1ZUSGAAlQolQCApBYSgMJUFJUDKUqc4GU6oTQBEoAkUjIDtMdZ4gAWoHQfKC5CUSwA2FIqA4cABkAAxTAsAQoxCMQjAKKTAUdCEwVHShMFR0gSkQTIEGAngXGiPAu1AKgAxwQ+UEgCHmQhMMM7rIMCzoosBQ0IXAUNAFFpJiIWmFYfUuaogA76LGAMiAZshtl6iUAFCmrdsgZQfbDDvg5oybCxTbECewZdOhOFQo1ZUYrNBOCoppUAXR0GhotuKdxrNp+CUBWT3YzqhoBWGaKIPst9WJxlVbl2ynVLRtzGloyaqQJkqDKigPLQ+tDG2qzkT2O+NsZCvTKYNsSTqpE021yqfTeoXj+OnzuN3aaXxxPrdT+2Nz3B4+Vw+Hr/1+vfprs/+abvr1sTlM8XNzbFdbbbaH1xab4dtuvzU6rc9Ph/lHU0jsT6dQ0jBos3irBVFStyCOddaC5i04pYg0GudzHkI3p8E5IY1E941ERxakHGct8ryFVkxGDXkYsPLNBqLDQGcNZGEQIhWDEL2wKDdbtMUt0T1sedPZhK9N6h/Ng1KiMaU5/n+LOmsRlhanwKK9kunsqrC1M1tRIsW8thfsUC5c9NolLbjUzEilcQpzP5O4sMDay6hkjIe4zpssjocjncfDND+epXXWjukCF6k1z6aii+MJeh4PpfvGczU/nObHs+BCsYz9oy284ZF/2wjjvEWlgIrU9p/NeSz52mJhM23v6ZiaxFrmyrFsweVsUWctFtYqc65jmXGhcseWzsLYTRvSPVs6F6WzBc8fTrK0AejYyrj9Z3LP6dQmZZyzl7+5f+WxsKOObUhkPJ9u3sbKSKBcnK+/HyxLBhVnglzsX//FQM8GcpdBwTQU0XsMxKa5Z5D42uCxNTcvu+PVB5KTWR13m+f91ptvX4eXi6uff3/gCj6wfBzfX7avX8etOZ2/srS3wB/tU8Sacnm0V1lrtr2EolozWrOENRV6PFky/wA="
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+y9CZxdVZUuvm/VrSIXKrlJmCFAMYQZwhhCAFNhMIQ5jAKKVSQR0ECAJCq2QymgokCYZXCoAkFUcHjatna/7n932/bw7OF120+f3ba2bXer3Y6tPan9+u8hZ1V997vf2Xefc/at3JBzfj/IqbP3/tbea6+19tprD7fmtjzz03833HbT6lfefOsNrx3buPaVGzb+8v/J11qaWncFn1pHMl9ctiVlVpqjD0r2//K/YRdGaBZRzFd+/OpZDJirvOuflZYpRn9L+5MyBdvvBtN/rx6fLo91MdwdfvnfTvB+ENEvw78y9Z/vqbP1zRnj0/mHXdAzJRdnjouyP93wlWe+eM+nfu/ZjR96+pF5fzX7sZ2O3PEtd975w71/sODxH935lJU9a3y6TnWXr0+T56XjhcpP1X3FeKHyfVb+7PHpj8P28pJf67/q+k/+bP1OK27/+Ov+6qsXbJq9YOx393vn01d94f79vvvKt1vZlarsd+5+4i3Njz8wMXzEn/zr4IrN33vlT1YOLPmrP3njnp9/2y+++6MHrew5quxfXPWLv/l088E3vP6ez/3KkkN3Hnvuwa/8+J/+4Isfa/7km8/f8pUTrey549NtLmIHzhsvVH6ulT9/3LXX/a0ffPZvlt/zJ8d86xc7vuv8sTtef/y7v3TF99+wx4cW/sOrn1/w3Dwre4Eq+3cbz7h/4+43Lv7+rD+759jJvff5xk8/9Olv/9tta5d879vf+cz+P7GyF6qyHR4re9F4e9k9jjvk5Jsf/d+7fO3QA/565LefO/qhPX960Klf++zZkz/62R/9B5RdJcpmPDWme/H4dEIOXk/J5yXjhcrXrfyl44XK91v5y8any9dcflm7fLxQ+Sn6V4wXKj/Fv5eNT38cdkHPgJW9cry97OGnNn709LvefKf72w/9873/dvj/HDlq3r7L5x39l098ee+bbr16zx9Z2avGp+udg+8LdnRbxp43pGN/Mh7ZOLRp4w3rbth42/ING9beuvGM9TfePLbxhmvXrb3w1rHV69ZevvbWDTesv4kBa/T3GeP6e0Jn11Y6K9ZuPH3d+tWvuWDTjdeuvbVGoDVBwBrrBPjObeCX3nDj2l/6OTfezBB9GdD1DOg926DPWH/Txl9yZePyNWtuXbthQ1Yda87/JODz2sBTTmfVrhjoGdeP3XDTyjUMOhAIai7GIOTPoS4XWfkdipVfa+VnFSt/q5VvFCv/Kiu/Y7Hy6638TsXK32jlh4qVv8HKzy5W/iYrP6dY+eusfLNY+WErP7dY+Q1Wfl6x8mNWfn6x8mus/M7Fyq+28rsUK/9aK79rsfK3DaX5d4OPZjMMe3f4nmNI2kdZeragiN+guuR1U2uEZ/S4fTZMWNv3EHVpijS2kXsIOnsIOgprh4hYsyJiNSJi7dijbdwpItZQRKzZEbHmRMRqRsSKyfuYOjS3R7HmRcSKKRMxeR9TvuZHxIqp2zFlYueIWDFt9C4RsXp1fDQ/a5ZIKxKa3qtY+X5ry574UdTJ8M3XQd+olvGvYXGa0WoQVs6613x1x/pxP+wJ9LCNWVh75sSaJdKK9MkennYhflkZ8rVd+buWf4Gnfph/Tpq2N5RfQHXfp1jd+6wue4m6LABMw0/8Bhsn0uDHmWuv3XTdeeuvY2wUXWQPNhvZ3ufaVXHvDCxHfzNmP+Dhk1R/t9bqv3TtxtXXXzp23XVr1/yyERuoQBvCmeP6+5BrFwLLU9LI9IUaBsNvuFIKVPMJhVLmhKs24KdcPW/92Jozxm7esGnd2j6Edq3TSuYKouI37ndM66dv/ZTvzPHWv231hfM5gWN094Y0xQnDNFXNkmHuld0EXfvWJ/LvRVh7iXJW935PecTAciwxPqkOkUprR/Iok2+0Q8IfBbVnl6LaUzb84eN18uAKMJv3HPR29skoYrILskCkGZaZ+wGnh4O9oQ2YH9+Tp07fPpL+23TtdttWB33DI37rgzp+kNqGvGc5KsNnxLN64TfEb7hSclvz9Su2j+VoQTF680P4jvUxXu8j0gxr3/RvlCPMvwDagPnxPXnq9O2z6b9N1y5zLEf7iPbgN5Sj/0FtQ96zHBXk8/JQOTL8hisltzVfv2L7WI4KupQjIXzH+hiv9xVphrVf+jfKEebfB9qA+fE9eer07ffTf5uuXeZYjvYV7cFvKEe/nb7PymjPsAt61qm+yFH+dbNcO69ylN9o5fcrVv76WZQ/Z/lfsfL7Fyt/jJU/oFj5N5lsHggf2Q4cBN/z7BQItQOG36C6FLUDBxE9bh8vyywUdWmKNF6WWSjoLBR0FNasiFg7RsTaOSLWDhGx5vYo1lBErNkRseZExGpGxFoQESum3Pcqv/aJiBVTVveNiLVfRKyYvI/ZxnkRsXpVVocjYu0fEct8Ixvv0T+opf/OEuXyzi0Rz+qJ3xC/QXXJSa/m4wu2j+c8BxejN69G5ZEeYlp9jNeHiDTDOjT9ewCwMP/B0AbMj+/JU6dvu6UMbxJm8vCc5xDRHvyGc565Ke4c0R6OL+WVVyzPPMRyLK9l+hPxrJ74DfEbrpR+1Hzyo/hi7TukGL25If2L9TFeHyrSDOuw9G+UV8x/CLQB8+N78tTp2yEkryjbLK+HivbgN5TX/WutbUPesxwV5PNZoXJk+A1XSm5rvn7F9rEcHVqM3pkhfMf6GK8PE2mGdXj6N8oR5j8U2oD58T156vTtRJIjlDmWo8NEe/AbytGiFHdWRnuGXdjDOmYYiI18CO+n2o9D5dDwG66UXNR8fFT6aO07vBC92o9YdpAeYlp9jNdHiDTDOjL9G+UQ8x8ObcD8+J48dfp2JskhYrLsHCHag99QDl9C9gx5z3JUjM/u9FA5MvyGKyO303Kk+lXpo7XviGL0lofwHetjvD5SpBnWUenfKEeY/whoA+bH9+Sp07eLSY5Q5tieHSnag99Qjs4je4btSZ5hF/TUVF/kKN/GW8QwbORVjn7+71A5NvyGa++3InJ8FNHL6gdr+9GiLk2RhjzGNKRztKBTYVVYFVaFVWFVWBXWto11eIX1osDaHuSr0qGqHys7UenjtopVyVclq9ujrFb+RMWvqo0V77dVrEpWK5nYHvlVyVfVj9sjVqVDlUxsj7yv7GqlQxW/KqxOWNXcqmpjZaMrWd1WsSr5qupVYVX6OJNtrLAqm1ONQ1UbqzZWNqfiV9WPlXxtu1hVrKNqY2VzKjtRYVVyX+lQxftKhyqsXpbVyp+oZKLifcX7mcSqxqGKX5UOVVidsHpdJuakf+OdYfx7Nep+rqM8dLC85RsS5Wrpv7NE/RI6wy7oCb63zPAbrr3NOejVfPxXfLG2LxJ1aYo07udFgs4iQafCKo91RI9iVW18cfBre6hXhfXi0MfKTlRYlaxW9n4m61X1Y9XGSr6qsWNbrVclExW/Kvmq+rHCqnSokontk/eVXa10qOJXhdUJq5pbVW2sbHQlq9sqViVfVb0qrEofZ7KNFVZlc6pxqGpj1cbK5lT8qvqxkq9tF6uKdVRtrGxOZScqrEruKx2qeF/pUIXVy7Ja+ROVTFS8r3g/k1jVOFTxq9KhCqsTViUTFVaFVWFVWBVWhVVhvdix1J1hyX/DLui5dJbAzlH+lVb+mGLlb7HyxxYr/3q7U+w4+FhL/zXs4+F7fzj2sTXCc2l5/Ib4DapLTnpT96kdT/S4fSYX1vYTRF2aIo1l5ARB5wRBR2HtFxFrh4hYzYhYO0fEWhARa15ErKGIWDtFxIopE/MjYi2KiDU3ItYxEbFmRcTaNyJWTN0ejogV0xbG1MfZEbFi9uMBEbFiykRM3sfU7ZhtjCkTO0bE6lU7EbNe24PPVI1pW4/3MfWxERErZhuP7dF6DUfEitlGG2vVXBjr3eHZxHNNw0DsE+F7jnnvS2qE55yeZxt+w7W3s8g8+0Sil8VXa/tiUZemSON59mJBZ7Ggo7D2i4i1Q0SsZo+2cSgi1uyIWPtGxIrJ++GIWFU/5sM6ICJWTJmYHxFrx4hYMe3X3IhYMXkfU1Zj8r5X7VdMWY0pXztFxIrZjzHlK6YOxZSvWRGx5vVoG3vVl4vZxpj+RK/2Y6/6csdGxOpVPyemj1n5Ey8OHYppJ2LWK6Z8HRMR6/iIWDF5H9MHsLHW4kDHQLla+m/JGNj+NcKzeuI3xG+49r6MFQPD9hlfrH2Li9EbDukHrI/x+iSRZlhL0r8HAAvzL4Y2YH58T546fbtocMu/TYF5CNXhJNEe/NYHdTwnxZ0j2sM6qfrlRIHbFOWZh1iO5bVgf/aHyqvhN1wp/aj55EfxRcmPlVX9yvwP7VcfFseNLT15ZolyOfhRD+W/4Tdcqf6u+fii7Ki1fYmoS9O16+CF49P5OK1ffOubYSzur+QZdt7HuqONF861y8HJ8D1HvwyEyoHhN1x7vxSRg5OJXhZPre1LRV2alJY83HdLBZ2lgs62goUyxDbK0pOnpFzMKyoXBe2RVy6U3bT2LS1Gb25IP2B9jNeniDTDOjX9G/0JzL8U2oD58T156vTtdvInEJP9iVNEe/Ab+hNvIn8C23MS4ap+OVngqvGMeYjlWF4L9mewHTP8hiulHzWf/Ci+KPmxsqpfmf+h/botYpn8LfXQyWsvsfxSD53FJeksDqSzpCSdJYLOkCjH+oT8Dpfv2t+G6pPhN1wp/a355Enxxdp3aiF6tW+wzUZ6iGn1MV6fJtIM6yXp32j/Mf+p0AbMj+/JU6dvHyH7j5hs/08T7cFvaP8/SPYf28Pzmbx6juWZh1iO5bVYf7pmqLwafsOV0Y9peVXyo/hi7TutGL05If2L9TFev0SkGday9G+UV8x/GrQB8+N78tTp22+QvKJssx/8EtEe/Iby+qsp7qyM9gy7oOcC1Rc5yn9zlmvnVY7yx1r5ZcXKT1j5kWLlD7Pyy4uV/6yVP71Y+bOs/BnFyn/Gyp9ZrPxbrfxZxcq/zMq/tFj5V1j5FcXKH2rlzy5W/ngrv7JY+e9Y+XOKlT/byp9brPznrPx5xcrfbOXPL1b+fit/QbHyZ1j5C4uV/1crf1Gx8g9a+VXFyv/Iyl8C5fPE8q38ZcXK91t9L8WPok6Gb2PhxZC/lvGvYXGa0WoQVs6613x1x/qxP3Up0MM2ZmFdmhNrlkgr0ieXuOx2If6Qpy6qnvvDe9k2z4+IdWpErFkRsU6LiPWSiFjLImKNRMRaHhFrMCLW6RGxzoiIdWaPYp0VEeulEbFWRMQ6OyLWyohY50TE2jUi1rkRsc6LiHV+RKwLImLFHDsujIh1UUSsVRGxDulBrOS5bHzLvyXjHStLxiuWloxXnF8yXnFJyXjD8pLxhhUl4wVnlowXnGe+9tnwsZb+q2IBOfz+C2qE55yePxl+g+qSk97U/Gkl0eP28brbOaIuTZHGOnKOoHOOoKOwZkfE2iUi1ryIWAsiYg1FxJofEasZEWuniFg7RMSa26NYMWV1TkSsmLxfFhErpqzG1Md9e7SNMfXx+IhYMXWoV3m/X0SsmHYi5lgb007E5H1MfvWqfMX0TWL2Y0zebw92Yjgi1khErNMjYi3vUawzImKdGRErJu8X9Wi9zoqINRgRK6ZMnBoR66URsWL2Y8x6xZTVkYhYMfl1dESsmLIasx9j1qtX+RVTVldExIopqzHt1wERsWL6X42IWDFjCjF98phzhZixR/PvLY59FpSrpf+WjOHPqRGe1RO/IX6D6pKTnjeGj+3jvdPnFKM3O6QfsD7G63NFmmHZ2i3uncb850AbMD++J0+dvv1FKtRNwkwe3jt9rmgPfuuDOv7xDq1tQ96zHBXk84JQOTL8hisltzVfv2L7eC1I9VNTpLHPHMpvhTUrItaOEbF2joi1Q0SsuT2KNRQRa3ZErDkRsZoRsc6LiBVTh2L24y4RseZFxNo3IlZM3Y4pXzF1KKZd3R54v1NErJg22myhnWtEf2Z3opPXN8fylq/keZiLS56HubzkeZYLS55Hean5VRfBx1r6rzprksPHe2uN8JzTPqXhN6guOelN+ZSriB63j33KS0RdmiKN9xep8xKXCDoKa3ZErF0iYs2LiLUgItZQRKz5EbGaEbHOi4g1KyJWTN73qqzuGxFrh4hYMeUrps3ZMSLW9sD7nXq0jXN7FCumbs+JiBWT98siYsWU1V71AWJiVeN2Pqxq3N568lWN21uP99W4vfV0u1fH7Zj86lVZPT4iVkx+xbQ5MXm/X0SsmDoUc9zuVRvdq/5EzDbG9H1j9mNM3m8PdmI4ItZgRKxzImLFjJOfGxHrjIhYR0fEOj0i1qKIWKdGxDo/Itb2wPuRiFjLI2KdGRErJr8uiIgVU1Zj6lCvyn2vtnF7sIUx61WNHS+OsePCiFgxfbmY/FoREeulEbGWR8SKKRMx+dWrY8cBEbFizvkaEbFirunEjAPEjE/E3J/DZ3Bwb1gt/bfknciza4Rn9cRviN+guuSkV/PxBdtnfCl5P/BQjcojPXUHsPH6MpFmWJenf+MZHMx/KbQB8+N78tTp2yGpsjUJM3n4DM5loj34rQ/quH+jtW3Ie5ajgnw+KFSO+D7rgnLrvc9a6ZfqVyvbFGkcnwrlt8KaFRFrx4hYO0fE2iEi1twexRqKiDU7ItaciFjNiFjnRcSaFxErpj7uGxErpnzF5NeCiFgx5SumDsW0qzFlIqZd7VXdjqmPMXVol4hYMfVxe5CvnSJixfQB+IwX+st8xivvHdpYPuv3Siw9eUr+ns39NcKzeuI3xG+49jYX8dkV/xVfrO2Xi7o0RRrH+y4XdC4XdBTW7IhYu0TEmhcRa0FErKGIWPMjYjUjYp0XEWtWRKyYvO9VWd03ItYOEbFiyldMm7NjRKztgfc79Wgb5/YoVkzdnhMRKybvl0XEiimrveoDxMTq1XE7Ju9j+gAxbXRMf6JXZbUat7eeXa188nxYlU++9eSr8gu3nnz1ql8Yk1+9KqvHR8SKya+YNicm7/eLiBVTh2KOHb1qo3t1TIvZxpi+b8x+jMn77cFODEfEGoyIdUZErHMiYh0dESvm+lBMfq2IiLUoItapEbHOj4gVUyZOj4gVk/cxdTumPsbUoXMjYsXUx+1BvkYiYi2PiHVmRKyY/LogIlZMWxjTRveq3PdqG7eHsTZmvSrf5MUxdlwYESumPxGTXzF98pdGxFoeESumTMTkV6+OHQdExIoZU2hExIq5bhUzzhQz/hVzfyGf0cS9rbX031miXEJn2AU9QzXCs3riN8RvUF1y0qv5+KL2SVv7rihGb6calUd6iGn1MV6/TKQZ1pXp33hGE/NfAW3A/PiePHX69my6QN8kzOThM5ovE+3Bb31Qxyd3bG0b8p7lqCCffydUjgy/4UrJbc3Xr0q/rH0vK0bvt0P4jvUxelcWo9dvfXW1wLa6vDz9G+UQ81u9+ig/vidPnb79T5KXq6Cc4TcpLXlYRjGtX3zr20pYVwss5Bvq9ydTXij9SP4bdkHPcWxXDAOxC8rKFaG6Z/gNV0oXamwHjV6WDVJyZGWbIu0MeC/T98n7vj2KtUNErJ0iYp0XESsmv4YiYs2OiDUnIlazR9u4Y4/Wa+eIWDH1MWY/zo+IFVOH5kbEitmPMWV1l4hYMeVrVkSsXSNixZT7XrU5Mds4HBFr/4hYB0TEismvmL5JTPnqVb8wptz3qi83LyLWgohY24Mv16tyH9M3qca0fFi96sv1qi2M6cvFtIUx+zEmv3rV/3pJRKxe9b8aEbFi6nZMHYrJr5jjUEwd6lXex7RfMeNyvRobiilfMX3fXvUxe3XsuCIilo0dQ4Rt6clTcr1pnxrhWT3xG+I3XHs7Y603YfuKrjfxfvhesYcx9ahXY+UxbVhMrGq9KR9WzNhcTB2K2Y8x1wNi+jq9GoeJKV8x69Wr6zq9GqOI2Y8x9yrEtPd89yr6Rnz3qvJDrvTQwfKWb0iUq6X/zhL1y+Ev3VkjPKsnfkP8hmtvcxH/TPFf8UXtbbOyTZHG+/h9+7eQjsKaHRFrl4hY8yJiLYiINRQRa35ErGZErPMiYs2KiBWT970qq/tGxNohIlZM+YpZr5j9GLNeMe1qTJmI2Y87RcSKyfu5PYoV007MiYgVk/fLImLFlNVe9SdiYlU+wNYbOyofYOvVq/IBtl4/Vj7A1rMTveoDxORXr8rq8RGxYvKrV+3EfhGxYupQr44dver79qp8xfSjY/ZjTN5vD3ZiOCLWYESscyJixYzfnxsR64yIWEdHxDo9ItaiHq1XzH6MWa9TI2LFlImY/TgSEWt5RKwzI2LF5NcFEbHOj4jVq7Ja6ePWa2Ovylc1DlVyz1gXRsSK6WPG7McVEbFeGhFreUSsmDIRk1+9qo8HRMSKORdtRMSKuW4VMz4RM24Scz+TxTps/yHO5RcTnUFBZ9BDB8tbvlmi3LALek6x/XtHw8ca4aI97g/HrtcIz6Xl8RviN6guOelN7V08jehx+4yn1vZloi5NkcYxmWWCzjJBpynS+B67GFizMuo57IKey1R/5yj/GuanYWDdRuB7jr7dI1SWRtL3hmvvvyKyNEL0svrF2r5c1KUp0riPlgs6ywUdhTU7ItZpPVqvHSNi7RMRK2YbmxGxdoqINTci1pyIWDH5tW9ErF0jYp0XEYt9r17h/VBErPk92sbhiFj7R8Sy+ctM+aqKzpKSdJYIOkOiXC39t6QvcmSN8Kye+A3xG669zbF8EcWXvL7IhfBeVp5ijtPHR8SKOU73qo3ZJSLWvIhYCyJibQ9jRa/6zTHrtXNErJh+TUxfN6ZMNCJixZSJWRGxYvIrpv3q1XlGzH6MWa9eHTti9mNM3sfU7e1pztJr/OrVcTumbndjrLX5ygiUq6X/zhLlujFXM/wG1SUnvZqPLyPwjedqZ4q6NEUarxufKeicKegorKGIWHMjYu0cEWvHiFi7RMTaISLWrB6t1/yIWM2IWMMRsfaPiHVARKyY/JodESumPu4bESum3Me0hTH7sRERK6bNiSkTO0XEisn7eT1ar/MiYsWUiZi+ScxxO2Y/9qr9iilfMfWxV210TKyY8jUnIpbx3tbvlkPaKqKzXNBZ7qGD5S2fmvcl/w27oOdanlcZBmLj/tQcc7zVNcJzTs8pDb/h2vlZZE65guhl9Z+1/RxRl6ZIOx3eMQ3pnCPoKKxjI2KdFxFrh4hYO0fE2rdH2zg/IlYzIlZMmZgXESumTJwWEWt7kInZEbF2jIjVq7odk/cx+dXo0TYuiIgVsx9jyv2ciFgx5X6/iFgxZWI4IlZMmaj8rxeHjY451i6KiLU92MIDImLFtDnLI2IdHxErpg7F5FfMMW3HiFi9yq/hiFi9OreKyfuYOhSTXzFtdDV2vDjGjphzqx0jYs2KiFXFFLaeDsXkfcw27hoRq1fnQzF5PxQRq1fjhcMRsSo7kQ8rpj9R2Ymtx/tetRPmf9kaKN4FUkv/tfXf0+F7jvXYgRrhWT3xG+I3qC456U2t/55O9Lh9vP67QtSlSWnJc8b4dD5O6xff+jxYF/Y4lu1fwL4/y7XSUXw+3UMHy1u+IVGO5a/g/oNTQuWP9x8UlHfv/gPFl7z7Dy6E97L6H3MeHdPG9erct1d9tJhj+44RsWK2MWZcK2Ybd4qIFdMX6tWYda/O5WLawiq28uKQiZjr6THla26PtrGKwVZ2Ynu0E1VsZevxfjgiVqVD+bAWRcSqdGjr8b7X45NzRJv5vr1Fgs4iDx0sv8hDZ0lJOksC6XSjPbNEuWHnfer2wnFRw0Zc7KtuxIQNv0F1yUmv5pNFFRO1tp8r6tKktOTh2Ou5gs65gs62gtVJdjkmnFd2zwqkU+l877RnltPj0LALet6gbEiO8kexjhoG1g1/EyiHvTgv1D4ZfsO160sR+3Q+0cvST2v7VaIuTZHGv+FxlaBzlaCjsHaMiLVvRKwdImI1I2LtFxFrXkSsuRGxYvIrZhtj1mtRRKyYsjorIlZM3Y7J+9k92sbKfr047FfMNsbk/c4RsWLK/fERsWLqdq/qY0wb3atjbcx+nB8Ra3sYh7aHNsasV0y72qvj9jk9Wq+Y/Do2ItZQRKyYvkmvjmmVPm69NvbquL09zNNiysTyiFi9KvfnRcTq1VjHLhGxumGj1ZoA35uVd00Ay/fCGseKknRW9Fh7qjWoqj3J+6qSdFYF0qnkoHfaU2Dfhj0n2NrgsfCxRri4HphjnXJOjfCc0+uiht+guuSkN7UueirR4/bxuuj5oi5NkYb9iGlI53xBpynSeK9FhVVhVVjFsHp4f5y51FO2Bm0T29mC+0+C98fx/pOCdt27/wTbx3b2KlEXnockD8tI0TlNr2Jt575I35/tfM2mwQ++YvVRh8w+68d7zH/o9mW/d8/blh1yJI/Hho24yMMcMlsP1RHDb7hSOlnzyYiyb9b2q0VdmpSWPHyvwNWCztWCTlPQYb+mDNYR6Xs1Z9iG9fSnG77yzBfv+dTvPbvxQ08/Mu+vZj+205E7vuXOO3+49w8WPP6jOz9YUhevsPJXFyu/s5V/ebHy8638K4qVn2flrylW/kwr/8pi5Zdb+dFC5WtTfT8GX4eDyk63/doptFx1H7Hyq4uV38/KrylW/v9Z+bWFytd+ZOVfVai8+y8rfx18HLaXl/xa/1XXf/Jn63dacfvHX/dXX71g0+wFY7+73zufvuoL9+/33Ve+w8peX4z2kJW/oVj5naz8q4uV39vKvwY+DgcVdX1Wdh3Q7gsvP8vK31is/GIrf1Ox8idZ+fVQPgfvhq38zcXKT7X/lkLla9+w8rdipdJ/D/ryr+/w7x/ZXP8f//dH61/3r4c/+L9W3PNbHz31gT856iXjl3zrkR+cb2U3FKLtZlv5jYJ2h3pP2bpNU1/yxbCs/Gtz03b9VvZ1+cvWrezrVdnv3P3EW5off2Bi+Ig/+dfBFZu/98qfrBxY8ld/8sY9P/+2X3z3Rw9Z2dtU2b+46hd/8+nmg294/T2f+5Ulh+489tyDX/nxP/3BFz/W/Mk3n7/lK1Ny/oY0e05+7WLlf6VY+QEr/8Zi5Qet/JuKld/Byr+5WPmGlX9LsfI7Wvlx+Djsgp6mlX2rKLvzse4r+33jxNuO2G3x+gtfe8c3Ln3+zbs8ddi3m3v8YNOpr/3Pr623sm8TZTs8Jw788n+vTzexmP9aSxOTf/eEd7ObyZOUM/91D8qTPHXKf97B0+XemNIbojIO3mdR+Zx9sSe2wR41ZzT8hmtve5E5Yx/R4/bxnLEu6tIUacPwjmlIpy7oKKwDImI1I2KdFxFrh4hYsyNizY+INdSjbZwTEatX5WteRKxZEbH2jYgVU75i8mtBRKyY8hVTh3aMiBVTJmLaVds7OyTK2ZhpfsAAfM8xLvfVCM/qid8QvyHqWcQPGCB6WXxJ7hS0MWHTxhvW3bDxtvPWj605Y+zmDZvWrUVvouZavSHmCqLit5prbT2m9dO3fsp39njr3+eOt5dzAhs9n90gTXHCMM37xDbtllEOeeHEtz6Rf4CwBkQ5q3u/p3zylJTKmpXfvVj5fh9vsU6GbxqWJR/4r2FxmtFqOM2zYRf01Hx1x/qx5dgN6GEbs7B2y4k1S6QV6ZMBT7sQf8hTF1VPlEXWId9Mw77v7qkX5p8jaFtZ4xHOCvNa4yweoS4YfmIdbYROreOZa6/ddN15669jbBRZZM8elM/MTZ/zmxvEcvT3HvStH/Dw8U1wQ9TO6pk8TcLCelQD6JanGkB9Et1LA6gyjCwxc8R33iKb1/1cJegpOpeVpHOZoDNLlBu2l7d+8Nm/WX7PnxzzrV/s+K7zx+54/fHv/tIV33/DHh9a+A+vfn7Bc/MT3n2XwnQ8COK79TuG6VR/1Sn/owuny30/pZdomBnnVMNO37TuNRev3XjrDWtfu/aXtniDo6eTWpw/3vr3BePt5dTj82OYvd0ydIYfyw9SoqXG5XyGjgUCueJcfENnPWhPEUPnMxCIqRR2IKNcVpuQD1mGSBmxGtXdZ8iSpxqatzz5JXZ7HppDJDZ0aM6S2KyhmcsNuGwJr1PeHdMwX0nJbokWch2rMWDLU40B28oY0C/KscSUjdA41+6EqvbPcu38GLaXv9t4xv0bd79x8fdn/dk9x07uvc83fvqhT3/7325bu+R73/7OZ/b/aUnturykVbgsKbdvahpUlCIr4pG1Vm1l65T/oHnT5Q5I3xPNS31j07zLx9bdsGZs49qzbrpl09pNa9dcsH7j2g3Lb1pz1mvX3rQxt0u8crz173PG28upZ0c33eBDCR8bmTymPJb/sPT7INDBPMwgy39oypRkMWB82ZZ3JXRWnyEqb+nJY0JxJNV92AU9wSbb8BtUl6Im+0iix+0rZrJRnJkriIrfWJ0xbSZM9lGQpjjBJhvbdFRGOZZc/tYn8h9JWEeKcmyyVXnEwHIsMaxFaGYOFbRZi04GLbp9WTbdQ107H1iTaoKead1RlDd5TOuOpjYNu6DnilCtM/wG1aWo1h1N9Lh9xbQOJQWpXE6olgfz4nM51Azz89/ce3VRjh92FI6mtORRFzXn4PL80F41/IYrJUVTvaoORWD7jP/WvmOK0ZtXo/JIDzGtPsbr40SaYZ2Q/o3aj/mPgTZgfnxPnjp9uzC1Dk3CfCFtvLUOx4n24DfctLeSHChsz97UtryHVbC871DM0SXpHB1IpxvtsX4ym3EDOItXEW+P9LRZjTZHBrb5SJdNZ++SdPYWdEwPcInuCErb05O2F6QdTWkHQhqvZx0E9TSZt7SFos2WdrAH8xCBmfTdzvOnyyT/LYV8aqRhr+ZkoIll8e8Byps8dhiwTnlfC3J107zWNmB/M6+Vnlka2jjmi7IvloY2i3l9ogfzJIGZtGfH+a35mF/JY7b+FPieZ7IZOpYZfoPqUnQsO4Xocft4LFtWjN5lNSqP9BDT6mO8HhFphnV2+jeOZZh/GbQB8+N78tTp2x00lo1AXh7LRkR78BuOZW8mvUDe1zL+NVz+xnYQeWP9Z3RQ1/eA+tw1r7UtqPf9oqwFQlj374RVuLtpTMHy3LdKj4q2f6loo4/PJeV551B9NfyGK2Ufaj79wfaxvo4Uozc/RL6xPsbrs0WaYa1M/0b5wvwj0AbMj+/JU6dv7yd9Rd1mfT1btAe/ob4+SvqKvC8rrz6bh7NO1NenSF9PgbR+UdYOLdcp/02gr8+QvqJ8ct92q/087h8dkQ76oXzwR8kCtt/4Z7wZgbSzqRzKKubD6A3K+kpBW+EbRifZ+PQ83bYs2RhJ33nsuwRk49cCZGOOy+7POa69D9BOZ9kXzP9yp9s1mJF/JKNdvwXRq7cva8W08ll+BI97lv93APOuZbqe2C70ozn4r+RB2UbF05WuM+0R+MZxdSs/6PyyyHb3DwVP1Xhs5YdEXXg8ZrkfdkHP6SH2AfEbrtT4WAvlNY/HK4vRW+6TE8RkXl8k0gzLdpeh3GP+ldAGzI/vyVOnb1+h8fgiyMvj8UWiPfgNx+M/p/EYeV92nFC61snmfo1s7gikKZtrl3DUKf+pYHO/QTZ3BMpz33ar/TxnXhmRDsoqj8erCIvbb/wz3qCsrqJyF0Ma5sPxGOX5YkFb4YeOx9+fp9uWJRtGi3Vpf5CNH5FsYPmziTcjkLaS0rCveTzuNA69kvJbvQed38+pU/5/94zHyndBueHx2PL/zDMeKzvjG4+VLCrbqHjKu35PFljIZx6PFU+x/SdT+6fqNX+6/b7x2Mqr+NzhlIbxOZ6nYHyO5wq4psD+PcbnjqI0jM+NUNpJkIYywvG53T3twbgvx4sx7strKgdC2jGUdhCkHUdpGPc9gdIw7nsipR0CaSdBWy3uy5tAdku/l9yfILeyZcXVOR/+61zYeMBHypDOkRHpIJZtpfStOBelwyvGSGeRoFNyjTB4P4nhN1y7Xhfxe9WapFqbyreyzatOyBVExW8119p6TPOtbCdPjP0kajVzkcC0kQLbdFxGOeSFE9/6RP5jCOsYUc7q3u8pjxhq5ZLbb9+z9pMYRp3yL4LR6m4arRUt5AePmFb3rJ1hXAfLfzzUYXyZxqxntGtRBuZL50/zY/F8jekEpmrXcdQursMxVAfLv1R4Ar7VfpfxDXWLy/LfSmYOpfwndGgP95PlH/H009GiDqiTzFOuA+c5LqMOZ4o6COt2xvqbb0utm6OHD1WwdWLO876bowVO1mP4iRSaRKo1nUWiHI9TKAFWNmm5/bjM1FHXdWs3rs1oe5+om6LZ5/QTMoYWXAsNHkMNP9YYqtbs1RjK61hYVq3/Yf/i353oJH1qPwaW9uklG9ffmtWloYNrTVTLuexBFkXOURle0sS0rSUGJxej5xUDNTXN50rxxi/kCqLiNx/nO/V2jPNJajPCyQLTXCls0ykZ5ToZuT6RfylhLRXlrO79nvKIgeVYYlhDslwpdjks/7UwNN2+TLfT/r4O3nnrbRc2tswL1aqttbEln1axaTUqcwnV8mBefOZCzTB/1rBoz3nj7eX4MZyQIbNgrw4V7dWyQ6bqVTWUldzesVONyiO9Xtuu9LpUfGNvV7qFQk0m+3fABOe29F1t9+ERSLkhapxrumyLyUdzknfeUogTRd4aeIwnLXRLIYcGi2wp/FMKWcbYCubrY7R8PIqiPI8Q1tkdsC4mLCzPy40rO2BdSlhqGYHdXSznW64ye8BLQcMu6Jkdau8Mv0F1KWrv1LIFto/t3api9IZqVB7pIabVx3idtcyW/HdJ+jfaO8y/CtqA+fE9eer07Qmyd7h0x/ZOLevhN7R3D5NOIu+L6iQvgWP/ddqeOUHBI7V9Dsten77zNo0dYQnxKbLXKJ/ct91qP9vPRRHp4JjBy8tKFrD9xj/jjVoetnIoq6xzStYvEbQVvmF0ko1Pztdty5INo1Wn/D88aLrcpz1j+UXEG+Sb70gL+0DKnmH+6ym/1XswI3/WsvlviABojcqrbS/JYz42B6x/CzB5eVnZTTXb8MmisrOKpxcTlpptYns4AKp4ivppeMzTL3iWl33bz9FX4+VYDN7yEjIuYIxQGgaeeVsM+mrsN6KvxnYYl5dRRv6U/GBrz5/TkmvBuY1ccmWdQh7iMjWmOTfdn+pod1OUP8xDZ2FJOgsFnZK8qpWM8U3deukLifpk2NLVv4bFaUYr1lF+VXdfP8SckymsWSKtSJ8s8rRL6bKqi6onLyrZFpBXpLHuRMe/Tb4fHuavUTsL3oK7OFReDL9BdSkqL+omVXXbrNoiY2WbIu1CeMc0pLOnoKOwdoyIdXxErNkRseZHxGpGxIrZxpj9GLONO/doG3eKiHVeRKwFEbF2iIi1b0SsoYhYMWUipj7G1KGYMhGTX3MiYs2NiBWT942IWDF5PysiVkx+xbSF8yJixeRXr9rCmPyKaXO2B58ppkzEHLdj8n6fiFgx5T4m7/eLiBWT9zHbGNNOxPQBYvJrOCLWAYQVOq+3/AeK/CpuZLFAjBNaWYuB4JGXHDGJPh8fDgRMwy/xiyrGnhMpn4XD+1w7i/fKwHL094n0rR/w8MErYLu4dfG4GuFxGxzhz/TWxbw7WC+Ad0xDOurWE4W1Y0SsnSJinRcRa0FErB0iYu0bEWsoIlZMmZgdEasZESumTMTk15yIWDH51YiIFZNfx0fEiimr8yNibQ/9OCsiVkx+xRyH5kXEismvXh2HYvIrpr2PKV8xbU5MfYwpEzF9ppi83yciVky5j8n7/SJixeR9zDbGtBO96n8NR8Q6IH1XB8UOIzpqDrvUQwfLLw3AUvNhyz8i8vtCMmqrfsmb0/p8/B4BTMMvEZIx9hxL+Tgkg125LAPL0d/H0reskAzvAvrf6dYAY2PB3VlyFx/vrsNQ0wlU/7yRQSy/p4fOXiXp7CXoDIly1u6SfAw+aWH4Ddfe5iKhLLW7UfGl5G63qZMWJwt6iGn14bOZyoSZvuCOZnXhk9IvVHu+KPbvU91ounbzxictQs1oUsev79zatqK7KxFXmecQeS1KB+XNduarnfOs575+V3TUbmbGwn7HHfQnUn7c2a0wj4B0zP/jtL8SN3dzapDVBWF4QuEnO3eu6yJRVz5t+OdwQuHfUkzFZ+t3JQcnU9qegq7CZNuZt+/2EnXwYWF/HUj5rS8GM/IbHved3dKhTkJY+Sz5OTmjDig/WIcs+alDHULlZ3CXznXFsgcSbcv/KZCfRoqpTlX45GcRpaH8GI/U2Ms76POOvVjeN8YfRWmq7r5xzrd7XPFI0bm8JJ3LBZ1ujw+XE50TI9JRp4LVdORl8N6ity5sOoLll3roLCxJZ6Ggo3yNgwGj5Cn8/pJTm6mTBSP4UdSJTxChT5RHDpBWg7By1r3mq7tvGjwC9PgHGBTWSE6skj8sMdUnvh+yQPwhT11UPUMumMdvvjbvGRHrGMJS+vcygWX5fT9WgPl9J/FLXkLe5+s7dVo/Qqjgcspnh/37XLuIj2RgOfr7cvqWFSpQZnRRRj2NbicziuVn2lwrOotL0lkcSGdJSTpLAumcVpLOaYF0Xmx8m6n2rChJZ0WPtefF1j+VnrbSqeS6kuvtpT1dvAYwOKxv+NvY71tOhfW3hQvj3p2GwXiakjxlLoy7k8Jr2B7Wi7yru1je8ik6S0rSWRJI58XWnmNL0jk2kM5M8e3UknRO7bH2zJQcnF+SzvmBdCp70Dvt8f22+Qu/A7mLponjEpa1EDAvJ9+x+3S5X6exAkNtg9TGvMsmWN63bMLLGdgGXhY8WGDWKA3rd7Cnflj+4IxyWJ/kKbmtYuripBOLlZ8K26pfO8E6Zf2OkaWrfw2L04xWg7Dytt1Xd6wf9xNeMsZbLhTWcTmxZom0In1ymKddiD/kqYuqJ8piFp1B+MYh66WeemF+0zGUTStbct7R5+svnFsYfomQtbHnCMrHu9uQxSdmYDn6+wj61ilkjd3P5uoQakMnNcDyh2Rg4Y/kqGGkTvmfSQ+qJkPB36RDgW+1t6SqHF/U5JS9q81nLpPHeK3uJ7SyakX5pfCOaUjnREFHYQ1FxJobEWvniFg7RsTaJSLWDhGxZvVoveZHxGpGxBqOiLV/RKwDImLF5NfsiFgx9XHfiFgx5T6mLYzZj42IWDH7Mab9ismv8yJizYuIFZNfMXUopj8Rk18LImJVdnXr2dWYvN8nIlZMuY/J+/0iYsXkfcw2xrQTcyJi9aq/+pKIWOavWuwB5+gce8gbNsPylq9kKLOvZEhpKuymwltYJw6vYztrGf8aFqcZrYZr53GRuISqu68fMFSGbczCWpoTK9a9/id62oX4Q566qHpyKLRMm48mLLV8oGJEeftuJsKqR4u6RA6rGnuOo3z202N9rp2tJ2ZgOfqbVbJTWBXFwHfohg/95T0Mg+V9h24WlaSzKJDOXiXp7BVIpxs/OaLo7FmSzp6BdM4qSecsQUetuuFhQl55S95xNXfTrq11OgrS1OrRgel7nfJ/Ytfpcq/ftZUHyB+7h3EO/Z28H0l1xhVP08EYV04innN6iDX8BtWl6BB7ENHj9llf5/sBWtZE5Aqi4reaa7doNagZfuMj0rtTOVvM6nfZj3HM6C6ENMUJwzQJwTYtzCiHvHDiW5/IfxBhHSTKWd37PeURA8uxxNToe9bPOhtGnfK/K9WqZPJ8Nx3dVbSQH8ZTlhM7Psx5uA6W/16ow/gyjVnPaBdr80L6G2XrjHFN/ymwMg/squk7QZ/bh6P3YEZ9sT2Y/xHggR2h7qc8XB/1DXmAZbP+xrz4I0D8t5LFQyn/IR3azv1v+d/n6f+9RB3wAmLmP9eB8+yWUYdJUQdhNc9Yf/NtqdV09NThXVk57iXuib0ETtZj3Hjh5zbTmjN3WDuYjv2tJCBpuS1BTrnS69ZuXJvRdh4R9syg2ef0M+R03ZJnlis1VgaPzYbfcFryhl3QU2PrafS4fbwsf5CoS1OkZWlpJzpJn9pyd9qnl2xcf2tWl4YO2spYcHlHZWviW/LgVdY2UOOUi6c8amaI33xTHsun6CwqSWdRIJ29StLZK5DOwpJ0FgbS2bMknT0FHcbKmkJcm77XKf/vgmHnX1Q9GurBmMljB4Etv4r8qE2ilr/T/SvMS4wi8b0oijbykgfCpTnr6jvEgvTVHTan5KzrxTNc16NFXbt4ECl4yNlaB5HyTQc5FotcQVT8VnOtrcc0HlkOpnwrx1v/LjIdVEeklgpMtf19WUY5lmz+1ifyn0JYp4hyVndfbBMxVKzVMFS55O/XizI+DQiR4ORhJ2ZZRKwRgVXytpZdQzXT8BtUl6KaqW7WGIFv3PaVoi5NkcZrBisFnZWCjsI6JiLWcZGwkoePC1ZYFVaFVWFta1hqnXaEyuH4abMPNTvgGWrePQ9Y3vIpOmeVpHOWoFN2r4Kio+qsbqlivo249vaMeOhg+RFqz1GQhoth++ymaeJMFsva7Zh1yv8eOM8yvFt2G5HPL7RrvL3Otq+zDmk5/Jo5yWz6AbplE32cgfFp3Cz9QR9uQ/qufInDKA37mm/Vy+qDw6kPjoM01QdWnzrlH4c+OIr6AMvzrXhKbxQ9lpHBjPzHUf0s/3FpnXAZQdVvaQY95Afy+Q0Z9BYDvbtAHl5o5/h0eaNdUu52VXI3AhlY7kL97lA55fNSKKccsTlKYKEccMTGyg863QeGx7cXLxd9Hirn3K+W/8zAfh1Jv3WjX5FX3K8qsqbGIZ8cYH8ZT5quvc+zIpGIhX0d0q9HCXzu1ws9/ao2VGA9uV8t/8WB/Yr7IF/AgbSy/Yq8CulXzM/9OiLyY78aT5qufZw8iLCUjfZFWFW/Yh+wjbb8r/D0q4py++yw5R/tATuMvArpV7USENqvbIdHIO0kSvPti5wpG71O9Dn7/GwXsuqn+FZycY/Xok/JqMYuoryjsjX6tksGluEk3zCsyiy35mZdSs8st/wbBMuVmmJ9lImy9pQ8Hh68KMDHw48qRs97PFyZ1LzHw/MOi10Q1eSx1YKaqBaXd4RVE98wTYkqrg+aqKrtkDhCb6KtiyhCIfdnK8/f8psHmuVdGF6d8t/pGYV8XnDysLW+SORHz5i3MWMbLqI0LLc0g07WZXU8Olr+uwNHR6PdjdERecSj4ypI6xf5md8Xi/yrIM9I+t6k/EqlkccXEZ1OpoPlX8mpmn0rb3yRy25vp1kZy9cIpK2kNDWbU7KA95knTx3SykZKsD0sCz5dSh7mjU92kDdN11lOUC9XEp0RQSdUFqwsRsNmATbSGXZBzyFGR60+GzYOrzn6bDXWyR41VNu3BtWl6FDdT/S4fTxU10VdmiLtDHjHNKRTF3QUVjMi1nkRseZFxJoVEWvfiFhDEbFi8mtBRKyY8jU7ItaOEbFiysQOEbFqEbHmRsSKKRM7R8SKKRM7RcSKaVdj6nZMWe1VuxpTJmLar5g6FFMmYvJrTkSsmPyaHxErpqzGrFc1bm89fsX0V2Pa6Jg+wPERsWLar16ViZh2olfHoZhzmJht3DUiVmVXXxz2K2Y/Lo+IFZNfvWpzetUvbETEiqmPMcfamP3Yq/7qOT1ar5h2db+IWDHtRK/a6Jj1isn7XrUTMX3y7WFeG3Pc3qVH6xVzXhuzH2PqY8w5TMy4b0ysmDLBOlRL/8Y8R8D74ZCO+e2HokquFa/htVjDQOyBgtg1wnOutZ6O8IcEPatXIyNt2Pmfn67+7Tkfe9cVz9WovNWFv/H+hEGRX61pG69QVnLw6lq1h8NoW1od0gYobQDSrA7Jv88ua63fYMH6hfAP8ZsiP59KC+2Lea5dj0yObF8M7kNb5Frp+H5wFOk0RfllHjoLS9JZKOgwVtYPyF2bvtcp/z2pXVD3hYyI+i0U9bP8vtMnWB/FGz7ZNAJYtYx/jQ5/Y76NQJ5FROfsiHRwr9XJRGdlRDrqFLvad1eWDu6r4tOMqyLSwT1aexKdiyPSwX2BhxGdSyLSuQTy4LW5yd+XQtqBgGH1uEzUw2zxFfA9hy2uh7QD8RtUl5z0pvZ3XUH0uH28v+tKUZemSHsNvGMa0rlS0FFYh0TEsr6d49r7mn/M9FJB51IPncWBdJaUpLNE0BkS5crqiOKN0bkiIh3UmSVE58qIdFAO9iA6V0WkcxXkOYLonCLqkPgDX9h9+nvy39WQ1k9lk8dO4tcp/6UHTZf7wxTTZBBtBdYRy6M/dploB9P7E5qzXANlctijljmnI6xOvPsz4t1lkBbCO8t/EvDuL4h32C7W7VFIu4LSxiDtSkpbDWmIgWkO2oDfWOawvOUbEuV4vFoD33P010CIbiB+w7W3uch4tYboYduTh+dua4vRqxu9Vwl6qh/mOs1TpG9YpmPKzl5DaWgbV1Ma2rMxSkP9PhzeETOrTeeOb/lXjV0s31i/EUobgbSzKQ39cD4Pgb4zn8XBNrN/a20eIJzksXlqnfL+C/w49w/Sd2Vv2I5fJrAt7WqRluAPLmhtC9oU5COmJU+/+OYbQ6/JwKq79jlf8rA9nJLB1MiaXI8Cbg5dus74MgYf2Q4VtAvXhdqhLJuI9VI2KiQe9dChP5j/kdU//2pe2+2zaWeK/CVtmoxHGW0Vj1pNaQOQZnVQ8aiCY8q1IfxD/KZIey285+mLpkjju1aLYrEtLIu1siCWxdzGoPwoYalzbThe8Ngw4qnXNR2wLiYsLM82bLQDFt9MdY1oI/sLnG9AYDPtIdfeNrZliN+NGMBo+t4QbSjiU40Svayxhu04lm2KtBF4xzSkMyboKKyVEbE4jhkjvqhk+DSqc94b27D8Sko7W9DhuWzy3nLj1B66Pij3OA9mv8DyL4R50lF7tLYfaft8Po61qLi0Ot+tYi0+OitK0lkh6HQ7Ls2xltGIdEYhzwqiMxaRDuobx1pWR6SD4yL76CtFHRKZPZ30YA2kKb28ZHzLv3XK//sHTpc7y6MHWEcsj7EWFTNieueQP17QD5SxFsPqxLvziHc451K8Yxti+T8MvLswhw1B33KU0pAfY5T2KkhDDExz0Ab8xjKH5S3fkChn/LX+ejV870asxfAbrr3NRfyCVxM9bHvy8LxkXTF6U7GWGwU91Q8Ya0GeIn3D4lgL2tmrKG0U0l5FaWOQtpbSUL851nJVhzaxP63q54tRby2f86pi9Lw+J7aviM+ZPPaDWjWRVtRPjIHFcbOt4QstKUlniaDzYvGFeN1pLCIdlINe84XeltMX4vF8yjeB8fzOGfCF3tUDvtDdkXyho4B3m4l36lcXFF9HKQ19lDFKQ17xOiBedtYvvvnWOplvWI7Hq4K+SbAvZPgNV0o+psYr5SOq8aqkrzflC60T9FQ/oC+EPFV+kc8X4vjCKKSxvzMGab5YLPtCKzu0yecL8d4sjF0kf+O+B17rsbx7gp49k+qZ2vt1+XhrGsr4pUD3w6SryBeOX4659rbjN9YrLG/5Yo5Nag2a41V5Y9RYfjWljQk6PKazff30Hro+aF9HoT5sXy3/DtDvv0Z9hrTZTmKd2UfL25+LA+msKElnhaDTbZ+GfbRu+TQcr1oTkQ6Ol+yjrY1IB8ch9tGuEXVIZPaPSQ9eBWkqXs/xKsv/7AHT5f7MowdYRyyPPtqoaAfT+0vy0QqOidJHM6xOvPsy8W4U0hTv2IZY/ncD776aw4bgmLya0pAfaygNYxmIgWkO2oDfWOawvOUbEuWMv9ZfN8L3bvhoht9w7W0u4qOFxo+sfTcVozflo60X9FQ/oI+GPEX6hsU+2hjkGaU0tI3rKA3t2aspDfWbfTSjl9Um9tFGoXzIeFNyv0dwvMrwG66dj0VkS/lC2D6OV60RdeG+SR6OV6m9ICrmqvp51MXD8u3zYl9I7Se7wkNncSCdJSXpLBF0ur1/eWvFq7rlc7Ev1C2fK9QXGtpz+jvastDx3PIfCeN5M8VU/jivFVl59IXGRDuY3i4pjZLxD+kL8RpUFu92I96NQVoI7yx/E3i3p4d3rNs47oxSWqifxL6pWqPCbz7/m31ILMfjVUHfJNgXMvyGa29zkfEqNH5U0teb8oVuEvRUP6AvpNbrEIt9IbSzY5Q2Cmns76A943U91G/2hQwzq03sC6k9Y4yFZ75VzInnHcel+pXo2jHpu9Jzo53k+yzlGwM6LNeVH7bl/XXwjmlIJ9R3ujIiVuWHTdPhb3n8sG75R+yHvdhiUqOiDomNWUW+hIpJjQJN9iUs/yf2ny53qceXCIlJjYl2ML0ryQ/rZkxqFNKQd1cH+GGjQCvLD3sQeHdNDj+siklN1xO/IX4Vk8qOSfn8sF6ISan6MVaoH2b5X0t2o6DfJO2GYVX+Wri/xud8yvhYV0XEqvy1aTr8rfLX4tAp4q89HMlfO2H/6XKPzoC/9r4e8Nc+EMlf2x149yTxDmn77hBgf03ta1e+HGJgmnNhcTMsv73Fzcbg27YeNxulNLSN7JOpcw4h/tqo87cpJG4WGuNimll+3RXjremW/zchvvYbFDdTZ+qTfGfs1ZoP5YPlv/LXtrz3anzN+lXdL8H+Wt57pxaLOis6S0rSWSLodPv+JPbXrolIB3X+xb7OOSrqkNiYrwWsc44Czax1zs8OT5f7xgysc/79DK5zjkIa8u4fI/lrTwxPl/uuh3es2zg2sn2p1jm3PNU6Z7a/5rvXCW1jrHXOazq0if01rJ/vriH75vPDpsqnPtUs165fZe2GYam9/iz/Be/SCPbXDL9BdSkq/6rv1J0S6hwl3zWGaRxfGxN0xgQdhXVVRCyfH1X5a610fP5at+67ZH+tW34h+2tjEemgvIX6a8N7TX9HW5z3rMqpw9PlDkwxfXttmV7oHn3LfyjZXRwnytpdvFuMbV3LvTTEu1FIUzYta4/+fsPT5Y4i3iFt1u1RSLuK0nBMZV8u5t5bLM98U3ORkudeg/01w2+4UvIxNV6p86Wj8I39tYLzhyl/LfQOC/TX1J2diOXz1/gcJdpGPiuJ9oxjJ2OQxv7alR3axP6akn0V48IzlRzjUuPSLNHGHH00J1QGDb/h2vldRAbVnRxqvE5+/3xh+r5p4w3rbth424q1Gy/adO26G1afu/a2DctvWnPR2K0bbxhbt3zNmlvXbtiAlUZC+AMxmI4P57H3EfEdMa7p0BgWBuyskEv2EIsv7FOX7BnWWAcsvrAPy2NZ/HvAtdfTDvv2BeCgomXV6xKqFyriasJa48FK3n/FtWJh+ayASxbWGwkLy/PiIgaLuJ7MLx9OlgHFer2J6pV1CD35b10HrJsJK+tyn+S/GztgvZmw1CSc/x5w7fVkfvlwkv9u6lCvt1C9sjbfJP+t74B1A2GpzTuGdUsHrOsJC8tjWfx7wLXXk/nlw0n+u7VDvTZQvW6BtFspDcstJTp5J2lYfqYmaUuJzq0R6dwKefaAcsnfGyFtFDB8h5hs8N8E37sRMDH8BtUlJ72pwX8T0eP2ccDkNlGXpkjjIMdtgs5tgo7CuiYi1kZqT+ZFQDQJK3qZzazh6XJ30iQMeXQrtVH5Meoy0hq1a1DkR7w65X9XWqfk4uq3pxdXKx25JqMuPJ76Ah2zXLt+dUNHDD/WhcAbiR63j3Vkk6hLU6SNwXuWLm4SdBTW6ohYfNFelo48FklHfrzfdLn39qCOTEbQEfShQnSkzOWRiGf1wW+IH0tHlC/r05GNoi5NkcYb65UubhR0FNarI2KF6sgnIunIX4GOfKqLOmL8DtURy//ZCDqCfnOIjpQJhiGe1Qe/IX4sHVGXpvl05NWiLk2RhnMmTEM6vsVxxLopIlaojvxBJB35POjI/+pBHfmznDqi6t6NuZeKXx0L71k88v0Az7GiPWqOdyy1J0tGvrqXro+SkeTd5u+8sP5JkJGveWSkFxZWTy1J51RB58WyEe5UovOqiHRwXOGF1VdHpIO2MvSC2h+THqyDNKUHFi+qU/6LQQ9+6tGDrJglLqz6Lqi1/P9JC6sFNx7JhVXD6sS7n0caZ04E3v2/HDYEfXq28ciPV1Eajskc91XxVfzGMoflLd+QKGf8tf7CuGU3FlYNv+Ha21zE1wo9+Gntu7UYvamFVTWXUP2AC6vIU6RvWL6FVb6sH23jTZSG9uxGSkP9DrmsH9vk2wiX57L+md5kVvay/k7+IvvxrxJ1UX0zDu+YhnR8P8SBWFdGxLI1hmqTWfu3XjwUsL34QsfuPf0d7XvoeG75v7zvdLkTUsxu+kInpzS2pi90CvGuqC/0OeDdSzy8q3yhbccXuqUYvSlfSK1h5/GF1Jr2i8EX6hf1w3yoeyqe5MS3moce0+gTZd/qWuuNaecTjbwxoPNFfbsY1+0P1a9tJa7La+hlYrEhPk/JDYzB/vhMbGA8H75F2kTb7+uHazz0Cq7l9Rk9394upJfY00HX3oedfggFaWB/Zel80f2Ur+qA5dtPyeuAr+6AxfspszYuY9odqf+S2OGNe7fmsb2Ar4c8r03fWaeQDy/sJaF86vKTGD+Ug3jOad3jH0UsuGHe+6OI6sBhIps7OL+MYB+NwftqeFeXZoXIrO+HdVR98vap2lSe5Hu7J9+YyKdoJX+PQJphsC9+V4qR8PlTy1rbiOVH4R3TkqdffPMdzrB8is7iknQWB9JZUpLOEkFnSJSrZfxrdPgb0xmBPBwbWBmRDsoYxwa6ddCNYwPdinVwbOBKUYdEZyZofjsGab7xgg+9XwXz26dofjsKtLN+4Cr0AJrlf5ZiA2j7ysYGDKsT7z5CvBuFtBDeWf7TgHfPe3g34lrTxiBtJaUhP/hwGo4NiIFpDtrgO4CG5be3A2hj8G1bPIA2AnlGKQ1tIx9AUz/MqWxQyA/5+Q6gjUB5K5scrkrVBQ5Xnbv2tsvH1t2wZmzjDetvunjtLZvWbthYB2Smjq1wTlvi0fQdcfip0d99lDZC6XjKQT2+0bTkFQfBnq/hN1x7LxTRnDGix+3jWf9qURd1VcXb4B3TkM5qQUdhXRERazR9r67ybP+W5yrP0Yh0RiHPi/0nm7O8lW+St4LHdkO8Fcv/9X2my/09eSs4amAdERs9vZWiHXXK/13y9ApG3aSnx6vvI5CGvPvnAN6NAK0s3v0O8O4HxDukzbqNfBqlNHXtj5qxIwamOedfnVcewQzsWgj29GZi14K6Gqfk1RdTnp7yLFU/oKeHPFUncX1XeY5Q2iik8QrRGKRdSWmo3yGeHrYpxNMz2TpF0LG0yyDtbEq7WrQ50bvBBa208eeiL0rf60R7QVpmlmvXhRx9ftoQ0TEMxL6iIHaovmSN51ivhkirB9Tl+L/7/K79r1rz4RqVt7rwtz7ARxnD/KeL/CXHgqVDRmN8ujyu/CRPHdKuoLQBSLM6JNHEZ5e11q/gis3SEP4pncT8/BOReX1ApIM6kgdrnmuVK9Qd0z/U71Xp+xDRtfTkKamDwfMgw2+4dh4UGVeUTcT28TxI8awp0viK3IsEnYsEHYV1SkQss82qn3kedIqgc4qHzmJRZ0VnSUk6SwSdIVGulvGv0eFvTEfxZqYj3hdFpINywPOgVRHprII8PA8aEXVIxv9TF0x/R7sV6stb/mvBl1/m8Smwjlge50Fni3YwvTPJByk4tsh5EO96GIE05N1LiXdnQ1oI7yz/WcC7lR7esW6ra6fUPOgiSkM/gWM9eedBWH57mwepMd7aN1qM3tQ8aEzQyzMPGoV3w+J5ENrZsylNzW+VPWOfC/Wb50Fnd2gTz4NU/SpfKNwX4utny/gvl0bE8vkolS/USqfyhYrRKeILvTGSL/SPC6bLvWUGfKE7esAXenskX+iPgHd3Ee+QNus28ol9IRXTUX4Sz+vznhbC8jOwczbYF5qJnbNqvIpxUi/5b1TQy9rJqniq/CKfLzRCaWqXnrJnV1Cazxcacf42+XwhLIt/D4i8y6C9mHcC9Oz3F2TTuti1pi2DtEsobQTSfPqJGMhftBWY/1pqg+X/UFrvJNb4mWUas89pGTX7o2KfI+m3WUYX0nLI7+8k9Xpg2TQdlJfkGRhvrTOOfz6fyvJfLPKjzLFveDGksT83IrDQvzB5VPyyOnaDX1iHEH6ptalQfo2k74pflxGW8n9H4JuPX1bHbvBrBDKE8Avz5+WX8UDx62rC6jTHOZfqatiDTtsE3s1s+T8PNoFvy/HZ+GUCG21jjTCwHQeKdgxRGpZNcH9tly3vMxXnYV9T3YQzAnlwfwLm/98wbnyLeDPqpp+Q9a0xkX8U8oxQe3AcHwvAOttDe7XIP+ahPQppvHdljP5W/oayA8abknZgQNkBjFexHRiFtH6RP4RXo5BnJH1Xa+FjlBYac+IbD0JjTngC4lsZcxJsxwh8Y90dEXVVcx01T/DJnu/qfCV7Ksaq9J/thtrvonSJ7cYopLHdsP7Mu0P9xzRHRRkpO0flvVWjUAcl31k7z3eAOPxPM2zbQE7Mf4fx6C7Q0eRR6+0lbUFd2YJRyMC2YAzS+kX+vHaT9Rb7htca1Lo58pR9AuPRoMiPeLxnri/t104+wSjVPTQG7pv3mT4kcrMwrUenvYmNfVrbrW5Z8O1NtPyHgjwPpe8x7cYqShuFND6FbGnO+eVM7aq3fL69sCX3gwfHUgw/1k3qY0QP2548HEspaDenYinqRMuooIexFOQp0jcsGwtm2q4hn0LsmlprUnv7WJ/RRrAdUHtR2UYoemgj0BdfSLqvbOSIwFU+C8av30gxHtQv1n/Ucdb/UUhjvwF5yH7DaqiL8nkMl39abRHYsNOJN0qWfX6s2luqfhJbnRpbG4B1lYe2OsW+1kNb/Ww818W5bJ1Uumi86cZ8A/0C1kXVT5g/hFeqn9TtLGspLVR3V1Maju+jlIayPZa+K/n0+fnJw7qbdWq8QWP3thIrOA9095XEm1E3/VSxgtZyVaygXXe7HStg+YwVK3hpFSvIHSu4Me2LXo4V3A627eYM25Y3VrAB5qlVrKAVa6ZiBW/ukVjBZGCs4M5IsYIPgjy/s4oV+J4qVkD0qljB1okVTHYpVnDqNhor+CjYsN+qYgVttLN0sooV5NPdGLGC3+pSrOBOGrux3nyOXumU0vkxSlM/uc79lxUrMNw65f9D0N2/Jt4o/VH7/0L1Z4Tao/THh+XbY6RuKnqVhzbWi29GZ11WZ9u7OI5K3UX9ZN312czkCeGV6id1My3fgKviXupMP9/eNAZprPMo2zjusnyqvU0j8M037uJeo3/OuF09C5f56fuFCTVuqBiK74yY0v9RSlO3qSlZZ7th/YmxAszPsQLL/12KFRS8CVXGCvjmfrxPQsk3z60s/3+Dbftehm0byIn5w8BYgfVjN3xq1He2BT4bnDx57SbrLfYN3+USerMa69mg0z5E1s2pP/PECtAesZ8xCmkcAxkTdH33HCVys8++W955rpO8Y6ygtm9ru1VcX/2CIcf1h+GGxnr6HtNurKY0tAN8Y6Yac5ScqRv5cAzlcmYHSt5gGBwr4NvlC94Imft2+Rg3SCf/rRP0sm50VjxVN4z7YgXdtGu+9ZBOfOW5O7aR9RltBNuBUUhj+zHmoafmd2gjfDYydL6BPss36d4uFWNVOj5KaSjvY5SGPGS/4dVQF+Xz4JiN+Q8BG7aUeKNk2efHqpv28ZZ8Xofx/QqvwvLFKW4S+W/00Fa/XsN1cS5bJ5UuGm+6Md9Av4B1UfWT+mULH69UPzUpP/Imr+6+mtLGII31GmXbZF7Jp8/PTx7WXXUWDv2BmbpdOWvszorzGS77vmeC7l5BvFH2eQy+5fU7ec6k5us+rFEPbZ/8KtpYLyzLtLmeVk7prvGmG7obc36geKX6qena9Zp1cATSRikN5xKsn6E3PeO4y/I56trbETrujgIu37a+WuCOwjfmpy/OqmRvTLRP6f8Ipal5lNIlthvq1y9ZzzBWgPk5VmD516Z9UfIXdmSsgH9VDuMZSr55bmX5fwVs2/UZtm0gJ+ZrUpxOsQLrx2741KjvbAt8Njh58tpN1lvsmzHCGhNYyFOOFRiPBp2OWRoer029FvqAYwUjUJ7jmqE3z49Rmvr1i0RuHqNYAeouxgreRLKn4vpoc1j2LP97QZ7Hyd+IYTc4bqliRr4xx/drtmpdQMmz2YGSc+ngWAH/GlPB2IT315jUfKek3ZyKFag5juoHjBV0+gUyX6ygm3bNtx7Sia88d8c2jrnWtBFIYzuANoLth28fg4qFoY3w2chQn2UMcCcoVoD6NeJa01DHWf9R3n1za/Yb1kFdlM+DYzbmfwps2GeIN0qWfX5sp/k6xz7VfN2H5YtTrBf5b/LQxnphWaadpZNKF4033ZhvoF/AuuiL0SRPCK9UPzUpP/Imr+6uozT1a4xKdzEG9pmMcRvbgeM2625W/PBNnjh/N36lmefW66EuvA7P4wDm/23Q3S8Rb+wXg50Lkwn1C8X4q8Nsp1Ambg3A8u0J2ijy3+qhjfXCskyb62nllO4ab7qhu6hvrLuqnzB/CK9UPzUpP/LG0kJ/MXo9pYX+YrTJvJJPtf6fdScP6wPuCeJfbVe20Cd7ncYslj01Zin9Z7uB+s92A2WU7Qb2LdsN/iVwzs+xAsv/TYoVoIyUjRVspDreAnVQ8s1zK8v/72Db/j7Dtg3kxPx2YKzA+rEbPjXqO9sCnw1Onrx2k/UW+4ZjOirugDzlWIHxaFDkR7w65f8XT6wA7dEtVHe0R+yDqNixskcYK9h1vy3vQ65ddzFW8J8ke2jT2F4kD8ue5d9jv+lyvyB/I4bdeDWloR1g31qNOUrO1FoRjqFczuyA2RWUxW7ECgy/4drbXCRWoPQPxweOFRS0m1Oxgk2CnuoHjBUgT5G+YfliBd20a8inELuG+Xnujm1kfUYbwXYAbQTbj1d56KGNQF/cbITPRob6LDg/P5ZiBahfrP+o46z/KO/sNyAP2W/YCHVRPg+O2Zh/P7BhxxFvlCz7/NjbRP5NkOdGag/K+m0BWDd5aN8u8t/moY31wrJMO0snlS4ab7ox30C/gHVR9RPmD+GV6qcm5Ufe5NXdjZSG4zvrNcq2ybyST5+fnzysuzeKuqI/sK3FCk4F3b2QeKPssy9WkHe+jjZsYwCWb77mk19FG+uFZZk219PK9VKsQPWTz8YqXql+arp2vWYdnMlYActnrFjBz/dqxX2xxQpCxnyMFWB+jhVY/lekfWH+J8pI2VjBJqojxjNC5vWWfwPYttEM2xYaK7D8q1OcrRkrQH1nW+CzwcmT126y3mLfbK1YwU3QB75YAcc1Y8cK7g+MFWzK8DnyxgoeAnl+ffrezVgB2gGOFagxR8mZihXgGMrlzA6UnEsHxwoMv+Ha21wkVqD0zxcrKGg3p2IFao6j+gFjBWougli9GCvoxFeeu6uYZt75BtuPIrGC+7sUK/hx6rOUjRWgvLPfgDxkv2ET1EX5PDhmY/4nwIZ9jHijZNnnx8aYr/uwfLGCO0T+2z20sV5Ylmln6eRMxwrQL2Bd9MVokieEV6qfmpQfeZNXdzdRGo7vrNco2xgD+1iXYgXsD3T6vXn2m9QeK9/8pNPeUd9eo3WUpvbqMx11B1jyviF9571Gnwv0qY12SXmf0+19NJ3mg3x2Bm0373lBHuN5JB4b8IzLV2lswFgU78nw3fXAZbEPBjPy834yy/+Hwmf3ybPv/FdeecY2lJVn1I3rqa2W/89mVp5nb215ZplFeeaYkJLnmmu3YWXiOX/Qg/L/je1I/v+xx+VfzSV88t8pRsLyj/7b1pD/T+SQ/40emkr+rW1Z8o/xRMz/bx75V/z1yX+nNUKf/N9GaVjuygw6KP/Y7yz/lv+/AuXfaHdD/pFHLP++eVPy5J3r8JoA+u8++ef12ljy/1gO+ff53kr+ra1Z8m94HC+fPbzlXyX/SgdH4VvZtS5swyZKw3JXZtDJ8udZ/i3/LsPTbfXJv9HuhvzHnL92ijOwP4+64ZN/XueIJf9vI/kfhXy+OxxDzrGrsypj1A51ZlOd6eMzmwcPT5c7ebgVU/lIq+FbN+a8PqxRD+1Od2MwbXU3BtfFiXpauS6e/xro9rlWxSvVT03Kj7xRujVKaaHnSnx35eF5MZbPUdfejlDdHQXcw2ktek0H3Lx3uI6m70r/11Ka7+7XvOfYlayPUd1xvc+J/LwWbflXDG/519Y3UEZyyLpci+a7avAcvpJvXruz/K8Y3vJv0sfnDGvMgZyY56c4ncbZSHfV1Lt9V00nu8l6q86m1ehvxFLrN6xng07PdQ2Pz3q/bHjLv53Wovk+DnVfk7JHqyltDNJwLfpXhre88xnd5B3Xol853Nruoncxvnl4uty16XtMuzFGaequA9+Yo+SsKcrjGMrlzA6UPAMevBZt+A3X3uYia9FK/9Q53ZJ2c2otWsUJVT/gWrQ6Q4tYvrXobto13z0+nfjKa8PYRtZntBG+u3fYfvju3xuDcuiLm43w2chRgTtEaVg2wR2m+Qbql+8+p5Bz7GrPHLYP5UbZMB6zMf+dw9PlHh1uxVSy7PNj14v8GAfn+4PUOXMflu98ve+sqKKtzu1wXZzL1kmli8abbsw30C9gXey0JhvCK9VPTcqPvMmru7y+rc6xK93F+DvLp8/PTx7WXXWPOvoDcwR939jtu4NmNaWhXvP9NGqNYRTyZN1P8eTwdLlfHW7FjH0/xSi1R+3f9WGNeWh3shujRLu6n6I1v+qnpmu3gbxXRN3XovSTYww4z+D5iBpzlHyOiXaMwjffuDsGuP+4Zytu7HsgR9N3pf+8V9R3f2TouM52A/uW7Qb7h5yfYwWW//PDW/41/xNlJIesy1gBj+N45kbJN8+tLP9Xh7f8m/Tx7w9rzIGcmH+U4nSKFUQax+vdHsc72U3WW+wbnj+qsRR5yrEC49Gg03EKw+P49l8Ob/m3U6wgj7+g4nfKHmGs4N+Ht7xzPDd5x1jBXw+3trtonOpnw9Plvp6+x7QbPt+a962qMUfJmdobiGMolzM7YHYFZbEbsQLDb7j2NheJFYTO3UvazalYgfLDVT9grAB5ivTxXHLyzLRd88VAO/GV5+7YRtZnXzwRbQTbj9Ueemgj0Bc3G+GzkaMCV/ksON/4Wuqz+PYfKR33nZNlv0HN53jcyNrTlHVOtrb/dLld9m/FjH2nFu/DV+dPfVi+GHunM7q+e4aqO7V0P6kzJ747tXy6yzEGHN9Zr1G2cX85y2enNVnWXbXGjP6AihXw717kjQconWc/Tfm+o6Ku7PvuC7p7LPEmdpxvlNqTN8435qHdKc43SrSrOF9rftVPIXE+/N2LMUoL1U/WeZRtHHdZPsdEO0bhW2is4AMUK1A2wSd7nfbTjKbvec+QsN3IGw9Qss52w/oTYwWYn2MFln9Z2hfmfxa8R0rGCm6hOmI8Q8l31pngy8C2nZ5h2/KeMz4rxZmh/du5z4L6bHDy5LWbrLdqjK/R34ilzoCxng06HbPMOi9wEfSB73f2OK6J9ohjIOpud2WPMFawIa0Hz3WSd4wVXEGyp+L6aHNY9iz/a0Ger0rfY9oN3uOkYkasP8755Uyt8+IYyuXMDpScSwfHCgy/4drbXCRWoPRPzXdK2s2pWEHo/XsYK1BzEcTyxQq6add86yGd+Mpzd2yj77eBfWsYbD98d/WjjUBffAPpvrKRowJX+Sy4X+FhihWgfrH+540HqLk1+w3qPll1NxHfJ/smsGH3EW+ULPv82E7zdd/9niF3apU59+S7L6TTnVpKJ5UuRrpvYqDbd+52ulOL/X/fnVqhust33ql4gNJdjIHdlzFuYztUvFL5AzjmX0Fj9xjk6+VYweOgu88Tb6pYQXs9q1hBa9pMxgpYPsdEO0bhW2is4OoqVpA7VvAbaV/0cqzgz8G2/VaGbcsbK/idFKeKFWy9WMEfQx9szVjBD9N6dIoVfIlkr2is4F9Anr+cvlexAvlUsQKiV8UKtk6s4Iek+7FiBau20VjBf4INGzqgFbOKFWTrZBUryKe7MWIFLJ+xYgVforF7DPKx7mLdRikt5hkE3JORdQZhtwOmyx1GvIl9BsG3//GmAKwxD+1OcQrf3iuODbDvsr2dQeC7QHDMYD3zxQpGIS3GGQSWzzHRDnWmcMi168MY4O7W5TMIvntHfGcQ2G744g8zfQbhpLQvevkMwvlg25Zm2La8ZxBOS3GqMwhb7wzC2dAHvlgBxzlGIS3GGYTXpPXodAbhQpK9omcQbgJ5vjh9j2k3qjMI1RmEF8DTf1+sZxDQRrAdGIW0GGcQXkO6r2xkqM+CZxCGPGcQfLHCUUqb6TMIm8CGvZN4U51ByNbJ6gxCPt3lNc3QdUtcQ3pnxriN7ShyBuFCGrtHId+Ya02bqX0F6nwm+74PgO4+TbyJva8gZL7uwxr10O60Psa0q30FrflVP4XsKxiDtFFKi72vgOVz1LW3I3TcHQXcL+/Riqtswih8y7uvwHcniW9fAduNXtpX8CmKFfTivoI/Atv2mQzblndfwecCYwXVvoJ2nsbaV/B7nljBGJTv9r6Cb1OsIGtfwRcz1ify7iv4J5DnPyV/I4bdqPYVVPsKXgBP/32x7isYg7Ru7yv4Num+spGhPgvuK/jj1MAoHWf976V9BT8GG1Y/sBWz2leQrZPVvoJ8uhtjXwHLZ6x9BewPrBa4owK3RvXF/L7fpVE2x7dfQflCap1zLIMO2gRs2yXjW/7ltZ9myudOPnU31+Jj/nZAp/mg8UT5Rr57/o2m2nNmmAnvP03z2VqahnO8I+D9cEjH/Eel/WJ+A7YzB7/PH4IyDjAQu14Qu0Z4zmk/D30aRS95GiKtHlCXI9/8uqP2u23gmBqVt7rwN5aXAZH/XJHfeDVIdR92Qc+5SqeMtqXVIY39QNQLq0OiS88ua63fQMH6hfAP8Zsi/4Xj0/ny9MU81yoLKO9m+/Du3LMpDW3mKKUpm+mLBbPdQXuKv8/Ba+mW/4QDp8utCBjD0K/txm/G+LB8vw/bae8Z01ZzTK6Lc9ljs9KPSHe5D3T7NyoUr1Q/qbVUjvGcDWn8O1GjkOa7I5rXZ1G20U9g+Yz1W1N30xiofCaf7HXymVj2Qn0mthu+e23zxnRYz9BmYn6O6Vr+y2i8LxgLkTFd3gu6DuqQJwb2GrBtL8uwbXnjalfPrP9Z7/Ze0E52k/XWtydgjcBScx7Ws0GnfV/Dq1P+V0EfcEwX7RHP+UYhzRfnYb8adQZjunel9Rhy7bqLMd0bSfbU3AdtDsue5b8b5Pnm9D2m3eB4D9oBjt+rMUfJWVOUxzGUy5kdKPl7LsExXcNvuPY2F4npKv1T87+SdnMqphsaQ8aYrlqjRixfTLebds03r+7EV46xqjVOZSPYDoxCGtuPMQ89tBHoi99Fuq9sZKjPsgZw30YxXdQv1v/Q/Z9jlKZiwTxuKBvGYzbmfxBs2DPEGyXLPj+203qkb43qlgAsX9ym094zpq32nnFdnMvWyS6urwx0e91Y8Ur1U5PyI2/y6i7HbccgzRcLxvWYZzLGbWwHjtusu2tFXdEf2NZiBZ8A3f18FStoo831rGIFrWkzGSv4fJdiBedVsYLcsYI/3wZiBd8G2/aXkWIFX6liBVNpWytW8Hc9EisYOGjLe6dYwXcjxQpmHTRd7ntVrMD3VLEColfFCrZOrMBshM9GFokVnL6NxgqaYMMOIN5UsYJsnaxiBfl0N0asgOUzVqyA/YGVAvcqgVtz7XbI8vv2f60W+ZEf/HvXo5DGPgGWOzuDjopBJA/v/7L8R6V87uRTG+1uyDvyiOVd2WzMz/xW80f0lXl+rfbiKXk3mlbnqwRmwvvDaWy4DPJd6lrTroY0PmOMe4/5N9BGIQ3rgf2EcnAK5DHcOuV/CYwNq0j3lAxfDd+4D3x9hvVRch0yr7nMQ7tT/zNtrBeWZdpcT5SHF2iNT6cZb7qhK2OYYXwat5OtSZ4QXql+UrrCft2lkHYZpfnuNMLfQOOzjyjbo+m7ks/LRDtOgW88Npwi6prg/tnurbjXCFyf7I2K/KjHLHtXi/Yp/We7MQppbDdQRtluYN+y3cD5vhP5ORZl+V+Z9oXNb1BGcsi6jEWtpTquhjoo+ea5u+XfBLbt2gzbNpATc23guGn92I0520yOm6y32DdXE9bVAgt5yj6V8WjQaR/J8OqU/2boA45FoT1aTXVHezRKaVcKusoeYSzqQYpFoe5iLOp1JHujkKZ8SZY9y/8IyPMb0veYdoN9UrQDiMEy5ZMzNU9gnwrLmR0wu4Ky2I1YlOE3XHubi8SilP6NwjeORRW0m1OxKDU/Uv2AsSjkqZov+WJR3bRro5AhxK5hfo4NYRtZn9FGjFIa2gi2H1d66KGNGLM2uGkb4bORoT7L1YD7hdRnUTrO+o86zvqP8s5+A/KQ/Ya1UBfl8+CYjfnfBzbsEwFz/TH41o37In1Yox7avvVfRVvF4rkuzmXr5EzPzdEvYF3sFJMJ4ZXqJ3U2i9fCQnWX41s4vrNeo2xjvPcTGeM2tqPI3Sevo7H7RMh3mGtNWwppe7rW+pwi6oP5F1H+tItb/C3Mb3h1yv854W/NoTzJ+14Z9LB++I19BCy/LAML7Q227xUZdf//hL9umCOifnuJ+ln+s0X+Echj9VG84bjdiGgP2vrrqT2W/wuB8w+TqZK2YbayDSOQgW2Dj0fJwzxVcVjkFccicG1mGaUdBmkjlIa6s5TqcKKowyL4xnqNcmdlk34c3GXLu/X/yZCvF/X6K4F6fUIGPayfT6+xfF69viGj7n+TU69PEPXrJb3+VqBem0xVet1Zr08WdQjVayub9ONPdm7FvRjS+l27rnMfW/5/8cjsJaKuyEPm76Ui/yWi/nOoDlh2jih3EaWhv8V25zLBB8zPumv5fwZ8+IxH1q1eJWV9SMk6xnNZ1q+AtJD475UiP/qixhPli15MWBcLLOxrjqEZjwad7gPDq1P+gYVb/lUxtIugPMf0F+Ws+8mi7kOuXWdQpz45f8u7ySDahlOI5ioPTS6LdAYz8hse625T8IttHeoB1uu88VZMyz8fMNkeKF4uhW8sg8p+XCzapXh6CaWtgjSTBaWflq8bYxG2n/XT19bkKWor1RyT141RN1j+1ZgXKv8oQxPzW3FXQZrhHgVlX5m+1yn/QTnlawS+5ZUvq4+SIZYvLMf7prBfWHcvFXzA/Ne6Vj5Y/iOBD77xxupVUp6XK3lGGWR5VuuYmJ/7wjc+IU9UXGQVYSn7iX3N442yn5cIfLafJ3nGG/QLeaxcmbPuR4m6D7l2nUGd+n66CGkyOAL52Kdc6aHJZdFeDGbkN7w65V/uGW9GoO7sK9bc9F0tPMc402MPjC62C20Xy6Di/UWiXYqnvrHIZEHpp+UrqZ+nK/3E9rN++tqaPMwbZVtRdq3/m67dHo5QGurGRURnRNAJlX8rm8jK1+a14p4NaUpmX56+1yn/5R75UnqDcQ7moZJHlBMebxSflHwtozTk6dFUBzXuYn6OOVr+awLHm0jyPF/JM8osy7NPPpMn79hvPGm69vGA4yMqjoB9zeON8WjQ6T4wPPatb/CMNxi/WUV1Pzpn3UP1DXXq0zTe4JyGx5sRD00ui3SyxhvDY93d4BlvToG6q/gYjzeW/7Uee6B46RtvOsWTRtJ3xVPfWGSyoPTT8pXUz52VfmL7WT99bU2eorZSzWE4DueLbaq4dKj8oww9RePNUsJFLJSLGtUR5RH1xvYvcMz4Lo88jjh/2/LGjK0+vpixWgswPil5tHwl5fHyrR375fm2L/aLejxCdJYKOqHzbSv7wt0i81rz4RpgLf3X9s4cCN9z8LyvRnhWZ/yG+A2qS056U/uRDiR63D7ru51++V8adnCbNt6w7oaNt523fmzNGWM3b9i0bm0fQrv2FSvkCqLit5prbT2m9dO3fsp39njr39aznM8JHKN7EKQpThimaSW26aCMcsgLJ771ifwHEtaBopzVvd9THjGwHEtMjb6j1RwQtOuU/1mwmrcvy6Y74Nr5MEB/XyfodVHr5m0fWjeXUC0P5sVnLtQM8/Pf3KMWxw7RujrV+VdTKUow/0f6bj2/G5S1/bWWtjtg2z2zL5znIow9qQ7qX6w7fuPxK4al4PXJ5LmUyh0E5VYF1OEgUeemKG/5hkS5orxpeupsdNCa4P7n313oWtq2ENKUJeL1U8t/4sHT5b6QfjReosZaHRWfMU5ahM+XCTrd5vNlRGdhRDoLIc8e8J78dwhhMZ+tn4zPB0PaIVTuUEjDfDjKHQLfDxW0Fb5hdJLBLy/UbcuSQaNVp/x7gQx+lWRQjaY8+jrnl3mWy8GM/HtR/Sz/1z3z+AHRZqwXr1Na/m965k0Dol3KVvrahTI1kNGuf/DEc5QXosaWwyltd0gzG45jS50wvpd+L3nnujzzlFVvzGd09yxGN3gOYvgN187DIt7QnkSP21fMG0LuM1cQFb/VXGvrMa3THOT88da/i8xBlBXYTWCaRVF+PZdjLeRvfSL/noSlNIitsyqPGFiOJUaVS/6uizIhGlDQP+8P1QDDj6UBnfrdZNXafqCoS1OkYd0xDekcKOgorN0Ja/fAOidam26QM629ZOP6W9emauvo6TTp2DOjGn2ivKOyrNrs2O8mmoSqw4OV0c4ahA2vTvkbqZOAg5WvfPKEiD12UTcM/1T9XRyxDxUhnsRhWd8gX3PtfThDopo8NiLURLWcyyeq9rfyJWv0PlNivIcQ46aok5V/wXea20q7k5/Ncz3Lvw/QZp9TzQ185zYOE/lxPmL1mUN1wLJzRDmeZ+I+5YVUhyNdOx8wP++VtfwLgQ++tWSrVzf2yh4JGQbGXUu7cI2kX+Tnvjha5Md1IuOJWo89hLDU/BT7mvXAeDTodB8YXp3yH+PRA5ynH0l1X5iz7kqH1bwWderLNAdFmjyUHuyhqWTW6GTZjaw58lLBrxrRQD3AevEc1PKf5rEHvjhF8rAMKvtxiGiX4umhlIYxCYwHvYA93o7Zjb2y2H7WT19bk6eorVRnMxZSGuoGy/9CQSdU/lGGOLb4TsiHMy/Gte93pd9NxlWe5KlT/otAHsc98QirzxCVd4Bt7t27qO7DLugJdu8Mv0F1yUlvyr17F9Hj9hWb19foHbmCqE7kdSKtkxd35njr30Xm9e+GNMUJntdjm96dUS6rTcgHzv8uwnqXKGd17/eURwwsxxLDWoRW/Z2CNmvRGGgRry0i3Xe61kdp0iJBz7Tu3ZQ3eUzr7qY2Dbug52WhWmf4DapLUa27m+hx+4ppHUuKUbmCUC0P5sXnCqgZ5ue/ufeuEuX4MZw61fkNEJN/Tfo+x7VLLJ9Pxzr47Jc6n275FJ29S9LZW9AxScbxmtdK66KtvnURS7sd6mJrrJZ2h2iXpd3pwXy7B/MdIi2p338f3JoPrVEt49/k6RffmKfvEnW1vkMLgCGPLG2720MHy1u+IVGubHtUndnHwLYm/L3zYNfStnsgTY0GfP+W5V+9bLrcO0nf7oHyVkfFZ9bFvHzeS9DpNp9Zp+6NSOdeyMPrsPcRFvPZ+sn4vBnS7qNy90Ma5kOP4D74fr+grfANo5MMPnawbluWDBqtOuU/G2TwvQVl8F5Kwz7g8dDqgXzA/HwXntVzMCN/Vrue8sQa3iXKq7ofTHW511P35GFZxPKWr9syfzDRyZKf50h+NkOakh++99byHwvy83GSH/TQutF+n16jJ8ezBqV3zEtVDnX0sIA63CfqrOb7lm9IlCsrG6rOnWTjN0k27oc0JRuvTN/rlH8vkI3fJtlA+2l1VHxmHzAvn/cWdLrNZ/bvHohI5wHIw+PbQ4TFfLZ+Mj4/CGkPUbmHIQ3z4fj2EHx/WNBW+KHj258frNuWJYNGq075//sl0+X+0jOn8cngA5SGPEXby33t64Ma1XswI/8D1C7L/9ee2LDSV5QbtuWW/+ue2LDRxXap2bJPFh8U7VI8fch1po185jijlR90uv1ZsvIPHp5a+YGM9jBPLf93PDxVPPLxVOnYQ6Jdc0SbHyYsFWlDPofwFNv/bmq/5f+hxw+7V5RXvgP7kMoPw/zXUH6lY8o3YR3710Afkn0b7DfeK4exhXsoDWMLPBe7HdI2UxrGFjjOgbEFHv/eDmn3U9o7IA1l32ILdWprX7owUTIGL/f0vYvqlhVDw3+dCxtP+6ieSKdbcROm8+6IdBDrzPEt/6o524HwjmlGh7/5djz55ob1knTqgg5joU1Gn4j3wFr+XVJZTfT6c2ST7xH1q8M3nhNgnays6QDatzwRait/X7Hy/daWTnNttgfY9jxyiLQahJW37b66Y/1YTnBOxz6ZwtqcE2uWSCvSJ/d62qVsu6qLqmeWbiCdA+FbyBxa8ds3hzYeoS+Xd/01i0cqlpaszDTT93Rl5sy112667rz11zE2iiyyZ2/KZ+rd59pFaXMGlqO/96Zv/YCHz0yZS0XnoJJ0DhJ0uh025mNCWVPHEw9xLW3rFJ7n60cs//dh6rgkxVRTxyzVqzn/lgyuX9bWiYGM+p0Gw9h4wBGVV3jqfA/QYLrJ+xEZdTid3L6CQ550+zisjPVhc4TmjBf+0V3sF99Y5u4SdBgry+UwvrJ7vDKny+Hb9IB1srIqZM98UHR8Q+pdgXQWlqSzUNAp65IoOqrOalqGtuRysiX3QppyD3nbneX/a7AlV3psCdaR/1Z2mW2J0cuyJSyflv8ajy1hNxvbqeqM02mmq2yJ5V9NtqSgqyVtCS/zYH0OpfrnHQux/EyNhYcSnW4voSq3j+1LXjdbLU920sdbDtE0lT7yuIb5nwJ93Bgwtocse3bb9jJW6Bhk+d8YcQy6O6B+ddeuU8n7IdDmLCwnvll+HP84FHQv5b3HkzfLbiXvY+l7N/Urec4Yb6WTJffvzCn3a9J3lvt7Qe7fTXKPUyxuL0+p7xNtsPT7od2huANUNnkuJNz7CBdl5WVpXh5TfnLINP4D6fuQoFW2TxGL+1TZ06Q+76E+VUsMWJb71PJ/Hdr4OPUpLgFwiDdG++37g/Cd6fLy50OUF5cROCT1IJVV/3aqY1PQeYhwH/bUn7cI3C/KdXup9yGi81BEOoh15XgrnSzZfY5k92FIU7JrPz9Vp/yfAtn9OMkulmfZRVvH2zdVyCzB3+XQ1jo/AvmMT1eNt5e1/O+h/IiRPOyLP5p+z/LFrWyd8n9W+OLWtocFvaRtv36Ibhv2By4BvodoW/7/C/3xm9QfyC/rjzmunTesA49CXTBv8pitZB58Aerxu4dk02K9UG1MMP7gEJ0P64D5GMPsAvLAMJRdsHJzRL1Ydx8hGg97aDwkyikabI+RZ48CfZONxzqkPyra5sS3PpH/kYz2OkH7PR1wHxY4yr6/h9IeEGlsu7C9ahuYsolo957z6EuWTii5esRT90ep7o+Iuj/sqbviH9oPn99gf4eM9TXxt9XvVfCNbazaZoB58KdVMf/fe+IXausQ1mtNBua3AZO3biiZOQq+cdzQ109YnzkuW89V3dGW8DefL+NEHZLHbKGS2Sw/jvmh6qC2/ii7yVt/1HaqUN1Ef/o9Peb7/0ck3/82mM/9fBv3/Tn22wu+/z2EU/n+zs0mP7qo738ByO7cFDOv78/bqzr5/pZm/O0T5fhIgdFbfOg03u6EVwdaKDfJY3EM4xduP3SiTRwft/x7pzST8eh/LvPTVzaf23N8ijfLtetIjnj7cp9cGvbDBbFD5FrpovK3GyKtHlCXz3/6ZVdu+ukTt7C8W134W8jYf4LIb7zieeawC3pOGzIa49Pljbal1SHtYUobgDSrQyJrzy5rrd8jBesXwj/Eb4q018B7nr5QWJsjYt1TEGuea5VR1ENlhznWoeKliQ1Y1cE+qTGO7cMFZB8Kbkc7wTeeG/ZDBbFD7UPWGIr1aoi0EPsw+8cXHbji7TefWXPtdrBffAvZ1n2cyF9S/45R9oFtQB3SHqI0tA9WB2UfCtr6Y0L4h/gqJsL2IbQvFNbmiFj3FMQy++CLkaN9YH9IHVNF+8DrJZeSzhfcxinX4HkvB+57Sp6LxqfTeA3pXg8O2zAnymStib4cfLoryWbiumTyXCjqp3xS3C9xzaHZ+e4X+ZItjXYMPd3SuGLtxkuuH7t17ZpL1q6+de3GftdaS+YGr7DxrkX1WAvr9O0d9DfP/Dj/EQKnE021q+kYeGe6ITu4jhF1VnROLEnnREGn24cUTiQ6KKU4S3s1zdLQA1C7Wi4e3/IvewG/cup0uRtploa0fXw+ybXWJS+fTwqkc3JJOicLOt3uT/6BcbS4zLe8u0iwPEdXsnYavPFQTTNrxxvLjeU/FuTmLQFy42uj2vHm2w1pWPd2wLqYsLA87+6511NnRcd3MUBfIJ2Q9vjobM32GJbaFYZ9wD/moXbcG9Z9HbAuISx1SMG3k6smMBUd3445346xzSXpbA6kM1PtuaskndCddieVpHOSoDMkypW166rOnezt02Rv1UUuvh3Gln8/sLfPkr3FmfuLnc/dWNnBPuvUn5+m/lQrO77+tPw7QH/+WkB/Kt5k7VxCur6+Vhdr1ASWb7cv8wHzqzGli9Gi4J8x44hxwcj41GFG3+UYyWNtT2Z/u6Tv6exv+doNxx635MxfTv1uu3ljVuRoLhJ1ratsmN/R31wuqVvWCTTMmzwsP/dTPu53+874IXXqlLdTurJ1D2a007kwW4fl787Aytqhbf3DB5P/CFZ4eIe28snUhQ0+f0CtzmG+ftGGHTPK3ex0/fCUCO524zZb/v/tafPmDm1m/135jmybOF+/aMMs1y4DiKF4zD84nVeesPxMjZ1LiU7WmPY1GtM67T6/JX3n3ec/PWW63DdoTFO+YLfbz/6run73FsiTNbepZ2DySq7l/06clRUZZeXosIqIJu37J+pT1XZfn1r+f4Q+/X5An/r0Q13m6rMF93jyq7miiv34/EbrH97FNuxCntrfhsgo4jeoLjnlYcrfUBcmYfuK+huG+w1oENa/k7/B5Xz+BufN0j32Ae6j7538DVWnrLx5/Q3kx/2UN29sEsvzimDBC+iHmef9Tu8yzDrNltRDjZNZJ7CRv2oFmm1R3bXzBscmtkW19IbDxJf4/1JfQvXFKRn1cy6sL7D8TMWJTyE6d0Wko25SUD4Oy3BeHwfLZ40HWTK4Pn3v5KvMPawV1xe/Rrocv34ExrWdD8vmiW89wne5Obc/7+XmIX5MJ/1hHoX6MZZ/UcqXkrc/XMS79wwDsQv6SBeF6ATiDwl6Vq+GSAvZIfLklxZ/fmT9y+/nMcrqwt9CYi1ni/zl/BV3/pDRGJ8ujyvdyVOHtPsobQDSpuJYrn2HSEH/5vwQ/iF+U+THHe55+kJhnVsQy3Z1qDnp1rIVWbEKw+Kx9kQYa0NOk/vW8NRpd/bxuY1sc5Jn2Onnv+kxPOP/DoLWvdRuy3sqtPt36adW7hV1NRvR76HhxLeay+YN01C7ZG51rXXbHFA3FT9BjLsy6plgqDU3ltu8N0T4Yi9I56ySdM4SdHxjEv9rdPibb/3uLKKT5c9cQP6Mb30oed+QvvP60B3gz6wifwbLZ61R1pz2jdkGWvmsU69sTyz/5aBXfIKrT7R5A9QrS86wXTimZsVlriZ/phtxGW5T3bXb1uQ5a9zJNnW69cPyK5/Bd5GlGj8ZKyu2yz60te36I6fLXXtYvva/dFxjXnfENObanJgrMjDHD5vGvJ50A+VmmdP0kidk3ojl2WdDWc0T87HytxcrP3UxJd5Qp+yK4Zed5yKthmvncZF4l6q7rx/wJjmODymsgZxYs0RakT6pu+x2If6Qpy6qnuxjKDpwwKhtPnKHp16Y33QIZdPKGo/uhLQcPOrz9dcdgGn4JS4LNfbsTvnMBPa5dhbfnoHl6O/d6Vs/4OGTYO+bnjCeI5p5BeGqLsJvLMZY3vIpOruXpLO7oOPDukJgWX41Ddpd5Ld24H3nVrZk6GJKDO8UdVHucgkxNPYsgDzoBfS5do16ewaWo78ZM0sM+wUNPiPg08LkmSMw2Arf6aFpbU2epihv+WyUN+/lGfLuClqed5i1xZ/mMz6VjMi/I3QE5Wv+kZ7VqyHSQqJVP2we9aUrF571xz41863Uqdn/lSJ/SdW7Q0WrcJdz8tQh7S5KG4A0q4OKVhU8A3NHCP8Qvynyc7Qqb+RH3eGXF8uiVWg+TXdmSpd9WCqyVKM6Dzq9UsW2wvI/D7PRt1OUR/HBiW99rt1OrBrf8q8akhY7XXdF2/CTpynKW74u2qqBvLaq4drbXMTbV3Kr+GJtVxFE3iGfPHxOP+9pi17HQtkccu3yW8v41+jwN+ZzjBVJ7rMYWPdGwFJRx6PhHdMMi79xv2D5zZR2p6CjVmvfTmnIN7OFalf/EdQu1Em233ntUF3Uj6MGyTtGOb90mKaJ0S4syxGnqfpAdOjLh2W3MWQnF+bPihj+9QxEDDvx7m9y8C557MQN8+5bh0+X+1sP73jsVysLKqrId8hn/YQupjnn38GkIushdx2VXCkNHvti7+xSu+iVjSl5p0vd6Pl+UhLpzXWap+reJY5MqfmqsnW8qovjWtbPuCbvh8N7lj3DNnFkXNVvpuymorOqJJ1Vgo7PTwyRdUVH1bmTLftvsmVqdRrLXp++c7T/z8GW9aXvarUL68h/h8wvjF7o7y1Y/h3SOqnVLtXm6z11RhrOtesNj11Tu6vTOnTzrgffDu6SdPtCbbDhN6guRW1wp90NuLt2fvqehvrOWz+25oyxmzdsWreW10+y9ljWCBW/1Vxr6zGtn74NUL5zxlv/Nqntd9kPagVaWefC9nmovQ9qVn6XoMt7HTB/yJ4Rq3u/pzxiZO2/6c8ol/x9mygT8wxDzBlNF/fc7RyqmYbfoLoU1Uy1/0p5R+wZYlm1VxUXdjAN6fi8U8S6IxJW8nBkoMKqsCqsCmsmsHx79HgWljx8VhPtIM+c8i4qY3nf4vVZJemcJegMiXJFx+Smp84q2sJ8yxuBVPv+Os3Qrjhc0wydoVn+34UZ2lWHt9ZZzdCQBzgDwn54AWO8vewsqwOk5fAv5iSztAfolziQrwPj07id/JDk3fYuNik/tl3JQmgfraU+Und/9Yn68N1fH4U+up5m0Vg+ZD+Rosd6OJiRv071s/w3wiz67Z7zXndn0MvaQ/vyDHq3AL27QB5eaOf4dHmMwr2AA2l5/Ggld2hnWO5UJEjZM5+9UBEtFWXllVm1F1LtN61R+UGn+4D3CVv+N4o+D5Vz7lfL/5bAfsW9ay/gQFrZfkVecb+qVW/Mz/2q5AD7yxepu52wbhdYvv3fnXTZ8Fi33uXpV7X/G+vJ/Wr57wnsV9y3+QIOpJXtV+QV92voPkqfHOD4YDxRkfV3UJo6w+iz3ygHIX2O/ZNlvx8Tfa4i+PWA+im+JRG4ndP3NAJ3ycb1t65NQ3COHl/ILPn7noxqzBflHZWt0bf5lKbMp2/zjtEedDpkxebT8k8IlvvMb/L4tnyX3H4eHMQ1/FhbxjuZNQ4V+dTMN5XZCqKaPBbdrYlqcXlHWDXxzTm9BRlx2Qv0WTfFKrVXC/MbHq9bf8IzcqiRUM2ILL/y3HF05P0g2Aa+YRLL3Z1BB0c0FCMe0Sz/rwWOaJFmPnJEQx7xiKYiC76TzWo9W0VLm5Qfea9GND5t1UkNzbyqmRV6lTyzUvLi88x8/FHypfY1qL0Vvlmw5evGLBjbw7Lg69vkYd6oW2uwv9lrxb0FHHlCXeLTbGrWEyoLGO3gSMhdgbiWX91MgUM4z8ot//8RNsAw1YqcTx4VL9QpZrWCt5nSsBzuK3gBe3w6DW9Ze6F9kJZDHmfHjMokT1FdVas8vKcbxwJfFAfX/v97hvdg8fitbi7FuvLvSln+f4Ko0X+Rjigd9/WB2n+Ees/2Uv1umg/r7R7a6tbOhzy0sV5Zv4foRD3x935eoDU+nWa8KakrA0pX0D6zrvhscfKE8Er1U5PyI2/y7gfj35EM3Q+Gp5lZPpW/GDo24L7LvyHd7XbUnn3igXTTj7qdo9Pe2g0ZmLMA866Amzp9406nCDnrFto+9rNVVFLZPraLyl4rO8J2Uf1+H+bP+v2+ndOEkrcYy/1WWb+bWnfa9+I9wJb/MNg/vdsRGnMgJ+aeQm66aOvq3bZ1ncYk3qeKfZO13xCx1F5U1rNBp+dLhserbQdBH3CkDe0t21S0t2xT7xF0fWcNErlZkf7B/lryjitYR5Dsqfky2hyWPct/Dsjz0el7TLvBtzap391k/XHOL2dqVdDyKXk2O1Byz3fwnnb+vbyCe+i9t5WqmEFJuzm1p135KqofcE+72seOWDYWzLRd88ViOvGVzwdhG1mf0UawHQjxyRS9LJ9sBel+LJ/sS+SToX6x/qOOs/6rm0vVHID9BvU79GiDcMzG/KvAhq0h3ihZ9sVYOv0OPc/p1e/Q+7B8sb73iPyPeGhjvbAs087SSd9tht2YT6FfwLrom0smTwivVD81KT/yJq/u8jwMx3fWa5Rtk3kln51iLqy7m0Vd0R9QN8pc4lppqqUd/MbjLJa3fIrO7iXp7C7o+LAuEVg+m+i7+kTNqUue/566+kSt86irVkpcfWLsORDyJN/56hMM+96ZgeXob8bsBzx8lEjUM+ppdDuJBJbPEgkbLpLHNlEm6Xy0yPLfTdPMO6htwy7oedB3RNywCx7lf7BGeM5pVzPreBrWS10rEHLNyV/8y1vfefXqf/iqT6V84UEV7r9U5C95zcl9ahjjq0zqkMahdxyKfNecFDQD94XwD/GbIj9fc5L3SCOmXVwQy645QVPJm4m7rfs8bb9fhPFmui7mMj3iCSmqIQDDf7z5G+vu27DN7erWxvDLStK5TNDp9sbwy4hO1mbgp8gluxPSVPj3hvSdN15eduR0uWfIHVN8rjk9/uDYlTysr7wxlPPcnVG/j4J88pFa1eYbPHXGMJpz7XaBQ7xTW1Fo7C1oU2WIl6/86sKVPsG7sbbWlT75jtTyFmXkCqLit5prbT2m9dM33nR19njr3za56XfZD2oFa4bihGH6rolXo2+ei6oQV21M4IvzfKM9YqhJiGGocsnf14kyMS8rmKnjuaaZOMHNoSnBP11p+A2qS1HN9G0QSR5uu7rURW2Q4NlOmSO190XEuicSVvJURwsrrAqrd4+uqgvBeDNp8vBP1Hd75qXorCpJZ5WgMyTKFR37mp46q82DzLe8lxpieb5sJmsm9O9HaJqhMyHL/1KYCf3siNY6q5kQ8kCdI+jiUTO5SRL5OjA+jYt68EJ9XHu/2XFe3zEdJQuhfTRwZGt9Oh3p4+PFln8R9NGs9D3kaKhvozjSYz0MPbpq+Wendep0dPXtGfTU0dXk4Z+Tt/zzgN4MHF2dp+QO7QzLnYq4KHvmsxcqcqQWs/gonO/4Y95jreoonDpXxUfh9hHywGMRy0ZW/RTfIh+FuyujGnNFeUdla/RtbgaW4STfcPoachROnXZlE3GQYLmvy5KnOgq3zR2Fs6hMTVSLyzvCqolvznU+Csejio/FilXKimB+jtFb/hOESPssrO8HtJUngN3rOwrH2+Kw3Nsz6KjD3cnDI5rlPyVwRIvkSckRDXnEI1po5MTyd9oSzarmuzREzWxC1TD0KBx7arGPHrF8hR498nnV2+PRIxyONhMd5UWFygLOnv49Y40pCzdrjRZtAA7hWUcSrhQ2wDBVBNonj0p+VdTbd5242m6D64EvYI+3Y5aUxyElj9h+lkdfW5OnqK42Xbuc8VZSHAvYjewkNz55xDW+p2h9EumsJJp5f1Jlpai/orN7STq7Czo+rJUCy/KrrcC+7WLqeFrJ7dd9PtlT26tLbBcz9uwNeZLvvF0MRfiBDCxHfzNmv/NvF8OuuyOjnka3k0go1VF06iXp1AUd3g6yOTW9JZecbw9ZNCt4wuD2GuE5p2dUWacrsF7qtEPINrO/+twpv7XzW/9yTo3KW134W4jqXiTyl1TPcTU88cnUOqQ9QGk4xFgd1DazgqdTxkP4h/hNkZ+3meU9kYNp5xbEmufabc/W0mUbph8CN4q3mXW7LorOqpJ0Vgk6yi2qZfxrdPgb01F17hTg/kDGtCk0wG35b4Xf836SAtyKzzWn7XTyLy52sVwbvdBfOLD8HwKZ4u1Yd4s2X++p871Ag+km70dk1OE5GqMKbr6Q27F4Cor1YT1Rm3rwm09P7vbQubwkncsFnZgbYpqeOvvG/aJ00KaazqnTni+Dd0wzOvyN6WD5zR46d5Skc4ego0JDOG0q6TP1l/Qjpn67utNtPoavbhLKIwdIq0FYOevuPZHq22SAPg22MQvrwZxYJX2nqT7pdNsW+ntZdVH15LBSmTYPRMTijWFK/14msCx/6K9fqdOfVtb6Dk/vFZk2q75Tpx5LTJuNPZdTPtv/0ufaRfzBDCxHf19O3zpNm1Gk6hn1NLqdzKi6MGWmzHUnd/AbR2qaWe6gmXp24c84errc35E7iPUapDbmPemA5X0nKthtwYgoR0vVde41SsP6+U4CqZWmfkFHDZkFf4iqVtK9nDLPnfbesEwVddGQVqwfxVJ197me6KrxnluFdW9OrJKn7qb6xPdjX4g/5KmLqmfIRTCD8C0kIq/4rVbIrKzxqKC71OfjEeqC4ZcYmow9R1A+m4n2uXZRujcDy9HfR9C3TkNTt82VojNSks5IIJ2Zas/dJencLej4sEYEVqVKLc/WVqV6Rj2NbieRwPIzLeLKw8BAYycvcK+jWuvU6WdP2Qu0/JcfNV1uH3jnvUqI9S7XmoZ8fDfV/3Y3/ViflrxnIHjbm+E3qC456U15LKE7TvOdOeTpK3IFUfEbaxOm9dM3Ll+ncqbF/S77MY4ZXbXqfrvAVH7+nRnlkBdOfOsT+e8grDtEOat7v6c8YmA5lpgafUdte6egzXuqj0m1Kglx300hbkUL+dFp3zDn4TpM7fiDOoxn7PirZ7SLtZlv+kDZsqUzpr8SrMySozR9J+hz+9B6DmbUF9uD+U8FHvBGXmX5XcY35AGWzfqbzxfjO/6tZPGdlP8dHdrO/W/5z/D0/4Cog9UreZj/XAeVR9VhhaiDsJpnrL/5tow9vChpyspxL3FPDAicrMe4kZQx6WXusHYwHftbSUDS8l3S9ynXbN3ajVn7l7mtWSNKn9PPkNN1S56ttSV9oBg975Z0bF/RLelZWtqJTskt6VmDtjIWXN5R2Zr45tJqvz49SrE11yTvKElHBREZK8stvjZ9r1P+V4KBuitjLbpPYCaPBb8tv29bvHP5t04yL1XAz0fbt3Z/f866dlof4sAt1u+BnHW9eIbrereoq2/tseQ6arDpNPxYa5ehv7qSb1rDhwiQK4iK32qutfWYxhaSpworx1v/LjKt6bSKy9OarGWtLMly4lufyP8AYWXdLd+fQU/1KJZjiVHlkr9fL8qUXX1PHh6MH4yI9ZDAKrmiumuoZhp+g+pSVDND74C1tj8i6tIUaRxyUPfyPiLoKKz7ImLdEwkrefgaiAqrwqqwKqxtDUsd2ON7t3H85Ktnun2FiqJzVkk6Zwk66iqSor5C01Nnaw+O3cw3tcvrIQ8dLM+7GHHnMi7w/PpRmibOZLEs7/q2/CccPV3uN4/KbiPy+YV2jbfXuRu/B4k+zsD4NG6W/qAPZ4c8lS/Bhwixr/G+f18f/AH1QdHfX9wH+uB/UR9gedwNmKU3ih7LyGBG/nuofpb/z0Q4XNXv/gx6yA/k8xsy6H1JRFeU3BntknK3a7d/e6GTnPK2HvUbFoalTq6o30SpUflBp/sg6wTP10Wfh8o596vl/2Zgv0ayJ7vmvapKRdZ8F1ooOcD+4gvKsc+zIpGI5fu5dtWv6upW7tfvefpVbRLAenK/Wv4fBvYrbqV7AQfSyvar73C66lff4XQ1fmO/Gk+arn2cvJ2wfNv9kiekX7EP2EZb/p95+lVFuX122PL/Vw/YYeRVSL+qlYDQfmU7jP3KV3zhWMe6PFM2upH6DeqKrwdFeV/9FN8iX/H1QEY1dhHlHZWt0bddMrAMJ/mGYVVmuTV30OkQKLPc8s8VLFdqqvZqqYOiJXeKBy8KGH7DtYtEkdCjz/V8oWLpv3l3MecdFrsgqsljqwU1US0u7wirJr5hmhLV0CtJcITei2YKKEI8U1CWT3n+lt880CzvwvDqlP8AoR6MiXVAD4qtdadfd+Pz3tiG91Aalrs/gw6Ojmj5eXS0/IdBW32jo9HuxuiIPOLR8VFI6xf5md+PifyPQh6OKj0GaazSyOP3EJ1OpoPlX8mpmn0rb9x3PVOnWRnLl/rlwjminC9SYvm6ESnB9rAs+HQpeZg3PtlB3jRdZzlBveRffPTZpeTxyQJGF36dbCHKH0fn8l74jeUtn6JzR0k6dwg6jBW6T8XynydslGGqVWDf/ohO56/5VIPvHLD6tWH+1+jwt6w7VLCvYq4c+zxq36pyUTpoZ+4jOg9HpJNls9g2lKWjVpbV+FWWDtonvnvi0Yh00NbhMRYeE9Gns3o8LuphU4An4HuOsaAe0g7Eb1BdctKbmgI8QfS4fTwFeK+oS1OkvQbeMQ3pvFfQUVhvj4hlfTvHtff1YqKjfKnHPHQWB9JZUpLOEkFnSJQrqyOKN0bniYh0UGeWEJ33RqSDcrAH0XlfRDrvgzxHEJ3Nog6JPb3j6OnvyX/vhzSOciWPrQDXKf/OcP/TO1JMk0G0FVhHLI9+0uOiHUzv7pSG2b8PQJkc9kjepWRYnXh3L/HucUgL4Z3l/7el0+XuJ95hu1i3JyDtCUqbhLT3UtqTkIYYmOagDfiNZQ7LW74hUY7Hq6fge47+GgjRDcRvuPY2FxmvniJ62PbkMb5Y+z5YjF7d6D0t6Kl+mOs0T5G+YfG13GhnP0BpaBufpDS0Z5OUhvp9OLwjZlabeAcs1o/lG+v3AKWpnbO+O3HUHP1hSsM2s39rbR4gnOSxnTZ1yvtJWLV/Pn1X9obt+OMC29LeL9IS/C8c19oWtCnIR0xLnn7xzTeGfiADCw/84dyN7aHl/1Oy7ROAm0OXrjO+TMJHtkMF7cJ1oXYoyyZivZSNCrnL9aFDfzD/I6t//tW8tttn084U+UvatGtVLMtoW1od0p6ktAFIszqou1wLjinXhvAP8Zsi7bXwnqcvmiKNz/gUxWJbWBbroYJYdsfsJJSfICwVy8Pxwnc6guv1gQ5Y/PPfWJ5t2EQHLN4R+QHRRvYXON+AwGbaQ669bWzLEL8bMYCJ9L0h2lDEp5ogelljDdtxLNsUaSzzk4LOpKCjsB6KiJV1n6Glq3+NDn/jeCnW8zSqc94dpVg+azcw5uO5bPKO86TvHq3rg3KP82D2Cyz/38M86Xs0T0LaPp+PYy1573NcHEhnRUk6KwSdbselOdYyEZHOBORZQXQmI9JBfeNYy5MR6eC4yD76Q6IOL8wNFk1/T/57CtKUXl4yvuXfOuW/E/SgnmIqPcA6YnmMtaiYEdNrpDRK+oEy1mJYnXi3E/EO51yKd2xDLP/1wLs5Ht6xbqNvOUFpyI9JSnsa0hAD0xy0Ab+xzGF5yzckyhl/rb+ege/diLUYfsO1t7mIX/AM0cO2Jw/PSz5UjN5UrOVZQU/1A8ZakKdI37A41oJ29n2UNgFpT1PaJKR9kNJQvznW8r4ObWJ/WtXPF6PeWj7n+4rR8/qc2L4iPmfy8G95TAo6k4KOz0+MgcVxs63hCy0pSWeJoPNi8YV43WkyIh2Ug17zhZbn9IV4PJ/yTWA8P3MGfKGVPeALnRvJF/reydPlLiDeIW3WbeTTBKWhjzJJacgrXge0NAdtwG++tU7mG5bj8aqgbxLsCxl+w5WSj6nxSvmIarwq6etN+UIfEvRUP6AvhDxVfpHPF+L4wgSksb8zCWm+WCz7Qg91aJPPF+K9WRi7SP7GfQ+81mN5/y/o2dpUz9Ter8vHW9NQxh8DuteTriJfOH456drbjt9Yr7C85Ys5Nqk1aI5X5Y1RY3leq5wUdHhMZ/u6YZGuD9rXCagP21fL//vQ76+lPkPabCexzuyj5e3PxYF0VpSks0LQ6bZPwz5at3wajlc9FZEOjpfso30wIh0ch9hH+4CoQyKz7yY9eBrSVLye41WW/zrQg3s9eoB1xPLoo02IdjC9B8lHKzgmSh/NsDrx7mHi3QSkKd6xDbH85wDvHs1hQ3BMfpLSkB9PURrGMhAD0xy0Ab+xzGF5yzckyhl/rb+ehe/d8NEMv+Ha21zERwuNH1n7PlyM3pSP9hFBT/UD+mjIU6RvWOyjTUKeCUpD2/ghSkN79gyloX6zj2b0strEPtoElA8Zb0ru9wiOVxl+w7XzsYhsKV8I28fxqqdEXbhvkofjVWoviIq5qn6ecPGwfPu82BdS+8me8NBZHEhnSUk6SwSdbu9f3lrxqm75XOwLdcvnCvWFvkjj+QchLWQ8t/z/vGS63J965nG8VmTl0ReaFO1gel8iX6hg/EP6QrwGlcW7/0O8m4S0EN5Z/j8F3v1fD+9Yt3HcmaC0UD+JfVO1RoXffP43+5BYjsergr5JsC9k+A3X3uYi41Vo/KikrzflC31Y0FP9gL6QWq9DLPaF0M5OUtoEpLG/g/aM1/VQv9kXMsysNrEvpPaMMVYdvqmYE887fpzqV6JrP6SYldo/nOR73TGt+SaBDst15YdteX8dvGMa0gn1nd4bEavyw6bp8Lc8fli3/CP2w15sMakJUYfExsw9Zvo72tXQ2KzlXw++xM4ppvIlQmJSk6IdTG+PlMZMxKQmIK3lZ92Id5OQFsI7y38x8G4fD+9Yt6uY1HQ98RviVzGp7JiUzw/rhZiUqh9jhfphlv9EshsF/SZpN/CcDbeX5b/y17a88zmfMj7W+yJiVf7aNB3+VvlrcegU8dcujeSv/eSk6XJXzIC/9vIe8NeuieSvfRl4N0a8Q9q+OwTYX1P72pUvhxiY5lxY3AzLb29xs0n4tq3HzSYoDW0j+2Rozzhu5vPXJpy/TSFxs9AYF9PM8uuuGG9Nt/xvPGYa8w0UN1Nn6pN8fce25kP5YPmv/LUt770aX7N+VfdLsL+W996pxaLOis6SknSWCDrdvj+J/bUPRKSDOv9iX+ecEHVIbMwTZN/UOucE0Mxa53wd+Bzv9/hrsdY5nyJ/rZvrnBOQhrx7OpK/dhXw7lkP71i3cWxk+1Ktc255qnXObH/Nd68T2sZY65wf6NAm9tewfr67huybzw+z/L9NdgP1q6zdMCy115/lv+BdGsH+muHH+vVQ1Xe+Xw+dFHVRczyOr00KOpOCjsJ6X0Qsnx9V+WutdHz+Wrfuu2R/rVt+IftrkxHpoLyF+mvfIJ+j6FmVny+eLvd3nhgR1hHLh+7Rt/zfJruL40RZu2tYnc5RfjdjLh96jtLyfx149z3iHdJm3Z6AtPdRGo6p7MshrxAD05wLm5NieeabmouUPPca7K8ZfsOVko+p8UqdL52Ab+yvFZw/TPlroXdYoL+m7uxELJ+/xuco0TY+RWlozzh2Mglp7K+9t0Ob2F9Tsq9iXHimkmNcalyaJdqYo4/mhMqg4TdcO7+LyKC6k0ON18nPES1M39OfI1qxduNFm65dd8Pqc9fetmH5TWsuGrt14w1j65avWXPr2g0bsNJIaDZ8x3R8OI+9PyC+I8YHOjSGhQE7K+SSPcTiC/vUJXuGNdkBiy/sw/JYFv8ecO31tMO+fQE4qGhZ9bqE6oWK+CRhPeXBSt5/xbViYfmsgEsW1hsJC8vz4iIGi7iezC8fTpYBxXq9ieqlDKZhfagD1s2ElXW5T/Lfsx2w3kxYahLOfw+49noyv3w4yX8f7lCvt1C9sjbfJP99pAPWDYSlNu8Y1kc7YF1PWFgey+LfA669nswvH07y33Md6rWB6vVRSHuO0rDcKqKTd5KG5WdqkraK6DwXkc5zkGcPKJf8/TykTQCG7xCTDf4fg+/dCJgYfoPqkpPe1OD/MaLH7eOAycdFXZoijYMcHxd0Pi7oKKwPRMR6ntqTeRHQsa00i15m8wcwCTszxVS+x3PURuXHqMtIa9SuQZEf8eqUf2Vapx1c+8+tPifKK2wcT0MuBEb96oaOGH6sC4GfJ3rcPtaRj4m6NEXaJLxn6eLHBB2F9WRELL5oL0tHXhZJRz4BOnJ1D+rIaAQdQR8qREfKXB6JeFYf/Ib4sXRE+bI+HXle1KUp0nhjvdLF5wUdhfVMRKxQHVkfSUceAx25tYs6YvwO1RHL/7oIOoJ+c4iOlAmGIZ7VB78hfiwdeZroddKRZ0RdmiIN50yYhnR8i+OI9eGIWKE68vZIOvI20JG7elBH7s2pI6ru3Zh7qfjVsfCexSPfD/AcK9qj5njHUnuyZOTRY3V9lIwk7zZ/54X1m0FGnvDISC8srJ5aks6pgs6LZSPcqUTn6Yh0cFzhhdVnItJBWxl6Qe0nSA8+BGlKDyxeVKf880APPuXRg6yYZegFtZb/symNkhuP5MKqYXXi3a9HGmd+euJ0ud/MYUPQp2cbj/x4mtJwTOa4r4qv4jeWOSxv+YZEOeOv9RfGLbuxsGr4Ddfe5iK+VujBT2vfc8XoTS2sqrmE6gdcWEWeIn3D8i2s8mX9aBs/TGloz56lNNTvkMv6sU2+jXB5Luuf6U1mZS/r7+Qvsh//tKiL6ptxeMc0pKMOSyus90bEsjWGapNZ+7dePBSwvfhCP8rhCyUPj+eW/2EYz38yA77Qf/SAL/SzSL7Q64F3/1X5Qr5nm/GFPlqM3pQvpNaw8/hCak37xeAL9Yv6YT7UPRVPcuJbzUOPafSJsm91rfXGtPOJRt4Y0Pmivl2M6/aH6te2EtflNfQysdgQn6fkBsZgf3wmNjCeD98ibaLt9/XDBzz0Cq7l9Rk9394upJfY00HX3odZe9DU3i3sryydL7qf8ukOWL79lLwO+EwHLN5PmbVxGdPOSH+QPrHDxx/Xmsf2Ap4EeU5M31mnkA8v7CWhfL4fAirzQzmI55zWPf5RxLI/BKT6IeuHeXZwfhnBPpqE96x9os8AXfuWJbO+H9ZR9cnbp2pTeZLvLE++SZFP0Ur+Vj8szr742SlGwudPLWttI5afgHdMS55+8c13OMPyKTqLS9JZHEhnSUk6SwSdIVGulvGv0eFvTEfxxncIsygdlDGODXTroBvHBroV6+DYwHtFHRKdeeVx099Z13zjBR963xPmt9emmGqPftYPXIUeQLP816U0ZuJivSze3UC8m4C0EN5Z/l+cMF1unYd3rNuTkPYQpSE/+HAajg2IgWkO2oDffIceLd/2cgBtEr5tiwfQ1FinbONTlKZ+mFPZoJAf8sM2sb+hxvLkcNW+6fv04apz1952+di6G9aMbbxh/U0Xr71l09oNG+uAzNSxFc5pSzyRviMOPzX6u4/SHqB0POWgHt9oWvKKg2DP1/Abrr0XimjOJNHj9vGs/0lRF3VVxdvgHdOQzpOCjsJ6IiLWRPpeXeXZ/o3p9MJP4ExGpIO6ubV+sjnLW5kgbwWP7YZ4K5b/feCtPEXeCo4aWEfERk/vIdGOOuV/ljy9glE36enx6jvaOuTdRwJ4hzYti3fjwLvniXdIm3Ub+TRBaeraHzVjRwxMc86/Oq88ghnYtRDs6c3ErgV1NU7Jqy+mPD3lWap+QE8PeYr0+fo1ZWcfoLQJSOMVoklIey+loX6HeHrYphBPz2Rrs6BjaY9D2oOU9n7R5kTvvkB6hz8X/XD6Xifaf002qOD1S6cNER3DQOwnCmKH6kvWeI71aoi0ekBdjv+7z+/a/6o1H65ReasLf+sDfJQxzH+6yF9yLFg6ZDTGp8vjyk/y1CHtCUobgDSrQxJNfHZZa/0KrtgsDeGf0knMzz8RmdcHRDqoI3mw5rlWuULdMf1D/X4kfR8iupaePCV1MHgeZPgN186DIuOKsonYPp4HKZ41RRpfkfuwoPOwoKOwNkfEMtus+pnnQZsFnc0eOotFnRWdJSXpLBF0hkS5Wsa/Roe/MR3Fm5mOeD8ckQ7KAc+DHolI5xHIw/OgLF/+5+TL4/XgIb685d8ffPn/5/EpsI5YHudBD4p2ML3+47f8W3JskfMg3vWQxbuB41vb8iCkhfDO8teBd7NSTMU71m117ZSaBz1MaegncKwn7zwIy29v8yA1xlv7JorRm5oHTQp6eeZBE/BuWDwPQjv7IKWp+a2yZ+xzoX7zPOjBDm3ieZCqX+ULhftCfP1sGf/lsYhYPh+l8oVa6VS+UDE6RXyhU2g8L+oLPX38dLmXeMbzWL7QGT3gC50VyRd6J/DubOId0mbdRj6xL6RiOspP4nl93tNCWH4Gds4G+0IzsXNWjVcxTuol/00Ielk7WRVPlV/k84U4Jqx26Sl79gSl+XyhBzq0yecL8Xo4xnM57/3QXsz7StCzO4/PpvUe15p2P6Q9Smmh+okYyF+0FZj/WmqD5X9VWu8k1viZZRqzz2kZNfujYp/WjllGF9JyyO/vJPV6YNk0HZSX5BkYb60zjn8+n8ryv0fkR5lj3/A9kMb+3AMCC/0Lk0fFL6tjN/iFdQjhl1qbCuUX6z3y63HCUv4v8tDHL6tjN/iFdQjhl9p7Esov44Hi1/sJq9Mc51yqq2EPOm0TeDez5X8b2AS+Lcdn4+8X2Ggba4SB7egT7RiiNCyb4H7jyC3vMxXnYV9T3YSD9hv3J2D+zTBuPEm8mXDTT8j61qTIPwF5eIcnjuOTAVgPemg/KfJPemhPQBrvXZmkv5W/oeyA8aakHRhQdgDjVWwHJiCtX+QP4dUE5GFd8u1ZC4058Y0HoTEnPAHxZMacBNuRZbNZH3A+w3MdNU/wyZ7v6nwleyrGqvSf7Yba76J0ie3GBKSx3bD+zLtD/RM0R+3GDnWW77rT8p218/z3wbZ9KsO2DeTE/AyMR3eBjiaPWm8vaQvqyhZMQAa2BZOQ1i/y57WbrLe+faVq3Rx5yj6B8WhQ5Ec83jP3O4E+wQTVPTQG7pv3mT4kcvP3aT067U38Q5I9dcuCb2+i5f82yPMXaY4Xw248QmkTkMankC3NOb+cqV31ls+3F7bkfvDgWIrhx7pJfZLoYduTh2MpBe3mVCzlKUFvQtDDWAryVJ2qtLFgpu0a8inErqm1JrW3j/UZbQTbAbUXlW2Eooc2An3xv8+IQWM7Qn0WjF+fQvqP+sX6jzrO+j8Baew3IA/Zb3gS6qJ8HsPln1b7Adiw2gmtmEqWfX6s2lv6FOTh22ZQ1j8YgPU+D+2nRf4PemhjvbAs087SSaWLxptuzDfQL2BdVP2kzo/4eKX6qUn5kTd5dfdJSsPxfYLSULYn03clnz4/P3lYd7NOjf/hDO8JiRUr2An2texLvJlw008VK2gtV8UK2nW327ECls9YsYKBKlaQO1ZwZNoXvRwrOB1s26IM25Y3VnBcilPFCrZerOA06IOtGSsYTevRKVZwZobPkTdWsBrkeUX6XsUK5FPFCoheFSvYOrGCUdL9WLGCn9P+/W0lVvBqsGFvqmIFbbSzdLKKFeTT3Rixgjd1KVZwJo3dWG8+R690Sun8JKWhzrM//RTURcUKDLdO+d8Buvs48cb3q87Jk1d/eM6k9MeH5dtjpG4qetpDG+vFN6OzLmM9rVwXx1Gpu6ifrLs+m5k8IbxS/dSk/MgbdQ6J971NQNpTlDYJaazzKNs47rJ8qr1NoeMu7jXiezXe1wGX+en7hQk1bqgYiu+MmNL/CUpDGWW7gX3LdsP6E2MFmJ9jBZb/WYoVFLwJVcYK+OZ+vE9CyTfPrSz/b4Ft+2iGbRvIifmxwFiB9WM3fGrUd7YFPhucPHntJust9g3f5RJ6sxrr2aDTPkTWzamf88QK0B6xnzEBaRwDmRR0lT3CWMHXKFagbthM8v02yZ6K66tfMOS4/jdAnj9P/kYMu/EkpaEd4Bsz1Zij5KwpyuMYyuXMDpS8wTA4VmD4sW5YVvrnu228zA3SyX/ql3yzbnRWPFU3jPtiBd20a771kE585bk7tpH1GW0E24EJSGP7Memhp+Z3aCN8NjJ0voE+ywTFClSMVen4BKWhvE9SGvKQ/YZnoC7K58ExG/P/I9iw/yTeKFn2+bHPivx4Sz6vw/h+hVdh+eIU6tdrnvXQVr9ew3VxLlsnlS4ab7ox30C/gHVR9ZP6ZQsfr1Q/NSk/8iav7j5DaZOQxnqNsm0yr+TT5+cnD+uuOguH/sBM3a6cNXZnxfkMl33f/hOny+12Yiumss+T8C2v38lzJjVf92FNeGj75FfRxnphWabN9bRySneNN93Q3ZjzA8Ur1U9N167XrIOhNz2zfobe9IzjLsvnhGtvR+i4OwG4fNu6b99F8jA/fXFWJXuTon1K/32xNbYbKKNsN7Bv2W7wDd6cn2MFlv+gtC9K/sKOjBXwr8phPEPJN8+tLP9SsG2HZNi2gZyYh6c4nWIF1o/d8KlR39kW+Gxw8uS1m6y32DeThDUpsNSvvrCeDTodszQ8Xps6EfqAYwVojziuGXrz/CSlqV+/SOTmZWk9eC0mecdYwakkeyqujzaHZc/yXw3yvCx9j2k3OG6pYka+MUfJWVOUxzGUy5kdKDmXDo4V8K8xFYxNeH+NSc13StrNqViBmuOofsBYQadfIPPFCrpp13zrIZ34ynN3bOOka01DG8F2AG0E2w/fPgYVC0Mb4bORoT7LJOC+kmIFqF++dTHWf5R339ya/Qb1S79qzlWn/NeCDdtEvFGy7PNjO83XOfap5us+LF+cQv2i64c9tLFeWJZpZ+mk0kXjTTfmG+gXsC76YjTJE8Ir1U9Nyo+8yau7H6I09WuMSncxBrYpY9zGduC4zbqbFT88lcbubv9KM8+tPwJ14XV4Hgcw/1tAdx8g3tgvBjsXJhPPifz4q8Nsp1AmngvA8u0Jel7kf85DG+uFZZk219PKKd013nRDd1HfWHdVP2H+EF6pfmpSfuSNpYX+YvRHKA3HKN8vRpvMK/lU6/9Zd/KwPuCeIP7VdmULfbLXacxi2VNjltJ/thuo/2w3UEbZbmDfst3gXwLn/BwrsPwTFCtAGckh6zJW8DzV8aNQByXfPLey/J8B2/ZUhm0byIn5TGCswPqxGz416jvbAp8NTp68dpP1FvuGYzoq7oA85ViB8WhQ5Ee8OuX/pCdWgPboo1R3tEe+X7BnPwN1BmMFf0mxAtRdjBV8lmQPbRrbi+Rh2bP8XwF5/g3yN2LYjWcoDe0A+9ZqzFFyptaKcAzlcmYHzK6gLHYjVmD4Ddfe5iKxAqV/OD5wrKCg3ZyKFXxM0FP9gLEC5CnSNyxfrKCbdg35FGLXMD/P3bGNrM9oI9gOoI1g+/G0hx7aCPTF/5J0X9nIUJ8F5+c/Sn0WpeOs/6jjrP8o7+w3IA/Zb3ge6qJ8HhyzMf/XwYb9mHijZNnnx35c5P8Y5HmW2oOy/vEArA97aH9C5P+4hzbWC8sy7SydVLpovOnGfAP9AtZF1U+YP4RXqp+alB95k1d3n6c0HN9Zr1G2TeaVfPr8/ORh3X1W1BX9gW0tVvBz0N05i1sxlX32xQryztfRhj0fgOWbr/nkV9HGemFZps31tHK9FCtQ/eSzsYpXqp+arl2vWQdnMlbA8hkrVvDrL/JYQciYj7ECzM+xAsu/IO0L8z9RRsrGCj5GdcR4Rsi83vIfl9Yx6eP9MmxbaKzA8h+Q4mzNWAHqO9sCnw1Onrx2k/UW+2ZrxQqOgj7wxQo4rhk7VnBRWo9OsYITSPaKxgouAXk+KX3vZqwA7QDHCtSYo+RMxQpwDOVyZgdKzqWDYwWG33DtbS4SK1D654sVFLSbU7ECNcdR/YCxAjUXQaxejBV04ivP3VVMM+98g+1HkVjBRaT7sWIFn4gUK0B5Z78Bech+w8egLsrnwTEb818FNuxG4o2SZZ8fG2O+7sPyxQo+KfJ/wkMb64VlmXaWTs50rAD9AtZFX4wmeUJ4pfqpSfmRN3l192OUhuM76zXKNsbAbswYt7EdRWIF7A+osw3KJtSovpjfNz/ptHfUt9foQ5Sm9uozHbQJ2Ccb0nfea/T6QJ/aaJeU9znd3kfTaT7IZ2fQdvOeF+QxnkfisQHPuDxKYwPGonhPhtofqubJLHuDGfl5P5nlf4fw2X3y7Dv/lVeesQ1l5Rl143pqq+W/d2blefbWlmeWWZRnjgkpea65dhtWJp7z9h6U//dvR/L/dI/Lv5pL+OS/U4yE5R/9t60h/+tzyP/zHppK/q1tWfKP8UTM/6se+Vf89cl/pzVCn/x/nNKw3Hsz6KD8Y7+z/Fv+/xko/0a7G/KPPGL5982bkifvXIfXBNB/98k/r9fGkv+X5ZB/n++t5N/amiX/hsfx8j/2yL/SwQn4VnatC9vwMUrDcu/NoJPlz7P8W/4vBcq/0e6G/Mecv3aKM7A/j7rhk39e54gl/8tJ/icgn+8Ox5Bz7L67K6wd6symOtPHZzb/AWJD/0FzZOUj+e5IjDHn9WFNeGh3uhuDaau7MbguTtTTynXx/NdAt8+1Kl6pfmpSfuSN0q0JSgs9V/IUpU1CGp4XY/mccO3tCNXdCcD97jGtuE91wM17h+tE+q70/4OUhuV8d0KEnGNXsj5Jdcf1Pify81q05R88acu/tr6BMpJD1uVaNN9Vg+fwlXzz2p3lX5DWMenjxkkacyAn5lCK02mctX7sxppNzLtqOtlN1lt1Nq1GfyOWWr9hPRt0eq7L97JY/t2hD3xr0Xwfh7qvSdkjPnM3CWm4Fr00rQef0U3ecS16X5K9oncxngbyvH/6HtNuTFKauuvAN+YoOWuK8jiGcjmzAyXPgAevRRt+w7W3uchatNI/dU63pN2cWotWcULVD7gWrc7QIpZvLbqbds13j08nvvLaMLbxSdeahjbCd/cO2w/f/XuTUA598aWk+0+KdkwI3CFKw7IJ7jdSn0XpuO8+p5Bz7GrPHLYP5UbZMB6zMf+ZYMOuIN4oWfb5sZ3OmT9F7VHnzH1YvvP1vrOiirY6t8N1cS5bJ5UuGm+6Md9Av4B1sdOabAivVD81KT/yJq/u8vq2OseudBfj71dkjNvYDhy3WXefEnVFf2COoO8bu3130DxJaajXWA9uI9sgxGWffwx0dyPxJvb9FBPUHrV/14c16aHdyW5MEO3qforW/KqfQu6nUPe1KP3kGMOTkMbzETXmKPmcFO2YgG++cXcScJ+mWIFay/TJXqd7ICfSd6X/vFcUy7HdCB3X2W5g37LdYP+Q83OswPK/jWIFKCM5ZF3GCngcxzM3Sr55bmX5HwXbdmeGbRvIifnOwFhBpHG83u1xvJPdZL3FvuH5oxpLkaccKzAeDTodp+D7ly3/g4Gxgjz+wpOCrrJHGCv4DMUKUHcxVvB4pDjV50Ce30f+Rgy74fOted+qGnOUnKm9gTiGcjmzA2ZXUBa7ESsw/IZrb3ORWEHo3L2k3ZyKFSg/XPUDxgqQp+r+Hl+soJt2zRcD7cRXnrtjG1mfffFEtBFsP5700EMbgb74ZwLmGxMCV/ksON94gmIFvrufQ8/Jst+g5nM8bmTtaco6J/vbYMO+RLyJfacW78PPe6eWL8be6Ywu067u1GrNr/pJnTnx3anl012OMeD4znqNso37y7+UMW5jO9RaiPIHcMx/3BMr4N+9yBsPUDrPfpryfSdEXdn3/RvQ3R91Oc43Qe3JG+eb9NDuFOebINpVnK81v+qnkDgf/u7FJKWF6ifrPMp2yx0wXYoVXEOxAmUTfLLXaT/NRPqe9wwJ24288QAl62w3rD8xVoD5OVZg+f8fxQoK3iMlYwUfpTpiPEPJd9aZ4F2WbPk36ePaEo05kBOznuLM0P7t3GdBfTY4efLaTdZbNcbX6G/EUmfAWM8GnfOeneA5cxP6wPc7exzXRHvEMZCnBF1ljzBWcFxaD57rJO8YK9iNZE/F9dHmsOxZ/hNBnvdM32PaDd7jpGJGvjFHyZla58UxlMuZHSg5lw6OFRh+w7W3uUisQOmfmu+UtJtTsYJO98SpWIGaiyCWL1bQTbvmWw/pxFeeu6s7X5SN8K1hsP14ykMPbQT64seR7isbOSFwlc+C+xUupVgB6hfrf954gJpbs9+g7pNVdxPxfbKngg27kHijZNnnx3aar/vu9wy5U6vMuSfffSGd7tRSOtnF+ybkfCPmnbuKV6qf1BkxPj8Tqrt8552KByjdxRjYhRnjNrZDxSuVP4Bj/m40dk9Cvl6OFVwJursuw592rooVOCpXxQradXeS0mLHClg+J0U7JuBbaKxgrypWkDtW8Ia0L3o5VnAf2LY3RYoVjFexgqm0rRUreHePxAo+FhgreCBSrOCTIM8PV7EC31PFCoheFSvYOrGCj3UpVjB3G40VfBZs2BerWEEb7SydrGIF+XQ3Rqzgi12KFTyQI1aAdZugtLxxhJqoi7UD92RknUH4P6C73yHexD6D4Nv/2O0zCL69V9UZBP/dfr4zCL5YwQSkxTiD8J2AWIE6Uzjk2vVhEnD/z6JWXDWe+2Sv0xkE370jvjMIbDd88YeZPoPwbxQrKOjTd/UMwtDJW/5N+vg/M2xb3jMIvwiMFVRnENp5GusMwg5pv3aKFXCcYwLSYpxBODytR6czCHNObm130TMIR4E8z0vfY9oNnitUZxCC6VVnEFx5uzZTZxDQRrAdmIC0GGcQDifdVzYy1GfBMwhfTH2WvLHCCUqb6TMIJ4ANW0G8qc4gZOtkdQYhn+7GOIOwImPcxnYUOYMwh8buCcg36VrTZmpfgTqfyb7vKtDdNcSb2PsKQubrPqwJD+1O62NMu9pX0Jpf9VPIvoJJSJugtNj7Clg+J1x7O0LH3QnAfZhiBcomTMC3vPsKfHeS+PYVsN3opX0Ft6Z90cv7Ct4Jtm1Thm3Lu6/g9TBPrfYVtGLN1L6C2z2xgkko3+19Bc9QrCBrX8G7SPaK7iv4MMjzPeRvxLAb1b6Cal/BC+Dpvy/WfQWTkNbtfQXPkO4rGxnqs+C+gndTrAD1i/W/l/YVfAJs2OeJN9W+gmydrPYV5NPdGPsKPp8xbmM7iuwrYH8g9L7TGtUX8/t+l0bZHN9+BeULqXXOyQw6aBOwbZeMb/mX137+NNCn7uZaPPKI5b1TjCjvfJDv2lXrNUrejWane2830Hy2lqbhHO8IeD8c0jH/92iOh+3Mwe/zh6CMAwzErhfErhGec9rPQ59G0UuehkirB9TlyDe/7qj9bhs4pkblrS78jeVlQOQ/V+Q3Xg1S3Ydd0HOu0imjbWl1SGM/EPXC6pDo0rPLWus3ULB+IfxD/KbIf+H4dL48fTHPtcoCyrvZPrw790FKQ5s5QWnKZvpiwWx30J7i73PwWrrl/wn4WINLWzGVbUK/lmXTtw8J66Pmoc8GYPl+H7bT3jOmreaYXBfnssfmLt7lPpB3bbSTrxHCK9VPai2VYzwPQhr/TtQEpPnuiOb1WbU3TMlnrN+aOpfGQOUz+WSvk8/EshfqM7HdQP2foLS8MR3WM7SZmJ9jupZ/l7QvSu7TkDFd3gv6IahDnhjY4Wkdkz7ePcO25Y2r7ZXizJD/mTv2kXcvaCe7yXrr2xPwlMBScx7Ws0GnfV/Dq1P+hdAHHNNFe8RzvglI88V52K9GncGY7tlpPfj3NpJ3jOkeSbKn5j5oc1j2LP+5IM+L0veYdoPjPWgHOH6vxhwlZ01RHsdQLmd2wOxKwf1YwTFdw2+49jYXiekq/VPzv5J2cyqmGxpDxpiuWqNGLF9Mt5t2zTev7sRXjrGqNU5lI9gOTEAa249JDz20EeiLn026r2xkqM/yFOAup5gu6hfrf+j+z0lKU7FgHjeUDeMxG/NfDDZsLfFGybLPj+20Hulbo/poAJYvbtNp7xnTVnvPuC7OZetkF9dXBrq9bqx4pfqpSfmRN3l1l+O2k5DmiwXjeszajHEb24HjNuvuB0Vd0R/Y1mIF60F331bFCtpocz2rWEFr2kzGCt7WpVjBTlWsIHes4L5tIFbwDNi2ByPFCh6pYgVTaVsrVjDZI7GC3wuMFTwbKVbwByDPH61iBb6nihUQvSpWsHViBb/XpVhBbRuNFfwp2LBvVrGCNtpZOlnFCvLpboxYwTe7FCtgf+Ahgfs+gVtz7XYoZP+X2l+G/ODfu56ANPYJsNyDGXRUDCJ5eP+X5f9eoE9ttLsh78gjlndlszE/81vNH9FX5vm12oun5N1oWp3fJzAT3n/36C3v1mePQ77HXGva+yGNzxjj3mP+DbQJSMN6YD+hHGyGPIZbp/z/BWPD3FNaMZUMvx++cR/4+gzro+Q6ZF7zuId2p/5n2uqeCq6LE/VEeXiB1vh0mvGmG7oyiRnGp3E72ZrkCeGV6ielK+zXPQZpj1Oa704j/A00PvuIsj2Rviv5fFy0YzN847Fhs6hrgnvv0a24HxC4PtmbEPlRj1n23i/ap/Sf7cYEpLHdQBllu4F9y3YD5/tO5OdYlOXfN+0Lm9+gjOSQdRmL4nMPT0IdlHzz3N3yn5DWMenj/TNs20BOzINSnE7jpvVjN+ZsMzlust5i37yfsN4vsJCn7FMZjwad9pEMr075F0EfcCwK7RHv+UZ7NEFp7xV0lT3CWNTFaT3UuSGMRS0m2ZuANOVLsuxZ/stAnk9O32PaDfZJ0Q4gBsuUT87UPIF9KixndsDsCspiN2JRht9w7W0uEotS+jcB3zgWVdBuTsWi1PxI9QPGopCnar7ki0V1065NQIYQu4b5ffcIsT6jjZigNLQRbD/e66GHNmLS2uCmbYTPRob6LO8H3DtovjEB+Vj/UcdZ/1He2W9AHrLfgHcoKZ8Hx2zM/3KwYeuJN0qWJ+Ebj10x7ov0YU14aHc6bxRy/wTXxblsnZzpuTn6BayLnWIyIbxS/aTOZvFaWKjucnwLx3fWa5RtjPeuzxi3sR1F7j5hf+BegdsncC3/ZsDqJ4zkfUP6Xqf8rxW+q2HeL+rgOz/1gMh/P+Sx+sxx7XbsAUrDcnel70reLV9JeZ+t5B3bw/L+IKT1i/zMGxVbxJgS+0a43sBz77sgzWgOEQ7yO5GJDxzZWp/7RH2wb1m+7gesfsJI3jel73XK/06PfCl5uRu+MQ99PMf6KBnitRgsZ/xV8mX5SsrXHCVf2B6WL5+8JA/z5mGRH2XI+rZJ+ZFPloZ6aTTVeU3jdyITFxzWmg/tVy3jX6srf2NdQCw7V8i+UAw62G6b0xmdeyAN53HvJ7uNPOkXZden73XK/+vgA03SPA7Lb6bylvZB0LMvLMsuzzYYxwg+Z4n8QJuT1U7MvymjnR+Ben7GEyuxepXUu6bSO7R9IXYd8+e162y7USfvIax7BJaaB7CPMOh0HxhenfL/qidWgu27j+p+V866q/FE2REr+0I8N7Ujc1z7GHM/0VRjmOqrpih/XwZWn6g/6i33e7/T4yHnN5nAeKWyz3XK/7vQV3+4TGO6jDrck1HnwYz8D1IdLP/vC3nx2QGU/wcI0/L/EWB+LifmLRmYf+zxNZSeon+bdzxlfwL5+DClYd15XHwI6HPejUQf01DOma7z1JfH1E715fHG0r4F49VXKO6PvkUOW93v66uLRX1D++oeT/sYy8rVXbs8+nQE+fH1UzTmQE7Mb4oxXfkqhwP+tzL8Eefa/ZHkYbuMNgP18P3kkyD9u6n+Nk58N3BdxLDKjfW1v1Vj/V2Qg8d6xRvMzzZBzYexH9nHxvHmEEq7G9LYt7pL0AkdS61s0mf/dGgr7mYPbvL+CqpHJx9vbfrOdvg/csYUfDzvFFPgdVTsD44pKJmdaXnE9rM8+tqaPHnnwyyPavxQ8sh+lk9ukscnjxiX+loqj2oObvSVjeb6dPK565TfbPxgRn62+ZZ/9qlb/lV+zyOiDr55wntE/kdEnedQHbAs087a33XeeGt7LP/O0B6fPY4U85in5B/5xvLv41HyME8fFfmRV7y/61FIe5jSUP4foTQVR/LpbKhuWNmkHz9Ntjp2fI5tteU/UMiEr20+W92t+JzPVndTVns1PoeyGhqfezrAF/DFXpU8bhb1V3El7ncsd5LrXK/Nol5NUR7juFyulvGv0eFvvtjgSdSe+zztyRujwPL3UXvui9geVedOsc7TT3UtbVM2B+cWPA5Z/pefOl3urPTdF+vMK1NZsqtiO8lz8biban/yxPcF9XrqTPqC7O/hOBYSy0PZwzHthTzj0+UjrcdJfqE+M7989il5QuYVKnbWdO28vJfSEHsz0YkVF33joZ3rf6+nvZ3kg2MkPbR2ttXHZpaFvGtnbC+RjrKX3MdoX7Ff1qfvdcq/zuPTKTnwyU2nuZbVR8kGn7dX8fcu2pCelpsHKE3FA0PlxhfDwzHaxm9l79CnxHES5RnzZ6178Dhco+87wncst47azD4SY99I+a2dgxn5DY99kds9c/z7O9ThJqrDAx3qcD/VwfK/Q9TBx//k8fmEs1y7LubdR4p4Vh/8hvgNp+Vj2AU9Neaf0VNykDysy0qf1BqGzwYqPQ/xlcpg+fZDLSY6eedFWH6zh86SknSWCDrdnn8tJjoPRKSDOrOE6DwYkQ7KwR5E56GIdHA84j0tdVGHZJz4EM3zHoY05cPy2QTL/8PTpst9hOZ5aCuwjlhexTKwHUzv4ykNs38YX81hj+T5I8PqxLtPEu/UGoqPd5b/L4B3n/bwjnVb+RhzXDs/2KfHuCmviaq4LH5jmVOx6yFRjscrjM/mmSuG6AbiN1x7m4uMVyr+jD4hn+t4rBi9qXMd6myj6oe5TvNUncvkuKPyN5RtfA+loT3j+Dnq9+HwjjSy2mS+7RxP/ZQfir6birew7M20r3R/MXpeX0nFh/L6Srwvqld9Jawn+0p5Y65Y/j4PnSUl6SwRdLod2618pXA6RXyl70TylTbAeP/PNN6jrQjxle4X7WB6P+oBX+lfAtYTfLyz/JcD7/7VwzvW7cpXmq4nfkP8ylfK9pWUv9FNX+n+Dm1iX0nVT/k7yTPswp4QXwrbl6Pv9g+VTcOP5Uspv0T5Uta+h4rRG05kbce0HPqxo/Cu9iVhf8XqPxWb2Vr9t7kYPW//qZhVzP5D3RqF9079p3TzGHjHNGyPz6/E8jPlVx5DdLLG+P1Pcy1tU2taOMbzngHLfyyM8Qel73ME7ZB9AV1c5+/Pe97It6fYufz7YW0dR41DPH6psz41194nan8QrzndLegkffXqjHXrGuCuF2VZtzH/A6Ielp/PuHAePo9i+RenMpX033jGPris8yhZ67AnA+ZMn0dBPvP5DiznW4e1fCV1Yn+lE9ge1gm1t1b5ipY/dG9tk/Izn5R+JQ+uy7N8qrpuLlFX7kfsK94HbHlRLrE9LJeW/1whl6r/jefd6H/fOrziqW8dvhNPOd7l2yPsW4ePtdd3fxq/uj1H5ZjBo1CXflFXw61T/lfAGHwzjes2X3IuTGfV/AznXLyfFOdmjwdg+WzpEyL/4x7aWC8sy7S5nlaui7ol98nhXJt1S/UT5g/hleqnJuVH3uSdLz9KaaHzZZN5JZ+d7jLx6S7GpThmpWyVT/ZinANR+s92Q41xSpfYbmDfst3gOAjn51ij5X9z2hc2/0IZKRtrfILq+BjUQck3xxAt/0Ng296aYdsGcmLeETjOWj924/401He2BT4bnDx57SbrLfZNyJld5Cn79cajQZEf8fjM02boA77rAO3RY1T30PgdnyNSawiJ3PyPtB58Dip5x/nyIyR7aNPYXiQPy57l/1WQ58fI34hhN3hvJ9oB9lPVmKPkTPlnOIZyObMDZldQFrsREzf8hmtvc5G4VWiMuqTdnIqJv1fQU/2AMXHkKdI3LN+9kN20a8inELv2/7d3daFxFVH4bpLmr2m3rQ0ioi0+VB9soaCiCCm1VJHgDxZFo622Ri1G0CqCtA9dBUNRTG1+Nik1iKikUkWt2qcGpFofmocoFMFSFCWCoC9B8A9K5W7vkG+//ebce5O9JpW9L3t37pkzZ2bOOXPmzMwZ5SfPB5V1ZHlGHcF6AHUE648BozzUEWiLHyXZVzoyqc2C65C/0JoYyhfLP8o4yz/yO9sN2IZsNxwCWpTNg2M2wh8HHTZJbaN42bJj1R11GP+vSPVBXh9NgGvYKFvF9xw1ylZxh5mWIPDLpJJF1zZZzDfQLmBZVP2E8EnaSvVTnuCxbdLK7iH6huM7yzXyNsaLn/SM21gPHLdZdouCVrQH/qu9f9XyFXwHsvvbAvcVWP72mq8goieI17HV9BUk3YdYDV8B82fSs/dxZ64/TuAryDpmhJJ/1hsLyVfwz0XgK1jWceE37ONzVfIVBBHOmq9g/nwFi6EPeo14W1n7CtZFdMT5ClZ0lNd7tr6C9cDP7dF7NfVGzVdQ8xWUkEe//1dfAeqIrH0F60j2q+UrGDN8BSz/C8lXcCPosE5qm5qvwC+TNV9BOtmthq+g0zNuYz1m4ytge4D39IdPV2EmrS/QdORi6HDwjk98e618voEtYGcVjH1BDldYt3s9dUM9oeY/bOM9B3rifsPW4bgWytYJgkq9zP25qRDINngE6Nja4S/L8VCbUccQx44ODYc0IBzjcPEKsA14fDsg8qm5J5/JKVIZQ0YZgyKfKmOAcGKbqbMGB2O+j4i6BSKtTsAXPfUNRNnDMXiHBB6laywdxTa1sg0w5gvrFxUbOuSdJRS/U+2xcv9HqF5Fo17Kn8NyjrQPGbSr9kP9ofZH8lkG5q1+Uc+c+O/oexzSWMeqGOwI4/Ly/tS9QmcyTt8+wG4PzpeEz8HimbWQxmOx1U9Ij9rXWKR8KoZQINJU/7xGsEhD+DhdqHi231MOt4eiwTpfa53fi4vjZckm7in8Kwowrfa9c8z514l2hN1P9PHZDOZv3g+LcXjUegHzt4MfNPhbnQtEuro9OIcN/lbtfi2kpY2fxnMjFT9N0Y66h9NU/zB/8zkg5G8+47PfU47ifaZBrTs5/u7z4OQy085LXd6w3/cRf6v7wZhfsEy1Jy8v8nOMJkfDYeAlvq8C6UxypsXBHzH4s9px0nmtAHmq38iH/dcsylrtXs7bj8PnZKEp8PMg71f/BNrpxAZNS47piXkyPMe4Okf4gkD7CC/Sc4yrqnGOkc9Ghe/o2x6n+Z6SMcz7aPTOMvYFzLM+9+AMgrnppl1Xl+PNKnarkt0kcbOte2gcDcqGRPjHone2ISdANo9lHlM+N618SmgjLioEZfWyzk2FT1o7lu/RUesjFn8pXy/zje+eAoePz5l9a6xb4bk8PuvSl5J2XwxglkWUDZbjPoHXimuv5B7p3hq9s9z/YIyt1b73xYrjx34kFWNYyYuDyyIG6kK5g4TtSBW3VOle194hT9xHulfFW8a+Zf5CXPWCjoei9waCnzb4K25cSRtbn2MzJ42Dnv0dN8GK+T7v7PpW+ZI4TjfqQj4nr+42DHnieuIvNU5i3oejdx4n66I2SuprsWQuboxy9Fi+FuVTZV5S/j1Hg7XXIHzfEZS3g4NvhXY4lv3Z041p14NH4FuS9Tprjxy2SZ7guV/wP+Ky1l/UvUZFgZ9jP7VDH1hnYiwfcxLald5V8oYy9c2aC+9qns82q3U/DefFsafRA++bf64S7cX6zOd73UY4HfxVhj5QY+qrkJY2Rjv7XpU/Us0frNgA1bHng1vmO0Y7jx9WbP+0MdqT8j/y0DjxP47nr1CZlh3LebEcH//7YqTfYPB/3Ly8i3A6+JsM/ldtafF/nI1g2UhWXB6nbzK0zzfPt33O/G/Z52n9vEn5H3no/TXleFX8ZMz7YPTO8ZM7U/IXzhtma4MqHrJ0L/tnlO3K/egbZ3ie4uC3JLS3qnTnxiXzrc957U3Zt5b+tGILKf2pxkvWn9sMe0vd5abkLQntSeUNZeogjTc49+Xxps8ok/OiXPvGG4ePx4adxniDczPlD+LxxsH3GPpA6S5rvImbr7M/SN2prOby1nzdwc1RPldmfa9WnK+MxxvUh3xfDsoG2zJJ/Txx8/uXI/6fW7u+UIIv0VKYwV0vIB3+BoLfG/VJC9DpfhsS0PHnW79/+O4Hp08tp/zh4/qodQ74r+nt/+i2s+c2ZYV/oufO49tvvW5JVvg3j53addnGqfas8J/s+bJr6bKgLiv8a79feenI1B1DWeEff6pl/Zmxpp1x+JdG742Fme+op8KnKfrvzlUxvMPXQPDFSAZC2RkhW2WRKK+0X92Ay3l+SzhEWkOhPK2lUAlfX6iEd2W3FippdN8WwzfUsSWY6D+2F+Jqge8I/05Ud9cnzZDH5c+L8pup/DK6RRrqeMZVL9IcfNg/o6TXsO5p17jDp5HyYxqX7XjDrVWHT1OhknbsU0ef6zdsU+5T5I8GoKtUZvQf+xRxoYwg/FHqU6yby58X5WO7cFmqfO5TxestAj5s1yPQrrPVN8+efPuBtp93P5GVPrtr99PP3HP6pzNZ4f/19j1v3P31gYGs8Dfn2p4/f8WTn2aFf+rm6b/3bKh/MSv8XXVTl3925XtvZoX/x+V/dPaeyJ/NCn/39n2Hv5ocnIjD/y8UXWxwtCIJAA==",
      "debug_symbols": "TL3LkjW7jpz5LnusweIFAFGv0gNZq1uSlVmZykyXUb28MuAE3Se1P6/zJ53BIHzFikBG/sc///9//S//57//53/9H//t3//XP//y//zHP//lf/7rv/3bv/73//xv//7//b//+1///X/8/X//45/f939W/PMv6z/9s84//+J//8l//uX8p3/23/80fn//HX//nX//nX//3X//XX///ftne9//2v2v3//G/e+5/0381373v+P+d97/3vHsjmd3PLvj2R3P7nh2x/M7nt/x/I7ndzy/4/kdz+94fsfzO57f8eKOF3e8uOPFHS/ueHHHizte3PHijhd3vHPHO3e8c8c7d7xzxzt3vHPHO3e8c8c7d7y84+UdL+94ecfLO17e8fKOl3e8vOPlHW/8fg2jYTasht1gDd4QDaehRx498uiRR488euTRI48eefTIo0cePfLokeffyPP3wWiYDathN1iDN0TDacgLq0dePfL6Rh4frIbdYA3eEA2n4Rv5r17GV0jzfDAaZsNq2A3W8Dfymh9Ew2nIC19JrfXBaJgN38jfin1lBbCGb+T8IBpOQ174igswGmbDatgN1tAje4/sPbL3yF+Z7W99vjoDzIbVsBuswRui4TTkhdMjnx759MinRz498umRT498euTTI58eOXvk7JGzR84eOXvk7JGzR84e+SvB/Z2drwY/mF8NAkbDbFgNu8EavCEaTkOPPHrk0SOPHnn0yKNHHj3y6JFHjzx65NEjzx559sizR5498uyRZ488e+TZI88eefbIq0dePfLqkVePvHrk1SOvHnn1yKtHXj3y7pF3j7x75N0j7x5598i7R9498u6Rd49sPbL1yNYjW49sPbL1yNYjW49sPbL1yN4je4/sPbL3yF8Nbv/AGrwhGk5DXqgaLBgNs2E19MjRI0ePHD1y1WB+kBeqBgv+Rrb9wWxYDbvBGrwhGk5DXvhqENAjZ4+cPXL2yHkTaaY3RMNpuIm0fr+G0TAbVsNusAZviIbT8M05/uCrQcBomA2rYTdYgzdEw2nokWePPHvk2SPPHvmrQTsfWIM3RMNpyAtfDQJGw2xYDT3y6pFXj7x65LqYtA/ywleDgNEwG1bDbrAGb4iGHnn3yNYjW49sPbL1yNYjW49sPbL1yNYjW4/sPbL3yN4je4/sPbL3yN4je4/sPbL3yNEjR48cPXL0yNEjR48cPXL0yNEjR498euTTI58e+fTIp0c+PfLpkU+PfHrk0yNnj5w9cvbI2SNnj5w9cvbI2SNnj5x35P37NYyG2bAadoM1eEM0nIYeefTIo0cePfLokUePPHrk0SOPHnn0yKNHnj3y7JFnjzx75Nkjzx559sizR5498uyRV4+8euTVI68eefXIq0dePfLqkbsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0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lnTL55a/H3EQJ3ERN9GITgziIdJt0G3QbdBt0G3QbdBt0G3QbdBt0G3SjVmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWVLPg+F6jNKpd8GJlycVBnMRF3EQjOjGIdMt2m9VD2DiI5TYKF3ETjejEIB5iPqwsuTiIdBt0G3QbdBt0G3QbdBt0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNt0M7oZ3YxuRjejm9HN6GZ0M7oZ3ZxulSXDCidxEcvtFBrRiUE8xHxYWXJxECdxEekWdAu6Bd2CbkG3Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7ekW9It6ZZ0S7ol3ZJuSbekWz43vDTs4iBO4iJuohGdGMRDpNug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptumm9HN6GZ0M7oZ3YxuRjejm9HN6OZ0c7o53ZxuzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnMkmrGHN9rS2d1YzYO4iQu4iYa0YlBPES6bbptum26VZbMWbiJRnRiEA8xH1aWXBzESaSb0c3oZnQzuhndjG5ON6eb083p5nRzujndnG5ON6db0C3oFnQLugXdgm5Bt6Bb0C3oduh26Hboduh26Hboduh26HboduiWdEu6Jd2Sbkm3pFvSLemWdMvnVj2djYM4iYu4iUZ0YhAPkW6DboNug26DboNug26DboNulSXfC39ntXlerCy5WG5ZOImLuIlGdGIQDzEfIkuAdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdDO6Gd2MbkY3o5vRzehmdDO6Gd2cbk43p5vTzenmdHO6Od2cbk63oFvQLegWdAu6Bd2CbkG3oFvQ7dDt0O3Q7dDt0O3Q7dDt0O3Q7dAt6ZZ0S7ol3ZJuSbekW9It6ZbPzX4/4iBO4iJuohGdGMRDpNug26DboNug26DboNug26DboNug26Qbs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEswR9r9+fN5noe73oxCAeYj6sLLk4iJO4iHSbdJt0m3SrLFlemA8rSy4O4iQu4iYa0YlBpNui26bbptum26bbptum26bbpltlybLCfFhZcnEQJ3ERN9GITgwi3YxuTjenm9PN6eZ0c7o53ZxuTjenW9At6BZ0C7oF3YJuQbegW9At6Hboduh26Hboduh26Hboduh26HbolnRLuiXdkm5Jt6Rb0i3plnTL54a+14uDOImLuIlGdGIQD5Fug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbsySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJL0Pe6ojCIh5gPkSXAQZzERdxEI9Jt0W3RbdFt023TbdNt023TbdNt023TbdNt083oZnQzuhndjG5GN6Ob0c3oZnRzujndnG5ON6eb083p5nRzujndgm5Bt6Bb0C3oFnQLugXdgm5Bt0O3Q7dDt0O3Q7dDt0O3ypLvL91N9L1ezIeVJfWHy9D3enESF3ETjejEIB5iXlzoe704iJO4iJtoRCcG8RDpNug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26bbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptulmdDO6Gd2MbkY3o5vRzehmdDO6Od2cbk43p5vTzenmdHO6Od2cbkG3oFvQLegWdAu6Bd2CbkG3oNuh26Hboduh26Hboduh26HboduhW9It6ZZ0S7ol3ZJuSbekW9KNWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKY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"
    },
    {
      "name": "verify_id_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "verified_id",
            "type": {
              "kind": "array",
              "length": 5,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "note_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 5,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 2,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                          "fields": [
                            {
                              "name": "log",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log::Log",
                                "fields": [
                                  {
                                    "name": "fields",
                                    "type": {
                                      "kind": "array",
                                      "length": 18,
                                      "type": {
                                        "kind": "field"
                                      }
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "note_hash_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "963818325383147006": {
            "error_kind": "string",
            "string": "Function verify_id_private can only be called statically"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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dR5d59F1Hl3n0XUeXefRdR5d59F1Hl3n0XUeXefRdR5d59F1Hl3n0XUeXefRdR5d59F1Hl3n0XUeXefRdR5d59F1Hl3n0XUeXefRdR5d59F1Hl3n0XUeXefRdR5d59F1Hl3n0XUeXefRdR5d59F1Hl3n0XUeXefRdR5d59F1Hl3n0XUeXefRdR5d59F1Hl3n0XUeXefRdR5d59F1nh1wYUnedJpuUxRlnYNG02xaTbupPaI9oj2iPbLOPb8v49c0mmbTatpN1uRNp+k2tcdoj9Eeoz1Ge4z2GO0x2mO0x2iP0R6zPWZ7zPaY7THbY7bHbI/ZHrM9Znus9ljtsdpjtcdqj9Ueqz1We6z2WO2x22O3x26P3R67PXZ77PbY7bHbY7eHtYe1h7WHtYe1h7WHtYe1R3710++XGI35FVAPx4crcRIXcRON6MRDvMRozK+Keki3Q7dDt0O3Q7dDt0O3Q7dDt0u3S7dLt0u3S7dLt0u3S7dLt0u3oFvQLegWdAu6Bd2CbkG3oFu0G76h6uEgTuIibqIRnXiIl0i3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TTejm9HN6GZ0M7oZ3YxuRjejm9HN6cYsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnMksUsWcySxSxZyBJPPMRLjEZkCXAQJ3ERN9GIdFt0W3RbdEOWnMRBnMRF3EQjOvEQLzEajW5GN6Ob0c3oZnQzuhndjG5GN6eb083p5nRzujndnG5ON6eb0+3Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7dLt0u3S7dLt0u3S7dLt0u3S7dIt6BZ0C7oF3YJuQbegW9At6Bbttn8/4iBO4iJuohGdeIiXSLdBt0G3QbdBt0G3zJLvy2dndh0WHuLnNnZiNGaWPBzESVzETTSiEw+RbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bbkY3o5vRzehmdDO6Gd2MbkY3o5vTzenmdHO6Od2cbk43p5vTzel26Hboduh26Hboduh26Hboduh26Hbpdul26Xbpdul26Xbpdul26XbpFnQLugXdgm5Bt6Bb0C3oFnSLdstOxsJBnMRF3EQjOvEQL5Fug26DboNug26DboNug26DbswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxkyUmcxEXcRCM68RAvMRqRJUC6TbpNuk26ZZbMkejEQ7zEaMwseTiIk7iIm0i3RbdFt0W3RbdNt023TbdNt023zJL5S3TiIV5iNGaWPBzESVzETaSb0c3oZnQzujndnG5ON6eb083p5nRzujndnG6Hboduh26Hboduh26Hboduh26Hbpdul26Xbpdul26Xbpdul26XbpduQbegW9At6BZ0C7oF3YJuQbdot+z6LBzESVzETTSiEw/xEuk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26Tbptui26Lbotui26Lbotui26Lbotui26bbptum26bbpxiy5zJLLLLnMksssucySyyy5zJLLLLnMksssucySyyy5zJLLLLnMksssucySyyy5zJLLLLnMksssucySyyy5zJLLLLnMksssucySyyy5zJLLLLnMksssucySyyy5zJLLLLnMksssucySyyy5zJLLLLnMksssucySyyy5zJLLLLnMksssucySyywJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglgSyZiZtoRCce4iVGI7IEOIiTSLdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNN6Ob0c3oZnQzuhndjG5GN6Ob0c3p5nRzujndnG5ON6eb083p5nQ7dDt0O3Q7dDt0O3Q7dDt0O3Q7dLt0u3S7dLt0Q5Z4ohGdmG438RKjEVkCHMRJXMRNNKIT6RZ0i3Jbv9+POIiTuIibaEQnHuIl0m3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6Gd2MbkY3o5vRzehmdHO6Od2cbk43p5vTzenmdHO6Od0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3S7dLt0u3S7dLt0u3S7dLt0u3S7dgm5Bt6Bb0C3oFnQLugXdgm7MksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLB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",
      "verification_key": "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\nAAAFiSRi70jt/BTMpcaOrm4="
    }
  ],
  "outputs": {
    "globals": {},
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "serial",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "binnedAmount",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::TransferEvent"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "serial",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "binnedAmount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::_log_transfer_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::_log_transfer_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::binned_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::binned_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::check_transfer_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::check_transfer_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "ShieldGateway::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::sync_private_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "verified_id",
                    "type": {
                      "kind": "array",
                      "length": 5,
                      "type": {
                        "kind": "field"
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::verify_id_private_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::verify_id_private_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::{compute_fn_selector, size_in_fields};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "108": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY, call_interface_stubs::stub_fn, stub_registry,\n    },\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_authorize_once, fn_has_noinitcheck, get_fn_visibility,\n        is_fn_contract_library_method, is_fn_initializer, is_fn_internal, is_fn_private,\n        is_fn_public, is_fn_test, is_fn_utility, is_fn_view, modify_fn_body, module_has_initializer,\n        module_has_storage,\n    },\n};\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\npub(crate) comptime fn create_authorize_once_check(f: FunctionDefinition) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[private] or #[public] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_fn_private(f) {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "110": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "113": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{private_notes::MAX_NOTE_PACKED_LEN, process_message::do_process_message},\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        do_process_message(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "114": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "115": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "116": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "117": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "118": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::decode_message,\n    encryption::{aes128::AES128, log_encryption::LogEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    constants::PRIVATE_LOG_CIPHERTEXT_LEN,\n    debug_log::{debug_log, debug_log_format},\n};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn do_process_message<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message = AES128::decrypt_log(message_ciphertext, message_context.recipient);\n\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "119": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\npub global MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{\n        GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2,\n        PRIVATE_LOG_CIPHERTEXT_LEN,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PlaintextLen * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let env = TestEnvironment::new();\n\n        // Log decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"utilityGetIndexedTaggingSecretAsSender\").returns(\n                IndexedTaggingSecret::deserialize([69420, 1337]),\n            );\n            let _ = OracleMock::mock(\"privateIncrementAppTaggingSecretIndexAsSender\").returns(());\n\n            // Encrypt the log\n            let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the log\n            let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec =\n                BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n"
    },
    "136": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "148": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::{Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "151": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "156": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "157": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "158": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(utilityGetContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(utilityGetBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(utilityGetTimestamp)]\nunconstrained fn get_timestamp_oracle() -> u64 {}\n\n#[oracle(utilityGetChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(utilityGetVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_timestamp() -> u64 {\n    get_timestamp_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "159": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "165": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "166": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "168": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "173": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "176": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 1;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. PXE is using version '1', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "206": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "209": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "210": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "212": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "213": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "215": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "217": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "229": {
      "path": "/home/vscode/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "294": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "310": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "319": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        // Q: I don't understand this comment. We could still compute a siloed nullifier from a zero contract address.\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert_eq(input[in_len - remainder + i], 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "333": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut result = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         result\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Serialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the serialized member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize(self.$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    result[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; _];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Serialize::serialize(self.$param_name)\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "334": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "335": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "345": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "360": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "362": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "363": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "383": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "395": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[derive(Eq, Serialize, Packable)]\n#[custom_note]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    pub fn get_owner(self) -> AztecAddress {\n        self.owner\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` so that they can discover the\n    /// note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            self.pack().concat([storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        note_completion_log.concat(padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, FromField, Packable}},\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        // The following is a misuse of the `deserialize` function, but this is just a test and it's better than\n        // letting devs manually construct it when they shouldn't be able to.\n        let partial_note = PartialUintNote::deserialize([commitment]);\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(private_log_without_public_tag.concat(public_log_without_tag), note.pack());\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "50": {
      "path": "/home/vscode/turnstile-monorepo/aztec/contracts/shield_gateway/src/main.nr",
      "source": "pub mod test;\n\nuse aztec::macros::aztec;\n\n#[aztec]\npub contract ShieldGateway {\n    use std::meta::derive;\n\n    use aztec::{\n        event::event_interface::{emit_event_in_public, EventInterface},\n        macros::{events::event, functions::{initializer, internal, private, public, utility, view}},\n        oracle::capsules,\n        protocol_types::{address::AztecAddress, traits::{FromField, Hash, Serialize, ToField}},\n    };\n\n    pub global VP_SLOT: Field = 0x1dfeed;\n    pub global BIN_AMOUNT: u128 = 1_000_000_000;\n\n    #[derive(Serialize)]\n    #[event]\n    struct TransferEvent {\n        serial: Field,\n        token: AztecAddress,\n        binnedAmount: u128,\n    }\n\n    #[private]\n    fn check_transfer(sender: AztecAddress, recipient: AztecAddress, amount: u128) {\n        let token: AztecAddress = context.msg_sender();\n\n        aztec::oracle::debug_log::debug_log_format(\n            \"Checking transfer of {0} {1} tokens from {2} to {3}\",\n            [amount.to_field(), token.to_field(), sender.to_field(), recipient.to_field()],\n        );\n\n        // TODO: Implement verified ID checks\n        // // Ensure Verified ID is provided & valid\n        // // Safety: value constrained later\n        // let mut verified_id: [Field; 5] =\n        //     unsafe { capsules::load(context.this_address(), VP_SLOT).unwrap() };\n\n        // let _ = ShieldGateway::at(context.this_address()).verify_id_private(verified_id).view(\n        //     &mut context,\n        // );\n\n        // Publicly log Verified ID Serial & Token & binned value (Amount / BIN_AMOUNT)\n        ShieldGateway::at(context.this_address())\n            ._log_transfer(\n                0, // TODO: using dummy serial number. Switch to verified_id[0] when available\n                token,\n                _binned(amount),\n            )\n            .enqueue(&mut context);\n    }\n\n    #[contract_library_method]\n    fn _binned(amount: u128) -> u128 {\n        amount / BIN_AMOUNT\n    }\n\n    #[utility]\n    unconstrained fn binned(amount: u128) -> u128 {\n        _binned(amount)\n    }\n\n    #[public]\n    #[internal]\n    fn _log_transfer(serial: Field, token: AztecAddress, binnedAmount: u128) {\n        emit_event_in_public(TransferEvent { serial, token, binnedAmount }, &mut context);\n    }\n\n    #[private]\n    #[view]\n    fn verify_id_private(verified_id: [Field; 5]) -> bool {\n        // TODO: Implement ID verification logic\n        aztec::oracle::debug_log::debug_log_format(\"Verified ID: {}\", verified_id);\n        true\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "63": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "64": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "71": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between a #[private] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[private] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[private] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[private] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[private] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp =\n            inputs.historical_header.global_variables.timestamp + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"undefined\" for the first\n    /// function call of every transaction. A value of `-1` is returned in such\n    /// cases.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// TODO(https://github.com/AztecProtocol/aztec-packages/issues/14025) - we\n    /// are considering making msg_sender: Option<AztecAddress>, since\n    /// a returned value of `Option:none` will be clearer to developers.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `-1` for the first function call of the tx.\n    ///\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[private] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[private]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some historical block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[private] macro.\n    ///\n    /// # Arguments\n    /// * `returns_hasher` - A hasher containing the return values to hash\n    ///\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[private] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a heft function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "72": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_U32_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between a #[public] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[public] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[public] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[public]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"undefined\" for the first\n    /// function call of every transaction. A value of `-1` is returned in such\n    /// cases, and is enforced by the protocol's kernel circuits.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The address of the account or contract that called\n    ///   this function\n    ///\n    /// # Examples\n    /// ```rust\n    /// #[aztec(public)]\n    /// fn transfer(context: &mut PublicContext, to: AztecAddress, amount: u64) {\n    ///     let sender = context.msg_sender();\n    ///     // Only the sender can transfer their own tokens\n    ///     assert(sender == get_token_owner(), \"Unauthorized\");\n    /// }\n    /// ```\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    /// * Globally visible unlike private execution where it's contract-local\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[public] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "74": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_timestamp, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let contract_address = get_contract_address();\n        let version = get_version();\n        let chain_id = get_chain_id();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "75": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/event/event_interface.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext},\n    event::event_selector::EventSelector,\n    messages::{\n        logs::{event::to_encrypted_private_event_message, utils::prefix_with_tag},\n        offchain_messages::emit_offchain_message,\n    },\n    utils::remove_constraints::remove_constraints_if,\n};\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator,\n    traits::{Serialize, ToField},\n};\n\n/// Specifies the configuration parameters for message delivery. There are two fundamental aspects to consider:\n///\n/// +----------------------------------------------------------------------------------------------------------+\n/// | 1. Delivery Mechanism                                                                                    |\n/// | - Messages can be delivered either on-chain or out-of-band                                               |\n/// | - On-chain delivery uses the Aztec protocol's private log stream, submitted to L1 blobs and consuming DA |\n/// | - Out-of-band delivery is implemented by the application (e.g. storing ciphertexts in cloud storage)     |\n/// | - Out-of-band delivery cannot have any cryptographic constraints since messages are never stored on-chain|\n/// +----------------------------------------------------------------------------------------------------------+\n///\n/// For on-chain delivery, we must also consider:\n///\n/// +----------------------------------------------------------------------------------------------------------+\n/// | 2. Message Encryption and Tagging                                                                        |\n/// | - Messages can use either constrained or unconstrained encryption                                        |\n/// | - Constrained encryption guarantees the ciphertext is formed correctly but costs more in constraints,    |\n/// |   which results in slower proving times                                                                  |\n/// | - Unconstrained encryption trusts the sender but is cheaper constraint-wise and hence faster to prove    |\n/// | - Tagging is an indexing mechanism that helps recipients locate their messages                           |\n/// | - If tagging is not performed correctly by the sender, the recipient will not be able to find the message|\n/// +----------------------------------------------------------------------------------------------------------+\n///\n/// For off-chain delivery, constrained encryption is not relevant since it doesn't provide any additional guarantees\n/// over unconstrained encryption and is slower to prove (requiring more constraints).\n///\n/// There are three available delivery modes described below.\npub struct MessageDeliveryEnum {\n    /// 1. Constrained On-chain\n    /// - Uses constrained encryption and in the future constrained tagging (issue #14565) with on-chain delivery\n    /// - Provides cryptographic guarantees that recipients can discover and decrypt messages (once #14565 is tackled)\n    /// - Slowest proving times since encryption is constrained\n    /// - Expensive since it consumes L1 blob space\n    /// - Use when smart contracts need to make decisions based on message contents\n    /// - Example 1: An escrow contract facilitating a private NFT sale that needs to verify payment before releasing\n    ///   the NFT to the buyer.\n    /// - Example 2: An application with private configuration where changes must be broadcast to all participants.\n    ///   This ensures every user can access the latest configuration. Without notification of config changes,\n    ///   users would be unable to read updated variables and therefore blocked from using the application's\n    ///   functions. This pattern applies to all critical events that require universal broadcast.\n    ///\n    /// Safety: Despite being called CONSTRAINED_ONCHAIN, this delivery mode is currently NOT fully constrained.\n    /// The tag prefixing is unconstrained, meaning a malicious sender could manipulate the tag to prevent\n    /// recipient decryption. TODO(#14565): Implement proper constrained tag prefixing.\n    pub CONSTRAINED_ONCHAIN: u8,\n\n    /// 2. Unconstrained On-chain\n    /// - Uses unconstrained encryption and tagging with on-chain delivery\n    /// - Faster proving times since no constraints are used for encryption\n    /// - Expensive since it consumes L1 blob space\n    /// - Suitable when recipients can verify message validity through other means\n    /// - Use this if you don't need the cryptographic guarantees of constrained encryption and tagging but\n    ///   don't want to deal with setting up out-of-band delivery infrastructure as required by mode 3\n    /// - Example: Depositing a privately-held NFT into an NFT-sale escrow contract. The buyers know the escrow\n    ///   contract's decryption keys, they receive the message on-chain and are willing to buy the NFT only if the NFT\n    ///   contained in the message is legitimate.\n    pub UNCONSTRAINED_ONCHAIN: u8,\n\n    /// 3. Out-of-band\n    /// - Uses unconstrained encryption with off-chain delivery\n    /// - Lowest cost since no on-chain storage is needed and short proving times since no constraints are used\n    ///   for encryption\n    /// - Suitable when recipients can verify message validity through other means\n    /// - Requires setting up custom infrastructure for handling off-chain delivery (e.g. cloud storage)\n    /// - Example: A payment app where a merchant receives the message off-chain and is willing to release the goods\n    ///   once he verifies that the payment is correct (i.e. can decrypt the message and verify that it contains\n    ///   a legitimate token note - note with note commitment in the note hash tree).\n    pub UNCONSTRAINED_OFFCHAIN: u8,\n}\n\npub global MessageDelivery: MessageDeliveryEnum = MessageDeliveryEnum {\n    CONSTRAINED_ONCHAIN: 1,\n    UNCONSTRAINED_ONCHAIN: 2,\n    UNCONSTRAINED_OFFCHAIN: 3,\n};\n\n/// Emits an event that can be delivered either via private logs or offchain messages, with configurable encryption and\n/// tagging constraints.\n///\n/// # Arguments\n/// * `event` - The event to emit\n/// * `context` - The private context to emit the event in\n/// * `recipient` - The address that should receive this event\n/// * `delivery_mode` - Controls encryption, tagging, and delivery constraints. Must be a compile-time constant.\n///   See `MessageDeliveryEnum` for details on the available modes.\npub fn emit_event_in_private<Event>(\n    event: Event,\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    delivery_mode: u8,\n)\nwhere\n    Event: EventInterface + Serialize,\n{\n    // This function relies on `delivery_mode` being a constant in order to reduce circuit constraints when unconstrained\n    // usage is requested. If `delivery_mode` were a runtime value then performance would suffer.\n    assert_constant(delivery_mode);\n\n    // The following maps out the 3 dimensions across which we configure message delivery.\n    let constrained_encryption = delivery_mode == MessageDelivery.CONSTRAINED_ONCHAIN;\n    let emit_as_offchain_message = delivery_mode == MessageDelivery.UNCONSTRAINED_OFFCHAIN;\n    // TODO(#14565): Add constrained tagging\n    let _constrained_tagging = delivery_mode == MessageDelivery.CONSTRAINED_ONCHAIN;\n\n    let (ciphertext, randomness) = remove_constraints_if(\n        !constrained_encryption,\n        || to_encrypted_private_event_message(event, recipient),\n    );\n\n    // We generate a cryptographic commitment to the event to ensure its authenticity during out-of-band delivery.\n    // The nullifier tree is chosen over the note hash tree for this purpose since it provides a simpler mechanism\n    // - nullifiers require no nonce, and events, being non-spendable, don't need the guarantee that a \"spending\"\n    // nullifier can be computed.\n    // TODO(#11571): with decryption happening in Noir we can now use the Packable trait instead.\n    let serialized_event_with_randomness = [randomness].concat(event.serialize());\n    let event_commitment = poseidon2_hash_with_separator(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n    context.push_nullifier(event_commitment);\n\n    if emit_as_offchain_message {\n        emit_offchain_message(ciphertext, recipient);\n    } else {\n        // Safety: Currently unsafe. See description of CONSTRAINED_ONCHAIN in MessageDeliveryEnum.\n        // TODO(#14565): Implement proper constrained tag prefixing to make this truly CONSTRAINED_ONCHAIN\n        let log_content = prefix_with_tag(ciphertext, recipient);\n\n        context.emit_private_log(log_content, log_content.len());\n    }\n}\n\npub fn emit_event_in_public<Event>(event: Event, context: &mut PublicContext)\nwhere\n    Event: EventInterface + Serialize,\n{\n    let mut log_content = [0; <Event as Serialize>::N + 1];\n\n    let serialized_event = event.serialize();\n    for i in 0..serialized_event.len() {\n        log_content[i] = serialized_event[i];\n    }\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    log_content[serialized_event.len()] = Event::get_event_type_id().to_field();\n\n    context.emit_public_log(log_content);\n}\n\npub trait EventInterface {\n    fn get_event_type_id() -> EventSelector;\n}\n"
    },
    "76": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "78": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n    // +1 to length to account for the separator\n    let nonzero_length = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, nonzero_length)\n    // NOTE: we use poseidon2_hash_subarray here because we want to hash the bytecode only up to\n    // its nonzero length. We do NOT want to include a `1` at the end to indicate \"variable length\",\n    // and we want to enforce that all trailing elements are zero.\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "95": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"
    },
    "99": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // TODO(#15012): Here we use PRIVATE_LOG_CIPHERTEXT_LEN for message ciphertext length. Fix message vs log naming.\n    quote {\n        #[$utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::do_process_message(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    }
  }
}
