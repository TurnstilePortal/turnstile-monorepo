{
  "transpiled": true,
  "noir_version": "1.0.0-beta.1+4144a8dce4789d85",
  "name": "ShieldGateway",
  "functions": [
    {
      "name": "get_default_channel_threshold",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_default_channel_threshold"
      ]
    },
    {
      "name": "process_log",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8861757336002045335": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 99
          },
          "9862881900111276825": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 35
          }
        },
        "parameters": [
          {
            "name": "log_plaintext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "tx_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "unique_note_hashes_in_tx",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 64,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "first_nullifier_in_tx",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "process_log"
      ]
    },
    {
      "name": "get_storage_address",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "H4sIAAAAAAAA/7WWTVODMBCGk5Z+UERn6i/wolewdNpj/bh48eDBe4RQOyrMAN770wXdyLoNTB3CzjCbhOTJm2WTwFltHLzF/hpnRxhvabsCb4MfoPfD8tlA3etmvk3mNclfe8HS1qzPoP6FDUzeD99T/J7i702Ac7+v+Xgtat5p+Zygsgtlt2V8n9rLbxvYiGmaX5p/3qC/MgficAH1KjanUN7K4vY9Dd8ePz9eZIZ3GY0u05CxVdR5Tb1LkyITYXETRZnMc0oYaMisgTpD1FexSx6iJj3/pD3LLN+lCaVZR9KG0GeE+uMxtqZtA97rZr/5NDbP9l1gT0hc8JqmqN1gHl/rMo5+XTz/jGg1va84mU/pofFR+VxlmAPlvEgzsZVPUkRYOg0f9TTtdPcm3kK6cTgtVX2s4bRZ39cF1+hsCy1nhynftgXP2OFRo8a6rPn6cFj9K2Htza99tf5Z+7d+4I+Y/lC10Hvc/xLqM6RfeauDzngl/HghYrEUURSEYk74jMTpC2r9GILgCQAA",
      "debug_symbols": "7ZjBioMwEIbfJWcPmUwySfoqy1Jsa4sgtli7sBTffc2uUXcVXcit5iJGPsY/3+gh82Sn7PC47PPyfL2z3duTFddjWufXsl09m4Qdqrwo8st+/JhxdwH5zd9vaemW9zqtarYDIpGwrDy5Wy3aCue8yNiOsEkmsOGqY43AHjV6BlXCo0rxHgUJzXvCQIVHUeSjaLMcRaLtUElmEoWCo1iOHWtBL0ehXiAJmkTR4VEk+ChKrkQxvEM1nzbIzEbhWvj67b2i5TAIyotBIezwDqIZGqT2HQVpR3LsHC3A6I4Wgq98AG0J42GOtAxrLr0XNXQT1FwKqX1dae0v1jm00eE/HKL1f6ca/xI/DgWPDoMdQnQY7FBEh8EOMToMdiijw2CHKjoMdkjRYbBDvVmHZAeHZs1hu0W/Q8RhhwhmLgbX2NszIxrnaAO+PwblCkvgz0s02p5jXS+3e156vV5u99z2cr3E7Z4fX6yXTbv8SKs8PRRZN+o8P8rjaPJZf96yP0PQW3U9ZqdHlblx6GgS6r4KxARNW7Yt/QU=",
      "brillig_names": [
        "get_storage_address"
      ]
    },
    {
      "name": "_log_channel_threshold_exceeded",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "7136678259008445534": {
            "error_kind": "string",
            "string": "Function _log_channel_threshold_exceeded can only be called internally"
          }
        },
        "parameters": [
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JgACBAEnAAABBIBHJgAABAMmAgQEAyYCBQQAHxgABQAEgEQtCIBEAAEtCIBFAAItCIBGAAMkAAAAUSQAAABSJwIAAQSARyYCAgQAOg0AAQACJSQAAAEbHgIABAAeAgAFADI4AAQABQAGJgIEAQEjAgAGAAAAeyQAAAFEHgIABAEeAgAFAAo4BAUGIwIABgAAAJckAAABVigCAAQAfG2HQyYCBgQEJgIIBAMAOAYIBywIAQUAEAEHASYDBQQBACgFAgcsDgYHACgHAgcsDgYHJgIHBAMAOAUHBiwMBgcsDgEHACgHAgcsDgIHACgHAgcsDgMHACgHAgcsDgQHJgIBBAQAKAUCBCwNBAMmAgYEAgA4BAYCNg0AAgADJScAgAQEeAANAAAAgASAAyMAgAMAAAFDKQEAAQX3ofOvpa3UyjsBAQIlKQEAAQW+Hj//PqT2+jsBAQIlKQEAAQVjCpMQmHOcXjsBAQIlLQAYyhjK",
      "debug_symbols": "7VnBbsIwDP2XnHtInNhx+JVpmgqUqVJVUIFJE+LflyKaFahWbet2wFxQg15iv/dcyY0PalnM968vZb1ab9Xs6aCq9SLfles6rg7HTM2bsqrK15f+30q3P+xP+O0mr9vldpc3OzUzRJCpol62jx7iCauyKtSM7DG7BWuNHVgDJrAxfgDtnPNntHNICc04AGabjmYLpg9+zlSACXLnBI7J/2PuU+juTNKdxnQ3SAlNLeKr3IMNHTg4665yNxonTT6ed5F8G8Lovw/Bfx4C7K9DOIIuRHwMYzXnIdUc+2vf4PeMJ3wFjP2uOqdN/INNjn6wCc3QJga2iZMdqw9E10VAGgGz7ozm3vtp2A1gkfmMJWNGsEydY0HfeEBaAkkUQNJLcNKLcDIIIMlOAkkJTgYJTga+f5KgrQSSXgBJAxJISnASBHyFAAho68AKaNDBOgkkBbR14CQ0A05CW4f30gxgupTWF3fSAxfYyN3NYyBDN4rcS+cwmSL0qJFrReihyKUi/l5a0ekUedRIX5FjXL3lTZnPq+I8eV7t60VvEL173xRXM+lNs14Uy31TtNPpz8H0aQCImJF+bmd1cRHnl2RjjBjnAw==",
      "brillig_names": [
        "_log_channel_threshold_exceeded"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "10775636126596421126": {
            "error_kind": "string",
            "string": "Function _log_channel_creation can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16541607464495309456": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 16
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "1775037338128445371": {
            "error_kind": "string",
            "string": "Deserialized value is too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "3238985437272151328": {
            "error_kind": "string",
            "string": "Function get_channel_threshold can only be called statically"
          },
          "4475601672736294460": {
            "error_kind": "string",
            "string": "Unauthorized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7136678259008445534": {
            "error_kind": "string",
            "string": "Function _log_channel_threshold_exceeded can only be called internally"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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ByMCAAcAAC3CJAAAMJMsDgMBLA4FAiwMBgElJAAAF6IcDAECACsCAAMAH/////////////////////////////////////////8OOAIDBCMCAAQAAC4QJAAAMg8lJAAAF6IcDAEDBBwMAwIAHAwCAQQlJAAAF6IAKAQCBgEoAAaARgAHLA0HBQAoBAIHASgAB4BHAAgsDQgGACgEAggBKAAIgEgACSwNCQcAKAQCCQEoAAmASQAKLA0KCCYCCQQEJgILBAMAOAkLCiwIAQQAEAEKASYDBAQBACgEAgosDgkKACgKAgosDgkKJgIKBAMAOAQKCSwMCQosDgUKACgKAgosDgYKACgKAgosDgcKACgKAgosDggKJgIFBAQAKAQCCCwNCAcmAgkEAgA4CAkGNg0ABgAHJSkBAAEFlYq/9yKlVgY7AQECJSkBAAEFYwqTEJhznF47AQECJQEAgAOABYAHLQCAA4AILQCABIAJCwCACIAHgAojAIAKAAAvUy0BgAiABi0CgAaACQEAgAgAAoAIAQCACQACgAkiAAAvIiUpAQABBeidCf6hES0OOwEBAiUkAAAXoiwNAwYsDQQHJgIIAQAKOAcICSMCAAkAAC+OJgIKBAA7CQEKCygABoBJAAcjAgAHAAAwHyIAAC+jLA0BBiwNAgcsDQMILA0ECSYCCwQDDDgICwwjAgAMAAAvyiQAAC9ULQQABoADJwCABAQABCQAADTELQiABQAKACgKAgsAOAsIDCwOBQwBKAAIgEcABQ44CAUGIwIABgAAMAokAAAwkywOCgEsDgcCLA4FAywOCQQiAAAwkiYCBgQHLAgABywMAQgsDAIJLAwDCiwMBAsAEAAGACQAADClLAQAACwNAQYsDQIHLA0ECC0EAAaAAycAgAQEAAQkAAA0xC0IgAUACQAoCQIKASgACoBGAAssDgULLA4JASwOBwItCoBHAAMsDggEIgAAMJIlKQEAAQVFp8pxGUHkFTsBAQIlJAAAF6ItCIBGAAUiAAAwtQ0oAAWASQAGIwIABgAAMSUiAAAwyiwNAQUsDQIGLA0DBywNBAgmAgkEBCwIAQomAgsEBQAQAQsBJgMKBAEAKAYCCyYCDAQEACgKAg0+DwALAA0sDQoGACgGAgYsDgYKLA4FASwOCgIsDgcDLA4IBCUsDQMGDDgFBgcBKAAFgEcABiMCAAcAADFDIgAAMfQsDQEHLA0CCCwNAwksDQQKJgIMBAQMOAUMDSMCAA0AADFqJAAAL1QAKAgCDAA4DAUNLA0NCyYCDQQDDDgFDQ4jAgAOAAAxjyQAAC9UACgHAg0AOA0FDiwNDgwAOAsMDSYCDAQEDDgFDA4jAgAOAAAxuSQAAC9ULQQACIADJwCABAQABSQAADTELQiABQALACgLAgwAOAwFDiwODQ4sDgcBLA4LAiwOCQMsDgoEIgAAMfQsDAYFIgAAMLUpAQABBR8KLSfcgoeiOwEBAiUpAQABBVoC5Bu1HqmfOwEBAiUkAAAXohwMAgYFKQIAAgUAAAABAAAAAAQ4BgIHJgIJBQAKOAkCCCMCAAgAADJmBjgHAgsKOAsGCiMCAAoAADJmJAAANVIcDAQGBQA4BwYEDjgHBAgjAgAIAAAygiQAADCTHAwBBgUpAgABBQAAAAIAAAAABDgGAQccDAMBBQQ4AQIDADgHAwEOOAcBAiMCAAIAADK6JAAAMJMcDAUCBQA4AQIDDjgBAwUjAgAFAAAy1iQAADCTHAwEAQAcDAMCAAUoAAKASgADADgBAwIsCAEBJgIDBAIAEAEDASYDAQQBACgBAgMsDAMELA4CBCUpAQABBb4eP/8+pPb6OwEBAiUpAQABBcVrxFoOEAACOwEBAiUtAYADgAcBAIADAAKACy0BgAuACAEAgAsAAoALLQGAC4AJAQCACwACgAoBAIAIgASACw8AgAuACYAMCwCABwACgA0jAIAMAAAzgSIAADPxIwCADQAAM44iAAAzpy0AgAOABQEAgAUAAoAOLQKAC4AOIgAAM+wnAIAPBAADAQCACYAPgA4tAAABgAUBAAABgA4AAScBgAUEAAEBAIAFAAKADi0CgAuADgEAgA4AAoAOLQKACYAOIgAAM+wiAAA0RScAgA8EAAIFAIALgA+ADicAgBAEAAMBAIAOgBCADy0AAAGABQEAAAGADwABJwGABQQAAQEAgAUAAoAPLQKAC4APAQCADwACgA8tAoAOgA8iAAA0RScAgA0EAAMBAIAFgA2ADAsAgAOABYANIwCADQAANKkBAIAKgAiADy0AgAqAEC0AgAyAEQsAgBCAD4ASIwCAEgAANKktAYAQgA4tAoAOgBEBAIAQAAKAEAEAgBEAAoARIgAANHgBAIAMgAiABiUpAQABBRiiMw3yM2+7OwEBAiUtAYADgAYLAIAGAAKAByMAgAcAADTfIgAANOotAIADgAUiAAA1US0AAAGABQEAAAGABAABAQCAA4AEgAktAIADgAotAIAFgAsLAIAKgAmADCMAgAwAADU9LQGACoAILQKACIALAQCACgACgAoBAIALAAKACyIAADUMJwGABQQAAQMAgAYAAoAGIgAANVElKQEAAQVkYYioxs+UyzsBAQIlLQAYyhjK",
      "debug_symbols": "7Z3bruw2zqDfJde50IGkqH6VH4NGH/I3AgRJI50eYNDodx+vVWXZtS2XtmRLS5Z5E9TKNiXyoyxRtA7/+eHvP/313//488+//u9v//rhT//znx9++e1vf/nj599+nf76z39//OGvv//8yy8//+PP6//9g/r4j3buU+Bf//zLrx9//+uPv/z+xw9/Qv3jDz/9+vfph5/E//fnX3764U9k//t/fvxBM2UKeJ0rkFmDUTpXILcGrXIFMFPA5NZgsmvwmQIWcgU4UwBspkBWW/px86BWBu3z2em3h/A446N8rFq+Vapy+ZX115X115X1N5kNzprM7tFakyuQ2RdZULkCmCuQ2VNYzMWKmT2FJcgVyLXB5dqQO3Ja1rkCuY7zuU3DZ9eQiRWUzRXIbBqgTa5A5hsHuWMzGMgVyMWaOzZD7tgMYA51xaz980m2SzdsLT8KdxULR12zcKxZuK9YeFYXml14Tc2zuubswg82ReVC4e6l8O2zU/jEz4et1quntf9UhU03qnjVjyrH2q0mMnNISM582815rlg6Klu1dFezdK2rlk41SzeqaulQtXRfs3RbVXdb7W2KPIxu7tc1+qXkzz5k8zRMMcfzaQCk9cQw0n1NE+nQfxm9fvjDSrANrSSzPEyYsHJKwczz3ym5snoaomU7R3PZbOjl6Q87vf4iO1cPx+10NJs5mRCeRf1Q219RbVJwTbVbvvJOhQbrSCXUttroEFgwJF4Go83cnRjt1bcvAyF9lZ3uiHsIrqm2v6TaruXIwCbkOtkmxz9v5iFtiqjh/fiXyqOSc/ew8+CM7Dp23sSf/ib+9Pfwpzv6vaumnTzbiUqpbxXX6qqK80UVNx2/+kiL4nqjeMfv8lvFrb6q4h33Km8Vh457lfeKX5a4v6ji2HSmAoviBAnFUdvQj2vSiQghS49UOIFOoGygkBEoWyjSUrZQnLSUCBRpKVsojKND+bTS38HKet/nu7KS7/cam6lHfz5sXgLOj9n15ulJ0zngZFp9QDEf1WzDU17yQK/Lcj57CFY3jE+/krfWwrsp7+FHwL54GyW8m/KW8bIpb3vDudeX8r7htO4reYOMl215Dz93bc1b+cDbmA1vBOHdlLfEJ015k8zn2/KW9t2Ut5P23Za3tO+mvFnml215k/BuydtL/rstb5nPt+TtleS/2/IG4d2Ut+SrmvLWMt85wPuToHxBOEjQyJzkKEGZZSQJ+kDQWZvoNRlMeBocJJ62YYU+mJVvKKa09jArbbRZP/zhR5C+ZAg/ovRoY/hR+tUh/Egyax7Dj5JtGsKPTt7HMfwI4sch/ChfYYfwo3zdHcSPMu8Ywo9e4pwx/AjixyH8KF8XR/DjpLp8thzEkfLFYwxHapl6DOJImXuM4UjZKj+KI+WrxyCOlOnHGI60Mv0YxJHy4WMMR4JMPwZxpEw/xnAkyk68QRwp049BHCnTjzEc2fQyOHFkPUeyOPIijjR2cSTgt46cUjviyGs40oVb5M2LGrMj5XvkGI6Ug7BHcaRMPwZxpEw/xnCkka8fgzhSgp0xHCmnxo/iSHkjx3AkyPRjEEe2nH44j4sjXcKRVsGshVVkE087P7cRXicitX2YiapfM1Uwc4pYEk+fejrahKVj738lFi9YIliafpe5EBZpLTEsTlpLFIu0lhgWtoIlhsUJlggWbwRLDAsJli0Wo7RgiWG5QfD/MPQGQ+6noRruYiiPYugV1nEZO8wLdAncMMxrfA3c0pm0xI3DxO7XwD3MDPISuElad1Pcw8x4L4HbDfMZ7Rq4QXC3xC2BYEvcLENlU9wyVLbE7YdJOl8D9zDJ7GvgloxgQ9xWgeBuiVsCwZa4tQSCTXFLRrAlbiOBYFPcEgi2xG0lI9gUNwjulrglEGyJG4ZZBHwN3BIItsSNEgg2xS357pa4nbTuhiey2XF2QFxhm7T1MlQ2xA3j7Ni4Bm7JmTTFLR/PWuLWMqtsiluGypa4jQSCTXFL626J20og2BR308NoWc0Pe00vAD+VAdWTMtyRMtgyovGOgzI+dfoa6XBoF2lcVDeIT9UbcjRKz4eCGWV1QnUgM2sx/Vz0iB4cxzacBceW3frhTzPJtjQz9ESTmTZhplZu7gK01rD1EHHTxuUW1WHb0p3tSBnWPSlzLL1tNIZ3Qzu3fviz+IPLl5PFY93ifc3iUdm6xbuqxWtdt/iqrsWD1z4ni6+s/dGGufoIY3FT/MHlIcniuWrxBy+5TBZPVYtHVbf4uq7Fuq4lW7f4utq7gw3TUJh1WfDb4l3V4g+GLcnisW7xvmrx3tYtvqprSem6xWPd4qu6lrStW3xd15q6rjV1XWvqutbWda2t61qo61qo69qjcU6q+MraN/z2ihSK5VTiDADm+T7AKnG2k31SGLJP5uWOg08jWx7UjeHg/SnhlzLSBCJgOGGkh1Cyn6ZlWyMP5qnU4p7p96s2nxUczT2lK3CVKzh6wkK6gtoW+Bwnf0i4rOTJp0TW9sOHBOVKZI3mnxJHtx4oEzIR0+9V4v6J1oGpXYGrXAHWtgBrW0C1Lcg6sOkhAdkSPlci67D3h0T2W+2z32qf+1azUtkSmCtxMFvL4YMvr74iWMvP0qlm6QdztanSoWrpXLP0gxOYVOlVdT84cKRKP9gilQulu5fSYws+IHwKdcjh6flTKB/csXOuLr4fXep93X4U76oW70zd4qlq8azqFo91i/dVi/d1G6bnmsV7ZesWX/W18trULb7qa+WNqls81C2+bsO0dRumras9NFwhTT6Ms+SNXc/HIhkuFUr2ijcZLg91X1is+8JS3TeKDuaJpzT5nCcmVpviD550nCwe6hbPVYs/mFdMFk9Vi/d1XetrNkyjlKpbPNQt/mjDNPPKaOMUJnoQDWEZtcblYUvwUEabnpRxHSlz9ONzjjJ2Xl4OS/rfPmaakyLUiSK2FyK2FyKgelEEO1EEeyGC3RDxnShy8Iv4iYpwJ4oc/Lp9oiK9EGHTiyK9dPG+l0HPd9KhadUJEa16IaJ7IaJ7IWI6CQO06YZIJ2GAtp0Metq6ThSBXl5f6GTQ071E8bqXKF73EsVr6uX17SWK171E8dr10qFxLx0a9/L6+l46NA/nKaLd+4e1Ih1ynNP0f9HbRU9zIT0fojIlQZevTdHvdi4sTOf1QajaPs30HZupVDBTf/vF0Uy5tMuqrtV1VXeXVd2Y66rOl1XdXvc1tdelDtdt63DdHgZ1x6rzrIZ1KrHYh5eTQVg73tqJ97CTeh6nz7TzJv50N/Gnu4s/e569nGgn38Sf/ibvp6eO7QxnElhn+L2d0ydGvezp1Pjt7n5jVc8R0bmW3sanXWcvzrW05373VEvNbXx65mfVsy11LiR2p7xtylILFMqexqStpR1PpB26xVJIWQoYDjtX4DfjqYWOR5mTLe14lDnXUuy4RzrZ0o5HmXMt7Tmfcq6lruP868mW3maU4dv4lG/jU38bn/q7+BR6zjmcbOldokHoOedwsqVwG0s7zt7vW/qpuuk5iZBQveNFDQnVoeOJEruwMoDTqRsf1h5Ov8luLO158nuypR13dydb2nF3d66ldBuful7GgYc2vYT4n9p0M11+aNM0VGYVzgNSrHmjjdddaYNdaeM70ubw9Wkna8M9aaO7YtN2ZXpKG9P0DXfhAsZJG0NbbagnbazqShvoShvfkzbQFRvgnrTBavHNo3iqWjzpusUfDCkchEvuHOmEqxInhCEfHKecD7YyJJQB9uFuHG+WHXfaxZ5GDo0M2b8sVtk+zBRmI0wrpZ+TEWT+IjPX11W7ZwPwtidlOiJDqiUZH644h/X8dVGGO1Lm6BmH5ypDHSlzdHneucpAT8r01IBtT6+27YkM9PRqQ0+vNvb0auNXvdqr43fjkdLHwe5zkOeJV0/rh+q+GsdH8b5m8U5l3jI1SXCuhM6uQ2fXYUy2hMuVsNl12Ow6QGdLUK4EqmwJzJWg7DqyPt48JOpebmlc5cstpwpc5QoqX25pHNe2IPdyS8O5l1saPngGYOqGwakCX7mCg7nE76igtgVQ2wKobQFmtzvS2RK5nT3nXm45SUC2hM+VyL3ccpLIppt7uaU5enXV20v7zNGbq1Klu5ql17xgcyoda5Ze84LNqfS6uvuapR+9YDPjukQ7fct4Pmz1Km9vtX/qwv3o0vB6zaQuWPOGqKl4qFu8r1p81Ts2p+Jd1eKr3rE5FU9Vi+e6DbPqHZvm6P1WyeLrvla+5mtlVdU7NqfiXdXiD8YqyeKxavFV79iciq+s/bGGaU1YTWkNJvK4Vtn5W71VmLhzEsiEpC+Zl2/YkQHcOhNGcHbfzPQ+6m1pJYYAQTnaELe+H13AdqSL60eXg8cznqsLdqRLR22XOnqnqSMurqN32rkvGl2c3+hyMLN+qi4Hg9lzdTnav4TvAdaaTfFaqbrFQ93iuWrx2tQtnqoWb+q61tR1ranrWlvXtbaua6Gua6Gua6Gua7Gua7Gua6mua6mua6muaw8HT4ni62pfefHAVIGrXMHB7Y7fUQHVrcCoyhYYnfmV1BqjcyUqLx6wBmztCrhyBVjbAqxtAdW2wGW3O4e5EqyyJSBbgnMlvM2WyFwtYfMOzH5IUK7EwfnJ26/ZU+muZulGVy0dq5bua5Z+MBueKr2q7mCrln6wRWasI9AOZlW0w2WZunncK2jtwVnGqbocnDOcq0vV1ktVW6+r2npd1f6Uq/anB09dSZTuq+ruq44FB5cOnLi2ycLBbOupumjTkS41V+5YqLvEAOouMQBTde0LWFu3eK5aPJi6xddtmKjrFl9Xe6r7WlHd14rqvlau7mvlqi4pA67bMLluw/R1tT/6xReWD8rgUlenf9WaLzz64TnPyrfrIFBhR7r4fnQ5eC7cubq4fnQ5mLs6V5eO2q7t6J22PXHp6J0G+0Wjy3Zt09Fz4E7V5ehn/TN1OXim2zSIhOvn0CbOx7Oe53EalFpNnh+Hrk3KUEfKHLz4+WRloCdlfEfKcE9kDh6nNxUQVnWQ3naoBw/ISxbvahZPStctHusW76sWr23d4qs2TDJ1tTd1G6Y92jAxdCGUOsEqHMcJix72+UGLji7lPE0R6IUI9EIEVS+KYCeKUC9EqBsivhNFDkeLpynCnSjCthdFeiFy8BbLExXppIt3qpNBz6lOOjSneyGieyFieiFieiFiOwkDnO2GSCdhgINOBj13dEP/aYpgL68v9jLo9RLFu16ieOd6IeK6IdJLh3Y413uaIr0Q8b0Q8Z3Ma1h1Muix6mTQY93JTI91L0R6ieK5lyiee4nij56GfaIivXRo0MvrC70QwV6IYC8dGvVChDqZ13AvUTz3kovnXnLx3EsunrmX17eXFLjvJQXue0mBe9XJTM/rTvoRr3shYjrpR7zppB/xvSxk8b0sZPFwYhiwukEu+jAZPT9MBpb9u87FSlZ2WTtNLyembB92fj5eZZrMh0eNtk8jsVsjjQlG2s3GHI/9eiehOF1UcbJXVZwvqviZ8X9TxfmqLydflvhV27i/aq/iXbeK+1Cy1vw+PGCNS3zg+BsrQZ05q+vYyn7H5BOt1Lfwpb6FL80tfGn6nZ2caKW9hS/tLd7LM7+4nW1l2Mikwb630vuw60lPIYDZmtlx8HOimXgPb3ackjjTTOq4nz3TzHt488yVheeaqRczjUqMJ1pZoGCndWpjJ3c7Qdbh6KTJTp+yExCDneC3Iyd3O6Sca6fvdkw52c5uu6FT7dT9ZkhOtvMm/tTdZlLPtdPcY1w5fEPXVey0N/GnvYk/4Sb+7DeVcK6d/eYSTrbzJnECdfuN+2Q7u83B79v5ULzfBMF7xftd9pFQ3Hc7FTI8N3Jr0ykZH9bXTb/Jbu3stos71U6juu3iTraz2y7uXDv1Tfyp++j5P3XpZJr90KWPqdOnLrZlOAxqLpdgdfNO0MX1owvojnTBjnTx/eiC0JEuHXFpukI8pUvLd9q60NdNHtno4kxHulA/ujRdJp7SBfvRxXfExUNHuhyMXzyEKNNT4vIDZDdf7Yfs9fuQlClEpEy4mRjbowfLrBV3iT1t2oV8zuo+I+CnJtyLJkdPLaewsQ0UJhrWVL9eVEmUzGFg4dW4ohkiz05Tx+ezxurEs2+U+ARijAB5BeIEyAuQowuFxwOCAuQFyNE9y+MBkRbyDRAvQF6A4AhxCIa7OnFVbPxZR3OQ7XgJgo3WTx48Ag8z31yG+Mrj00YaIdRK2ThC9JSw0d3Aj+4GfuQb+PHgbc+XsNGPEH6mbBwhokzZOEKQ+N5GUHADG8eP5WCIPGLKxiFiAJ5z5KT11sYh0p8pG4eIAd7baIeIARI2DjF2JGwcYux4byPcoM+BG4wdeAM/HtxXoRVS0Hsycjnw9PmRGg4ej/AdFWDlCg4e3P4dFdS2ICtJ8CmRNR39kMCDAbNWJhyBM/328K0ReDBaTVdwMFT8jgpqW2BrW2BrWwDZ7S7ry9OnRNY6y4cE50pkfQp4SLhcCaezJbLpZq2le0jk9jXos+3I7518biuhrMVVD4lcD5I22RLZdRidLZFLl6zKloBsidx3kCCbLuS2XcJsuphdB2XTpWy6lP1+uOz3w2W3Xc6my9lt12fT9fl15NJ1B5d2agpf7jU5sy3eVS3+4P1+yeKpavFG1S0e6xbvqxZv6zbMg+mhVPFQV3uo+1ph3dcK675WVPe1yhrzCoqv2zBd3Ybp6mrP1Rrm9uGPiHbOqpFZSo7voLDhaAG2/O1p+5PirqHiU6JnVnya7qUUD2sR2Rq9UdzX7Qp81Y6MVdUhkA9uSGdFYduNVqm8rfWzV/WU5U2V/P1526zFqPtKPIB4AfICxIAAeQXCAuQFyMFU6oBAnAB5AQLSQr4BQgLkBQiOEIectweEEUfg8XZNHeMIoVbCxoNT7WvYeAM/uhv40d3AjwfvcriGjSOEnwkb/QgRZcrGEYLE9zb6g3c3XMPG8WM5P0QeMWUjjGDj2zWufoj0Z8JGM0QMkLBxiBjgvY12iLEjYeMQY0fCxhv0OXCDsQNu4Ec8unQ/sf/AHzz8JV0BmdoVuMoVuNoWcO56Te8z18+i0kd3yrzfHjBVALUr8JUrMLUtMLUtsLUtgOx2l7tuG1Xuuu1JArMlfK5E7rrtSYJzJVw23dx126hy+5pJItuO/N7J57YSrVS2BGRL5LYSrbPr0Ll0tTHZErmtRFudLYHZEtl0wWZLZNPF7Dowmy5l06Xs98Nlvx8uu+26bLqc3XY5m25276Oze5+j9yS9XyU5FQ91i/dVi9e2bvGuavHG1C2eqhZv6zZMi1WLh7raQ93XCuq+Vlj3tcK6r9XRsyZSxddtmK5uw3SVta/WMLcPn7gHBA1DQ8XP2wMyKV63K/BVOzKrTN3iD34rMmwDe5vwqkacv7FqpMTD1Raj7ivxCeTgptnxgBgtQF6BoAB5BeIFyAuQg6nfAYFIC3kFcnCD/YBARohDTtsDgvbgGQad8Hi3pm6ycYRQK2EjjRA9pWy8gR/dDfzobuDHg5feXsNGuIGNI0SUCRv9CEFiykYe3kZQ48dyMEQeMWGjHiIGeLfGdbJxiBjgvY1miBggYSPcwMYhxo73Ntohxo6EjTfoc+AGYwfcwI9Y95KLqQKsXYGvXMHRE0bTFdS2IPc0/0kid8Ut+Ow6cs/TRsxel40quw6dXYfOrsNk12Gy67DZdWSvskbIriNrldxDIncld/Y9H5NEdh3ZOzYwe8cGZu/YwOwdG5h70j5m3/Mxwc1uJfk9Q+5J+0gKsiVyPUjaZkvkepCyd2yQyfUgZe/YoOy+hLL7EsruSyi7L6HsHRuE2a2Esj1I2a3EZXvQZbeS7Cgj+9aOSSLbgz67lfhcD7rcO4Pw6EUcYWWrW8J/NI+iD17C8a7og4mmt0VjvaJ9taIPLox6W3Q9rQ8u1nlX9MElEO+KPrjy4G3R9bR29bR29foQrtdCuF679vXeRl9Na1bVtD56IcLboqv111zvqqHIw87Pa/400yqX9pFX2zxtVUi8WW1STzP5eUkcO2vD0+ZDqe3TYMLT4CDxtMX54enrz/IsxVY1WjU/a6yG9cMP3Cy4G+IGad0tcaMW3C1xk+BuiJukdTfFLa27Je56G6Pvidt4E3CvjhkMuFFwt8TtBXdD3Cxxd1PcTnA3xO0lEGyKW4bKprhlqGyI2x/MSAvuTNzSulvi1pLvbokbWuKesusLbkgA/DhXdtZC08s5Wwf1MC583zJsVzuvlLpsNsajFUeO4Uh5I8dwZNN0tDiyniOdFkeO4Uh5I8dwJMsbOYgjURx5DUcm5pFeiSPHcCSII8dwpMwjR3AkqXpHsosj2zpSph9jOFJLsDOII0EcOYYjvThyCEcaeSPHcKSV75FjODJ+QyZrP2tjF2Ws5U8hrXSJEJYI+QKh+MkvKSEuEDIlNcUv7U0IxU+BYeWCkIsIUYEQZNYUaZ5azcfeWb06I89q/6yCqlcRP4fq1CpciUtciUu4pKb4Xv+EkId8ob2bTzncX8J2K7RzRFpCKKre1E08hchSRMgXCEFJTfF7VlJCrkCISmqikpp2Po/7cLClirSInd1M74V2jjBKCJXU5Etq8kU1+XwhGz/RiMKgv45UglD8PPGUEBUIxYP4lJAvELIlIOKXP1EIg5xahVfaPoR23tyEUElNO0cRhvAPV2tPn0GadbZAxuXL7Fzi/l6moB5fUI/PrwficWpCBvNldjKG72WgQMbny8RDVKS508fVHCnIuHyZnbPF38vEAwc/H8Y8xcobmZ2jCt/LYL4MFtSDBfVQQT07B6C+l+F8mZ1+572My5fZ6XfeyxS0nZ2Neu9kMD7aTWHRPF0zL7P7WSpKe0o3hEwG8eZ9wPh4l5Qqqis+B0tJxU90SUpF3wvt3NxxfWzV2EjF34ykFBRJcYlU/JDgpBSVSHERDS4i74vq8kXkfQl5UqZIqoQ8aVUkBUVSRTTiY3xSKtpTa69DStSbrVR8nE9JxUftlFS8jzfazUGFMXqVh6WnWLwhGoM2iDl+Edtmf5wN90c4WMXx0TSy0yFt4SaV3j+s9ZQ9n63Wir69MYBc/KR9M83WQiZ3fUXu02wXj1yTYrqstnhLTYrFm6qBMAZPSRSV8g3buRLHyAnfTFOH+WHyKuUbDaFFTilhu/FNPG11If3jrxQtty/T6kWM668VzC/g1H6XkEl7avppQy/QzTZyc/FE9pim4m1Mxft4Fe/zrtJ9vEr3eVfjdysNaWo8VTKmqe42pvJ9uiW+T7cUT2+MaSrcx1S+i6msbjPYsLrNYMP6NoMN69vMbNjcZrBhc5vBhs1tZjY7N8KMaep9Bhsw9zH1PoMN3mewwdvMVxkHGmzeb0dhGiiESJk60Hw1YaobaLBJmTrQYJMwlQcabFKm3qdb4vt0S36gmU3K1Nt41auBBpv3q4z9SMnRhKkjJUdTpg40s0mZOtDMJmGqGWiwSZl6n27J3mewGSk5mjB1pJWjKVPjgw1ikEJOmfqF65n9znLQmvqHbQSOHG8Vos4UIn1tD8dX1k1J0dlqJrO8MNGTe6wP+zNArXfcEzzr4Pp1xDc5nlwH1a8jvony5Dqq2+FUfJcNow1nnaA3yTpgqYOWl8jZZx3YoA5fv46dE5XOrcPVr8PoBnU08Llt0HZtCzsatF1o0HahQdvF420XVHgY1OqMvo86tk8jhUEfyanE03Y56sHS6gSz+NPTh74Q765jhHi8C6zmiALYLEZai082JGz22JASNrtsUNjssXHSbvbZSLvZZcPSbvbZgLDZZcPCZo+Nt8Jml40bik0fp0a/XZHo9g5LFuYVmZux+oBrMJe+pTlzO1ae4xrMx8qfXII5SDtvz3ysefs1mHth3po5SqzYnrnEis2Zk4yh7ZnLGNqc+WDfYq7BHIR5c+aSV2zOnCVWbM9cYsXmzL3Eiu2ZS16xNXOjJFZszxyEeXPmkldszlxLrNieucSKzZkbI8ybM5dYsTlzK7Fie+aSP2/OHKWdn8/c2IU54Ia5k3zL+czfnuYwMZcxtDnzwfa7XIM5CPPmzOXbXHPmXuah7ZnLGNqauVUSK7ZnLu28OXMtsWJ75tCcuVaBucXE01930byzRnWOxi1otH9vLXsVtPbrosnH1CbgWW2ipWhSMa2DGuhXFvonRBSIhyECCcTDEL/ghKgBIXqBeBgi9T7mVoTog9pudTvBBPFB5sbN6z0Zd98248KXlCkyVlsy920zLkSwExm/IfMF66irkZnAzEV7xfRC5tPYL0gGfqGxN/IsqKE8Sz4Yuw4NZmP1QPOlpLEjzbAnY+f40GvFEWPH8ux7Y+2dPGtH8qwOKVGv0WyNhZE8qy0GYwm3xn7BSRFfaCwPZSwEY53dGksjedaEq3e8sRHP0kieNSp41oDbGuvG8mzC2LE8a4OxGJkI8FCeDRca+OkjXMTYoTybMNaP5dnQjK2JRFB+JM8un6K9jUzeUY3k2aSxY3k2BBXWb99ZUmfMeryejdWaUsaym4tG9onP+0x2nrQx4Yutn9qfstZkpb15hf+oA+vXYRrYcUbmQofWBNqlmrX2FO6SVJEZtzvj5GG7vGiWtlY7axrU0cCOM071TNVxxg4i60ILmTrBRAthzaFo83IflI62p2Wpjyd+efpTfz5hgQW48BYB64T+08fkeakSYbLns6DngceCT61TO/cGAXfGyTDDskFhs8OGzzhpZVg20m522WhpN/tspN3ss/HCZo/NGbejDMuGhc0emzPmQB2xucJpDHzGnFCY5zGHseY412A+VixzCeY4Vmx9DebSztszH2sucAnmNNYc4xrMJVZsztxJrNieuYyh7ZnLGNqc+RkndwnzTOZj5f8uwdxLXrE9c4kVWzP3SmLF9swlVmzOfLBv9tdgDsK8OXOJFZszH2ztwjWYS6zYnLmVWLE987HWfV+COUis2J45CPPmzCV/3pw5STs/n/n7m4w8S77lfObvT+32XsbQ9sylb2nPXPItjZmzUvJtrj1zmYc2Zy7fLL6AucSKzZkbaeftmYMwb868fawYzrSh9NOOl8OXmBf146cXAYfTi1Cvzv2LH2/C4bgczW453uTjqLVPNNbeA83DWHcjY8Hcydg7eRbv5Fm8k2dJ38lYvJGxTt3JWLiTsf5GxvrePRuuKHCM/N5YhzB/vZp+4vrhD1t1+4wEhutuiFTqFtlr3jn79ist6/YZCWHePiMhzNtnJIR5+1SHMLfSzpszb5/4EeZAwrw1c5RYsT1zEObNmcsY2pw5yRjanrkT5q2Ztz+xSpg7ySs2Z84SK7ZnDsK8OXOJFZsz95JXbM9cYsXWzI2SWLE9c8krNmeuJVZszxyEeXPmXpi3Zm4kVmzPXGLF5syt5M+bMwdp5+czf3vCCRuSfMv5zN/v5pv+nzBvzlz6lubMWfIt7ZnLt7n2zGUe2py5fLP4AuYSK7ZmbpW08/bMJVZszly3jxVh3lZKSD7x9JtNqA/16dLqf8GuxVPVh2urz5dW/wtSpaeqf+1XF6796gJeWn28Nn28dseJvXecOYc5EM9R3fTTb2xtfwX519nqeg8Gz7S19w4wy1brg62rsxejD2utYT7Xcfodeb3b548pPE3kXWoetsysrCOTnIdBmFmt2cRnVsBqJglslrKtndmQsNlj0/4GgQuxQWGzwwaUtJt9NtJudtloaTf7bEDY7LJhYbPHpv060wuxcUOxucLaRGif5BTmdqw5ziWYw1ixzDWYjxVbX4I5SjtvzxyEeXPmY80xLsGcJFZsz1xixebMnYyh7ZnLGNqeuRfmrZnzWPm/azCXvGJz5l5ixfbMJVZszRwH+7Z+DeaSV2zPXGLF5sy1xIrtmUtesTlzI7Fie+YSKzZnbsda930N5hIrtmcusWJz5gDCvDVzlHZ+PvP35/ohS77lfObvz7BAljG0PXPpW5oz95Jvac9cvs21Zk5K5qHtmcsY2pz5YPsXr8Fc2nl75hIrNmfefh+n0+F4E+cw8bTWi63Tb2dT1IE5KK7XHtVPe9297G2/L/KL7aXe7XVusde/ng76aQHoy1uAl7fAX90C7L5fT1rQfU+dsoAu/ybT5d/k9ntgTrfg+j64fG/K3fem4czADwtSMxlgg7MuvDqhfD7BhNrf8v219vruo8ZT7XWq+14x0973J/I4BTezt/se91x79c38q2/mX3Mz/5rRxt+Evf1nqU62t/u57bn29p/TOtne0eLJhL14s3gSu5+Tn2zvleONTwvoyjP4hwVXjgk+LXC9j/KgljwQ2NTzX7Ve2/ne2/JVOPb+Rl2DIyt5r8/h2HvUeBGOuvfZxlU4Sns8haPpfXZ0FY4gHE/hKHHPKRy7z1pehaOMM6dwBBlnzuHYe3bvKhx7zxpehGP3azmvwlHinlM4ksQ953CUuOcUjk7yPedwlLjnHI4S95zCkUE4nsJR4p5TOHqJe87h2Pvqt2tw9ErinnM4StxzCkct+cdTOFrh+H0c35+x6EHinu/j+P6MEC/5x5M4StxzCsfu99VfhaPEPedwlHzPKRydjDPncJS45xSO3Z/6cBWOEvecwtG3P+/WLucjYmoXmWM7m+qmb+3hacbYw2RnWx159f5hPbnFBA9ptuvHH2jiTYxJzWiY1Xs0yOEUGJxyGe81YrLhHDpC/40+Xu1siXjRh97ro918hofmBT3wswJXuQIdt4CCj6f5jE5VYGZtpp/8/mFWc1Pj9bl+DLEXRc2aG6sTz75R4tNOo29iJ93Dzp3k2Xh2wk3s9PewE27iz52k7HB2YsfjJ9IcTaHziWcdrYK6JSTV+mmm69jMcFYw6ZQ7mebgbwp9NuEc9ezM86y8hS/dLXzpOg73zrOSOw7eT7TyFr70t/ClxxtYqVXHk7ATrYRbWNnxBOw8K/UtfKk7nnydZ6W5Q4SnzR2idW3vEBVoe4cIT8MoUQHqYCWsrdw+6pHnlJInTVsko4SDJyIZJd44DwmCIPkWibSSb5HItsOH4sllFlbNz05pflg//MlRth2exFHa4ykcZbvcKRyNHFN6Ekdpj6dw1NIez+Eox6h8H0fjTeCocMPRyLaaczjKtppzOEr8eApHK9sYzuEocc8pHLu/DOoqHGWcOYVj95dXXYWjtMdTOBIIxzM4+uYcyS3b5ZKXrlnys6nWkUlRXJ7ml72BUYpfNhf3Xpg3Zm6VtPPmzNvn7oS5dsK8NXMj7bw9c2nnzZlbLcwbx+e2/bU/wrz9FUHCHCQ+b8+chXlr5iixYnvmMoY2Z04yhrZnjsK8NXMn7bw9c8mft2YOqjlzdCowX+362GGO4Uw/SxYuwvx9vgU0CPPmzKWdN2fePpcrzNtfyy7MrbTz5sxB2nl75iTMW8fnqIV5c+YozJszl/i8OXOywrw5c4kVmzN3Moa2Zy5jaHPmrIR5c+bSzpszb7+35fbMUTcfQ6dp2Mw8/XTm9Vs0n1HmyL08/LCVRrIV7TtbzVB+ZRVsZb+1dSi/vrfV3siv1t/H1vbrab/Q1hv5FW/kV+SRbD3xKk+PNFQz2EXzaWv7MB54pk+4OkN2J4wHHZZ7wUr9K3/Cw/Zb1G/PfJowCvPWzNtvURfm7beoC3Mj7bw9c2nnzZl/QTpjfObvU77Ufou6MG+/RV2Yf0FKTZizMG/NHCVWbM9cxtDmzEnG0PbMUZi3Zu6knbdnLvnz1szdGVvUVXgYFPoEF1wuUsTpLUsxH3Crlztji7owz2Qu7bw58zNyucI8j/kZW9SFeSZzaefNmYO08/bMSZi3js/P2KIuzDOZozBvzlzi8+bMz9iiLswzmUus2Jy5kzG0PXMZQ5szP2OLujDPZC7tvDnzM/a2CPMs5hzfto3h+xmu9ltZyw8ho0qEot4lHQ4JsBQR8gVCtqSmeOIpJeQKhLCkJiypiaIBEvp5Iz8pFxHCAqH4Z/WUUElNXFITF9XkC4R8dO5F4YUlZzZCXukSISoQin+iTAn5AiFTAiKecddKzdsttTKr24O1iw0BAGEIAFzeiuh2S7ahaLZGrx/+VCjeK2jFy45UZZoqtEMIdCBEKUIaKTxN2r1XyFs/P+xhNerNCsWTamuFtHpV6FMsvt4sLcZFYj5KzXA40sR4u1pUQrGRVBsOrXA9kmofe9pZDkeIgIL3jJ0O7cmZV6dH9NDK2sVaom9cMr0tOvruTW4Pt3Ajr+IGDHKuTC6+oeo75KhMzqpCOSyU82VyUOiH+ELvtBwW+gEL/RCPL9JyHJcj7UO3ZJZXBt1TLL4PWxNQECO1EZtelyKxeGScUlLHw9y0mC8Ss2W1WS4S22nPKTHUZWJlDqCy2qisNldWWzz0TYuVtRIuewOYi8Q8lIgZpcvEqEgsvtc9LVaExJiy2kyZbbaM5M7omBQr6pUNFLVJ2hGbvnnNYm51YFsQ2+mCkmK+SCx+IE1aLN64OBwMNP10WzFny8RckVh8Kp0U82VK+iIkTtkysbLadiKFlFg8i6anxGEQczExKBPzRWK2rDZbVhuU1bYTL6fEKNorg7FLdhWWeZ4lmOVcmVx80P8OOZ+Uo5gcQ6Ecl8l5UyjniuRYmUI5isuFRAdYZV/kYmkRhpAWWSUCtY/l6ykkdSzppWjNsYf1cmOiWWVnog9PCQCHSzLA81qRh7XxEXNYazlp7aqWpU2gLZOLzzbSci7+3QVCjglRpz5f5W5cCqEVr0+Wi39iAlZz5wls1qna5ySe45P4S1mAV7fAq8tbcHUfeHV1H3h1fR/4q1sQT9lfygK+ugXxLE1dC/pYJDLl7J7PTp+fzPrhBxmwQmaHDAuZOBmUt2mPDAmZOBnSQmaHjLSZHTJOCZkdMiBkdsjIqL1DhmXU3iMjPfAOGS898B4ZFDI7ZLyQiZH5WG0oZHbIyKi9Q0bLqL1HRkbtHTJG5tp7ZGTU3iMjo/YOGStz7T0yMmrvkAEZtffIOCETJ4Myau+RkVF7hwxJfmaHjLttmzF2IQO4JeNvO29yYTOVeVHjSUar2/bASTK3fZuSZG47b0qR0bfNdibJ3DYGTpG5b+YqSUZG7R0yVtrMHhkZtffI7IzaOItNkFLHwOWdAzNN7+eHFZr1ww+N9tbhfqFG3JtG2B0j7I4RdceIXG8aOd2dRtSbRjuH8X2lRtidRt2NIr67t9/31kMa3Z6R46CR81uN9r4w1tNI05wjdHp1Ou6i0Slec4tG2r/XiMmEwxFpFbFNffVTpXMCpFNVQt2fSthcJWUXleBFpUgM78NxiKDUdvf8NM1VVzcArm4AX9wAZ69uwNU9sLfVoKIBLmQSiCHSMbLrTiWP/ankm6uEsKiER1ueVXB1A/jiBmhzdQPcxQ0wV/eAodYGTLOnkLYG2naM1ur+VPLdqdR+jub08r0BXKLlGVbhxhRe3Zb6cXPq0wC+uAF4dQ98QW72fXbGuuZ5RxPufnHGbLMztn1uVnt8r1FzRqfeqzB9D9SdpeCsp840AtUbI1C+N410b6lcMKo7jVxvGlnTnUbcm0btFygkNeqOEXbXjrC7UeS+h21YNT9r7Cr2nRclgb/tQrYkGWkzcTK4l+8UMvddmJ8io6XN7JGRNrNDxtx2M8fbW5Y/yNx2E3yKjL3tJvgkmdvGMykycNsNzUkytx21k2SkB94hc9+DupNkbrsFM0WGpM3skHG3zc8kyJCOkwmf6JAX3a3lWQqLpKJzNAqfTMlSRCp+tWJSqqgu60qk4kdGJaWK6sKiunZyyX7+fE7rxTxBamdBd0oKS6RcUV2uqC4uqit+cWNSKhrhUHiDyZmIVDxrmpBy8a+8SSlfIhXPRCWlSmi4ndloWOqCftV3+1nIFQjtHM6fEPIFQlyiXnxHFlFogrwaDvRzaRfHzy5OShXVFe/imdw8uvmXbV3bAQsQ5mcBcb3M6AmB4+PBqVXEG9y5VVD1KkDXr6K+u+PL4s6tgqtXQfXdHR9Bz60Cq1fB9d0d73qXKrx6WZT2EPKmRKigJq9MiRAVCGldIlRSkympyWCBkFUlQlAi5AuEoKQm4AIhLGlGWNJgqcS5VNKMXIlzXUkzisd0HPan+9RiGo8htzAB2i5b9fHpxKk1VLchfmbBqTVw3RrMzs0eJ9awc2KRVuGgI61ouTT9mZkxO8cKpcWir/DHppNZbPpYvhWLdxdpsbLa4jmCpFj8/U+LQVyMlmvrOUIyvslTg5pzLR/rqiNivkTMxNthWswVicWH/o/FArMYooqIUZGYKastnsNLisVH86RY/PtlWswVie28b0kxLhKLHy2VFiurze3Y5kwQ82YrxqpMDIvEvC0T4xIxq0yZGBWJaVUmFn/frA5i1m77EhtPyKTFuEgsnptJi1GR2E6nkBQrQwJlDsCy2rDMAVTmACpzwM6Qb8MkX1tSETEqEotnH9JiXCTmoUzMl4jBTqSQEtuJFBIBBmgsEysKnsCU1UbR2pydI2wHdisUv1jTw9yOPWJECEqEOF8I4yNNSohK5hq40zaSYlgkFt8OlxYrq82W1WbLaoOy2qCsNizzG5bVRmW2xU/jSotxkdhOzJoUK3txWOd3PBgPdKf8xPxmm4hQSW+1syjkfU07a0JSQr5AKL6iPSXkCkBYUyJUUlP8TU4IYYlzsaQmKqkp/gb7sIHROxMR8gVCrqSm+FFnKSFXIORLavIFNe0sAVn5KSpE+c51WpcIldRkoETIFwjZglfDgSkRKugjXPxTeEqoIIh0VFITldjkSpqRK/GTK2gRHN/Mz+DD92hczVo1+adcPHk/yYVlnggQkYsv1EvL7XyDS8sV1ucK69v5rpaU2/lalpYrrG/ny31Kbu/jPZIOcp5icnv14SLnInLxI/u+Q66wvp1v8km5vc/yOhxLRquQdyW38/FWh/ePMMZz75N5Sm53tZEJcp5jcpySc1pF5Mim9JwG2pgcl8m5wvpYF8rF+xe3LHefRrWInE/XF5ejEjmrlC6U82Vy8eWz7FyQY/Uqt/3wTGYOBQmWtjXl8J5V+BOqgLAyF922ip2lmKxDb8DWJKqY8mlzkg68xm0lO4sx8yphn6jE5VbykNtZY5mWozI5LKwPC+ujwvriH/jfyv13+vP//uX3n//y119++tck9PGv//71b3/8/Nuvzz//+H//nP/lr7///MsvP//jz//8/be//fT3f//+059/+e1vH//2g3r+53+meQ38OE0EcNLoo9czAPijAfz4+6Pdfsy5p39Xavr7Q9vpm7j/0WhnPyz4KOAjd/jjR47n4398cJiyKVOJ0wA+6Trp+/8B",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "initialize_channel",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "1775037338128445371": {
            "error_kind": "string",
            "string": "Deserialized value is too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3djtw2EkbfxddzwZ8iWcyrBMbCSbwLA4YdOM4CiyDvvuoei9JMc6SIQ02TrO9mkfGSUqlOSSIPJfVf7377+Muf//nXpy///vrHu59+/uvd56+/fvj+6euX6a+/3ml7/bc/fv/w5fLnH98/fPv+7iftvXl49/HLb5f/DObvh3f//vT547ufvP374aaxMT78aGwMx9RYK5VrHYl/tLbK6J3W2tvIKRLSS3tzCSvT3i3NQ1haX+K6bW29nVuTVk9av394pwm5eTE3Drl5MTe+8dyQdUtuKO7kxmjj51g0uVfmJiA3L+aGkZsXcxNfnRtScW5M2nBqzHTZgVFn70C/egfaKpobW7uiq0OutdJhBjD9d7TrgHKlwzGm2om38ZvO48+OdIhVYsYq7sSvwrwHrTUtNercdQ90+h7c6Xvwp+8h5PdA84WLolJ7dcQ67cJGv1y5fPbSEl1Uc/PoXdhuzj7OZcfB2p2rHFO6yk2HQDutrZsbk1ld43y2ntPVxFjlthtrq81yZumdxmrJnvK8bnzhw+DTNJ8IPi3zsQp8/hGfkI7RPAkjm/KwDAVCdK/io8GnaT6mAp+YpkGa1Cr4PB8KnMalxCbuNfdmae5XM5v8uDSEdB1iuzclkw7fAr5c+AT4cuG79uE7t8DnHR1hUyi0mgNrMteD9e0fbFx0XLC0fbCTDlSLGvQrlfjoXmwQdrw82PGGsIxgA+vw/HijrOMlddfjdUr57ebBzdsOq1UAvl5pSTcePBuz3NrWweMW+6pbLJnWwWudB38J/u1nBm5aE1uCJ143v0REbx+R9akYHOkdkWCUTtreKLN3jZR+djjgHAmnB86RcL79DMKRsQvO1WQ/29xPt4gfrb3mHTOgV/6Y/WrY4uz1YLn1gzU8l643Me5okJ2FeYqSjtblpw7Rcjra9UjjWg8uP2KPcT7maaTitzMUfXq8Jgazs4I/3NXDZUe+Tvm5j9OKtnNibZwHg9a51Snr87GrNHQMtPI/8TEe21g81Fg8rrF4fGPxhMbi4cbiiW3F41Vj8eg3jsfYpN8MBXUTz1tfn42h9Gwqre4tl3hyNxdSy83F7LQe7u7pLeg0TOet793G6fSMuXO0l+9koicnu4KjAia5NygdUI6C0gPlKChD0yi1MWkp2vqnLC/Rc9fRx7aj55BeG4yrQPLnUUhiiLVZnRfZV7OMTgNmY8KT1lNegkJesnnRyEs2L0ZsXmxaZDF0mxeLvGTzQshLNi9tj9DPzItb8hL0TV7aHu7eLy+Njx3vlpfGR6Vn3qdXeTE3eZE73k3ztWnV1D/PC8sd727nRe54dzsvcse7q+tLvBm/8EjjXfaL97duJzHDvWfMBJSDGEYeaVYhHOVIE6FqKC+JaX0mtLzcF63fuyOnZxPDugI4+xks9vOWDfPqI1vXlwi49YnQndLS+jzoPmmJrU+D7pSW1mdBd0pL65OgO6Wl9TnQndJCSEsuLa2Pze+UltbHuXdKC0a52bRglJtNC0a5ubRohWFuPi8Y5+bzgoFuPi8Y6ebzQshLNi8Y6+bzgsFuPi8Y7ebzguFuPi8Y72bzojHezecF4918XjDezecF4918Xgh5yeYF4918XjDezecF4918XjDezecF491sXgzGu/m8YLybzwvGu/m8YLybzwshL9m8YLybzwvGu/m8YLybzwvGu/m8jDTeXQ6VWT3Jy+VQ7UhD2J1DHWlUuvpOsFJ6p9wphDls4tU3iIV8+EjbkcbdIH+E/EgzC5A/Qp5AXij5kWaHIH+E/EjzX5A/Qn6kGT7IHyE/ksMA+SPkR7I0IH+API0krUD+CHk4PKnk4fCkkofDk0qeQF4oeTg8qeTh8KSSh8OTSh4OTyp5ODyh5B0cnlTycHhSycPhSSUPhyeVPIG8UPJweFLJw+FJJQ+HJ5U8HJ5U8nB4Qsl7ODyp5OHwpJKHw5NKHg5PKnkCeaHk4fCkkofDk0oeDk8qeTg8qeTh8ISSD3B4UsnD4UklD4cnlTwcnlTyBPJCycPhSSUPhyeVPByeVPJweFLJw+EJJc9weFLJw+FJJQ+HJ5U8HJ5U8gTyQsnD4UklD4cnlTwcnlTycHhSycPhCSUf4fCkkofDk0oeDk8qeTg8qeQJ5IWSh8OTSh4OTyp5ODyp5OHwpJKHw5NJ3ig4PKnk4fCkkofDk0oeDk8qeQJ5oeTh8KSSh8OTSh4OTyp5ODyp5OHwhJLXcHhSycPhSSUPhyeVPByeVPIE8kLJw+FJJQ+HJ5U8HJ5U8nB4UsnD4Qklb+DwpJKHw5NKHg5PKnk4PKnkCeSFkofDk0oeDk8qeTg8qeTh8KSSh8MTSt7C4UklD4cnlTwcnlTycHhSyRPICyUPhyeVPByeVPJweFLJw+FJJQ+HJ5Q8weFJJQ+HJ5U8HJ5U8nB4UskTyAslD4cnlTwcnlTycHhSycPhSSUPhyeUvIPDk0oeDk8qeTg8qeTh8KSSJ5AXSh4OTyp5ODyp5OHwpJKHw5NKHg5PKHkPhyeVPByeVPJweFLJw+FJJU8gL5Q8HJ5U8nB4UsnD4UklD4cnlTwcnlDyAQ5PKnk4PKnk4fCkkofDk0qeQF4oeTg8qeTh8KSSh8OTSh4OTyp5ODyh5BkOTyp5ODyp5OHwpJKHw5NKnkBeKHk4PKnk4fCkkofDk0oeDk8qeTg8oeQjHJ5U8nB4UsnD4UklD4cnlTyBvFDycHhSycPhSSUPhyeVPByeVPJweDLJWwWHJ5U8HJ5U8nB4UsnD4UklTyAvlDwcnlTycHhSycPhSSUPhyeVPByeUPIaDk8qeTg8qeTh8KSSh8OTSp5AXih5ODyp5OHwpJKHw5NKHg5PKnk4PKHkDRyeVPJweFLJw+FJJQ+HJ5U8gbxQ8nB4UsnD4UklD4cnlTwcnlTyrTs8pV8ifwnfti2ijLM+tV6RyheuNobmgzV2qRhrc9uOlufWkS7bS5HkDtKr+QyyXi/1pTnX2JCZGxvideNrzttWQGPmvG35MmbO29YeY+ackPP6Obdh3vKUHHeT87an+mPmvO1Jdqc5J51yTiZuNzZs5y2baSy/01jTvGWjvb6h2fbEGTSfNTbazo3NelKRa+zC3NbFuD68K/i2580Afxr4tqfNAH8WeIJw6Au8S17tKgDLwcN6CAUP9dIVeJuEvrExPB+qE6TOSDQJNAeiCRHVFU2nTMoH6e3G2nFawvXK3qCHDxOLHvJsXPTBpuX7sE718VE4TBuqZL9KoOVQJbtV4uDwBq6SRF6H+BrT6yD8UCX7VQI7ePcqWaQC886WdxbyHexgVzSrLes5AniZ4OEc+wJfa1nPwTgKBQ/f2BX47TUjBy84Ek34u4Foeni2rmhWXNTzkGdi0cOIjYu+2hqMh2lDlexXCaFKUCW7VQKHN3CV1Fqp8xB+qJL9KoEdvHeVREqmN+6Z3r25COzgSDRhB7uiWW2AFyAShYKHRhQKHhKxL/C1xt8BXlAoeAL4E8BHlTKi3N70vN4XsQKUXFc0qz1PGWDZhIKHOBMKHo6tL/C1HqQN0HEywTN0XFfgt5/SZDi2kWhCnI1EEzasK5oVH6NlAnqp6CHPxkVfbYmMYdpQJftVAi2HKtmvEji8gauk1hItQ/ihSnarJMIO3r1K6n0RK8IOdkWz2rJehEgUCh7OsS/wtZb1IgG8TPDwjV2B314zivCCI9GEvxuJJjxbVzQrLupFyDOh6EnBiI2LvtYaDCmYNlTJfpVAy6FK9qsEDm/gKqm0UkeKUCWokt0qgR28d5XU+4YSKdjBkWjCDnZFs94ADyJRKHhoRJngNSRiX+Brjb81vKBQ8I2rPm/TdNSvD7Rt8IbmqKf/5OcDat24OBsy54Scv3nOG5c6Q+a8cfXSZ85tSJ+2tNHd5LxxQTJkzht3E33m/NgPbVT7kifpxoUDaD5tXOs9EDKNCweAPwt848IB4M8CD+HQF/hKLwCRgfUQCp4Avifwm2+XkIHUGYkmdNFINCGiuqJZ8fUfAx8mFj3k2bjoqz3aY2HaUCX7VQIthyrZrxI4vIGrpNajZRbCD1WyXyWEKrl3lVT7kidZ2MGuaFZb1rMQiULBwzn2Bb7Wsp6FcRQKHr6xK/Dba0YELzgSTfi7kWjCs3VFs+KiHkGeiUVPQD8s+mprMATThirZrxJoOVTJfpXA4Q1cJbVW6gjCD1WyXyWwg/eukorffnSwgyPRhB3sima1AZ6DSBQKHhpRKHgC+K7A1xp/O3hBoeCh+s4Af+iHNup9EctByXVFs9rzlA6WTSh4iDOZ4D0cW1/gaz1I66HjhIKHjusK/PZTmh6ObSSaBJoD0YQN64pmxcdoPXyYWPSQZ+Oir7ZE5mHaUCX7VQIthyrZrZIAhzdwldRaog0QfqiS/SqBHbx7ldT7IlaAHeyKZrVlvUAALxM8nGNf4Gst6wUYR6Hg4Ru7Ar+9ZhTgBUeiCX83EE2GZ+uKZsVFPYY8E4seRmxc9NXWYBimDVWyXyWEKkGV7FYJHN7AVVJrpY4h/FAl+1UCO3jvKqn4DSWGHRyJJuxgVzSrDfAiRKJQ8NCIQsFDIvYFvtb4O8ILCgVPbYPnhNKws0/AX8Nv3EGxskv4dBt+43Ik+vRJN6XDbfiNz9r3wn/zaapXqZqfXD2m8K8BxbYCckq1FpBuLaA3HzF5yymgdes5INtaQNRaQG9+z4jL6CVGdxvQC3eB9M6E06vXcPIBzUdMy2Bgiiw/zuB0UTQrwatUbqDhbeTkhkgv7U0w2fZuaR6WoA3nRlPa+jSMIa2etL4mJjScGLKLNCOKO4kx2vi5BjS51yaGkZh8YuJuYqLaTkykOZ4YluBDyM4G5tEI6dVghMw1Fq1eHcuU4nQ6KWe2o5myrZbM+xUppseAdGsBmbcOyJNZAgp2HdBtcz8N2X+09tMa2rLtx+Btz8FTz8G7noP3bQcf0ynrownPgw89B889Bx87Dt6onoPXPQff+B12O/jG77DbwTd+h90OvvE77HbwPd9hTc93WNPzHdb0fIe1Pd9hbc93WNvzHdb2fIe1Pd9hbc93WNvzHdb2fIe1Pd9hbc93WOr5Dks932Gp5zssvfUdNoT00JEOvHrq4YdzJ2otoAp3Qr0sUhpjtwMKbl60Cbys7/DjUiz5tw2GzVxp6y8tcnYVOYS0isx2teacXYZjH+dlLA52iSK/CMeUFuGmOGintXVzYzKrJbh80Do91fYkDJ8vFZ8qZbVOnm+s0pa18rxufAUZ3hik1nmQ12D4jYNJH23iaLerioxdYPol59bnrnVbjxI6ig0fZXpeg+zqDZf8UZ74RKhJd5bpP3nd+JJBp5DBV2ZQI4OvzKBBBvcyaEN6rtRGd5NBiwzuPhl/5Lei6/1ksHMENvdjU+vzsc45YBwBowfGETAGYLwjxkpf6HWu5VkqMP5jjJiG3xHj5qdZnccEv102UAftsoGUuCObel+pdR5uZBCQBJCdgKz1dRjnYV3kMYeikcccPqcb5pW+A+Q85I885jBFlZnf45fVXIBUGgIj/NMdMd5npBXgteQxhwLrhnmtkVaALZPHHLasLvN6P2ngAqxWu2xgn+7Ipt4wB0JpCIxwRCNgZDiie2KsNaZkOKIhMEL7VP6Fw7s8acswOUNgJGC8H8b7SFiGnJHHHNKnG+bVRlqQSfKYwzzd8ffDt9+/Z+ikO7Kp9sZvhE4aAiN00hAYoZPuibGWh4jQSUNgJGC8H8bt94gjtE+7bKBn2mUDjXJHNhVf245wI4OAhEjpBWStBQyvYF3kMYeikcccPqcb5pUWraY7PJiLY05gXpV5vbdQphjBplk2MEV3ZFNvmAOpNARGKKUhMEIo3RNjrTGlhiMaAmMn2mf1c44XjNfQO7EXudA7mYTnQqds6MbPpe7s6ncds6FzjPMsOCq987Oe03kxH6dVZjVlzv4apfZ2SYsnvbTP/8Kk9m5pHpajNZw7+7X16bQjrZ60vubGtZ0bsstshyju5Mbo9FudRpN7bW48cvNibsKrcxOVWXLj3HZurJ9/mZb0aihH5jEarhCNn7MZteLtaHR0Nv3CanRuuZ1lfwbZTFlbnqCKhtfNr/HHvuM36m3jN0pzKmZlo74JKDtG0N4vP14dzDqgaydT0smWdKKSTq6kky/pFEo6cUmnWNDJqpJOJRVhSyrCllSELakIW1IRtqQibElF2JKKsCUVQSUVQSUVQSUVQSUVQSUVQSUVQSUVQSUVQSUVQSUV4UoqwpVUhCupCFdSEa6kIlxJRbiSinAlFeFKKsKVVIQvqQhfUhG+pCJ8SUX4korwJRXhSyrCl1SEL6kIX1IRoaQiQklFhJKKCCUVEUoqIpRURCipiFBSEaGkIkJJRXBJRXBJRXBJRXBJRXBJRXBJRXBJRXBJRXBJRXBJRcSSioglFRFLKiKWVEQsqYhYUhGxpCLi4YqY/vjl26fPnz/951+fv/764funr1/+uHRVl//JD1RdesHUudXKxaNPyg9Tt7vEw13yQ9TtLvpgl+kvfWmZ1wA+SSBer/XYq+LLS4DtLny8SzzcJT/93+6ij3fJno5sUhfimy72eBc63sUd7+KPdwnHu/DxLvFwl/xUf7uLPt4lTz8tu/J6WdLml13TqutKfVp7fUwrLwTqbZ7O3bw7d/P+3M2HczfP524+nrr5/D2pcPOrR4vnzetzN2/O3Xz2rI1pWS3a8Pw6klc2213c8S7+eJdwvAsf7xIPd8lrms0u+Sn5dhdzvEuWvqH0zS8fnhdMfjK+3cUd7+KPdwnHu/DxLvFwl/wE3IR58dfEm7MyP/3e7mKOd7HHu9DxLu54F3+wy/SXuU4JsuFNy3g/Ok7K7/n0I78Cud3FH+8Sjnfh413iwS7TX/bSMv/kg4mKU8bd8ryEdo/zU7qmPFuqQc33p+BWVx2XfdQpzHuh9b1sans5JPPazdu0zD+t3d9s3p67eTp38+7czftzNx/O3Tyfu/n8uRaXzfPO5o2m+VESo/3q4aXLc0M3rXVID6bq9bYvrd+/KBDuFo5uKxzTUDjTX+7S9oUc8RLUWnyFjePY7GKPd6HjXdzxLv54l/wVI9qkvG678PEu8XCXvMDZ7pKfNoY0r1u/xPqjiznexR7vQse75Kd36VIb9W0Xf7xLON6Fj3fJT++SVo1rsfbYJS8Ytrvo413MTpfV46ZzF3u8Cx3vkqfP8/Uycrzp4o93Cce75FfUlJ5nxFr5p0dzeyX3aQjs12MADi+rgIo7eOH5joo70GfvwJy9A3v2DujsHbizd+DP3kE4ewdnn8n+7DM5nH0mh7PP5HD2mRzOPpPD2WdyOPtM5hpVlN5u807f7KAGg/RQg/d8s4PDDN6/pBD3OvmCTtGdnOBY41ocZtvs2d3sIJy9Az57B/HkHWhV4zRK3xvy7G/3oE/fgzl9D/b0PdDpe3Cn78Gfvodw8jVZKz59D/HsPWh1+h706Xswp+/Bnr4HOn0P7vQ9+NP3cPo5rU8/p/W55/T0l7+0fGE302UxvSk+XV5WneO1b9joq3T6iI6yOx8EWS0Y6SefA5lSYNS5m9ev37ydFXSg+HzzpsLmZ3zBP/9sm7Gv3zzP2jHcfKPe0Lmbd6/ePKcnb5hu0PoKm5/rn51/vvnw+s2HGS3fJocrbj4+q/vpD948781y2vM/K2lNy6XC73ymZ/fCEi+NxT+Af30NIX+SuPR5kODWTl5NPac///vh26cPv3z+eHmb4fL//vnl1/nlhunP7//7ff5/5tcffv/29dePv/357ePlRYjlHYjL5cXqB9LvH8P52dkHx+ntgOs/eXrw8Xqvmv6YwoqUHhW6djcPZObuZB+IlydiLv+k44Oh9KTL9Z+seyCVlnCvjabimqrq/bXjz9qYB23TRvV0/dWW5xD0tI6ip4jTve3SZuphwnLLUo+B2bCcCdd/Ug/WpfrbOHi1bJgfrJ1yPuX9/w==",
      "brillig_names": [
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "notify_created_nullifier_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "channel_exists",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "_log_channel_creation",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "10775636126596421126": {
            "error_kind": "string",
            "string": "Function _log_channel_creation can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JgACBAEnAAABBIBHJgAABAMmAgQEAyYCBQQAHxgABQAEgEQtCIBEAAEtCIBFAAItCIBGAAMkAAAAUSQAAABSJwIAAQSARyYCAgQAOg0AAQACJSQAAAEbHgIABAAeAgAFADI4AAQABQAGJgIEAQEjAgAGAAAAeyQAAAFEHgIABAEeAgAFAAo4BAUGIwIABgAAAJckAAABVigCAAQAmKkMlCYCBgQEJgIIBAMAOAYIBywIAQUAEAEHASYDBQQBACgFAgcsDgYHACgHAgcsDgYHJgIHBAMAOAUHBiwMBgcsDgEHACgHAgcsDgIHACgHAgcsDgMHACgHAgcsDgQHJgIBBAQAKAUCBCwNBAMmAgYEAgA4BAYCNg0AAgADJScAgAQEeAANAAAAgASAAyMAgAMAAAFDKQEAAQX3ofOvpa3UyjsBAQIlKQEAAQW+Hj//PqT2+jsBAQIlKQEAAQWVir/3IqVWBjsBAQIlLQAYyhjK",
      "debug_symbols": "7VnBbsIwDP2XnHuIncRx+JVpmgqUqVJVUIFJE+Lfl6I1K1ANDcoOmAtq0Ev83rNBbrxT82K6fX8r68VyrSYvO1UtZ/mmXNZxtdtnatqUVVW+v/W/Vrr9YH/Ar1d53S7Xm7zZqAkQYaaKet4+eownLMqqUBMy++wcrLXrwBpdAgP4AbS11n+jrXWU0OwGwGzS0WwQ+uDXTAUcgTsncCT/j9zH8N1C8p0u+Q6OEppaxG/cgwkdOFhjT7iDdqOSj+cdkW9DgL5/CL57CDQ3h7CEXYj4GC7VnMdUc+xP84a3Kx7xJwDmr+4cNvEVmyxdscnB0CbWxJ2m+O9xoT5M6NwC26uPQTBrSAf/pA7YDmAddyQI4AKWqeMQ9FkOSEsQ6QSI9BIy6UVkMggQyVaCSAmZDBIyGfjxRaI2EkR6ASIBJYiUkEkU8BaCKKCtQyOgQUdjJYgU0NahldAMWAltnXuUZsClS2l9dCc9cIHtuLt5DAR05sijdA6jOULPGjl1hJ6OHDviH6UVHc+RZ430HdnH1UfelPm0Kr4nz4ttPesNojefq+JkJr1qlrNivm2Kdjr9M5g+DACdy0i/trO6uIjzSzIxRozzBQ==",
      "brillig_names": [
        "_log_channel_creation"
      ]
    },
    {
      "name": "verify_id_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "963818325383147006": {
            "error_kind": "string",
            "string": "Function verify_id_private can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "verified_id",
            "type": {
              "kind": "array",
              "length": 5,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7ZbRquIwEIbfJde9yCSTzMRXWQ6Hqj2HQqlSdWER332Tw0mrtF3pyMIu9EYa839m8vc3k6vaV9vL53vdfhxOavPjqprDrjzXhzaOrgrM13enY9mm4elcdme1Ae9Noap2nx7J3Ar1UTeV2nh7K0ZiYzx9i43h0ItB6yl1QP5WW23giRq8DdxXgjDoTSprQu8GOdGgTnWN1dbbrEbQD+q3QoFdvZn1BldvZr1x/7g3aN3gDYYn3hgwPtcC6F70xq/ezHpDqzez3vDqzaw34WVvUIcsRjDcixnTAkb/7QXg5QXAasxia+/eLtCUWgPlFxCfg70vaCo6HEKfnTCu3/zn9S+96SQGpxhizNugAPznPbPOe2C879Dw9fuvd1GyNv+HyfITj2x/OiDgYD+a21scbbu6aerP94fLs04fftK7wP19QuvR3jwKGCdgvIAhAcMCJixnSAsYEDBGwAhyQIIckCAHJMgBCXJAghyQIAcsyAFP58APx6jGEWMEjBUwKGCcgPEChpYycQRJipO7cpDvMs6Zx3O2UOiWI345QssRXojc4vBn2dXltqlSs0izl3aXe0ccnn8d80zuLsfusKv2l65KfWZoMSlRThdep8teij6HImDvc5q2UCDk6ah1LlYQq/gN",
      "brillig_names": [
        "debug_log_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper"
      ],
      "verification_key": "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"
    },
    {
      "name": "get_channel_threshold",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "1775037338128445371": {
            "error_kind": "string",
            "string": "Deserialized value is too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "3238985437272151328": {
            "error_kind": "string",
            "string": "Function get_channel_threshold can only be called statically"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          }
        },
        "parameters": [
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "uint253::uint253::U253"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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AycAgAQEAAQkAAAJXC0IgAUAEgAoEgITASgAE4BEABQsDg4ULA4SCiwOEAgsDgELLA4RDCIAAAdBADgEAQ4sDA4EIgAABAgnAIAEBHgADQAAAIAEgAMjAIADAAAHdykBAAEF96Hzr6Wt1Mo7AQECJSkBAAEFvh4//z6k9vo7AQECJSkBAAEFLPMwGCVFFSA7AQECJSkBAAEF6J0J/qERLQ47AQECJSQAAAdPHAwBAgArAgADAB//////////////////////////////////////////DjgCAwQjAgAEAAAH7yQAAAn8JSkBAAEFGKIzDfIzb7s7AQECJSQAAAdPJgIGBAEtCIBEAAUiAAAIFw0oAAWARQAHIwIABwAACIciAAAILCwNAQUsDQIGLA0DBywNBAgmAgkEBCwIAQomAgsEBQAQAQsBJgMKBAEAKAYCCyYCDAQEACgKAg0+DwALAA0sDQoGACgGAgYsDgYKLA4FASwOCgIsDgcDLA4IBCUsDQMHDDgFBwgAOAUGByMCAAgAAAiiIgAACVMsDQEILA0CCSwNAwosDQQLJgINBAQMOAUNDiMCAA4AAAjJJAAAB5wAKAkCDQA4DQUOLA0ODCYCDgQDDDgFDg8jAgAPAAAI7iQAAAecACgIAg4AOA4FDywNDw0AOAwNDiYCDQQEDDgFDQ8jAgAPAAAJGCQAAAecLQQACYADJwCABAQABSQAAAlcLQiABQAMACgMAg0AOA0FDywODg8sDggBLA4MAiwOCgMsDgsEIgAACVMsDAcFIgAACBctAYADgAYLAIAGAAKAByMAgAcAAAl3IgAACYItAIADgAUiAAAJ6S0AAAGABQEAAAGABAABAQCAA4AEgAktAIADgAotAIAFgAsLAIAKgAmADCMAgAwAAAnVLQGACoAILQKACIALAQCACgACgAoBAIALAAKACyIAAAmkJwGABQQAAQMAgAYAAoAGIgAACeklKQEAAQVFp8pxGUHkFTsBAQIlKQEAAQVaAuQbtR6pnzsBAQIlLQAYyhjK",
      "debug_symbols": "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",
      "brillig_names": [
        "get_channel_threshold"
      ]
    },
    {
      "name": "channel_key",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3NTuMwEIDfJeceYnv8x6usVqhAQZGqFpWy0grx7huvmhRsY2tS5+LxBRHqwZ7Psf0lJOaje9o9vL/cD4fn41t39+uj2x8ft+fheBiPPj433cNp2O+Hl/uvP+5694WZ/+XfXrcHd/h23p7O3R1Tim+63eHJfav5+Bueh/2uu1PicxMUNr28lDVczEWNjhSVfCoqZT8XZcA+f286Zm9vilRTU7RJNwWEvRQFZfym8P7mptheXMpaptNNUTNAxVXQFHZ7U4BNTZGQaYrpL0V1H3QQ57c3RbO5LZrLr4VdBWLtCmDtCuTaFai1K9BrV2DWrsCuXIHo166ArV3B2iNZFBjJSolrBTYz8QOfZ37Q10mOu1qC0mJeJoBfZzk39wZFObNwKcs54+nCcm6E5PprUUcEGhGPiGxEPCKqEfGI6EbEI2IaEY+IbUS+E4G+EfGIsEbEI8IbEY9Ic1afCDQiHhGazqqmu0JSMZ8ITWdNEaHprCkiNJ11Lqu+F3VEaDprgoik6awpIjSdNUWEprOmiNB01hQRaEQ8IjSdNUWEprOmiNB01hSR5qw+keasHhHVnNUn0pzVJ0LAWV2aBETUpQk00iSgjC5NAh7o0iQgdy5NAsbm0iSgYWOamoBbuTQJCJNLk4YFaRoWpIFGmjQsSNOwIE3DgjQNC9I0LMjQsCBDw4JMNQsKF9c0QfppVjMFaTa9JMi1EIsLOybVzFcYJuzaZKaM/1iQrWZyK8ikmpmwIJNqLh4LMqnmShPFROvpFzNt/XXHQmMSMKlGOQoyqeaCtyCTaq6OCzIh6bEZJjQ9NsmE9TRFNgOFpslmoNBU2QyU5rIRKNCghFCazUagNJ2NQGk+G4HShDYCpRltCIXRNFrL5vwsD6HQNNoMFJpGm4FSzZIs+qksFwyCPKtZZTN5VrNwZvKsZi1M58mrWd4yeVazYmXyrGYRyuRZzZ0SbvmcZy8zi20/r8zjxa4JoECDEkKp51EjDBQm5r+ZM8kCKNVoWUko1ThcSSjVCF9JKNXYIQ6KkjMUE0y0ohr1QEGBftrua/w2OFPq2f67JBRoUEIoND0lA4Wmp0g+rz5f/z3MBIWmp2Sg0PSUDBSanpKGUs+e4CWhVHN/rCQUmkabgULTaDNQoEEJodA02gyUZrQRKESNVs/5ScsDKESNNg2FqNEmodSzY3hJKESNNg2FqNGmoRA12jQUaFBCKDTlTVwf8RMiuEdbz47ZJaHQlLcMFJryloZSz9bZJaHQlLcMFJryloFCU94yUKBBCaHQvB2ZgdKMNgKlGW0EClGjBT1DUcGN63q2IC8IpZ4Ny0tCIWq0aShEjTYNhajRpqFAgxJCaY+Mho+M1rOJe0koNI02A4Wm0aah1LPP+s9QXJ7xLVK1mF4l1CCCkOggsjBVY2VYi8GHWGwIj++6lw6J62jyVUr+w55tmSCxJAiWBMklQWpJkF4SZJYE2QVBP+xZkwlackawJWcEW3JGsCVnBFtyRrAlZ0R8X4zUdMLjW0zYfvp/ApYHIRw/0OMvyqdrAXyIxIcofIjGp2/wIfgJWOD7RTB8CMeHCHxIvPelvS7pQYjEhyh8iMaHGHyIRYfEXyhJh+R6PxKC733A9378QfZ0iMSHKHwIfuwDfuwDfuxL/NiX+LEv8b0v8b0v8b0v8b0vkb3/OR792Z6G7cN+9zZGuA/fD4/n4Xi4HJ7/vk6fPJyG/X54uX89HR93T++n3f3++Og+6/rLl198vDzhBpxsu0NmxIYZ4w5dv3Ajx0/1WOtY8z8=",
      "brillig_names": [
        "channel_key"
      ]
    },
    {
      "name": "compute_note_hash_and_optionally_a_nullifier",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 20
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "contract_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "storage_slot",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "note_type_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "compute_nullifier",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "packed_note_content",
            "type": {
              "kind": "array",
              "length": 3,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 4,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "compute_note_hash_and_optionally_a_nullifier"
      ]
    },
    {
      "name": "set_channel_threshold",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "1775037338128445371": {
            "error_kind": "string",
            "string": "Deserialized value is too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "4475601672736294460": {
            "error_kind": "string",
            "string": "Unauthorized"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          }
        },
        "parameters": [
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "new_threshold",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "set_channel_threshold"
      ]
    },
    {
      "name": "verified_id_transfer",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "fields": [
                {
                  "name": "value",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "uint253::uint253::U253"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Zrdbts8DIbvJcc5EEWKpHorH4ahP9kQoGiLtP2Aoei9T84q2WnkGFSaLh18UlQxH+bNK8Ui5bwsblZXzz+/r+9+3D8uLv57WdzeX18+re/v0uhlAbh97fHh8q4bPj5dbp4WF8Dsl4vV3U33r/jX5eLH+na1uGB8Xe4Fe8/yFuy9xhIMztWiI+lbNDoPE9HAGLUoIejjfSerEh/6cJE+utO1H42MOZrA7UR/Wy6AZm9GvQmzN6Pe8Jl7Qxh6byhOeOPBc9YCFI70RmZvRr3R2ZtRb+LszZg33h3tDbmYgwm8lmCl7RvAqd/AH/0GgI5yMOJgdkFq0Q4kT0D6P+JQUG3paIxl7cR9/fjF9VNNP0fNa1rSZzmsX13WozTcbWGbv1otCEbI+cnRMH/HVHdRofLFEdJwWFPI6UOcuDV8neLCy/na8jfvgTrbUrMlzrZUbEE321KzBaZsCQ4Pf1rUss9j9L0eqe1iWAoygv72D+S3YvzxYiLFImawR1bFJLdd7zwPZurPHol4Znrok/WIRJf1iIK81xPOTA8frSdVqtAvUDisR0JezDJoLpS3WuRztaj3pRiToZbKDUQkx3rFqa5IOZYyTxAnbk7af8CkgyaiMeRg8oNbU100lHJ2RwbXF0oplSWGiWBXMoNjHQZ386jzPP4T8xjnefwX5pHcJ88jQH0eOy314ilw1i8ME1oC5Q0/hD4Umb92y0p+dmbEGTxrZ/5iK0I0OzPiTJidGXGGJ50JNNGsp60u66GAR7SvJB8gpnxcHwZbcFO7SHpmeuIn65loF4M7Mz3woXpYJ85ifCkk0elOaZMGV5v17e365/edn4647k+sfueilj3Sub2nAVEaGG1gop1Jr7VA0AL5FghbIGqBQgvELZC0QNoCtawIaFkR0LIioGVFQMuKqP+0KXL/TNHRPhRaIG6BpAXSFihaoTSCLrT+UNxTqR+43wHYjz/lPkigmSAzEcwE24g08F1gvXINgKUY9XtVFNsRsSNqR6IRSSPcLpvqBKUmNB8suH6jBozjM3QYYTsidkTtSDQj9Yd16gtCuoeAHfF2BO0I2ZFgR9iOiB1ROxLNSP2ITzX/WEZj3EFqbVruQ3Bw5omo46d2H5fenzY9njY9nTZ9OG16Pm16OW16/cD0invp40nTB3fa9PXqupwlRZT395Hg7QjaEbIjwY6wHRE7omaEoxkRZ0dGKu9Q6k95v2DE2xG0I2RHgh1hOyJ2pDr76elkRuLet1KiGVFnR8COeDuCdoSMSBrRtiWoymOfO3ge/Pb2rf2oN4aHEbIjwY6wHREjkkZh7ifT8P/Lzfry6nbVHcd2V5/vrvPpbBo+/XrIV/L57cPm/np187xZdSe5/SFut5jUL6P/1p2RpUH3TDw9mSlnHV1Amg/UHJD6NaLS2HeXEZYE+XKAZeDS8m5fYr9k6a53X9908p3eLK//Le6W5DJOKReXaR7L/ppM+A0=",
      "brillig_names": [
        "debug_log_oracle_wrapper",
        "pop_capsule",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "store_in_execution_cache_oracle_wrapper"
      ],
      "verification_key": "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"
    },
    {
      "name": "set_default_channel_threshold",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "4475601672736294460": {
            "error_kind": "string",
            "string": "Unauthorized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "new_threshold",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "set_default_channel_threshold"
      ]
    },
    {
      "name": "channel_transfer",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "16049994897275280777": {
            "error_kind": "string",
            "string": "Non-zero delay change for zero hash"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "1775037338128445371": {
            "error_kind": "string",
            "string": "Deserialized value is too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2435529361475140548": {
            "error_kind": "string",
            "string": "Non-zero value change for zero hash"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7461896932686329849": {
            "error_kind": "string",
            "string": "U253 addition overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "get_public_storage_hints",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "init",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "admin",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "shield_gateway_storage",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "default_channel_threshold",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "init"
      ]
    },
    {
      "name": "get_channel_balance",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "error_types": {
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "14217640468024275109": {
            "error_kind": "string",
            "string": "Function get_channel_balance can only be called statically"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "1775037338128445371": {
            "error_kind": "string",
            "string": "Deserialized value is too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "H4sIAAAAAAAA/7WTyw7CIBBFqcUo0sTEx39MU0y7dOHafyCtLHVRN+766dZkJkyI0QVwEzJMgMNcHoXwKjBKESGCHDEqjAs2Xs7tjDnEqVbBvin5HRijvvhLWH+jkFnk4QPxM50/rJBzmTyfe6F913PTrF8J/z5y+af7y+l//8OzRq9bzCvh/8P4uvfXx/M2ij/SbJGc0ptoOwAqvkT+EvmhJBvn8w+Yb4Svj6KMqNO1tnaNdfZkh8H0dhfwP+KH/QbzqHp4zgQAAA==",
      "debug_symbols": "dY/RCoMwDEX/Jc99aCoO9FdkSNUohdJKrYMh/felQ7ZuYy/h3nByyT1gomFfeuNmv0HbHWD9qKPxjt2RBAzBWGuWvlyDzAOrJ7+t2mW7RR0itDUKIDexaPh6NpagvVRJ/IAoUaqTZa3eONZ/+AZfvEL5wV8T25sORg+Wztfn3Y1Fk3hf6avUGvxI0x4o1yua8eywFkpyLEc/AA==",
      "brillig_names": [
        "sync_notes"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "U253Note"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "U253Note"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "U253Note"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Beacon"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "target",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "overrides",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "ShieldGatewayStorage"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "authorized_caller",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "channel_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "channel_thresholds",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "minter",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "shield_gateway_beacon",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "private_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "shielded_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "ShieldGateway"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "default_channel_threshold",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "shield_gateway_storage",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "new_threshold",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "effective_block",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::DefaultChannelThresholdChanged"
        },
        {
          "fields": [
            {
              "name": "from",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "to",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::ChannelCreation"
        },
        {
          "fields": [
            {
              "name": "from",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "to",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::ChannelThresholdExceeded"
        },
        {
          "fields": [
            {
              "name": "new",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "effective_block",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::ChannelThresholdChanged"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::initialize_channel_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::initialize_channel_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "shield_gateway_storage",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "default_channel_threshold",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::init_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::init_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::get_channel_balance_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::get_channel_balance_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "new_threshold",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::set_channel_threshold_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::set_channel_threshold_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "fields": [
                        {
                          "name": "value",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "uint253::uint253::U253"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::verified_id_transfer_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::verified_id_transfer_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::get_channel_threshold_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "uint253::uint253::U253"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::get_channel_threshold_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::_log_channel_threshold_exceeded_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::_log_channel_threshold_exceeded_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::_log_channel_creation_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::_log_channel_creation_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "new_threshold",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::set_default_channel_threshold_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::set_default_channel_threshold_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::channel_exists_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::channel_exists_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "verified_id",
                    "type": {
                      "kind": "array",
                      "length": 5,
                      "type": {
                        "kind": "field"
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::verify_id_private_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::verify_id_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ShieldGateway::channel_transfer_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ShieldGateway::channel_transfer_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "107": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        /// Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "111": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    /// Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "117": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "126": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/note/discovery/mod.nr",
      "source": "use std::static_assert;\n\nuse crate::{\n    context::unconstrained_context::UnconstrainedContext, note::note_header::NoteHeader,\n    oracle::note_discovery::deliver_note, utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\n    hash::compute_note_hash_nonce,\n};\n\n// We reserve two fields in the note log that are not part of the note content: one for the storage slot, and one for\n// the note type id.\nglobal NOTE_LOG_RESERVED_FIELDS: u32 = 2;\npub global MAX_NOTE_SERIALIZED_LEN: u32 = PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_LOG_RESERVED_FIELDS;\n\npub struct NoteHashesAndNullifier {\n    pub note_hash: Field,\n    pub unique_note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Processes a log given its plaintext by trying to find notes encoded in it. This process involves the discovery of\n/// the nonce of any such notes, which requires knowledge of the transaction hash in which the notes would've been\n/// created, along with the list of unique note hashes in said transaction.\n///\n/// Additionally, this requires a `compute_note_hash_and_nullifier` lambda that is able to compute these values for any\n/// note in the contract given their contents. A typical implementation of such a function would look like this:\n///\n/// ```\n/// |packed_note_content, note_header, note_type_id| {\n///     let hashes = if note_type_id == MyNoteType::get_note_type_id() {\n///         assert(packed_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///         dep::aztec::note::utils::compute_note_hash_and_optionally_a_nullifier(\n///             MyNoteType::unpack_content,\n///             note_header,\n///             true,\n///             packed_note_content.storage(),\n///         )\n///     } else {\n///         panic(f\"Unknown note type id {note_type_id}\")\n///     };\n///\n///     Option::some(dep::aztec::oracle::management::NoteHashesAndNullifier {\n///         note_hash: hashes[0],\n///         unique_note_hash: hashes[1],\n///         inner_nullifier: hashes[3],\n///     })\n/// }\n/// ```\npub unconstrained fn do_process_log<Env>(\n    context: UnconstrainedContext,\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: fn[Env](BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>, NoteHeader, Field) -> Option<NoteHashesAndNullifier>,\n) {\n    let (storage_slot, note_type_id, packed_note_content) =\n        destructure_log_plaintext(log_plaintext);\n\n    // We need to find the note's nonce, which is the one that results in one of the unique note hashes from tx_hash\n    for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            let header = NoteHeader::new(context.this_address(), candidate_nonce, storage_slot);\n\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes =\n                compute_note_hash_and_nullifier(packed_note_content, header, note_type_id).unwrap();\n\n            if hashes.unique_note_hash == expected_unique_note_hash {\n                // TODO(#10726): push these into a vec to deliver all at once instead of having one oracle call per note\n\n                assert(\n                    deliver_note(\n                        context.this_address(), // TODO(#10727): allow other contracts to deliver notes\n                        storage_slot,\n                        candidate_nonce,\n                        packed_note_content,\n                        hashes.note_hash,\n                        hashes.inner_nullifier,\n                        tx_hash,\n                        recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n}\n\nunconstrained fn destructure_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>) {\n    assert(log_plaintext.len() >= NOTE_LOG_RESERVED_FIELDS);\n\n    // If NOTE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\n    // `storage_slot` and `note_type_id` must be updated as well.\n    static_assert(\n        NOTE_LOG_RESERVED_FIELDS == 2,\n        \"unepxected value for NOTE_LOG_RESERVED_FIELDS\",\n    );\n    let storage_slot = log_plaintext.get(0);\n    let note_type_id = log_plaintext.get(1);\n\n    let packed_note_content = array::subbvec(log_plaintext, NOTE_LOG_RESERVED_FIELDS);\n\n    (storage_slot, note_type_id, packed_note_content)\n}\n\nfn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..MaxLen {\n        if i < vec.len() {\n            f(vec.get_unchecked(i), i);\n        }\n    }\n}\n"
    },
    "137": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n    utils::array,\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    compute_unique_note_hash,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let header = note.get_header();\n    let nonce = header.nonce;\n    let counter = header.note_hash_counter;\n\n    // If same tx note, read request always uses the normal note hash\n    if counter != 0 {\n        note_hash\n    } else {\n        // If the note comes from a different tx, we need to compute the note hash that reached the tree\n        compute_unique_note_hash(\n            nonce,\n            compute_siloed_note_hash(header.contract_address, note_hash),\n        )\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if (header.note_hash_counter != 0) & (header.nonce != 0) {\n        // Non-revertible note, nullified by a revertible nullifier, we need to nullify the note hash that will reach the tree\n        let siloed_note_hash =\n            compute_siloed_note_hash(header.contract_address, note_hash_for_read_request);\n\n        compute_unique_note_hash(header.nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    unpack_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    packed_note_content: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = unpack_content(array::subarray(packed_note_content, 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, note_hash);\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"
    },
    "139": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "140": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "141": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "142": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field]) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\n}\n\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\n    let _ = store_in_execution_cache_oracle(values);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "143": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    /// Safety: The to_address function combines all values in the instance object to produce an address,\n    /// so by checking that we get the expected address we validate the entire struct.\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "147": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\n    }\n}\n"
    },
    "148": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "149": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "152": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr",
      "source": "use crate::note::discovery::MAX_NOTE_SERIALIZED_LEN;\nuse dep::protocol_types::address::AztecAddress;\n\n/// Informs PXE of a note's existence so that it can later retrieved by the `getNotes` oracle. The note will be scoped\n/// to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The note's `content` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value is\n/// typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are the\n/// inner hashes, i.e. the raw hashes returned by `NoteInterface::compute_note_hash` and\n/// `NullifiableNote::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree at\n/// `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was sucessfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    content: BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        content,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    content: BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n"
    },
    "153": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note_content,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        packed_note_content,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note_content: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    let _ = notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    sync_notes_oracle_wrapper();\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let note_content = array::subarray(fields, read_offset + 2);\n\n            let mut note = Note::unpack_content(note_content);\n            note.set_header(NoteHeader { contract_address, nonce, storage_slot, note_hash_counter });\n\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_indexed_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\n/// for later querying via the `get_notes` oracle.\npub fn sync_notes() {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        sync_notes_oracle_wrapper();\n    }\n}\n\nunconstrained fn sync_notes_oracle_wrapper() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n"
    },
    "156": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::Packable};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "166": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub unconstrained fn read(self) -> T {\n        WithHash::unconstrained_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub fn read(self) -> T {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "169": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_delay_change.nr",
      "source": "use dep::protocol_types::traits::Packable;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub(crate) struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pre: Option<u32>,\n    post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub(crate) fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub(crate) fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub(crate) fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub(crate) fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior contraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub(crate) fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Packable<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn pack(self) -> [Field; 1] {\n        // We pack all three u32 values into a single U128, which is made up of two u64 limbs.\n        // Low limb: [ pre_inner: u32 | post_inner: u32 ]\n        // High limb: [ empty | pre_is_some: u8 |  post_is_some: u8 | block_of_change: u32 ]\n        let lo = ((self.pre.unwrap_unchecked() as u64) * (1 << 32))\n            + (self.post.unwrap_unchecked() as u64);\n\n        let hi = (self.pre.is_some() as u64) * (1 << 33)\n            + (self.post.is_some() as u64 * (1 << 32))\n            + self.block_of_change as u64;\n\n        let packed = U128::from_u64s_le(lo, hi);\n\n        [packed.to_integer()]\n    }\n\n    fn unpack(input: [Field; 1]) -> Self {\n        let packed = U128::from_integer(input[0]);\n\n        // We use division and modulo to clear the bits that correspond to other values when unpacking.\n        let pre_is_some = ((packed.hi as u64) / (1 << 33)) as bool;\n        let pre_inner = ((packed.lo as u64) / (1 << 32)) as u32;\n\n        let post_is_some = (((packed.hi as u64) / (1 << 32)) % (1 << 1)) as bool;\n        let post_inner = ((packed.lo as u64) % (1 << 32)) as u32;\n\n        let block_of_change = ((packed.hi as u64) % (1 << 32)) as u32;\n\n        Self {\n            pre: if pre_is_some {\n                Option::some(pre_inner)\n            } else {\n                Option::none()\n            },\n            post: if post_is_some {\n                Option::some(post_inner)\n            } else {\n                Option::none()\n            },\n            block_of_change,\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n"
    },
    "17": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "171": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_value_change.nr",
      "source": "use dep::protocol_types::traits::{FromField, Packable, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub(crate) struct ScheduledValueChange<T> {\n    pre: T,\n    post: T,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub(crate) fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub(crate) fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub(crate) fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub(crate) fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub(crate) fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Packable<3> for ScheduledValueChange<T>\nwhere\n    T: ToField + FromField,\n{\n    fn pack(self) -> [Field; 3] {\n        [self.pre.to_field(), self.post.to_field(), self.block_of_change.to_field()]\n    }\n\n    fn unpack(input: [Field; 3]) -> Self {\n        Self {\n            pre: FromField::from_field(input[0]),\n            post: FromField::from_field(input[1]),\n            block_of_change: FromField::from_field(input[2]),\n        }\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n"
    },
    "173": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    hash::{poseidon2_hash, poseidon2_hash_with_separator},\n    traits::{FromField, Packable, ToField},\n    utils::arrays::array_concat,\n};\n\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse crate::state_vars::{\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    storage::Storage,\n};\nuse dep::std::mem::zeroed;\n\npub(crate) mod scheduled_delay_change;\npub(crate) mod scheduled_value_change;\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// Separators separating storage slot of different values within the same state variable\nglobal VALUE_CHANGE_SEPARATOR: u32 = 0;\nglobal DELAY_CHANGE_SEPARATOR: u32 = 1;\nglobal HASH_SEPARATOR: u32 = 2;\n\n// This will make the Aztec macros require that T implements the Serialize<N> trait, and allocate N storage slots to\n// this state variable. This is incorrect, since what we actually store is:\n//  - a ScheduledValueChange<T>, which requires 1 + 2 * M storage slots, where M is the serialization length of T\n//  - a ScheduledDelayChange, which requires another storage slot\n//\n// TODO https://github.com/AztecProtocol/aztec-packages/issues/5736: change the storage allocation scheme so that we\n// can actually use it here\nimpl<T, let INITIAL_DELAY: u32, Context, let N: u32> Storage<N> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    T: ToField + FromField + Eq,\n{\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    // Since we can't rely on the native storage allocation scheme, we hash the storage slot to get a unique location in\n    // which we can safely store as much data as we need.\n    // See https://github.com/AztecProtocol/aztec-packages/issues/5492 and\n    // https://github.com/AztecProtocol/aztec-packages/issues/5736\n    // We store three things in public storage:\n    //  - a ScheduledValueChange\n    //  - a ScheduledDelaChange\n    //  - the hash of both of these (via `hash_scheduled_data`)\n    fn get_value_change_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], VALUE_CHANGE_SEPARATOR)\n    }\n\n    fn get_delay_change_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], DELAY_CHANGE_SEPARATOR)\n    }\n\n    fn get_hash_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], HASH_SEPARATOR)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: ToField + FromField + Eq,\n{\n\n    pub fn schedule_value_change(self, new_value: T) {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        self.context.storage_read(self.get_delay_change_storage_slot())\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    ) {\n        // Whenever we write to public storage, we write both the value change and delay change as well as the hash of\n        // them both. This guarantees that the hash is always kept up to date.\n        // While this makes for more costly writes, it also makes private proofs much simpler because they only need to\n        // produce a historical proof for the hash, which results in a single inclusion proof (as opposed to 4 in the\n        // best case scenario in which T is a single field). Private shared mutable reads are assumed to be much more\n        // frequent than public writes, so this tradeoff makes sense.\n        self.context.storage_write(self.get_value_change_storage_slot(), value_change);\n        self.context.storage_write(self.get_delay_change_storage_slot(), delay_change);\n        self.context.storage_write(\n            self.get_hash_storage_slot(),\n            SharedMutable::hash_scheduled_data(value_change, delay_change),\n        );\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: ToField + FromField + Eq,\n{\n    pub fn get_current_value(self) -> T {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for both the ScheduledValueChange and\n        // ScheduledDelayChange, but that'd require one full sibling path per storage slot (since due to kernel siloing\n        // the storage is not contiguous), and in the best case in which T is a single field that'd be 4 slots.\n        // Instead, we get an oracle to provide us the correct values for both the value and delay changes, and instead\n        // prove inclusion of their hash, which is both a much smaller proof (a single slot), and also independent of\n        // the size of T.\n        /// Safety: The hints are checked to be a preimage of a hash obtained from constrained context.\n        let (value_change_hint, delay_change_hint) = unsafe {\n            get_public_storage_hints(address, self.storage_slot, historical_block_number)\n        };\n\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let hash = header.public_storage_historical_read(self.get_hash_storage_slot(), address);\n\n        if hash != 0 {\n            assert_eq(\n                hash,\n                SharedMutable::hash_scheduled_data(value_change_hint, delay_change_hint),\n                \"Hint values do not match hash\",\n            );\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized, meaning no value or delay change was ever\n            // scheduled. Therefore, the hints must then correspond to uninitialized scheduled changes.\n            assert_eq(\n                value_change_hint,\n                ScheduledValueChange::unpack(zeroed()),\n                \"Non-zero value change for zero hash\",\n            );\n            assert_eq(\n                delay_change_hint,\n                ScheduledDelayChange::unpack(zeroed()),\n                \"Non-zero delay change for zero hash\",\n            );\n        };\n\n        (value_change_hint, delay_change_hint, historical_block_number)\n    }\n\n    fn hash_scheduled_data(\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    ) -> Field {\n        let concatenated: [Field; 4] = array_concat(value_change.pack(), delay_change.pack());\n        poseidon2_hash(concatenated)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UnconstrainedContext>\nwhere\n    T: ToField + FromField + Eq,\n{\n    pub unconstrained fn get_current_value(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    unconstrained fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n}\n\nunconstrained fn get_public_storage_hints<T, let INITIAL_DELAY: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>)\nwhere\n    T: ToField + FromField + Eq,\n{\n    // This function cannot be part of the &mut PrivateContext impl because that'd mean that by passing `self` we'd also\n    // be passing a mutable reference to an unconstrained function, which is not allowed. We therefore create a dummy\n    // state variable here so that we can access the methods to compute storage slots. This will all be removed in the\n    // future once we do proper storage slot allocation (#5492).\n    let dummy: SharedMutable<T, INITIAL_DELAY, ()> = SharedMutable::new((), storage_slot);\n\n    (\n        storage_read(address, dummy.get_value_change_storage_slot(), block_number),\n        storage_read(address, dummy.get_delay_change_storage_slot(), block_number),\n    )\n}\n"
    },
    "18": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    /// Safety: borrow is enforced to be boolean due to its type.\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        /// Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            /// Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        /// Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "184": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/unencrypted_logs/unencrypted_event_emission.nr",
      "source": "use crate::{context::PublicContext, event::event_interface::EventInterface};\n\nfn emit<Event, let N: u32>(context: &mut PublicContext, event: Event)\nwhere\n    Event: EventInterface<N>,\n{\n    let selector = Event::get_event_type_id();\n\n    let serialized_event = event.serialize();\n    let mut emitted_log = [0; N + 1];\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    for i in 0..serialized_event.len() {\n        emitted_log[i] = serialized_event[i];\n    }\n\n    emitted_log[serialized_event.len()] = selector.to_field();\n\n    context.emit_public_log(emitted_log);\n}\n\npub fn encode_event<Event, let N: u32>(\n    context: &mut PublicContext,\n) -> fn[(&mut PublicContext,)](Event) -> ()\nwhere\n    Event: EventInterface<N>,\n{\n    |e: Event| { emit(context, e); }\n}\n"
    },
    "187": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "188": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    vec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(vec.storage(), offset), vec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "19": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "196": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UnconstrainedContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn unconstrained_public_storage_read(\n        context: UnconstrainedContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            /// Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "21": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    /// Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "211": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "213": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "248": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "255": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        function_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            function_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "26": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "270": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "271": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "272": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::{constants::TWO_POW_64, utils::{arrays::array_concat, field::field_from_bytes}};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_contract_class_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_contract_class_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; N * 32];\n    for offset in 0..N {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "282": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "288": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "289": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "298": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "314": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "318": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::{Packable, ToField};\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for U128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self.to_field()]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "319": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 2;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        // We use little-endian ordering to match the order in which U128 defines its limbs.\n        // This is necessary because of how Noir handles serialization:\n        // - When calling a contract function from TypeScript, the serialization in encoder.ts gets used and then Noir\n        //   deserializes using its intrinsic serialization logic (based on the limb order in the struct).\n        // - When calling a contract function from another function, the `serialize` method is invoked on the type\n        //   first.\n        // For this reason if we didn't use the ordering of U128 limbs here and in encoder.ts we would get an arguments\n        // hash mismatch.\n        [self.lo, self.hi]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_u64s_le(fields[0] as u64, fields[1] as u64)\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "335": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    /// Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    /// of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "336": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "338": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "355": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/shield_gateway_storage/src/main.nr",
      "source": "mod test;\n\nuse aztec::macros::aztec;\n\n#[aztec]\npub contract ShieldGatewayStorage {\n\n    use aztec::{\n        context::PrivateContext,\n        encrypted_logs::log_assembly_strategies::default_aes128::note::encode_and_encrypt_note,\n        macros::{functions::{initializer, private, public, view}, storage::storage},\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Hash, Serialize},\n        },\n        state_vars::{Map, PrivateMutable, PublicImmutable, SharedMutable},\n    };\n\n    use uint253::{uint253::U253, uint253_note::U253Note};\n\n    pub global CHANGE_DELAY_BLOCKS: u32 = 5;\n\n    #[storage]\n    struct Storage<Context> {\n        admin: PublicImmutable<AztecAddress, Context>,\n        authorized_caller: SharedMutable<AztecAddress, CHANGE_DELAY_BLOCKS, Context>,\n        channel_balances: Map<Field, PrivateMutable<U253Note, Context>, Context>,\n        channel_thresholds: Map<AztecAddress, SharedMutable<U253, CHANGE_DELAY_BLOCKS, Context>, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn init(admin: AztecAddress) {\n        storage.admin.initialize(admin);\n    }\n\n    #[public]\n    fn set_authorized_caller(caller: AztecAddress) {\n        assert(context.msg_sender() == storage.admin.read(), \"Only the admin can set the authorized caller\");\n        storage.authorized_caller.schedule_value_change(caller);\n    }\n\n    #[contract_library_method]\n    fn _assert_caller_is_authorized(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n    ) {\n        assert(context.msg_sender() == storage.authorized_caller.get_current_value(), \"Unauthorized\");\n    }\n\n    pub unconstrained fn is_channel_initialized_unconstrained(key: Field) -> bool {\n        storage.channel_balances.at(key).is_initialized()\n    }\n\n    #[private]\n    #[view]\n    fn is_channel_initialized(key: Field) -> bool {\n        _assert_caller_is_authorized(&mut context, storage);\n        // Safety: `initialize` must be called if the key is uninitialized, so the caller\n        // must attempt initialization for uninitialized keys to constrain this value\n        unsafe {\n            is_channel_initialized_unconstrained(key)\n        }\n    }\n\n    #[private]\n    fn get_channel_balance(key: Field) -> U253 {\n        _assert_caller_is_authorized(&mut context, storage);\n        storage.channel_balances.at(key).get_note().note.get_value()\n    }\n\n    #[private]\n    fn initialize_channel_balance(key: Field, value: U253, owner: AztecAddress) -> U253 {\n        _assert_caller_is_authorized(&mut context, storage);\n        let mut note = U253Note::new(value, owner);\n        storage.channel_balances.at(key).initialize(&mut note).emit(encode_and_encrypt_note(\n            &mut context,\n            owner,\n            owner,\n        ));\n        value\n    }\n\n    #[private]\n    fn set_channel_balance(key: Field, value: U253, owner: AztecAddress) -> U253 {\n        _assert_caller_is_authorized(&mut context, storage);\n        let mut note = U253Note::new(value, owner);\n        storage.channel_balances.at(key).replace(&mut note).emit(encode_and_encrypt_note(\n            &mut context,\n            owner,\n            owner,\n        ));\n        value\n    }\n\n    #[public]\n    #[view]\n    fn get_channel_threshold(key: AztecAddress) -> U253 {\n        storage.channel_thresholds.at(key).get_current_value()\n    }\n\n    #[private]\n    #[view]\n    fn get_channel_threshold_private(key: AztecAddress) -> U253 {\n        storage.channel_thresholds.at(key).get_current_value()\n    }\n\n    #[public]\n    fn set_channel_threshold(key: AztecAddress, value: U253) -> U253 {\n        assert(context.msg_sender() == storage.authorized_caller.get_current_value(), \"Unauthorized\");\n        storage.channel_thresholds.at(key).schedule_value_change(value);\n        value\n    }\n\n    unconstrained pub fn get_authorized_caller_unconstrained() -> AztecAddress {\n        storage.authorized_caller.get_current_value()\n    }\n\n    unconstrained pub fn get_admin_unconstrained() -> AztecAddress {\n        storage.admin.read()\n    }\n}\n"
    },
    "364": {
      "path": "/home/vscode/nargo/github.com/ClarifiedLabs/aztec-uint253/aztec-packages-v0.75.0/src/uint253.nr",
      "source": "// Copyright (c) 2025 Clarified Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nuse aztec::protocol_types::traits::{Deserialize, FromField, Packable, Serialize, ToField};\nuse std::cmp::{Eq, Ord, Ordering};\nuse std::ops::{Add, Div, Mul, Rem, Sub};\n\n// Maximum value for U253 (2^253 - 1), chosen to fit within Aztec's field arithmetic bounds\npub global MAX_U253: Field = 0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\npub global U253_PACKED_LEN: u32 = 1;\n\npub struct U253 {\n    value: Field,\n}\n\nimpl U253 {\n    pub fn new(value: Field) -> Self {\n        value.assert_max_bit_size::<253>();\n        Self { value }\n    }\n\n    pub fn new_unchecked(value: Field) -> Self {\n        Self { value }\n    }\n\n    pub fn from_integer(value: Field) -> Self {\n        value.assert_max_bit_size::<253>();\n        Self { value }\n    }\n\n    pub fn to_integer(self) -> Field {\n        self.value\n    }\n\n    pub fn zero() -> Self {\n        Self { value: 0 }\n    }\n\n    pub fn one() -> Self {\n        Self { value: 1 }\n    }\n\n    pub fn max() -> Self {\n        Self { value: MAX_U253 }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.value == 0\n    }\n\n    // Performs division with remainder using binary long division algorithm\n    // Returns (quotient, remainder) tuple\n    pub unconstrained fn div_rem_unconstrained(self, other: Self) -> (Self, Self) {\n        assert(!(other.value == 0), \"Division by zero\");\n\n        self.value.assert_max_bit_size::<253>();\n        other.value.assert_max_bit_size::<253>();\n\n        let bits: [u1; 253] = self.value.to_be_bits();\n        let divisor = other.value;\n\n        let mut quotient: Field = 0;\n        let mut remainder: Field = 0;\n\n        // Process each bit from MSB to LSB, similar to paper-and-pencil division\n        for i in 0..253 {\n            // Shift remainder left by 1 bit and add next bit\n            remainder = remainder * 2 + (bits[i] as Field);\n\n            // Single comparison to determine if we should subtract divisor\n            // Changed to just !remainder.lt(divisor) which means remainder >= divisor\n            if !remainder.lt(divisor) {\n                remainder = remainder - divisor;\n                quotient = quotient * 2 + 1;\n            } else {\n                quotient = quotient * 2;\n            }\n        }\n        (Self { value: quotient }, Self { value: remainder })\n    }\n\n    // Performs division with remainder using unconstrained binary long division algorithm, then\n    // constrains the result via multiplicative properties\n    // Returns (quotient, remainder) tuple\n    pub fn div_rem(self, other: Self) -> (Self, Self) {\n        assert(!(other.value == 0), \"Division by zero\");\n\n        if self.value == other.value {\n            (Self::one(), Self::zero())\n        } else if self.is_zero() {\n            (Self::zero(), Self::zero())\n        } else if other.value == 1 {\n            (self, Self::zero())\n        } else if self.value.lt(other.value) {\n            (Self::zero(), self)\n        } else {\n            //Safety: constraining this immediately after by checking the division property\n            let (quotient, remainder) = unsafe { self.div_rem_unconstrained(other) };\n\n            // Verify quotient * other + remainder == self\n            assert(\n                quotient * other + remainder == self,\n                \"Unconstrained division result is incorrect\",\n            );\n\n            (quotient, remainder)\n        }\n    }\n\n    // Adds two U253 values without overflow checks - use with caution\n    pub fn add_unchecked(self, other: Self) -> Self {\n        Self { value: self.value + other.value }\n    }\n\n    // Subtracts two U253 values without underflow checks - use with caution\n    pub fn sub_unchecked(self, other: Self) -> Self {\n        Self { value: self.value - other.value }\n    }\n}\n\nimpl ToField for U253 {\n    fn to_field(self) -> Field {\n        self.value\n    }\n}\n\nimpl FromField for U253 {\n    fn from_field(value: Field) -> Self {\n        value.assert_max_bit_size::<253>();\n        Self { value }\n    }\n}\n\nimpl Serialize<1> for U253 {\n    fn serialize(self) -> [Field; 1] {\n        [self.value]\n    }\n}\n\nimpl Deserialize<1> for U253 {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        fields[0].assert_max_bit_size::<253>();\n        assert(fields[0].lt(MAX_U253 + 1), \"Deserialized value is too large\");\n        Self { value: fields[0] }\n    }\n}\n\nimpl Add for U253 {\n    fn add(self, other: Self) -> Self {\n        let result = self.value + other.value;\n        result.assert_max_bit_size::<253>();\n\n        assert(!MAX_U253.lt(result), \"U253 addition overflow\");\n        assert(!result.lt(self.value), \"U253 addition overflow\");\n        assert(!result.lt(other.value), \"U253 addition overflow\");\n        Self { value: result }\n    }\n}\n\nimpl Sub for U253 {\n    fn sub(self, other: Self) -> Self {\n        assert(\n            other.value.lt(self.value) | other.value.eq(self.value),\n            \"U253 subtraction underflow\",\n        );\n        let result = self.value - other.value;\n        result.assert_max_bit_size::<253>();\n        Self { value: result }\n    }\n}\n\nimpl Mul for U253 {\n    fn mul(self, other: Self) -> Self {\n        let result = self.value * other.value;\n\n        result.assert_max_bit_size::<253>();\n        // Allow multiplication by 1 without additional checks, otherwise check for overflow\n        assert(\n            (self.value == 1)\n                | (other.value == 1)\n                | (result.lt(MAX_U253 + 1) & !result.lt(self.value) & !result.lt(other.value)),\n            \"U253 multiplication overflow\",\n        );\n        Self { value: result }\n    }\n}\n\nimpl Div for U253 {\n    fn div(self, other: Self) -> Self {\n        let (quotient, _) = self.div_rem(other);\n        quotient\n    }\n}\n\nimpl Rem for U253 {\n    fn rem(self, other: Self) -> Self {\n        let (_, remainder) = self.div_rem(other);\n        remainder\n    }\n}\n\nimpl Ord for U253 {\n    fn cmp(self, other: Self) -> Ordering {\n        if self.value.lt(other.value) {\n            Ordering::less()\n        } else if self.value.eq(other.value) {\n            Ordering::equal()\n        } else {\n            Ordering::greater()\n        }\n    }\n}\n\nimpl Eq for U253 {\n    fn eq(self, other: Self) -> bool {\n        self.value.eq(other.value)\n    }\n}\n\nimpl Packable<U253_PACKED_LEN> for U253 {\n    fn pack(self) -> [Field; U253_PACKED_LEN] {\n        [self.value]\n    }\n\n    fn unpack(fields: [Field; U253_PACKED_LEN]) -> Self {\n        U253::from_integer(fields[0])\n    }\n}\n"
    },
    "365": {
      "path": "/home/vscode/nargo/github.com/ClarifiedLabs/aztec-uint253/aztec-packages-v0.75.0/src/uint253_note.nr",
      "source": "// Copyright (c) 2025 Clarified Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nuse aztec::{\n    context::PrivateContext,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::partial_note,\n    note::{\n        note_header::NoteHeader,\n        note_interface::{NoteInterface, NullifiableNote},\n        utils::compute_note_hash_for_nullify,\n    },\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n        traits::{Empty, Hash, Packable, Serialize},\n    },\n};\n\nuse crate::uint253::U253;\n\n#[partial_note(quote {value})]\n#[derive(Serialize)]\npub struct U253Note {\n    // The amount of tokens in the note\n    value: Field,\n    owner: AztecAddress,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NullifiableNote for U253Note {\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl U253Note {\n    pub fn new(value: U253, owner: AztecAddress) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value: value.to_field(), owner, randomness, header: NoteHeader::empty() }\n    }\n\n    pub fn get_value(self) -> U253 {\n        U253::new_unchecked(self.value)\n    }\n\n    pub fn get_field_value(self) -> Field {\n        self.value\n    }\n}\n\nimpl Eq for U253Note {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n"
    },
    "366": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/token/src/main.nr",
      "source": "mod types;\nmod test;\n\nuse aztec::macros::aztec;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n#[aztec]\npub contract Token {\n    // Libs\n    use std::meta::derive;\n\n    use compressed_string::FieldCompressedString;\n\n    use aztec::{\n        context::{PrivateCallInterface, PrivateContext},\n        encrypted_logs::log_assembly_strategies::default_aes128::note::encode_and_encrypt_note,\n        macros::{\n            events::event,\n            functions::{initializer, internal, private, public, view},\n            storage::storage,\n        },\n        oracle::random::random,\n        prelude::{\n            AztecAddress, FunctionSelector, Map, PublicContext, PublicImmutable, PublicMutable,\n        },\n        protocol_types::{point::Point, traits::Serialize},\n        unencrypted_logs::unencrypted_event_emission::encode_event,\n    };\n\n    use authwit::auth::{\n        assert_current_call_valid_authwit, assert_current_call_valid_authwit_public,\n        compute_authwit_nullifier,\n    };\n\n    use beacon::Beacon;\n    use uint253::{uint253::U253, uint253_note::U253Note};\n\n    use crate::types::balance_set::BalanceSet;\n\n    // In the first transfer iteration we are computing a lot of additional information (validating inputs, retrieving\n    // keys, etc.), so the gate count is already relatively high. We therefore only read a few notes to keep the happy\n    // case with few constraints.\n    global INITIAL_TRANSFER_CALL_MAX_NOTES: u32 = 2;\n    // All the recursive call does is nullify notes, meaning the gate count is low, but it is all constant overhead. We\n    // therefore read more notes than in the base case to increase the efficiency of the overhead, since this results in\n    // an overall small circuit regardless.\n    global RECURSIVE_TRANSFER_CALL_MAX_NOTES: u32 = 8;\n\n    #[derive(Serialize)]\n    #[event]\n    struct Mint {\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Burn {\n        from: AztecAddress,\n        amount: Field,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Shield {\n        from: AztecAddress,\n        amount: Field,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Unshield {\n        from: AztecAddress,\n        amount: Field,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    #[storage]\n    struct Storage<Context> {\n        minter: PublicImmutable<AztecAddress, Context>,\n        shield_gateway_beacon: PublicImmutable<AztecAddress, Context>,\n        private_balances: Map<AztecAddress, BalanceSet<Context>, Context>,\n        public_balances: Map<AztecAddress, PublicMutable<U253, Context>, Context>,\n\n        total_supply: PublicMutable<U253, Context>,\n        shielded_supply: PublicMutable<U253, Context>,\n\n        name: PublicImmutable<FieldCompressedString, Context>,\n        symbol: PublicImmutable<FieldCompressedString, Context>,\n        decimals: PublicImmutable<u8, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn init(\n        minter: AztecAddress,\n        name: str<31>,\n        symbol: str<31>,\n        decimals: u8,\n    ) {\n        assert(!minter.is_zero(), \"invalid minter\");\n        assert(name.as_bytes().len() > 0, \"Name cannot be empty\");\n        assert(symbol.as_bytes().len() > 0, \"Symbol cannot be empty\");\n\n        storage.minter.initialize(minter);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        storage.decimals.initialize(decimals);\n    }\n\n    #[public]\n    fn set_shield_gateway_beacon(beacon: AztecAddress) {\n        assert(storage.minter.read().eq(context.msg_sender()), \"caller is not minter\");\n        storage.shield_gateway_beacon.initialize(beacon);\n    }\n\n    #[public]\n    #[view]\n    fn public_get_name() -> FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_name() -> FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_decimals() -> pub u8 {\n        storage.decimals.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_decimals() -> pub u8 {\n        storage.decimals.read()\n    }\n\n    #[public]\n    #[view]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n\n    #[public]\n    #[view]\n    fn shielded_supply() -> Field {\n        storage.shielded_supply.read().to_integer()\n    }\n\n    #[public]\n    #[view]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n\n    #[public]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        assert(storage.minter.read().eq(context.msg_sender()), \"caller is not minter\");\n\n        let amount = U253::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n\n        // Emit the mint event\n        Mint { to, amount: amount.to_field() }.emit(encode_event(&mut context));\n    }\n\n    #[public]\n    fn transfer_public_to_public(\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n        nonce: Field,\n    ) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let amount = U253::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n\n    #[public]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U253::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n\n        Burn { from, amount: amount.to_field() }.emit(encode_event(&mut context));\n    }\n\n    #[private]\n    fn transfer_private_to_public(\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n        nonce: Field,\n    ) {\n        assert_from_shield_gateway(&mut context, storage);\n        assert_current_call_valid_authwit(&mut context, from);\n\n        let amount = U253::from_integer(amount);\n\n        storage.private_balances.at(from).sub(from, amount).emit(\n            encode_and_encrypt_note(&mut context, from, from),\n        );\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n\n    #[contract_library_method]\n    fn assert_from_shield_gateway(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n    ) {\n        let from = context.msg_sender();\n        assert(\n            from.eq(get_shield_gateway(context, storage)),\n            \"Private transfer must be initiated from the shield gateway\",\n        );\n    }\n\n    #[contract_library_method]\n    fn subtract_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        account: AztecAddress,\n        amount: U253,\n        max_notes: u32,\n    ) -> U253 {\n        let subtracted = storage.private_balances.at(account).try_sub(amount, max_notes);\n        // Failing to subtract any amount means that the owner was unable to produce more notes that could be nullified.\n        // We could in some cases fail early inside try_sub if we detected that fewer notes than the maximum were\n        // returned and we were still unable to reach the target amount, but that'd make the code more complicated, and\n        // optimizing for the failure scenario is not as important.\n        assert(subtracted > U253::from_integer(0), \"Balance too low\");\n        if subtracted >= amount {\n            // We have achieved our goal of nullifying notes that add up to more than amount, so we return the change\n            subtracted - amount\n        } else {\n            // try_sub failed to nullify enough notes to reach the target amount, so we compute the amount remaining\n            // and try again.\n            let remaining = amount - subtracted;\n            compute_recurse_subtract_balance_call(*context, account, remaining).call(context)\n        }\n    }\n\n    // TODO(#7729): apply no_predicates to the contract interface method directly instead of having to use a wrapper\n    // like we do here.\n    #[no_predicates]\n    #[contract_library_method]\n    fn compute_recurse_subtract_balance_call(\n        context: PrivateContext,\n        account: AztecAddress,\n        remaining: U253,\n    ) -> PrivateCallInterface<25, U253> {\n        Token::at(context.this_address())._recurse_subtract_balance(account, remaining.to_field())\n    }\n\n    // TODO(#7728): even though the amount should be a U253, we can't have that type in a contract interface due to\n    // serialization issues.\n    #[internal]\n    #[private]\n    fn _recurse_subtract_balance(account: AztecAddress, amount: Field) -> U253 {\n        subtract_balance(\n            &mut context,\n            storage,\n            account,\n            U253::from_integer(amount),\n            RECURSIVE_TRANSFER_CALL_MAX_NOTES,\n        )\n    }\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n\n    #[private]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n\n    #[private]\n    fn transfer_private_to_private(\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n        nonce: Field,\n    ) {\n        assert_from_shield_gateway(&mut context, storage);\n        assert_current_call_valid_authwit(&mut context, from);\n\n        let amount = U253::from_integer(amount);\n\n        storage.private_balances.at(from).sub(from, amount).emit(\n            encode_and_encrypt_note(&mut context, from, from),\n        );\n\n        storage.private_balances.at(to).add(to, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            to,\n            from,\n        ));\n    }\n\n    #[private]\n    fn burn_private(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U253::from_integer(amount);\n\n        storage.private_balances.at(from).sub(from, amount).emit(\n            encode_and_encrypt_note(&mut context, from, from),\n        );\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n\n    // Moves token `amount` from the user's public balance to their private balance.\n    #[private]\n    fn shield(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U253::from_integer(amount);\n\n        Token::at(context.this_address())._transfer_public_to_private(from, from, amount).call(\n            &mut context,\n        );\n\n        Token::at(context.this_address())._log_shield(from, amount).enqueue(&mut context);\n    }\n\n    #[private]\n    fn unshield(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U253::from_integer(amount);\n\n        storage.private_balances.at(from).sub(from, amount).emit(\n            encode_and_encrypt_note(&mut context, from, from),\n        );\n        Token::at(context.this_address())._increase_public_balance(from, amount).enqueue(\n            &mut context,\n        );\n        Token::at(context.this_address())._log_unshield(from, amount).enqueue(&mut context);\n    }\n\n    // Transfers token `amount` from public balance of message sender to a private balance of `to`.\n    // Requires a shield gateway check.\n    #[private]\n    fn transfer_public_to_private(\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n        nonce: Field,\n    ) {\n        assert_from_shield_gateway(&mut context, storage);\n        assert_current_call_valid_authwit(&mut context, from);\n\n        let amount = U253::from_integer(amount);\n\n        Token::at(context.this_address())._transfer_public_to_private(from, to, amount).call(\n            &mut context,\n        );\n    }\n\n    #[private]\n    #[internal]\n    fn _transfer_public_to_private(from: AztecAddress, to: AztecAddress, amount: U253) {\n        let token = Token::at(context.this_address());\n\n        // We prepare the private balance increase (the partial note).\n        let hiding_point_slot = _prepare_private_balance_increase(from, to, &mut context, storage);\n\n        // At last we finalize the transfer. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that he can transfer only his own tokens.\n        token._finalize_transfer_public_to_private_unsafe(from, amount, hiding_point_slot).enqueue(\n            &mut context,\n        );\n    }\n\n    /// Prepares an increase of private balance of `to` (partial note). The increase needs to be finalized by calling\n    /// some of the finalization functions (`finalize_transfer_public_to_private`, `finalize_mint_shielded`).\n    /// Returns a hiding point slot.\n    #[private]\n    fn prepare_private_balance_increase(to: AztecAddress, from: AztecAddress) -> Field {\n        // TODO(#9887): ideally we'd not have `from` here, but we do need a `from` address to produce a tagging secret\n        // with `to`.\n        _prepare_private_balance_increase(from, to, &mut context, storage)\n    }\n\n    /// This function exists separately from `prepare_private_balance_increase` solely as an optimization as it allows\n    /// us to have it inlined in the `transfer_public_to_private` function which results in one less kernel iteration.\n    ///\n    /// TODO(#9180): Consider adding macro support for functions callable both as an entrypoint and as an internal\n    /// function.\n    #[contract_library_method]\n    fn _prepare_private_balance_increase(\n        from: AztecAddress, // recipient of the outgoing: TODO(#9887): this is not great?\n        to: AztecAddress,\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n    ) -> Field {\n        let to_note_slot = storage.private_balances.at(to).set.storage_slot;\n\n        // We create a setup payload with unpopulated/zero `amount` for 'to'\n        // TODO(#7775): Manually fetching the randomness here is not great. If we decide to include randomness in all\n        // notes we could just inject it in macros.\n        let note_randomness = unsafe { random() };\n        let note_setup_payload = U253Note::setup_payload().new(to, note_randomness, to_note_slot);\n\n        // We get the keys and encrypt the log of the note\n        let setup_log = note_setup_payload.encrypt_log(context, to, from);\n\n        // Using the x-coordinate as a hiding point slot is safe against someone else interfering with it because\n        // we have a guarantee that the public functions of the transaction are executed right after the private ones\n        // and for this reason the protocol guarantees that nobody can front-run us in consuming the hiding point.\n        // This guarantee would break if `finalize_transfer_public_to_private` was not called in the same transaction. This\n        // however is not the flow we are currently concerned with. To support the multi-transaction flow we could\n        // introduce a `from` function argument, hash the x-coordinate with it and then repeat the hashing in\n        // `finalize_transfer_public_to_private`.\n        //\n        // We can also be sure that the `hiding_point_slot` will not overwrite any other value in the storage because\n        // in our state variables we derive slots using a different hash function from multi scalar multiplication\n        // (MSM).\n        let hiding_point_slot = note_setup_payload.hiding_point.x;\n\n        // We don't need to perform a check that the value overwritten by `_store_point_in_transient_storage_unsafe`\n        // is zero because the slot is the x-coordinate of the hiding point and hence we could only overwrite\n        // the value in the slot with the same value. This makes usage of the `unsafe` method safe.\n        Token::at(context.this_address())\n            ._store_payload_in_transient_storage_unsafe(\n                hiding_point_slot,\n                note_setup_payload.hiding_point,\n                setup_log,\n            )\n            .enqueue(context);\n\n        hiding_point_slot\n    }\n\n    /// Finalizes a transfer of token `amount` from public balance of `from` to a private balance of `to`.\n    /// The transfer must be prepared by calling `prepare_private_balance_increase` first and the resulting\n    /// `hiding_point_slot` must be passed as an argument to this function.\n    #[public]\n    fn finalize_transfer_public_to_private(amount: Field, hiding_point_slot: Field) {\n        let from = context.msg_sender();\n        let amount = U253::from_integer(amount);\n        _finalize_transfer_public_to_private(\n            from,\n            amount,\n            hiding_point_slot,\n            &mut context,\n            storage,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _finalize_transfer_public_to_private_unsafe(\n        from: AztecAddress,\n        amount: U253,\n        hiding_point_slot: Field,\n    ) {\n        _finalize_transfer_public_to_private(\n            from,\n            amount,\n            hiding_point_slot,\n            &mut context,\n            storage,\n        );\n    }\n\n    #[contract_library_method]\n    fn _finalize_transfer_public_to_private(\n        from: AztecAddress,\n        amount: U253,\n        hiding_point_slot: Field,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        // First we subtract the `amount` from the public balance of `from`\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        // Increase the shielded supply by the `amount`\n        storage.shielded_supply.write(storage.shielded_supply.read().add(amount));\n\n        // Then we finalize the partial note with the `amount`\n        let finalization_payload =\n            U253Note::finalization_payload().new(context, hiding_point_slot, amount.to_field());\n\n        // At last we emit the note hash and the final log\n        finalization_payload.emit();\n    }\n\n    /// Mints token `amount` to a private balance of `to`. Message sender has to have minter permissions (checked\n    /// in the enqueud call).\n    #[private]\n    fn mint_shielded(to: AztecAddress, amount: Field) {\n        let token = Token::at(context.this_address());\n\n        // We prepare the partial note to which we'll \"send\" the minted amount.\n        let hiding_point_slot =\n            _prepare_private_balance_increase(context.msg_sender(), to, &mut context, storage);\n\n        // At last we finalize the mint. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that only a message sender with minter permissions\n        // can successfully execute the function.\n        token\n            ._finalize_mint_shielded_unsafe(context.msg_sender(), to, amount, hiding_point_slot)\n            .enqueue(&mut context);\n    }\n\n    /// Finalizes a mint of token `amount` to a private balance of `to`. The mint must be prepared by calling\n    /// `prepare_private_balance_increase` first and the resulting\n    /// `hiding_point_slot` must be passed as an argument to this function.\n    ///\n    /// Note: This function is only an optimization as it could be replaced by a combination of `mint_public`\n    /// and `finalize_transfer_public_to_private`. It is however used very commonly so it makes sense to optimize it\n    /// (e.g. used during token bridging, in AMM liquidity token etc.).\n    #[public]\n    fn finalize_mint_shielded(to: AztecAddress, amount: Field, hiding_point_slot: Field) {\n        assert(storage.minter.read().eq(context.msg_sender()), \"caller is not minter\");\n        _finalize_mint_shielded(to, amount, hiding_point_slot, &mut context, storage);\n    }\n\n    #[public]\n    #[internal]\n    fn _finalize_mint_shielded_unsafe(\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n        hiding_point_slot: Field,\n    ) {\n        // We check the minter permissions as it was not done in `mint_shielded` function.\n        assert(storage.minter.read().eq(from), \"caller is not minter\");\n        _finalize_mint_shielded(to, amount, hiding_point_slot, &mut context, storage);\n    }\n\n    #[contract_library_method]\n    fn _finalize_mint_shielded(\n        to: AztecAddress,\n        amount: Field,\n        hiding_point_slot: Field,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        let amount = U253::from_integer(amount);\n\n        // Increase the total supply by the `amount`\n        storage.total_supply.write(storage.total_supply.read().add(amount));\n        // Increase the shielded supply by the `amount`\n        storage.shielded_supply.write(storage.shielded_supply.read().add(amount));\n\n        // Finalize the partial note with the `amount`\n        let finalization_payload =\n            U253Note::finalization_payload().new(context, hiding_point_slot, amount.to_field());\n\n        // emit the note hash and the final log\n        finalization_payload.emit();\n\n        // Emit the mint event\n        Mint { to, amount: amount.to_field() }.emit(encode_event(context));\n    }\n\n    #[contract_library_method]\n    fn get_shield_gateway(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n    ) -> AztecAddress {\n        Beacon::at(storage.shield_gateway_beacon.read())\n            .get_target_private(context.this_address())\n            .view(context)\n    }\n\n    unconstrained fn get_shield_gateway_beacon_unconstrained() -> AztecAddress {\n        storage.shield_gateway_beacon.read()\n    }\n\n    #[public]\n    #[view]\n    fn get_shield_gateway_beacon_public() -> AztecAddress {\n        storage.shield_gateway_beacon.read()\n    }\n\n    #[public]\n    #[view]\n    fn get_shield_gateway_public() -> AztecAddress {\n        Beacon::at(storage.shield_gateway_beacon.read())\n            .get_target_public(context.this_address())\n            .view(&mut context)\n    }\n\n    #[private]\n    #[view]\n    fn get_shield_gateway_private() -> AztecAddress {\n        get_shield_gateway(&mut context, storage)\n    }\n\n    #[private]\n    #[view]\n    fn get_shield_gateway_beacon_private() -> AztecAddress {\n        storage.shield_gateway_beacon.read()\n    }\n\n    #[private]\n    fn setup_refund(\n        fee_payer: AztecAddress, // Address of the entity which will receive the fee note.\n        user: AztecAddress, // A user for which we are setting up the fee refund.\n        funded_amount: Field, // The amount the user funded the fee payer with (represents fee limit).\n        nonce: Field, // A nonce to make authwitness unique.\n    ) {\n        // 1. This function is called by fee paying contract (fee_payer) when setting up a refund so we need to support\n        // the authwit flow here and check that the user really permitted fee_payer to set up a refund on their behalf.\n        assert_current_call_valid_authwit(&mut context, user);\n\n        // 2. Deduct the funded amount from the user's balance - this is a maximum fee a user is willing to pay\n        // (called fee limit in aztec spec). The difference between fee limit and the actual tx fee will be refunded\n        // to the user in the `complete_refund(...)` function.\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            user,\n            U253::from_integer(funded_amount),\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.private_balances.at(user).add(user, change).emit(\n            encode_and_encrypt_note(&mut context, user, user),\n        );\n\n        // 4. We prepare the partial notes\n        // TODO(#9887): In each `_prepare_private_balance_increase` call we fetch the user's ovpk_m 2 more times. This is\n        // very inefficient.\n        let fee_payer_point_slot =\n            _prepare_private_balance_increase(user, fee_payer, &mut context, storage);\n        let user_point_slot = _prepare_private_balance_increase(user, user, &mut context, storage);\n\n        // 5. Set the public teardown function to `complete_refund(...)`. Public teardown is the only time when a public\n        // function has access to the final transaction fee, which is needed to compute the actual refund amount.\n        context.set_public_teardown_function(\n            context.this_address(),\n            comptime { FunctionSelector::from_signature(\"complete_refund(Field,Field,Field)\") },\n            [fee_payer_point_slot, user_point_slot, funded_amount],\n        );\n    }\n\n    // TODO(#9375): Having to define the note log length here is very unfortunate as it's basically impossible for\n    // users to derive manually. This will however go away once we have a real transient storage since we will not need\n    // the public call and instead we would do something like `context.transient_storage_write(slot, payload)` and that\n    // will allow us to use generics and hence user will not need to define it explicitly. We cannot use generics here\n    // as it is an entrypoint function.\n    #[public]\n    #[internal]\n    fn _store_payload_in_transient_storage_unsafe(\n        slot: Field,\n        point: Point,\n        setup_log: [Field; 9],\n    ) {\n        context.storage_write(slot, point);\n        context.storage_write(slot + aztec::protocol_types::point::POINT_LENGTH as Field, setup_log);\n    }\n\n    // TODO(#7728): even though the funded_amount should be a U253, we can't have that type in a contract interface due\n    // to serialization issues.\n\n    #[public]\n    #[internal]\n    fn complete_refund(fee_payer_slot: Field, user_slot: Field, funded_amount: Field) {\n        // TODO(#7728): Remove the next line\n        let funded_amount = U253::from_integer(funded_amount);\n        let tx_fee = U253::from_integer(context.transaction_fee());\n\n        // 1. We check that user funded the fee payer contract with at least the transaction fee.\n        // TODO(#7796): we should try to prevent reverts here\n        assert(funded_amount >= tx_fee, \"funded amount not enough to cover tx fee\");\n\n        // 2. We compute the refund amount as the difference between funded amount and tx fee.\n        let refund_amount = funded_amount - tx_fee;\n\n        // 3. We construct the note finalization payloads with the correct amounts and hiding points to get the note\n        // hashes and unencrypted logs.\n        let fee_payer_finalization_payload =\n            U253Note::finalization_payload().new(&mut context, fee_payer_slot, tx_fee.to_field());\n        let user_finalization_payload =\n            U253Note::finalization_payload().new(&mut context, user_slot, refund_amount.to_field());\n\n        // 4. At last we emit the note hashes and the final note logs.\n        fee_payer_finalization_payload.emit();\n        user_finalization_payload.emit();\n        // --> Once the tx is settled user and fee recipient can add the notes to their pixies.\n    }\n\n    /// Internal ///\n\n    #[public]\n    #[internal]\n    fn _increase_public_balance(to: AztecAddress, amount: U253) {\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(new_balance);\n\n        // Decrease the shielded supply by the `amount`\n        let new_shielded_supply = storage.shielded_supply.read().sub(amount);\n        storage.shielded_supply.write(new_shielded_supply);\n    }\n\n    #[public]\n    #[internal]\n    fn _reduce_total_supply(amount: U253) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n\n        // Decrease the shielded supply by the `amount`\n        let new_shielded_supply = storage.shielded_supply.read().sub(amount);\n        storage.shielded_supply.write(new_shielded_supply);\n    }\n\n    #[public]\n    #[internal]\n    fn _log_shield(from: AztecAddress, amount: U253) {\n        Shield { from, amount: amount.to_field() }.emit(encode_event(&mut context));\n    }\n\n    #[public]\n    #[internal]\n    fn _log_unshield(from: AztecAddress, amount: U253) {\n        Unshield { from, amount: amount.to_field() }.emit(encode_event(&mut context));\n    }\n\n    /// Unconstrained ///\n\n    pub(crate) unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.private_balances.at(owner).balance_of().to_field()\n    }\n}\n"
    },
    "48": {
      "path": "std/ops/arith.nr",
      "source": "// docs:start:add-trait\npub trait Add {\n    fn add(self, other: Self) -> Self;\n}\n// docs:end:add-trait\n\nimpl Add for Field {\n    fn add(self, other: Field) -> Field {\n        self + other\n    }\n}\n\nimpl Add for u64 {\n    fn add(self, other: u64) -> u64 {\n        self + other\n    }\n}\nimpl Add for u32 {\n    fn add(self, other: u32) -> u32 {\n        self + other\n    }\n}\nimpl Add for u16 {\n    fn add(self, other: u16) -> u16 {\n        self + other\n    }\n}\nimpl Add for u8 {\n    fn add(self, other: u8) -> u8 {\n        self + other\n    }\n}\nimpl Add for u1 {\n    fn add(self, other: u1) -> u1 {\n        self + other\n    }\n}\n\nimpl Add for i8 {\n    fn add(self, other: i8) -> i8 {\n        self + other\n    }\n}\nimpl Add for i16 {\n    fn add(self, other: i16) -> i16 {\n        self + other\n    }\n}\nimpl Add for i32 {\n    fn add(self, other: i32) -> i32 {\n        self + other\n    }\n}\nimpl Add for i64 {\n    fn add(self, other: i64) -> i64 {\n        self + other\n    }\n}\n\n// docs:start:sub-trait\npub trait Sub {\n    fn sub(self, other: Self) -> Self;\n}\n// docs:end:sub-trait\n\nimpl Sub for Field {\n    fn sub(self, other: Field) -> Field {\n        self - other\n    }\n}\n\nimpl Sub for u64 {\n    fn sub(self, other: u64) -> u64 {\n        self - other\n    }\n}\nimpl Sub for u32 {\n    fn sub(self, other: u32) -> u32 {\n        self - other\n    }\n}\nimpl Sub for u16 {\n    fn sub(self, other: u16) -> u16 {\n        self - other\n    }\n}\nimpl Sub for u8 {\n    fn sub(self, other: u8) -> u8 {\n        self - other\n    }\n}\nimpl Sub for u1 {\n    fn sub(self, other: u1) -> u1 {\n        self - other\n    }\n}\n\nimpl Sub for i8 {\n    fn sub(self, other: i8) -> i8 {\n        self - other\n    }\n}\nimpl Sub for i16 {\n    fn sub(self, other: i16) -> i16 {\n        self - other\n    }\n}\nimpl Sub for i32 {\n    fn sub(self, other: i32) -> i32 {\n        self - other\n    }\n}\nimpl Sub for i64 {\n    fn sub(self, other: i64) -> i64 {\n        self - other\n    }\n}\n\n// docs:start:mul-trait\npub trait Mul {\n    fn mul(self, other: Self) -> Self;\n}\n// docs:end:mul-trait\n\nimpl Mul for Field {\n    fn mul(self, other: Field) -> Field {\n        self * other\n    }\n}\n\nimpl Mul for u64 {\n    fn mul(self, other: u64) -> u64 {\n        self * other\n    }\n}\nimpl Mul for u32 {\n    fn mul(self, other: u32) -> u32 {\n        self * other\n    }\n}\nimpl Mul for u16 {\n    fn mul(self, other: u16) -> u16 {\n        self * other\n    }\n}\nimpl Mul for u8 {\n    fn mul(self, other: u8) -> u8 {\n        self * other\n    }\n}\nimpl Mul for u1 {\n    fn mul(self, other: u1) -> u1 {\n        self * other\n    }\n}\n\nimpl Mul for i8 {\n    fn mul(self, other: i8) -> i8 {\n        self * other\n    }\n}\nimpl Mul for i16 {\n    fn mul(self, other: i16) -> i16 {\n        self * other\n    }\n}\nimpl Mul for i32 {\n    fn mul(self, other: i32) -> i32 {\n        self * other\n    }\n}\nimpl Mul for i64 {\n    fn mul(self, other: i64) -> i64 {\n        self * other\n    }\n}\n\n// docs:start:div-trait\npub trait Div {\n    fn div(self, other: Self) -> Self;\n}\n// docs:end:div-trait\n\nimpl Div for Field {\n    fn div(self, other: Field) -> Field {\n        self / other\n    }\n}\n\nimpl Div for u64 {\n    fn div(self, other: u64) -> u64 {\n        self / other\n    }\n}\nimpl Div for u32 {\n    fn div(self, other: u32) -> u32 {\n        self / other\n    }\n}\nimpl Div for u16 {\n    fn div(self, other: u16) -> u16 {\n        self / other\n    }\n}\nimpl Div for u8 {\n    fn div(self, other: u8) -> u8 {\n        self / other\n    }\n}\nimpl Div for u1 {\n    fn div(self, other: u1) -> u1 {\n        self / other\n    }\n}\n\nimpl Div for i8 {\n    fn div(self, other: i8) -> i8 {\n        self / other\n    }\n}\nimpl Div for i16 {\n    fn div(self, other: i16) -> i16 {\n        self / other\n    }\n}\nimpl Div for i32 {\n    fn div(self, other: i32) -> i32 {\n        self / other\n    }\n}\nimpl Div for i64 {\n    fn div(self, other: i64) -> i64 {\n        self / other\n    }\n}\n\n// docs:start:rem-trait\npub trait Rem {\n    fn rem(self, other: Self) -> Self;\n}\n// docs:end:rem-trait\n\nimpl Rem for u64 {\n    fn rem(self, other: u64) -> u64 {\n        self % other\n    }\n}\nimpl Rem for u32 {\n    fn rem(self, other: u32) -> u32 {\n        self % other\n    }\n}\nimpl Rem for u16 {\n    fn rem(self, other: u16) -> u16 {\n        self % other\n    }\n}\nimpl Rem for u8 {\n    fn rem(self, other: u8) -> u8 {\n        self % other\n    }\n}\nimpl Rem for u1 {\n    fn rem(self, other: u1) -> u1 {\n        self % other\n    }\n}\n\nimpl Rem for i8 {\n    fn rem(self, other: i8) -> i8 {\n        self % other\n    }\n}\nimpl Rem for i16 {\n    fn rem(self, other: i16) -> i16 {\n        self % other\n    }\n}\nimpl Rem for i32 {\n    fn rem(self, other: i32) -> i32 {\n        self % other\n    }\n}\nimpl Rem for i64 {\n    fn rem(self, other: i64) -> i64 {\n        self % other\n    }\n}\n\n// docs:start:neg-trait\npub trait Neg {\n    fn neg(self) -> Self;\n}\n// docs:end:neg-trait\n\n// docs:start:neg-trait-impls\nimpl Neg for Field {\n    fn neg(self) -> Field {\n        -self\n    }\n}\n\nimpl Neg for i8 {\n    fn neg(self) -> i8 {\n        -self\n    }\n}\nimpl Neg for i16 {\n    fn neg(self) -> i16 {\n        -self\n    }\n}\nimpl Neg for i32 {\n    fn neg(self) -> i32 {\n        -self\n    }\n}\nimpl Neg for i64 {\n    fn neg(self) -> i64 {\n        -self\n    }\n}\n// docs:end:neg-trait-impls\n\n"
    },
    "51": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "52": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "57": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"
    },
    "6": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "60": {
      "path": "std/uint128.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::ops::{Add, BitAnd, BitOr, BitXor, Div, Mul, Not, Rem, Shl, Shr, Sub};\nuse crate::static_assert;\nuse super::{convert::AsPrimitive, default::Default};\n\nglobal pow64: Field = 18446744073709551616; //2^64;\nglobal pow63: Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    pub(crate) lo: Field,\n    pub(crate) hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i + 8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i + 8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        static_assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N - i]) * base;\n                base = base * 16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn unconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (\n            if ascii < 58 {\n                ascii - 48\n            } else {\n                /// Safety: optionally adds 32 and then check (below) the result is in 'a..f' range\n                let ascii =\n                    ascii + 32 * (unsafe { U128::unconstrained_check_is_upper_ascii(ascii) as u8 });\n                assert(ascii >= 97); // enforce >= 'a'\n                assert(ascii <= 102); // enforce <= 'f'\n                ascii - 87\n            }\n        ) as Field\n    }\n\n    // TODO: Replace with a faster version.\n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q, r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128\n    where\n        T: AsPrimitive<Field>,\n    {\n        let f = i.as_();\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size::<128>();\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T\n    where\n        Field: AsPrimitive<T>,\n    {\n        AsPrimitive::as_(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        /// Safety: euclidian division is asserted to be correct: assert(a == b * q + r); and assert(r < b);\n        /// Furthermore, U128 addition and multiplication ensures that b * q + r does not overflow\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        /// Safety: cf div() above\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nimpl Default for U128 {\n    fn default() -> Self {\n        U128::zero()\n    }\n}\n\nmod tests {\n    use crate::default::Default;\n    use crate::ops::Not;\n    use crate::uint128::{pow63, pow64, U128};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a = a.to_le_bytes();\n        let be_bytes_a = a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b = U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c = U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d = U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e = U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f = U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded = U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b: Field = a.to_integer();\n        let c: [u8; 17] = b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a = U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b = U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c = U128::one();\n        let d = U128::from_u64s_le(0x0, 0x1);\n        /// Safety: testing context\n        unsafe {\n            let (q, r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start: Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start: Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start: Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start: Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(),\n            U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(\n                U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff),\n            ),\n        );\n    }\n\n    #[test]\n    fn test_default() {\n        assert_eq(U128::default(), U128::zero());\n    }\n}\n"
    },
    "62": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/shield_gateway/src/capsule.nr",
      "source": "#[oracle(popCapsule)]\nunconstrained fn pop_capsule_oracle<let N: u32>() -> [Field; N] {}\n\n// A capsule is a \"blob\" of data that is passed to the contract through an oracle.\npub unconstrained fn pop_capsule<let N: u32>() -> [Field; N] {\n    pop_capsule_oracle()\n}\n"
    },
    "63": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/shield_gateway/src/main.nr",
      "source": "mod capsule;\nmod test;\n\nuse aztec::macros::aztec;\n\n#[aztec]\npub contract ShieldGateway {\n    use std::meta::derive;\n    use std::ops::arith::Add;\n\n    use aztec::{\n        context::{PrivateContext, PublicContext},\n        event::event_interface::EventInterface,\n        macros::{\n            events::event,\n            functions::{initializer, internal, private, public, view},\n            storage::storage,\n        },\n        protocol_types::{\n            address::AztecAddress,\n            hash::poseidon2_hash,\n            traits::{\n                FromField,\n                Hash,\n                ToField,\n                Serialize,\n            },\n        },\n        state_vars::{PublicImmutable, SharedMutable},\n        unencrypted_logs::unencrypted_event_emission::encode_event,\n    };\n\n    use authwit::auth::assert_current_call_valid_authwit;\n\n    use shield_gateway_storage::ShieldGatewayStorage;\n    use token::Token;\n    use uint253::uint253::U253;\n\n    use crate::capsule::pop_capsule;\n\n    pub global CHANGE_DELAY_BLOCKS: u32 = 5;\n\n    #[storage]\n    struct Storage<Context> {\n        admin: PublicImmutable<AztecAddress, Context>,\n        default_channel_threshold: SharedMutable<U253, CHANGE_DELAY_BLOCKS, Context>,\n        // External contract to hold the channel balances\n        shield_gateway_storage: PublicImmutable<AztecAddress, Context>,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct ChannelCreation {\n        from: AztecAddress,\n        to: AztecAddress,\n        token: AztecAddress,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct ChannelThresholdExceeded {\n        from: AztecAddress,\n        to: AztecAddress,\n        token: AztecAddress,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct DefaultChannelThresholdChanged {\n        new_threshold: Field,\n        effective_block: Field,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct ChannelThresholdChanged {\n        new: Field,\n        token: AztecAddress,\n        effective_block: Field,\n    }\n\n    #[public]\n    #[initializer]\n    fn init(admin: AztecAddress, shield_gateway_storage: AztecAddress, default_channel_threshold: Field) {\n        storage.admin.initialize(admin);\n        storage.shield_gateway_storage.initialize(shield_gateway_storage);\n        _set_default_channel_threshold(&mut context, storage, default_channel_threshold);\n    }\n\n    pub unconstrained fn get_default_channel_threshold() -> Field {\n        storage.default_channel_threshold.get_current_value().to_field()\n    }\n\n    #[public]\n    #[view]\n    fn get_channel_threshold(token: AztecAddress) -> U253 {\n        let mut threshold = ShieldGatewayStorage::at(storage.shield_gateway_storage.read()).get_channel_threshold(token).view(&mut context);\n        if threshold.is_zero() {\n            threshold = storage.default_channel_threshold.get_current_value();\n        }\n        threshold\n    }\n\n    #[contract_library_method]\n    fn _assert_only_admin(context: &mut PublicContext, storage: Storage<&mut PublicContext>) {\n        assert(\n            context.msg_sender().eq(storage.admin.read()),\n            \"Unauthorized\",\n        );\n    }\n\n    #[public]\n    fn set_default_channel_threshold(new_threshold: Field) {\n        _assert_only_admin(&mut context, storage);\n        _set_default_channel_threshold(&mut context, storage, new_threshold);\n    }\n\n    #[public]\n    fn set_channel_threshold(token: AztecAddress, new_threshold: Field) {\n        _assert_only_admin(&mut context, storage);\n\n        let new_threshold = U253::from_field(new_threshold);\n\n        let _ = ShieldGatewayStorage::at(storage.shield_gateway_storage.read()).set_channel_threshold(token, new_threshold).call(&mut context);\n\n        ChannelThresholdChanged {\n            new: new_threshold.to_field(),\n            token,\n            // Change will be effective after `CHANGE_DELAY_BLOCKS` in public context and `CHANGE_DELAY_BLOCKS + 1` in private context\n            effective_block: context.block_number().add(ShieldGatewayStorage::CHANGE_DELAY_BLOCKS.to_field() + 1),\n        }\n            .emit(encode_event(&mut context));\n    }\n\n    #[private]\n    fn channel_exists(from: AztecAddress, to: AztecAddress, token: AztecAddress) -> bool {\n        _channel_exists(&mut context, storage, from, to, token)\n    }\n\n    #[contract_library_method]\n    fn _channel_exists(context: &mut PrivateContext, storage: Storage<&mut PrivateContext>, from: AztecAddress, to: AztecAddress, token: AztecAddress) -> bool {\n        let key = _channel_key(from, to, token);\n        ShieldGatewayStorage::at(storage.shield_gateway_storage.read()).is_channel_initialized(key).view(context)\n    }\n\n    #[private]\n    fn initialize_channel(\n        from: AztecAddress,\n        to: AztecAddress,\n        token: AztecAddress,\n        nonce: Field,\n    ) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let key = _channel_key(from, to, token);\n        let _ = ShieldGatewayStorage::at(storage.shield_gateway_storage.read())\n            .initialize_channel_balance(key, U253::zero(), from)\n            .call(&mut context);\n\n        // Publicly log new channel creation\n        ShieldGateway::at(context.this_address())\n            ._log_channel_creation(from, to, token)\n            .enqueue(&mut context);\n    }\n\n    #[private]\n    #[view]\n    fn get_channel_balance(\n        from: AztecAddress,\n        to: AztecAddress,\n        token: AztecAddress,\n    ) -> Field {\n        _get_channel_balance(&mut context, storage, from, to, token).to_field()\n    }\n\n    #[private]\n    fn channel_transfer(\n        token: AztecAddress,\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n        nonce: Field,\n    ) {\n        let amount = U253::from_field(amount);\n        let threshold = _get_channel_threshold_private(&mut context, storage, token);\n        let current_balance = _get_channel_balance(&mut context, storage, from, to, token);\n\n        let mut new_balance = current_balance + amount;\n        // Check if the threshold is exceeded\n        if new_balance > threshold {\n            // Log the channel threshold exceeded\n            ShieldGateway::at(context.this_address())\n                ._log_channel_threshold_exceeded(from, to, token)\n                .enqueue(&mut context);\n            // Once the threshold is exceeded, reset the balance to 0\n            new_balance = U253::zero();\n        }\n\n        // Update the channel balance\n        let _ = _set_channel_balance(&mut context, storage, from, to, token, new_balance);\n\n        // Finally, execute the transfer\n        Token::at(token).transfer_private_to_private(from, to, amount.to_field(), nonce).call(&mut context);\n    }\n\n    #[private]\n    fn verified_id_transfer(\n        token: AztecAddress,\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: U253,\n        nonce: Field,\n    ) {\n        aztec::oracle::debug_log::debug_log_format(\n            \"Checking transfer of {0} tokens from {1} to {2}\",\n            [amount.to_field(), from.to_field(), to.to_field()],\n        );\n\n        // TODO: What checks should we perform here?\n        // Ensure Verified ID is provided & valid\n\n        // Safety: pop_capsule will eventually be verified\n        unsafe {\n            let verified_id: [Field; 5] = pop_capsule();\n            let _ = ShieldGateway::at(context.this_address()).verify_id_private(verified_id).view(\n                &mut context,\n            );\n        }\n\n        Token::at(token).transfer_private_to_private(from, to, amount.to_field(), nonce).call(\n            &mut context,\n        );\n    }\n\n    #[private]\n    #[view]\n    fn verify_id_private(verified_id: [Field; 5]) -> bool {\n        // TODO: Implement ID verification logic\n        aztec::oracle::debug_log::debug_log_format(\"Verified ID: {}\", verified_id);\n        true\n    }\n\n    #[public]\n    #[internal]\n    fn _log_channel_creation(from: AztecAddress, to: AztecAddress, token: AztecAddress) {\n        ChannelCreation { from, to, token }.emit(encode_event(&mut context));\n    }\n\n    #[public]\n    #[internal]\n    fn _log_channel_threshold_exceeded(from: AztecAddress, to: AztecAddress, token: AztecAddress) {\n        ChannelThresholdExceeded { from, to, token }.emit(encode_event(&mut context));\n    }\n\n    #[contract_library_method]\n    fn _set_default_channel_threshold(context: &mut PublicContext, storage: Storage<&mut PublicContext>, new_threshold: Field) {\n        storage.default_channel_threshold.schedule_value_change(U253::from_field(new_threshold));\n\n        DefaultChannelThresholdChanged {\n            new_threshold,\n            // Change will be effective after `CHANGE_DELAY_BLOCKS` in public context and `CHANGE_DELAY_BLOCKS + 1` in private context\n            effective_block: context.block_number().add(CHANGE_DELAY_BLOCKS.to_field() + 1),\n        }\n            .emit(encode_event(context));\n    }\n\n\n\n    #[contract_library_method]\n    fn _get_channel_threshold_private(context: &mut PrivateContext, storage: Storage<&mut PrivateContext>, token: AztecAddress) -> U253 {\n        let threshold = ShieldGatewayStorage::at(storage.shield_gateway_storage.read()).get_channel_threshold_private(token).view(context);\n\n        if threshold.is_zero() {\n            // If the threshold is not set for the token, use the default threshold\n            storage.default_channel_threshold.get_current_value()\n        } else {\n            threshold\n        }\n    }\n\n    #[contract_library_method]\n    fn _channel_key(from: AztecAddress, to: AztecAddress, token: AztecAddress) -> Field {\n        poseidon2_hash([from.to_field(), to.to_field(), token.to_field()])\n    }\n\n    #[contract_library_method]\n    fn _get_channel_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        from: AztecAddress,\n        to: AztecAddress,\n        token: AztecAddress,\n    ) -> U253 {\n        let key = _channel_key(from, to, token);\n         ShieldGatewayStorage::at(storage.shield_gateway_storage.read())\n            .get_channel_balance(key)\n            .call(context)\n    }\n\n    #[contract_library_method]\n    fn _set_channel_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        from: AztecAddress,\n        to: AztecAddress,\n        token: AztecAddress,\n        amount: U253,\n    ) -> U253 {\n        let key = _channel_key(from, to, token);\n        ShieldGatewayStorage::at(storage.shield_gateway_storage.read())\n            .set_channel_balance(key, amount, from)\n            .call(context)\n    }\n\n    pub unconstrained fn get_storage_address() -> AztecAddress {\n        storage.shield_gateway_storage.read()\n    }\n\n    pub unconstrained fn channel_key(from: AztecAddress, to: AztecAddress, token: AztecAddress) -> Field {\n        _channel_key(from, to, token)\n    }\n}\n"
    },
    "69": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/authwit/src/auth.nr",
      "source": "use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\nuse dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\nglobal IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "7": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "77": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub gas_opts: GasOpts,\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"
    },
    "84": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        execution_cache::store(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            /// Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            /// for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        /// Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        /// execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        /// the number of side effects that took place), along with the hash of the return values. We validate these\n        /// by requesting a private kernel iteration in which the return values are constrained to hash\n        /// to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        /// WARNING: This is insecure and should be temporary!\n        /// The oracle hashes the arguments and returns a new args_hash.\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        /// We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        /// b) this is only temporary.\n        let args_hash = unsafe {\n            enqueue_public_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.set_public_teardown_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        /// WARNING: This is insecure and should be temporary!\n        /// The oracle hashes the arguments and returns a new args_hash.\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        /// We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        /// b) this is only temporary.\n        let args_hash = unsafe {\n            set_public_teardown_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "85": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, Packable, Serialize};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            /// Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            /// Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "86": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        /// Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "87": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.75.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    }
  }
}
