{
  "transpiled": true,
  "noir_version": "1.0.0-beta.7+0000000000000000000000000000000000000000",
  "name": "Portal",
  "functions": [
    {
      "name": "_claim_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2550444873539515884": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7069518359247663558": {
            "error_kind": "string",
            "string": "Function _claim_public can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_claim_public"
      ]
    },
    {
      "name": "_log_claim",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "11430482739715627628": {
            "error_kind": "string",
            "string": "Function _log_claim can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgUEBCcCBgQAHwoABQAGgEQdAIBGgEYGLgiARAABLgiARQACLgiARgADLgiARwAEJQAAAF4lAAAAXygCAAEEgEgnAgIEADsOAAIAASYlAAACOB4CAAYAHgIABwAzKgAGAAcACCcCBgEBJAIACAAAAIglAAACYR4CAAYBHgIABwAKKgYHCCQCAAgAAACkJQAAAnMcCgMGACkCAAMAIxDODy0IAQcnAggEBgAIAQgBJwMHBAEAIgcCCC0KCAktDgEJACIJAgktDgIJACIJAgktDgYJACIJAgktDgQJACIJAgktDgMJJwIBAAAtCAECJwIDBAYACAEDAScDAgQBACICAgMtCgMELQ4BBAAiBAIELQ4BBAAiBAIELQ4BBAAiBAIELQ4BBAAiBAIELQ4BBC0IAQEAAAECAS0OAgEnAgIEACcCAwQFJwIEBAEtCgIFIwAAAWQMKgUDAiQCAAIAAAHuIwAAAXYtCwECJwIFBAUGIgUCAScCBwQDACoFBwYtCAEEAAgBBgEnAwQEAQAiBAIGLQ4FBgAiBgIGLQ4FBicCBwQDACoEBwYAIgICBy4CAAeAAy4CAAaABC4CAAWABSUAAAKFACIEAgYtCwYFJwIHBAIAKgYHAjcLAAIABSYAIgcCBgAqBgUILQsIAi0LAQYuAgAGgAMoAIAEBAAGJQAAAssuCIAFAAgAIggCCQAqCQUKLQ4CCi0OCAEAKgUEAi0KAgUjAAABZCgAgAQEeAANAAAAgASAAyQAgAMAAAJgKgEAAQX3ofOvpa3UyjwEAgEmKgEAAQW+Hj//PqT2+jwEAgEmKgEAAQWeoTt9j/vabDwEAgEmAQCAA4AFgAcuAIADgAguAIAEgAkLAIAIgAeACiQAgAoAAALKLgGACIAGLgSABoAJAQCACAACgAgBAIAJAAKACSMAAAKZJi4BgAOABgsAgAYAAoAHJACABwAAAuYjAAAC8S4AgAOABSMAAANYLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAAA0QuAYAKgAguBIAIgAsBAIAKAAKACgEAgAsAAoALIwAAAxMoAYAFBAABAwCABgACgAYjAAADWCY=",
      "debug_symbols": "tZfbauMwEIbfxde50Gg0OuRVSihp6haDcYKbLCwl774ztsZuChLZht7En8bR7zlJlj+b1/bl8v7cDW/Hj2b79Nm8jF3fd+/P/fGwP3fHga2fjZEfMHxxG75Ssw18BR6DEYgMwGAxA4KCZ5BJTiwyy4klMhAopAzeNVsrszxbrGUIMUO0CiFDUkvKFmusgs8gHs5AClnZWqeQH2ERFVTQqaD4bIlBfJ6BMnijoJaglrBYUoaICjHDFMUEYQY0oJAfimAUSCELokWFLIgkszxDkACDgNzi9OL09AnUktSSssVNOZwgZAC1gFosKPgMaBQog1OLUwvpLFIdjwr8dORGcgEVQgap+wxqSRwXgkCagYxTEB2uF00+B4GYwVKGydUJfAbpzBnUQvofmnJ4vW4aXQ7P57FtZTV8WR+8ak77sR3OzXa49P2m+bPvL9OfPk77Ybqe9yPfZffb4ZWvLPjW9a3QdbPONuWpwIV1eTovqpQWCQB7IwIVESPdPGsYZ1cJk24kbFnCxRSyhEvGLxKBbhSwrBAdah6ic0WFahgpaRgAqRgGPRyG/90wKC7ViOVqxIoEBVIJj1ByIpUVEi+arJCI4MEwwJbDqDW3RVgak/dhU27uSmuSCVoRxlgMpdqbS1tE3kRKEvVQ0K+hkC+H8nh7wuP9eX9VKBZDMTU3lv6K5HCR4MTcRFJpUQ9B3fD8+l8j+bZp1UKJJi1ViXyQWUTQwv2O4CLi3dfVlu6XcEHT4ckUJWytR6O+B5JJpbJaVxbAQBoGhuDWVPj/0IikDcoYf6aRCFQj+YrGfcmA4oqvCvhl+7PF3c/WNtBgtDtTQPxRQWJcChIT/jCZYU1m/FbUHQ/3h268OdRfRWzs9i99m4dvl+Hw5e7570nv6EfBaTwe2tfL2IrS+mXAP098KNnw62jHh0kZ8VmUjyw7+VqQIW+6/JUgQ5iGaQMWdldx7R8=",
      "brillig_names": [
        "_log_claim"
      ]
    },
    {
      "name": "_register_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "aztec_token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14788743618517749904": {
            "error_kind": "string",
            "string": "Function _register_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_register_public"
      ]
    },
    {
      "name": "claim_public",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17288131482828810359": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+y9BXxUR/f/n0ISiIe64O7MbJbsLnV3d6XZ3QR3KdBSd3cvtLi7Furu7kaVFkop1P1/5+nNw91lFpLcz7nfc/6/Z16veRHm4Zmemfmcz5z37s3uNln/tvd3yMp6b5d/f97G6fXdP+s5vXnaWPWf3p9zLP8u3zJWaBkrtoyVWsa2s4w5YWftkza2s9MvTBvbxTLW1DJfM8tYc8tYC8tYS8t/o5VlrLVlrI1lrK3lv9HB/Xfeto375z7un2WqPByujIQqdZmuUKFYPNpdhbvHy6M6qrtHuydD0bKyymg4GonFYxEV0+GySl3VPVZWpf5txfU3zaV8tVCCMs6SusfZPX3AxLat07M9sZp9+Nv9uV3Wpp/be34ucf9N9f+v1Pl7I6dv6/Tt6m8ar2710/ZA+Wu6A3Cu0vq4s9kepiGlKPevI3CuRsD92wG4fzZtb+/R9g6en7f1/LxdmrZ3dP6+k9N3dvouFm3XA59N2yzcfu6K20/t9WMzb3PifdgVqKvdiPZhN3cfstP2wNu2Ae/LNlk0HpOFjXPTHWg2pzhrk4lRbk67LAmbE6KbW/9rfNV729z9ubGz+U2c3tTpzYxond7C6S2d3srprZ3exultnd7O6e2d3sHpHZ3eyemdnd7F6V2d3s3pyuna6SGnlzk97PTuTi93esTpUafHnN7D6bunV9AmmIZpY00sY00tY80sY80tYy0sYy0tY60sY60tY20sY20tY+0sY+0tYx0sYx0tY50sY50tY10sY10tY90sY8oypi1jIctYmWUsbBnrbhkrt4xFLGNRy1jMMtbDMra7O+ZtLdw/93H/VP5aiun4vakaA269yirTlG4CmsussSlkrn/3q5n/uULufunmfucK/3fvdQt/cynPOeqWfuYKpWhCt6r7XCpNX7p1Hecqr9pMq7pN3eaKWnSv29Zlrqg1h3S72s8VyZCPun1t54pkzG3doXZzhbbgE7pjbeaKbNFzdKeaz5XYin/pzjWdK7JVL9RdajaXqoGv6q41mUvVyKN1t63P1b2Gfq/V1uYK1/ju0HqLc4WranEP6dCW5orU6k7TZZnnitbyftThDHPFqmp91+ru9rlUHe5tXW6bS9WpBtCRzefSdawndDR9rmSdaxMdS52rzEedo3t45gpV+aqZ9O71cdBnYLUkaxOYehsaVneH1XpJ7Y13j/qEAZvJ01/q8Rv8HrgD1HsCNrW6GKfaQxMj6m2B6j3cE5wE5q2oelnBJoHy1ZKkr6p492IvN8H2Tn9lY6/6m79HuLeFQOsTbqJfatwLmEB7gw8XLT6TNHsBk7F63XsJvZF6wHQUS3rj3ac+ZcDwGymW3Ad4I+3L/EYye7gv/EaKJfcVeiP1gMUdS1jCJbmR9nMTbP/0G2k/y420fwA3Ug/gjbQfMIH2JzpclAFVx4lc8wFAM8vKwt+We7oGhH4HGYkCBwLNzLaHyl/T5owPJKhkDhRaycRg/hMv88Z7UH3CgA+CVzLxsoOAyX8w80rG7OHB8EomXnYwcfIjDPRA5gZ6CHgPqxv64kVq/FBg7gVZAcdgccdDlnBJKuDDXGM+PL0CPsxSAR8eQAWMu4GUPgwoysOJDhediMg1H0FcASt/TRtzPJSgejuSedVqzuVIAeum0viRQI0fxVzjmYoURPGDmuto8IUdFO1EYXdNtMob7zH1CQM+Bk470apjgAd4LHPaMXt4LJx2olXHMqcdY3RH1+dtxseBzbi6odeM1PjxQmknCos7WmkJl4R2TnCN+cR02jnBQjsnBkA7uBtI6ROAojyR6HDRiYhc80nMK0FjjscTVP0nM6cdcy4nC1g3lcZPBmr8FOYaz1SkKH9NI4uUU4W+txOB3TUh5Y33tPqEAZ8Gp52QOg2YBKczpx2zh6fDaSekTmdOO8boTq3P24zPEEI7SI2fKZR2IrC4dZUlXBLaOcs15p7ptHOWhXZ6BkA7uBtI6bOAouxJdLjoRESu+WzmlaAxxzMJqv4K5rRjzqVCwLqpNF4B1HicucYzFSnKX9PIIiUhlHbKYXdNMoV2kvUJA07CaSepksAkqGROO2YPK+G0k1SVzGnHGF2iPm8zrhJCO0iN9xJKO+WwuBOB0U5v15j7pNNObwvt9AmAdnA3kNK9gaLsQ3S46ERErrkv80rQmGMvgqq/H3PaMefST8C6qTTeD6jx/sw1nqlIUf6aRhYpA4TSTnfYXVOe8pkYA+sTBjwQTjvleiAwCQYxpx2zh4PgtFOesm7ls9nWjTC6AfV5m/FgIbSD1PgQobTTHRZ3eWCfpTLUNeZh6bQz1EI7wwKgHdwNpPRQoCiHER0uOhGRax7OvBI05jiEoOofwZx2zLmMELBuKo2PAGp8JHONZypSlL+mkUXKOUJpJ4x7byfqjXdUfcKAR+Hf24mOAibBaOa0Y/ZwNP69neho5rRjjO6c+rzNeIwQ2kFq/FyhtBOGxZ2MWMIloZ3zXGMem04751loZ2wAtIO7gZQ+DyjKsUSHi05E5JrPZ14JGnM8l6Dqv4A57ZhzuUDAuqk0fgFQ4xcy13imIkX5axpZpFwklHbKYHdNOOaN9+L6hAFfDKedcOxiYBJcwpx2zB5eAqedcOwS5rRjjO6i+rzN+FIhtIPU+GVCaacMFnc4agmXhHYud435inTaudxCO1cEQDu4G0jpy4GivILocNGJiFzzlcwrQWOOlxFU/Vcxpx1zLlcJWDeVxq8Cavxq5hrPVKQof00ji5RrhNJOCHbXxFOeZLu2PmHA18JpJ66vBSbBdcxpx+zhdXDaiaesW/lstnUjjO6a+rzN+HohtIPU+A1CaScEizse2JNsN7rGfFM67dxooZ2bAqAd3A2k9I1AUd5EdLjoRESu+WbmlaAxxxsIqv5bmNOOOZdbBKybSuO3ADV+K3ONZypSlL+mkUXKbUJpR+NoJ+GN9/b6hAHfjqedxO3AJLiDOe2YPbwDTzuJO5jTjjG62+rzNuM7hdAOUuN3CaUdjSuI45ZwSWjnbteY70mnnbsttHNPALSDu4GUvhsoynuIDhediMg138u8EjTmeBdB1X8fc9ox53KfgHVTafw+oMbHMdd4piJF+WsaWaSMF0o7CvckW9wb7/31CQO+H/8kW/x+YBI8wJx2zB4+gH+SLf4Ac9oxRje+Pm8zniCEdpAanyiUdhTuYacKS7gktDPJNebJ6bQzyUI7kwOgHdwNpPQkoCgnEx0uOhGRa57CvBI05jiRoOqfypx2zLlMFbBuKo1PBWp8GnONZypSlL+mkUXKdKG00w1210RTPoF6Rn3CgGfAaSeqZgCTYCZz2jF7OBNOO1E1kzntGKObXp+3Gc8SQjtIjc8WSjvdYHFHAvsE6jmuMc9Np505FtqZGwDt4G4gpecARTmX6HDRiYhc8zzmlaAxx9kEVf985rRjzmW+gHVTaXw+UOMLmGs8U5Gi/DWNLFIWCqWdrkS0s6g+YcCLCGhnETAJFjOnHbOHiwloZzFz2jFGt7A+bzNeIoR2kBpfKpR2ugqknWWuMS9Pp51lFtpZHgDt4G4gpZcBRblcCO0g1/wg80rQmONSgqp/BXPaMeeyQsC6qTS+Aqjxlcw1nqlIUf6aRhYpDwmlnS6wu6Yi5TPZHq5PGPDDcNqpiD0MTIJHmNOO2cNH4LRTEXuEOe0Yo3uoPm8zflQI7SA1/phQ2ukCi7sisM9ke9w15ifSaedxC+08EQDt4G4gpR8HivIJosNFJyJyzU8yrwSNOT5GUPU/xZx2zLk8JWDdVBp/Cqjxp5lrPFORovw1jSxSnhFKO51xtBP2xvtsfcKAn8XTTvhZYBI8x5x2zB4+h6ed8HPMaccY3TP1eZvx80JoB6nxF4TSTmdcQVxmCZeEdl50jfmldNp50UI7LwVAO7gbSOkXgaJ8iehw0YmIXPPLzCtBY44vEFT9rzCnHXMurwhYN5XGXwFq/FXmGs9UpCh/TSOLlNeE0k4n2F2TTHlv5/X6hAG/DqedZOx1YBK8wZx2zB6+AaedZOwN5rRjjO61+rzN+E0htIPU+FtCaacTLO5kYO/tvO0a8zvptPO2hXbeCYB2cDeQ0m8DRfkO0eGiExG55neZV4LGHN8iqPrfY0475lzeE7BuKo2/B9T4+8w1nqlIUf6aRhYpHwilnY6wuyZR6Y33w/qEAX8Ip51E5YfAJPiIOe2YPfwITjuJyo+Y044xug/q8zbjj4XQDlLjnwilnY6wuBNJS7gktLPKNeZP02lnlYV2Pg2AdnA3kNKrgKL8lOhw0YmIXPNnzCtBY46fEFT9nzOnHXMunwtYN5XGPwdq/AvmGs9UpCh/TSOLlC+F0k4H2F2jU97b+ao+YcBfwWlHx74CJsFq5rRj9nA1nHZ0bDVz2jFG92V93mb8tRDaQWr8G6G00wEWtw7svZ01rjGvTaedNRbaWRsA7eBuIKXXAEW5luhw0YmIXPO3zCtBY47fEFT965jTjjmXdQLWTaXxdUCNf8dc45mKFOWvaWSRsl4o7bSH3TXxFNr5vj5hwN/DaSce+x6YBBuY047Zww1w2onHNjCnHWN06+vzNuONQmgHqfEfhNJOe1jc8cBo50fXmH9Kp50fLbTzUwC0g7uBlP4RKMqfiA4XnYjINf/MvBI05vgDQdX/C3PaMefyi4B1U2n8F6DGf2Wu8UxFivLXNLJI+U0o7bSD3TXRqDfe3+sTBvw7nHai0d+BSfAHc9oxe/gHnHai0T+Y044xut/q8zbjP4XQDlLjfwmlnXawuKMRS7gktPO3a8z/pNPO3xba+ScA2sHdQEr/DRTlP0SHi05E5JqzsnlXgsYc/yKo+rfJpr24lL+mzbmYGLmvm0rj3jj9zlWPucYzFSnKX9PIIqU+UDdB0k5b2F0TTqGd7GzCgM3kWNoJR7OBSZADTE6qPczJRtNOOJpDfGkgjK5+Nm8zzgWbcXVDrxmp8QbANQdJO21hBXE4MNpp6BpzXnZWKtk0zN6cdsw/oqadtkDaaQgUZV42zeGiExG55nzmlaAxxwYEVX8Bc9ox51IgYN1UGi8AaryQucYzFSnKX9PIIqVIKO20gd01Me2NtzibMOBiOO3EdDEwCUqY047ZwxI47cRS1q18Ntu6EUZXlM3bjEuF0A5S442E0k4bGO3ElCVcEtrZ1jXm7dJpZ1sL7WwXAO20AdLOtkBRbpdNc7joRESueXvmlaAxx0YEVf8OzGnHnMsOAtZNpfEdgBrfkbnGMxUpyl/TyCJlJ6G00xp210SUN96dswkD3hlOOxG1MzAJdmFOO2YPd4HTTkTtwpx2jNHtlM3bjHcVQjtIje8mlHZaw2invMoSLgntNHaNuUk67TS20E6TAGinNZB2GgNF2SSb5nDRiYhcc1PmlaAxx90Iqv5mzGnHnEszAeum0ngzoMabM9d4piJF+WsaWaS0EEo7rXCfUpDyCdQtswkDbgmnnXhlS2AStGJOO2YPW8FpJ17ZijntGKNrkc3bjFsLoR2kxtsIpZ1WuF9kT1rCJaGdtq4xt0unnbYW2mkXAO20AtJOW6Ao22XTHC46EZFrbs+8EjTm2Iag6u/AnHbMuXQQsG4qjXcAarwjc41nKlKUv6aRRUonobTTEnbXhFLe2+mcTRhwZzjthFRnYBJ0YU47Zg+7wGknpLowpx1jdJ2yeZtxVyG0g9R4N6G00xL3IcWBvbejXGPW6bSjLLSjA6CdlkDaUUBR6myaw0UnInLNIeaVoDHHbgRVfxlz2jHnUiZg3VQaLwNqPMxc45mKFOWvaWSR0l0o7bTA3TUJb7zl2YQBl8NpRyXKgUkQYU47Zg8jcNpRiQhz2jFG1z2btxlHhdAOUuMxobTTAvdZcnFLuCS008M15t3TaaeHhXZ2D4B2gDeQ7gEU5e7ZNIeLTkTkmvdgXgkac4wRVP17Mqcdcy57Clg3lcb3BGp8L+Yaz1SkKH9NI4uUvYXSTnPYXVOe8iTbPtmUAcNpp7xyH2AS7Mucdswe7gunnfLKfZnTjjG6vbN5m/F+QmgHqfH9hdJOc9zv7SQt4ZLQzgGuMR+YTjsHWGjnwABopzmQdg4AivLAbJrDRScics0HMa8EjTnuT1D1H8ycdsy5HCxg3VQaPxio8UOYazxTkaL8NY0sUg4VSjvNYHeNTvlMtsOyCQM+DE47Wh8GTILDmdOO2cPD4bSjU9atfDbbuhFGd2g2bzM+QgjtIDV+pFDaaYZ7ki2wz2Q7yjXmo9Np5ygL7RwdAO00A9LOUUBRHp1Nc7joRESu+RjmlaAxxyMJqv5jmdOOOZdjBaybSuPHAjV+HHONZypSlL+mkUXK8UJppynuYYyU39s5IZsw4BOy8fOeyJxQzLpPzN60waB5SajCGMrx2bxN7yQhVIHU5cnERo84k5MJNB6koTYhMtRTsgkDPoXAUE9lbqhm3acGZKjKX9MmMU7Npkk41LqDTLLGwG9K9MZ7WjZhwKcR3IinAR39dOYJa/bwdIIkOJ35a7QmSU8nwJ+TgOd9BvOXC4x2ziAy++qGzu0zgOdzJnPEz0QMyl/TSGI4i7nGzRmfRVDIIXVoUrA4a9NL5t4G/2ifLJo8z4LGGSJ9n2Mbz942d3/u6RzC2U6vcHrc6QmnJ51e6fQqp/dyem+n93F6X6f3c3p/pw9w+kCnD3L6YKcPcfpQpw9z+nCnj3D6SKef4/RRTh/t9DFOP9fp5zl9rNPPT3+Ppaf7fop37GzLWIVlLG4ZS1jGkpaxSstYlWWsl2Wst2Wsj2Wsr2Wsn2Wsv2VsgGVsoGVskGVssGVsiGVsqGVsmGVsuGVshGVspGXsHMvYKMvYaMvYGMvYuZax8yxjYy1j52dv/t5dC/fPfdw/lb+WYjp+zbInwHir3wc8GzSXWWMFZK5/9yvuf66Qu1864Xeu8H/3Xif9zaU856gr/cwVStGErqr7XCpNX7pXHecqr9pMq7p33eaKWnSv+9Rlrqg1h3Tf2s8VyZCPul9t54pkzG3dv3ZzhbbgE3pAbeaKbNFz9MCaz5XYin/pQTWdK7JVL9SDazaXqoGv6iE1mUvVyKP10K3P1b2Gfq+HbW2ucI3vDj18i3OFq2pxD+kRW5orUqs7TY/MPFe0lvejPifDXLGqWt+1epR9LlWHe1uPts2l6lQD6DGbz6XrWE/oc9PnSta5NtHnpc5V5qPO0WM9c4WqfNVM+nyhr2ifD6v1kilPHV+QTRjwBdnop46T+gLcAeoLAZtK+Yq22cMLga9oV+/hheAkCOrpUVzyJgN7evQiN8EuTn9l46LszZ8evTib/ulRnJMofREwgS4GHy5afCZpLgImY/W6LxJ6I42F6SiW9MZ7STZhwJfAb6RY8hLgjXQp8xvJ7OGl8BsplrxU6I00FhZ3LGEJl+RGusxNsMvTb6TLLDfS5QHcSGOBN9JlwAS6nOhw0W8EI9d8BdDMsrLwt+WFrgGh3whGosCVQDOz7aHy17Q54ysJKpkrhVYy58H8J17mjfeqbMKAr4JXMvGyq4DJfzXzSsbs4dXwSiZedjVx8iMM9ErmBnoNeA+rG/riRWr8WmDuBVkBnweLOx6yhEtSAV/nGvP16RXwdZYK+PoAKmDcDaT0dUBRXk90uOhERK75BuIKWPlr2pjjtQTV243Mq1ZzLjcKWDeVxm8Eavwm5hrPVKQgih/UXDeDL+ygaOdc2F0TrfLGe0s2YcC3wGknWnUL8ABvZU47Zg9vhdNOtOpW5rRjjO7mbN5mfBvYjKsbes1Ijd8ulHbOhcUdrbSES0I7d7jGfGc67dxhoZ07A6Ad3A2k9B1AUd5JdLjoRESu+S7mlaAxx9sJqv67mdOOOZe7BaybSuN3AzV+D3ONZypSlL+mkUXKvULf2xkDu2tSv3f8vmzCgO+D005I3QdMgnHMacfs4Tg47YTUOOa0Y4zu3mzeZjxeCO0gNX6/UNoZA4s7uO8df8A15gnptPOAhXYmBEA7uBtI6QeAopxAdLjoRESueSLzStCY4/0EVf8k5rRjzmWSgHVTaXwSUOOTmWs8U5Gi/DWNLFKmCKWd0bC7JplCO1OzCQOeCqedpJoKTIJpzGnH7OE0OO0k1TTmtGOMbko2bzOeLoR2kBqfIZR2RsPiTgRGOzNdY56VTjszLbQzKwDawd1ASs8EinIW0eGiExG55tnMK0FjjjMIqv45zGnHnMscAeum0vgcoMbnMtd4piJF+WsaWaTME0o7o2B3TXnKZ2LMzyYMeD6cdsr1fGASLGBOO2YPF8Bppzxl3cpns60bYXTzsnmb8UIhtIPU+CKhtDMKFnd5YJ+lstg15iXptLPYQjtLAqAd3A2k9GKgKJcQHS46EZFrXsq8EjTmuIig6l/GnHbMuSwTsG4qjS8Danw5c41nKlKUv6aRRcqDQmnnHNx7O1FvvCuyCQNegX9vJ7oCmAQrmdOO2cOV+Pd2oiuZ044xugezeZvxQ0JoB6nxh4XSzjmwuJMRS7gktPOIa8yPptPOIxbaeTQA2sHdQEo/AhTlo0SHi05E5JofY14JGnN8mKDqf5w57ZhzeVzAuqk0/jhQ408w13imIkX5axpZpDwplHZGwu6acMwb71PZhAE/BaedcOwpYBI8zZx2zB4+DaedcOxp5rRjjO7JbN5m/IwQ2kFq/FmhtDMSFnc4agmXhHaec435+XTaec5CO88HQDu4G0jp54CifJ7ocNGJiFzzC8wrQWOOzxJU/S8ypx1zLi8KWDeVxl8Eavwl5hrPVKQof00ji5SXhdLOCNhdE095ku2VbMKAX4HTTly/AkyCV5nTjtnDV+G0E09Zt/LZbOtGGN3L2bzN+DUhtIPU+OtCaWcELO54YE+yveEa85vptPOGhXbeDIB2cDeQ0m8ARfkm0eGiExG55reYV4LGHF8nqPrfZk475lzeFrBuKo2/DdT4O8w1nqlIUf6aRhYp7wqlneE42kl4430vmzDg9/C0k3gPmATvM6cds4fv42kn8T5z2jFG9242bzP+QAjtIDX+oVDaGY4riOOWcElo5yPXmD9Op52PLLTzcQC0g7uBlP4IKMqPiQ4XnYjINX/CvBI05vghQdW/ijntmHNZJWDdVBpfBdT4p8w1nqlIUf6aRhYpnwmlnWG4J9ni3ng/zyYM+HP8k2zxz4FJ8AVz2jF7+AX+Sbb4F8xpxxjdZ9m8zfhLIbSD1PhXQmlnGO5hpwpLuCS0s9o15q/TaWe1hXa+DoB2cDeQ0quBovya6HDRiYhc8zfMK0Fjjl8RVP1rmNOOOZc1AtZNpfE1QI2vZa7xTEWK8tc0skj5VijtDIXdNdGUT6Bel00Y8Do47UTVOmASfMecdswefgennaj6jjntGKP7Npu3Ga8XQjtIjX8vlHaGwuKOBPYJ1BtcY96YTjsbLLSzMQDawd1ASm8AinIj0eGiExG55h+YV4LGHL8nqPp/ZE475lx+FLBuKo3/CNT4T8w1nqlIUf6aRhYpPwulnSFEtPNLNmHAvxDQzi/AJPiVOe2YPfyVgHZ+ZU47xuh+zuZtxr8JoR2kxn8XSjtDBNLOH64x/5lOO39YaOfPAGgHdwMp/QdQlH8KoR3kmv9iXgkac/ydoOr/mzntmHP5W8C6qTT+N1Dj/zDXeKYiRflrGlmkZOXIpJ3BsLumIuUz2bbJIQzYTI6lHSd43AHqejm8acfsoYkRSzsVsXo5tJcGwuiycnibcf0crBlXN/SakRrPBq45SNoZDLs4KwL7TLYc15hzc7JSySYnZ3PaMf+ImnYGA2knByjK3Byaw0UnInLNDcDmg044Y47ZOfiLoSHxxaX8NW3OpaGAdVNpvCFQ43nMNZ6pSFH+mkYWKflCaWcQjnbC3ngLcggDLsDTTrgAmASFzGnH7GEhnnbChcxpxxhdfg5vMy4SQjtIjRcLpZ1BONops4RLQjslrjGXptNOiYV2SgOgnUFA2ikBirI0h+Zw0YmIXHMj5pWgMcdigqp/W+a0Y85lWwHrptL4tkCNb8dc45mKFOWvaWSRsr1Q2hkIu2uSKe/t7JBDGPAOcNpJxnYAJsGOzGnH7OGOcNpJxnZkTjvG6LbP4W3GOwmhHaTGdxZKOwNhtJMM7L2dXVxj3jWddnax0M6uAdDOQCDt7AIU5a45NIeLTkTkmndjXgkac9yZoOpvzJx2zLk0FrBuKo03Bmq8CXONZypSlL+mkUVKU6G0MwB21yQqvfE2yyEMuBmcdhKVzYBJ0Jw57Zg9bA6nnURlc+a0Y4yuaQ5vM24hhHaQGm8plHYGwGgnkbSES0I7rVxjbp1OO60stNM6ANoZAKSdVkBRts6hOVx0IiLX3IZ5JWjMsSVB1d+WOe2Yc2krYN1UGm8L1Hg75hrPVKQof00ji5T2QmmnP+yu0Snv7XTIIQy4A5x2dKwDMAk6Mqcds4cd4bSjYx2Z044xuvY5vM24kxDaQWq8s1Da6Q+jHR3YeztdXGPumk47XSy00zUA2ukPpJ0uQFF2zaE5XHQiItfcjXklaMyxM0HVr5jTjjkXJWDdVBpXQI1r5hrPVKQof00ji5SQUNrpB7tr4im0U5ZDGHAZnHbisTJgEoSZ047ZwzCcduKxMHPaMUYXyuFtxt2F0A5S4+VCaacfjHbigdFOxDXmaDrtRCy0Ew2AdvoBaScCFGU0h+Zw0YmIXHOMeSVozLGcoOrvwZx2zLn0ELBuKo33AGp8d+Yaz1SkKH9NI4uUPYTSTl/cJ1BHvfHumUMY8J5w2olG9wQmwV7Macfs4V5w2olG92JOO8bo9sjhbcZ7C6EdpMb3EUo7fWG0E41YwiWhnX1dY94vnXb2tdDOfgHQTl8g7ewLFOV+OTSHi05E5Jr3Z14J/sccCar+A5jTjjmXAwSsm0rjBwA1fiBzjWcqUpS/ppFFykFCaacP7K4Jp9DOwTmEAR8Mp51w9GBgEhzCnHbMHh4Cp51w9BDmtGOM7qAc3mZ8qBDaQWr8MKG00wdGO+HAaOdw15iPSKedwy20c0QAtNMHSDuHA0V5RA7N4aITEbnmI5lXgsYcDyOo+o9iTjvmXI4SsG4qjR8F1PjRzDWeqUhR/ppGFinHCKWd3rC7Jqa98R6bQxjwsXDaieljgUlwHHPaMXt4HJx2YinrVj6bbd0Iozsmh7cZHy+EdpAaP0Eo7fSG0U5MWcIloZ0TXWM+KZ12TrTQzkkB0E5vIO2cCBTlSTk0h4tOROSaT2ZeCRpzPIGg6j+FOe2YczlFwLqpNH4KUOOnMtd4piJF+WsaWaScJpR2esHumojyxnt6DmHAp8NpJ6JOBybBGcxpx+zhGXDaiagzmNOOMbrTcnib8ZlCaAep8bOE0k4vGO2UV1nCJaGdnq4xn51OOz0ttHN2ALTTC0g7PYGiPDuH5nDRiYhccwXzStCY41kEVX+cOe2Yc4kLWDeVxuNAjSeYazxTkaL8NY0sUpJCaacK9ykFKZ9AXZlDGHAlnHbilZXAJKhiTjtmD6vgtBOvrGJOO8bokjm8zbiXENpBary3UNqpwn1KQdISLgnt9HGNuW867fSx0E7fAGinCkg7fYCi7JtDc7joRESuuR/zStCYY2+Cqr8/c9ox59JfwLqpNN4fqPEBzDWeqUhR/ppGFikDhdJOJeyuCaW8tzMohzDgQXDaCalBwCQYzJx2zB4OhtNOSA1mTjvG6Abm8DbjIUJoB6nxoUJppxL3CdSBvbczzDXm4em0M8xCO8MDoJ1KIO0MA4pyeA7N4aITEbnmEcwrQWOOQwmq/pHMacecy0gB66bS+Eigxs9hrvFMRYry1zSySBkllHaSuLsm4Y13dA5hwKPhtKMSo4FJMIY57Zg9HAOnHZUYw5x2jNGNyuFtxucKoR2kxs8TSjtJGO2ouCVcEtoZ6xrz+em0M9ZCO+cHQDvAG0iPBYry/Byaw0UnInLNFzCvBI05nkdQ9V/InHbMuVwoYN1UGr8QqPGLmGs8U5Gi/DWNLFIuFko7CdhdU57yJNslOYQBXwKnnfLKS4BJcClz2jF7eCmcdsorL2VOO8boLs7hbcaXCaEdpMYvF0o7Cdzv7QT2JNsVrjFfmU47V1ho58oAaCcBpJ0rgKK8MofmcNGJiFzzVcwrQWOOlxNU/Vczpx1zLlcLWDeVxq8Gavwa5hrPVKQof00ji5RrhdJOHHbX6JTPZLsuhzDg6+C0o/V1wCS4njntmD28Hk47OmXdymezrRthdNfm8DbjG4TQDlLjNwqlnTjuSbbAPpPtJteYb06nnZsstHNzALQTB9LOTUBR3pxDc7joRESu+RbmlaAxxxsJqv5bmdOOOZdbBaybSuO3AjV+G3ONZypSlL+mkUXK7UJppwL3MEbK7+3ckUMY8B05+HnvZE4oZt135mzaYNC8JFRhDOX2HN6md5cQqkDq8m5io0ecyd0EGg/SUM8mMtR7cggDvofAUO9lbqhm3fcGZKjKX9MmMe7NoUk41LqDTLKe2bg98MZ7Xw5hwPcR3Ij3AR19HPOENXs4jiAJxjF/jdYk6TgC/LkLeN7jmb9cYLQznsjsqxs6t8cDz+d+5oifiRiUv6aRxPAAc42bM36AoJBD6tAUCcVZm14y9zZ03B2yaPI8CxpniPR9jm08e9vc/XmCc54TnT7J6ZOdPsXpU50+zenTnT7D6TOdPsvps50+x+lznT7P6fOdvsDpC52+yOmLnb7E6Uudvszpy53+oNNXOH2l0x9y+sNOf8Tpjzr9sfT3WCa476d4xyZaxiZZxiZbxqZYxqZaxqZZxqZbxmZYxmZaxmZZxmZbxuZYxuZaxuZZxuZbxhZYxhZaxhZZxhZbxpZYxpZaxpZZxpZbxh60jK2wjK20jD1kGXvYMvaIZexRy9hjOZu/d9fC/XMf90/lr6WYjl+znAAw3ur3ASeC5jJrnASZ69/9mux/rpC7X3qK37nC/917PdXfXMpzjnqan7lCKZrQ0+s+l0rTl55Rx7nKqzbTqp5Zt7miFt3rWXWZK2rNIT279nNFMuSjnlPbuSIZc1vPrd1coS34hJ5Xm7kiW/QcPb/mcyW24l96QU3nimzVC/XCms2lauCrelFN5lI18mi9eOtzda+h3+slW5srXOO7Qy/d4lzhqlrcQ3rZluaK1OpO08szzxWt5f2oH8wwV6yq1netXmGfS9Xh3tYrbXOpOtUA+qHN59J1rCf0w+lzJetcm+hHUucq81Hn6Ec9c4WqfNVM+jGhr2g/Bqv1kilPHT+eQxjw4znop46T+nHcAeonAJtK+Yq22cMngK9oV+/hE+AkCOrpUVzyJgN7evRJN8GeSn9l48mczZ8efSqH/ulRnJMo/SQwgZ4CHy5afCZpngQmY/W6nxR6Iz0K01Es6Y336RzCgJ+G30ix5NPAG+kZ5jeS2cNn4DdSLPmM0BvpUVjcsYQlXJIb6Vk3wZ5Lv5GetdxIzwVwIz0KvJGeBSbQc0SHi34jGLnm54FmlpWFvy2fcA0I/UYwEgVeAJqZbQ+Vv6bNGb9AUMm8ILSSeQTmP/Eyb7wv5hAG/CK8komXvQhM/peYVzJmD1+CVzLxspeIkx9hoC8wN9CXwXtY3dAXL1LjrwBzL8gK+BFY3PGQJVySCvhV15hfS6+AX7VUwK8FUAHjbiClXwWK8jWiw0UnInLNrxNXwMpf08YcXyGo3t5gXrWac3lDwLqpNP4GUONvMtd4piIFUfyg5noLfGEHRTsPw+6aaJU33rdzCAN+G0470aq3gQf4DnPaMXv4Dpx2olXvMKcdY3Rv5fA243fBZlzd0GtGavw9obTzMCzuaKUlXBLaed815g/Saed9C+18EADt4G4gpd8HivIDosNFJyJyzR8yrwSNOb5HUPV/xJx2zLl8JGDdVBr/CKjxj5lrPFORovw1jSxSPhH63s5DsLsm9XvHV+UQBrwKTjshtQqYBJ8ypx2zh5/CaSekPmVOO8boPsnhbcafCaEdpMY/F0o7D8HiDu57x79wjfnLdNr5wkI7XwZAO7gbSOkvgKL8kuhw0YmIXPNXzCtBY46fE1T9q5nTjjmX1QLWTaXx1UCNf81c45mKFOWvaWSR8o1Q2lkJu2uSKbSzJocw4DVw2kmqNcAkWMucdsweroXTTlKtZU47xui+yeFtxt8KoR2kxtcJpZ2VsLgTgdHOd64xr0+nne8stLM+ANrB3UBKfwcU5Xqiw0UnInLN3zOvBI05riOo+jcwpx1zLhsErJtK4xuAGt/IXOOZihTlr2lkkfKDUNpZAbtrylM+E+PHHMKAf4TTTrn+EZgEPzGnHbOHP8Fppzxl3cpns60bYXQ/5PA245+F0A5S478IpZ0VsLjLA/sslV9dY/4tnXZ+tdDObwHQDu4GUvpXoCh/IzpcdCIi1/w780rQmOMvBFX/H8xpx5zLHwLWTaXxP4Aa/5O5xjMVKcpf08gi5S+htPMg7r2dqDfev3MIA/4b/95O9G9gEvzDnHbMHv6Df28n+g9z2jFG91cObzPOypVBO0iNbwNcc5C08yBM78mIJVwS2qmX+++f9XOzUsnG/A/ptGP+ETXt4G4gpevl4kRZP5fmcNGJiFxzNth80AlnzHGbXPzFkJNLe3Epf02bc8kRsG4qjecANZ7LXOOZihTlr2lkkdIAqJsgaWc57K4Jx7zxNswlDNhMjqWdcKwhMAnygMlJtYd5uWjaCcfyiC8NhNE1yOVtxvlCaAep8QKhtLMcRjvhqCVcEtopdI25KJ12Ci20UxQA7SwH0k4hUJRFuTSHi05E5JqLmVeCxhwLCKr+Eua0Y86lRMC6qTReAtR4KXONZypSlL+mkUVKI6G0swx218RTnmTbNpcw4G3htBPX2wKTYDvmtGP2cDs47cRT1q18Ntu6EUbXKJe3GW8vhHaQGt9BKO0sg9FOPLAn2XZ0jXmndNrZ0UI7OwVAO8uAtLMjUJQ75dIcLjoRkWvemXklaMxxB4KqfxfmtGPOZRcB66bS+C5Aje/KXOOZihTlr2lkkbKbUNpZiqOdhDfexrmEATfG006iMTAJmjCnHbOHTfC0k2jCnHaM0e2Wy9uMmwqhHaTGmwmlnaU42olbwiWhneauMbdIp53mFtppEQDtLAXSTnOgKFvk0hwuOhGRa27JvBI05tiMoOpvxZx2zLm0ErBuKo23Amq8NXONZypSlL+mkUVKG6G0swT3JFvcG2/bXMKA2+KfZIu3BSZBO+a0Y/awHf5Jtng75rRjjK5NLm8zbi+EdpAa7yCUdpbgnmSrsIRLQjsdXWPulE47HS200ykA2lkCpJ2OQFF2yqU5XHQiItfcmXklaMyxA0HV34U57Zhz6SJg3VQa7wLUeFfmGs9UpCh/TSOLlG5CaWcx7K6JpnwCtcolDFjBaSeqFDAJNHPaMXuo4bQTVZo57Rij65bL24xDQmgHqfEyobSzGEY7kSpLuCS0E3aNuXs67YQttNM9ANpZDKSdMFCU3XNpDhediMg1lzOvBI05lhFU/RHmtGPOJSJg3VQajwA1HmWu8UxFivLXNLJIiQmlnUVEtNMjlzDgHgS00wOYBLszpx2zh7sT0M7uzGnHGF0sl7cZ7yGEdpAa31Mo7SwSSDt7uca8dzrt7GWhnb0DoJ1FQNrZCyjKvYXQDnLN+zCvBI057klQ9e/LnHbMuewrYN1UGt8XqPH9mGs8U5Gi/DWNLFL2F0o7C2F3TUXKZ7IdkEsY8AFw2qmIHQBMggOZ047ZwwPhtFMRO5A57Rij2z+XtxkfJIR2kBo/WCjtLITRTkVgn8l2iGvMh6bTziEW2jk0ANpZCKSdQ4CiPDSX5nDRiYhc82HMK0FjjgcTVP2HM6cdcy6HC1g3lcYPB2r8COYaz1SkKH9NI4uUI4XSzgIc7YS98R6VSxjwUXjaCR8FTIKjmdOO2cOj8bQTPpo57RijOzKXtxkfI4R2kBo/VijtLMDRTpklXBLaOc415uPTaec4C+0cHwDtLADSznFAUR6fS3O46ERErvkE5pWgMcdjCar+E5nTjjmXEwWsm0rjJwI1fhJzjWcqUpS/ppFFyslCaWc+7ttFU97bOSWXMOBT4LSTjJ0CTIJTmdOO2cNT4bSTjJ3KnHaM0Z2cy9uMTxNCO0iNny6Udubjvl00sPd2znCN+cx02jnDQjtnBkA784G0cwZQlGfm0hwuOhGRaz6LeSVozPF0gqq/J3PaMefSU8C6qTTeE6jxs5lrPFORovw1jSxSKoTSzjzYXZOo9MYbzyUMOA6nnURlHJgECea0Y/YwAaedRGWCOe0Yo6vI5W3GSSG0g9R4pVDamQejnUTSEi4J7VS5xtwrnXaqLLTTKwDamQeknSqgKHvl0hwuOhGRa+7NvBI05lhJUPX3YU475lz6CFg3lcb7ADXel7nGMxUpyl/TyCKln1DamQu7a3TKezv9cwkD7g+nHR3rD0yCAcxpx+zhADjt6NgA5rRjjK5fLm8zHiiEdpAaHySUdubCaEcH9t7OYNeYh6TTzmAL7QwJgHbmAmlnMFCUQ3JpDhediMg1D2VeCRpzHERQ9Q9jTjvmXIYJWDeVxocBNT6cucYzFSnKX9PIImWEUNqZg/t20RTaGZlLGPBIOO3EYyOBSXAOc9oxe3gOnHbisXOY044xuhG5vM14lBDaQWp8tFDamYP7dtHAaGeMa8znptPOGAvtnBsA7cwB0s4YoCjPzaU5XHQiItd8HvNK0JjjaIKqfyxz2jHnMlbAuqk0Phao8fOZazxTkaL8NY0sUi4QSjuzcZ9AHfXGe2EuYcAXwmknGr0QmAQXMacds4cXwWknGr2IOe0Yo7sgl7cZXyyEdpAav0Qo7cyG0U40YgmXhHYudY35snTaudRCO5cFQDuzgbRzKVCUl+XSHC46EZFrvpx5JWjM8RKCqv8K5rRjzuUKAeum0vgVQI1fyVzjmYoU5a9pZJFylVDamQW7a8IptHN1LmHAV8NpJxy9GpgE1zCnHbOH18BpJxy9hjntGKO7Kpe3GV8rhHaQGr9OKO3MgtFOODDaud415hvSaed6C+3cEADtzALSzvVAUd6QS3O46ERErvlG5pWgMcfrCKr+m5jTjjmXmwSsm0rjNwE1fjNzjWcqUpS/ppFFyi1CaWcm7K6JaW+8t+YSBnwrnHZi+lZgEtzGnHbMHt4Gp51YyrqVz2ZbN8Lobsnlbca3C6EdpMbvEEo7M2G0E1OWcElo507XmO9Kp507LbRzVwC0MxNIO3cCRXlXLs3hohMRuea7mVeCxhzvIKj672FOO+Zc7hGwbiqN3wPU+L3MNZ6pSFH+mkYWKfcJpZ0ZsLsmorzxjsslDHgcnHYiahwwCcYzpx2zh+PhtBNR45nTjjG6+3J5m/H9QmgHqfEHhNLODBjtlFdZwiWhnQmuMU9Mp50JFtqZGADtzADSzgSgKCfm0hwuOhGRa57EvBI05vgAQdU/mTntmHOZLGDdVBqfDNT4FOYaz1SkKH9NI4uUqUJpZzruUwpSPoF6Wi5hwNPgtBOvnAZMgunMacfs4XQ47cQrpzOnHWN0U3N5m/EMIbSD1PhMobQzHfcpBYF9AvUs15hnp9POLAvtzA6AdqYDaWcWUJSzc2kOF52IyDXPYV4JGnOcSVD1z2VOO+Zc5gpYN5XG5wI1Po+5xjMVKcpf08giZb5Q2pkGu2tCKe/tLMglDHgBnHZCagEwCRYypx2zhwvhtBNSC5nTjjG6+bm8zXiRENpBanyxUNqZhvsE6ipLuCS0s8Q15qXptLPEQjtLA6CdaUDaWQIU5dJcmsNFJyJyzcuYV4LGHBcTVP3LmdOOOZflAtZNpfHlQI0/yFzjmYoU5a9pZJGyQijtTMXdNQlvvCtzCQNeCacdlVgJTIKHmNOO2cOH4LSjEg8xpx1jdCtyeZvxw0JoB6nxR4TSzlQY7ai4JVwS2nnUNebH0mnnUQvtPBYA7QBvIP0oUJSP5dIcLjoRkWt+nHklaMzxEYKq/wnmtGPO5QkB66bS+BNAjT/JXOOZihTlr2lkkfKUUNqZArtrylOeZHs6lzDgp+G0U175NDAJnmFOO2YPn4HTTnnlM8xpxxjdU7m8zfhZIbSD1PhzQmlnCu73dgJ7ku1515hfSKed5y2080IAtDMFSDvPA0X5Qi7N4aITEbnmF5lXgsYcnyOo+l9iTjvmXF4SsG4qjb8E1PjLzDWeqUhR/ppGFimvCKWdybC7Rqd8JturuYQBvwqnHa1fBSbBa8xpx+zha3Da0SnrVj6bbd0Io3sll7cZvy6EdpAaf0Mo7UzGPckW2Geyveka81vptPOmhXbeCoB2JgNp502gKN/KpTlcdCIi1/w280rQmOMbBFX/O8xpx5zLOwLWTaXxd4Aaf5e5xjMVKcpf08gi5T2htDMJ9zBGyu/tvJ9LGPD7ufh5P2BOKGbdH+Ru2mDQvCRUYQzlvVzepvehEKpA6vIjYqNHnMlHBBoP0lAnEhnqx7mEAX9MYKifMDdUs+5PAjJU5a9pkxif5NIkHGrdQSbZhBzcHnjjXZVLGPAqghtxFdDRP2WesGYPPyVIgk+Zv0ZrkvRTAvz5EHjenzF/ucBo5zMis69u6Nz+DHg+nzNH/EzEoPw1jSSGL5hr3JzxFwSFHFKH2VmbXk6v3gPrY02w+CvjNPOGQjTzhsto5q2KZnn2HDev0rvXx/spOsYeAmKMCYgxKiDGiIAYywXE2F1AjGEBMZYJiDEkIEYtIEYlIMZuAmLsKiDGLgJi7Cwgxk4CYuwoIMYOAmJsLyDGdgJibCsgxjYCYmwtIMZWAmJsKSDGFgJibC4gxmYCYmwqIMYmAmJsLCDG87P5xzhWQIznCYjxXAExjhEQ42gBMY4SEOM5AmIcKSDGEQJiHC4gxmECYhwqIMYhAmIcLCDGQQJiHCggxgECYuwvIMZ+AmLsKyDGPgJi7C0gxl4CYqwSEGOlgBiTAmJMCIgxLiDGCgExni0gxp4CYnwsh3+MjwqI8REBMT4sIMaHBMS4UkCMKwTE+KCAGJcLiHGZgBiXCohxiYAYFwuIcZGAGBcKiHGBgBjnC4hxnoAY5wqIcY6AGGcLiHGWgBhnCohxhoAYpwuIcZqAGKcKiHGKgBgnC4hxkoAYJwqIcQJBjN6Gmbs8TDf3ps/KNXtb6v78ZW5W1ldOX+30r53+jdPXOH2t0791+jqnf+f09U7/3ukbnL7R6T84/Uf3czh+Sv+8XTNh87Sx1Zaxry1j31jG1ljG1lrGvrWMrbOMfWcZW28Z+94ytsEyttEy9oNl7EfL2E/umLehxf8l4IMfVDiZjCdUzBsn+vOSYb/cr5XyfpiB3w+7+Bn4gSHes//Zcvb1kHuqU2P3uw+/EO3DL5Z9QGsL+KEM+hfgnv5KtKe/BqCtX4H78BvRPvwWgLaAH6ahfwPu6e9Ee/o7tbacffiK6T5Q6qgceP9FgPffH0Q6+iMAj/oDqKM/ifbhzwA8CvghMPpP4J7+RbSnfwWgrb+A+/A30T78HYC2gB/eo/8G7uk/RHv6TwD332qm+0CpoxDw/isD3n9ZDWh0ZOZtTqkjnRq7709YJtqHbRrQexTwQ6f0NsA9rUe0p/UC0FY94D7UJ9qH+gFoC/hhYbo+cE+zifY0uwH9/fd1Ls99oNRRV+D91w14/+UQ6SgnAI/KAeZTLtE+5AbgUcAPudO5wD1tQLSnDQLQVgPgPjQk2oeGAWgL+OGEuiFwT/OI9jQvgPvvm1ye+0Cpo47A+68T8P7LJ9JRfgAelQ/MpwKifSgIwKOAH6qpC4B7Wki0p4UBaKsQuA9FRPtQFIC2gB+GqouAe1pMtKfFAdx/a3J57gOljtoC7792wPuvhEhHJQF4VAkwn0qJ9qE0AI8CfoivLgXuaSOiPW0UgLYaAfdhW6J92DYAbQE/fFlvC9zT7Yj2dLsA7r+1uTz3gVJHLYH3Xyvg/bc9kY62D8Cjtgfm0w5E+7BDAB4F/NBwvQNwT3ck2tMdA9DWjsB92IloH3YKQFvNgdraCbinOxPt6c4B3H/f5vLcB0odNQXef82A998uRDraJQCP2gWYT7sS7cOuAXgU8EsK9K7APd2NaE93C0BbuwH3oTHRPjQOQFvAL5fQjYF72oRoT5sEcP+ty+W5D5Q6gn25hpOb3i8T8bt/TYl01DQAj2oKzKdmRPvQLACPAn4pim4G3NPmRHvaPABtNQfuQwuifWgRgLaAX2ajWwD3tCXRnrYM4P77LpfnPlDqaDTw/hsDvP9aEemoVQAe1QqYT62J9qF1AB4F/BIm3Rq4p22I9rRNANpqA9yHtkT70DYAbQG/PEu3Be5pO6I9bRfA/bc+l+c+UOpoBPD+Gwm8/9oT6ah9AB7VHphPHYj2oUMAHgX80jfdAbinHYn2tGMA2uoI3IdORPvQKQBtAb+sT3cC7mlnoj3tHMD9930uz32g1NEQ4P03FHj/dSHSUZcAPKoLMJ+6Eu1D1wA8Cvglk7orcE+7Ee1ptwC01Q24D4poH1QA2gJ+OahWwD3VRHuqA7j/NuTy3AdKHQ0A3n8DgfdfiEhHoQA8KgTMpzKifSgLwKOAX2qry4B7Giba03AA2goD96E70T50D0BbwC8j1t2Be1pOtKflAdx/G3N57gOljvoA77++wPsvQqSjSAAeFQHmU5RoH6IBeBTwS7R1FLinMaI9jQWgrRhwH3oQ7UOPALQF/PJz3QO4p7sT7enuAdx/P+Ty3AdKHVUC778q4P23B5GO9gjAo/YA5tOeRPuwZwAelQR61J7APd2LaE/3CkBbewH3YW+ifdg7AG0lgNraG7in+xDt6T4B3H8/5vLcB++at0lbs9849wXEWRkPhcJlVVHKOPcDxFleoWKV5eURyjj3B8QZj5dHKiqj3SnjPAAQZ1mivLKqLBKijPNAQJwV3cNVVd3LKijjPAgQZ3etKruHIlWUcR4MiDMWV93Lo9EEZZyHAOLUVdGyZKwiThnnoYhzj1eqRFLHTGzbuTHu69535mfvdxt6v9PQ+12G3u8w9H53ofc7C73fVej9jkLvdxN6v5PQ+12E3u8g9H73oPc7B73fNbifJ/79PT8f4Pn5QM/PB3l+Ptjz8yGenw91fz7M+fNwpx/h9COdfpTTj3b6MU4/1unZWZu+77D6zJNZ9raPz7P7t1XGaeYNhWjmDZfRzLupBtgGOq/Su9fH11PoGHsIiDEmIMaogBgjAmIsFxBjdwExhgXEWCYgxpCAGLWAGJWAGLsJiLGrgBi7CIixs4AYOwmIsaOAGDsIiLG9gBjbCYixrYAY2wiIsbWAGFsJiLGlgBhbCIixuYAYmwmIsamAGJsIiLGxgBjPz+Yf41gBMZ4nIMZzBcQ4RkCMowXEOEpAjOcIiHGkgBhHCIhxuIAYhwmIcaiAGIcIiHGwgBgHCYhxoIAYBwiIsb+AGPsJiLGvgBj7CIixt4AYewmIsUpAjJUCYkwKiDEhIMa4gBgrBMR4toAYewqI8bEc/jE+KiDGRwTE+LCAGB8SEONKATGuEBDjgwJiXC4gxmUCYlwqIMYlAmJcLCDGRQJiXCggxgUCYpwvIMZ5AmKcKyDGOQJinC0gxlkCYpwpIMYZAmKcLiDGaQJinCogxikCYpwsIMZJAmKcKCDGCQQxehtm7vIw3dxhVc+zt6Xuz8c1yMo63uknOP1Ep5/k9JOdforTT3X6aU4/3elnOP1Mp5/l9J5OP9vpFQ3+nSPeIGvThwFs407aPG3seMvYCZaxEy1jJ1nGTraMnWIZO9UydpplLB7AB0rB3kzQSsWBH4SXIPpAqUQAH1aWAH6wVpJoH5IBaAv4JpBOAve0kmhPKwPQViVwH6qI9qEqAG0B37zTVcA97UW0p70C+CC845juA6WOYG9eOrnpfbPW7/71JtJR7wA8qjdQR32I9qFPAB4FfNNZ9wHuaV+iPe0bgLb6AvehH9E+9AtAW8CHBXQ/4J72J9rT/gHcf8cz3QdKHa0E3n8PAe+/AUQ6GhCARw0A6mgg0T4MDMCjgA+56IHAPR1EtKeDAtDWIOA+DCbah8EBaAv4cJIeDNzTIUR7OiSA++8EpvtAqaNlwPtvOfD+G0qko6EBeNRQoI6GEe3DsAA8CvhQnR4G3NPhRHs6PABtDQfuwwiifRgRgLaAD0PqEcA9HUm0pyMDuP9OZLoPlDpaBLz/FgPvv3OIdHROAB51DlBHo4j2YVQAHgV8iFePAu7paKI9HR2AtkYD92EM0T6MCUBbwIev9Rjgnp5LtKfnBnD/ncR0Hyh1NA94/80H3n/nEenovAA86jygjsYS7cPYADwK+EsDeixwT88n2tPzA9DW+cB9uIBoHy4IQFvAX/bQFwD39EKiPb0wgPvvZKb7QKmjWcD7bzbw/ruISEcXBeBRFwF1dDHRPlwcgEcBf0lJXwzc00uI9vSSALR1CXAfLiXah0sD0Bbwl8v0pcA9vYxoTy8L4P47hek+UOpoGvD+mw68/y4n0tHlAXjU5UAdXUG0D1cE4FHAX4rUVwD39EqiPb0yAG1dCdyHq4j24aoAtAX8ZVZ9FXBPryba06sDuP9OZboPlDqaBLz/JgPvv2uIdHRNAB51DVBH1xLtw7UBeBTwl7D1tcA9vY5oT68LQFvXAffheqJ9uD4AbQF/eV5fD9zTG4j29IYA7r/TmO6Dd83bgNd8upA4zxAS55lC4jxLSJw9hcR5tpA4K4BxZmf968H1PbGWZqU2dPzHEewzOsbjBcR4goAYTxQQ40kCYjxZQIynCIjxVAExnkZ0DyFijBLNSxXv/+b9v5kXN3eoO93c5eHq3PXWPTc6+XeT0292+i1Ov9Xptzn9dqff4fQ7nX6X0+92+j1Ov9fp9zl9nNPHN8hK/QC0Gxts/qFoN1nGbraM3WIZu9Uydptl7HbL2B2WsTstY+MsY+PdsWx3o+pZDgVthHc1YC5Q/e8f3r24v8G/fz6QLgTzPzRMCwD9itJdgFc/Kv99+UPfD3wl5QEhZCUlzruFxHmPkDjvFRLnfULiRPhQxJ3LG2f6q8V+fQn4SoS+kehs0GsGvrKhbxKyZuArJfpmIWsGvvKibxGyZuArOfpWIWsGvjKkbxOyZuArTfp2IWsGvnKl7xCyZuArYfrOgNas6tZ09Q/jgNw1geidfO+84H2obno88OwnQLjYaYnKlHp0G7DeJwHWbHuFFh3nZLCutsva/BsOvN9s4P1GA+83GXi/wcD7zQXebyzwflOB9xsKJnl+nlzLn70vkI33/HyY5+fDPT8f4fn5SM/PR3l+Ptrz8zGen491f57i/DnV6dOcPt3pM5w+0+mznD67wb8vzBVnbXpNaUvnr/w1PYX7C3P/Nrqv/dD/6rZ6b7Pdn+c4+zLX6fOcPj/9BcA57guA3rG5lrF5lrH5DTZ/8TAHu1kph+rXIOagDLdK6bmgucwa5wFfIJ0PfgwjqOSd+r/ktSbvAmdfFjp9kdMXpyfvAktSLrSMLbKMLQ4geacCk3cBMHkXApN3ETB5FwtN3mn/S15r8i5x9mWp05c5fXl68i6xJOVSy9gyy9jyAJJ3GjB5lwCTdykweZcBk3e50OSd/r/ktSbvg86+rHD6Sqc/lJ68D1qScoVlbKVl7KEAknc6MHkfBCbvCmDyrgQm70NCk3fG/5LXmrwPO/vyiNMfdfpj6cn7sCUpH7GMPWoZeyyA5J0BTN6Hgcn7CDB5HwUm72NCk3fm/5LXmryPO/vyhNOfdPpT6cn7uCUpn7CMPWkZeyqA5J0JTN7Hgcn7BDB5nwQm71NCk3fW/5LXmrxPO/vyjNOfdfpz6cn7tCUpn7GMPWsZey6A5J0FTN6ngcn7DDB5nwUm73NCk3f2/5LXmrzPO/vygtNfdPpL6cn7vCUpX7CMvWgZeymA5J0NTN7ngcn7AjB5XwQm70vg5DVnXc8jql2y7A3z3wyHaeYt704zb4Tot5zKq4jiLSOKN0YUL5EeQlTnRrW/RHoor6SZNyIsj6XtA5l+o0TzaqL9pco3on0oq6CZl0oPkTjRPlDFmzQ1yjZpczfL9N/Qqk5tzuY1Vh1nUmpu+lx1nkmpealz+ZhJqS0+clTLmRdknqvWMS7MNFcdVrvIPled9q1GT3nUcOYlW5+rxjEu3dpctVjtsi3PVat9q9Ub61uZ+cGaz7XVGFfUdK4arHZlzeaq0b7V6b3MDDM/XPu5Msb4SG3n2sJqH63dXFvcN19vH6XN/Hjd59osxifqOpdltU/WbS7rvkFesXdnftr/XP+N8Rm/c3lW+6y/uVL2DfgiacprScpPcyJ8ETPXf9aKfC0pq7pluz2IV4S3ySJYgKeh4qTcg+2Ae+A9s5cb/PvnK+6frzbI2vJh+n319rW6q7EsfcDEtm3WppfIt3EX9Lf78yuen1/1/Pya+3P1/+915+9vOP1Np7/VYNM41R68DctIHaGM8x2cc4RtZ/W250xMr/75nS2c1bvO399z+vtO/6DBJiMy71jUy9q8cU5EyjjfBbp+rifOD12D+Mj982P3z0/cP1c1+Hct7d1//6nz98+c/rnTv3D6l07/yumrnf61079x+hqnr3X6t05f5/TvnL7e6d87fYPTNzr9B6f/6PSfnP6z039x+q9O/83pvzv9D6f/6fS/jF6c/o+Jx3lbaxun13N6fadnOz3H6blOb+D0hulvhZngm7uCKsna/CUIioP6CHhQ3njzGhIGbCZHz5vfEOdcVOvO97xRCppXBSm2j4nEVtCQMOACArEVMhebWXehcLF9QiS2ooaEARcRiK2YudjMuosJxEYRq3Hgwob4WrekocwkW0WUZKUNCQMuJUiyRsyTzKy7kZAkM2ZQQpBk2zbErjtTUvmNc7u6xxlOH7CB70cewP3Y8/Mqz88mBi/4bu/8fQen7+j0nRpu/iIF+qNhgbe33h6Ymzs3xBpe+tns3HDTGezg+XlHz887pZ3NLs7fd3X6bk5v3DB1PqQujX9sS5CXTXB7qoN8VvjDBjR+kgWNMxSlm1uFvM8Kt3d/buqcZzOnN3d6C6e3dHorp7d2ehunt3V6O6e3d3oHp3d0eiend3Z6F6d3dXo3pyuna6eHnF7m9LDTuzu93OkRp0edHnN6D6fv7vQ9nL6n0/dy+t5GU07f1+n7OX1/px/g9APTX3Rp2nDTK4DVY80sY80tYy0sYy0tY60sY60tY20sY20tY+0sY+0tYx0sYx0tY50sY50tY10sY10tY90sY8oypi1jIctYmWUsbBnrbhkrt4xFLGNRy1jMMtbDMra7ZWwPy9ielrG9LGN7W8b2sYztaxnbzzK2v2XsAMvYgR5zr24d3D/3cf9U/lqKafq9OJoCLvZ/n8WvqmqGmyvZHDdXrAVuLt0SNlelbgWbK6Fbw+aK6jawuZRui5qrUul2qLkSSrdHzRVVugNqLie3O4LmqnTm6gSaK+HM1Rk0V9SZqwtoLuOFXTFzVZq5umHmSpi5FGYu89GeWmPm+s/dEYLMVfmfucogcyX+M1cYMtd/PglVd4fM9e9dW46Yq/LfuSKIuRL/zhVFzPXvB8fqGGIutzbpAZgr6c61O2CuuDvXHoC5qr+fYk//c4Xc+kvv5X8uXT3X3r7nilZVz7WP/7ni1XPt63+u6npV7+d7rsh/59rf91zd/zvXAb7n0v+d60Dcizmkn9WOYIfquQ7Crfk/j/GhX6gyLxA2IXjh7mDwWdcDr9s8/dMUeDbmnA8m2MdDBOwjUuNNifbxUCLvQcd5WN3jDKUPmNjS30Qweqp+s+BQz8+TPW/wHNYw9U2Ew52/H+H0I51+VMPMbyIof02bp/GaEZz90dvTvqnpNz6z5sMJ1n3M9jSazwaf++HA+/ZooBcBdaOlnMVnwNdgj2lIk8Oc8sLmsUd7fPWYGnrssc7fj3P68U4/gdBjzdPOzQm85ljmHmvWfCzBuo8TktfHAnPxRKDHAnWjpZzF50CPPakhTQ5zygubx57o8dWTauixJzt/P8Xppzr9NEKPNb9N0oLAa45n7rFmzScTrPsEIXl9MjAXTwd6LFA3WspZfAH02DMa0uQwp7yweezpHl89o4Yee6bz97Oc3tPpZxN6rPltvZYEXnMic481az6TYN0nCcnrM4G5WAH0WKButJSz+BLosfGGNDnMKS9sHlvh8dV4DT024fw96fRKp1cReqz5behWBF5zMnOPNWtOEKz7FCF5nQDmYi+gxwJ1o6WcxVdAj+3dkCaHOeWFzWN7eXy1dw09to/z975O7+f0/oQeaz5tojWB15zK3GPNmvsQrPs0IXndB5iLA4AeC9SNlnIWq4EeO7AhTQ5zygubxw7w+OrAGnrsIOfvg50+xOlDCT3WfJpPGwKvOZ25x5o1DyJY9xlC8noQMBeHAT0WqBst5Sy+Bnrs8IY0OcwpL2weO8zjq8Nr6LEjnL+PdPo5Th9F6LHm09LaEnjNmcw91qx5BMG6zxKS1yOAuTga6LFA3WgpZ/EN0GPHNKTJYU55YfPY0R5fHVNDjz3X+ft5Th/r9PMJPdZ8GmU7Aq/pydxjzZrPJVj32ULy+lxgLl4A9FigbrSUs1gD9NgLG9LkMKe8sHnsBR5fvbCGHnuR8/eLnX6J0y8l9Fjzab/tCbymgrnHmjVfRLDuuJC8vgiYi5cBPRaoGy3lLNYCPfbyhjQ5zCkvbB57mcdXL6+hx17h/P1Kp1/l9KsJPdZ8mnoHAq9JMPdYs+YrCNadFJLXVwBz8RqgxwJ1o6WcxbdAj722IU0Oc8oLm8de4/HVa2vosdc5f7/e6Tc4/UZCjzXfVtGRwGsqmXusWfN1BOuuEpLX1wFz8SagxwJ1o6WcxTqgx97ckCaHOeWFzWNv8vjqzTX02Fucv9/q9Nucfjuhx5pvA+pE4DW9mHusWfMtBOvuLSSvbwHm4h1AjwXqRks5i++AHntnQ5oc5pQXNo+9w+Ord9bQY+9y/n630+9x+r2EHmu+ba0zgdf0Ye6xZs13Eay7r5C8vguYi/cBPRaoGy3lLNYDPXZcQ5oc5pQXNo+9z+Or42roseOdv9/v9AecPoHQY823WXYh8Jp+zD3WrHk8wbr7C8nr8cBcnAj0WKButJSz+B7osZMa0uQwp7yweexEj69OqqHHTnb+PsXpU50+jdBjzbcFdyXwmgHMPdaseTLBugcKyevJwFycDvRYoG60lLPYAPTYGQ1pcphTXtg8drrHV2fU0GNnOn+f5fTZTp9D6LHm29i7EXjNIOYea9Y8k2Ddg4Xk9UxgLs4FeixQN1rKWWwEeuy8hjQ5zCkvbB471+Or82rosfOdvy9w+kKnLyL02B+cGBSB1wxh7rFmzfMJ1j1USF7PB+biYqDHAnWjpZzFD0CPXdKQJoc55YXNYxd7fHVJDT12qfP3ZU5f7vQHCT32xwabvv/UO6/v32Fn7rFmzUsJ1j1cSF4vBebiCqDHAnWjpZzFj0CPXdmQJoc55YXNY1d4fHVlDT32IefvDzv9Eac/SuixPzXY9H3S3nn97ukI5h5r1vwQwbpHCsnrh4C5+BjQY4G60VLO4iegxz7ekCaHOeWFzWMf8/jq4zX02Cecvz/p9Kec/jShx/7sxFBG4DXnMPdYs+YnCNY9SkhePwHMxWeAHgvUjZZyFj8DPfbZhjQ5zCkvbB77jMdXn62hxz7n/P15p7/g9BcJPfYXJ4YwgdeMZu6xZs3PEax7jJC8fg6Yiy8BPRaoGy3lLH4BeuzLDWlymFNe2Dz2JY+vvlxDj33F+furTn/N6a8TeuyvTgzdCbzmXOYea9b8CsG6zxOS168Ac/ENoMcCdaOlnMWvQI99syFNDnPKC5vHvuHx1Tdr6LFvOX9/2+nvOP1dQo/9zYmhnMBrxjL3WLPmtwjWfb6QvH4LmIvvAT0WqBst5Sx+A3rs+w1pcphTXtg89j2Pr75fQ4/9wPn7h07/yOkfE3rs704MEQKvuYC5x5o1f0Cw7guF5PUHwFz8BOixQN1oKWfxO9BjVzWkyWFOeWHz2E88vrqqhh77qfP3z5z+udO/IPTYP5wYogRecxFzjzVr/pRg3RcLyetPgbn4JdBjgbrRUs7iD6DHftWQJoc55YXNY7/0+OpXNfTY1c7fv3b6N05fQ+ixfzoxxAi85hLmHmvWvJpg3ZdK+Z4+YC6uBXosUDdayln8CfTYbxvS5DCnvLB57FqPr35bQ49d5/z9O6evd/r3hB77lxNDDwKvuYy5x5o1ryNY9+VSPrMUmIsbgB4L1I2WchZ/AT12Y0OaHOaUFzaP3eDx1Y019NgfnL//6PSfnP4zocf+7cSwO4HXXMHcY82afyBY95VSfn8TmIu/AD0WqBst5Sz+Bnrsrw1pcphTXtg89hePr/5aQ4/9zfn7707/w+l/EnrsP04MexB4zVXMPdas+TeCdV8t5b1sYC7+BfRYoG60lLP4B+ixfzekyWFOeWHz2L88vvp3DT32H+fvWXnO/+b0enl0Hpvl/Hf2JPCaa5h7rFnzPwTrvlZKXgNzsX4eLi6gbrSUs8gCnkV2Hk0Oc8oLm8caDVZ7aXZezTw2x/l3uU5v4PSGhB67jfPf3YvAa65j7rFmzWaP0fNeLySvc4C5mAf0WKButJSz2Abosfl5NDnMKS9sHpvn8dX8GnpsgfPvCp1e5PRiQo+t5/x39ybw2BuYe6xZcwGBx94oJK8LgLlYAvRYoG60lLOoB/TY0jyaHOaUFzaPLfH4amkNPbaR8++2dfp2Tt+e0GPrm/Ml8NibmHusWXMjAo+9WUheNwLm4g5AjwXqRks5i/pAj90xjyaHOeWFzWN38PjqjjX02J2cf7ez03dx+q6EHpvt/Hf3JfDYW5h7rFnzTgQee6uQvN4JmIu7AT0WqBst5SyygR7bOI8mhznlhc1jd/P4auMaemwT5981dXozpzcn9Ngc57+7H4HH3sbcY82amxB47O1C8roJMBdbAD0WqBst5SxygB7bMo8mhznlhc1jW3h8tWUNPbaV8+9aO72N09sSemyu89/dn8Bj72DusWbNrQg89k4hed0KmIvtgB4L1I2Wcha5QI9tn0eTw5zywuax7Ty+2r6GHtvB+Xcdnd7J6Z0JPbaB8989gMBj72LusWbNHQg89m4hed0BmItdgB4L1I2WchYNgB7bNY8mhznlhc1ju3h8tWsNPbab8++U07XTQ4Qe29D57x5I4LH3MPdYs+ZuBB57r5C87gbMxTKgxwJ1o6WcRUOgx4bzaHKYU17YPLbM46vhGnpsd+fflTs94vSox2OrWz3wOZdk4fazex6NtuuD1/wu8PdrPgLOFQPun9FNSdamu8Tb0Pc1Mm5vvD3yCAPukYefd3eg0VGte/e8TRsMmvc/YsvN2mROlGLzJq/y2Sjj/KgBTVLs4dEt/pMGgFXTf35DxI2xOmgjlAZZwbgS8gC8wt7TTaC9zJooDmAPAmfaA3w1U627HuG6fT/2TbyHyl/TRph7E+DjPuDrvdoUzLwXuvOi92Ivor3Yl2gv9t3CXkB0S7AX4/5vX05JbCU+bda9L8G6x2/P2wfMxbc3gZcCz1sj99AUFeY3923VZ1Yt92BrmvLOiT63fYgwar8tVYzKX9N7ExmiN+haxqy39t8xMe9HYAz3M3ltrzaFjO9nL/J4Gsz929Pocn/PRV3X89naniPP5wDPXLqszMmNZERXJavKukdiobguLysvrwpXRcqj4WRV93BFMlKpwxVloVhlRFXpaGVlpHtZIlJeFUsmyqu8pq2TZWXhZCye0N1D5RVxFU2WVaiqcKQspCqSZZFksixaXl5RVpYsj1ZFY9FQqKKqLKq6RyIxVR4qi4WozucA93yCJM13iUjzQJc0D5Ji4FTxHUhg1gcTXVwHE1KN2YuDCPbiEKK9OISYag4m2IsJAqjmEIJ1T2RONe8SUQ3wvPXE/1FNetMHE1HNoRKp5lBiqjmUwBgm/T9INYfl8TSYSURV82HCqOZwINVMBFIN1fkc7qGaTJcC55ejKOOkumCOkHjBHEF8wRxBcMFMJrpgcsBxIg3sSOBcyJfNkJfVZCIzPLIGl5XfPT0qD3cppLxsxuiyojqfo/5/9BLc0e5LcMfYHvZQ/prO9NAD8ike35+LD6yEKQ6+eg/rC9lDv3Mdy/w8TMIcS1AkHEdUMB1H+HLtMUR7cTzRXhxP+HKt2YfjCPZiGvOXa826jydY93QBL9ceS/ByLfC89fT/vVyb3jTaZ6vbCZQ0fSyRIZ5ASNMm5hMIjGGGkJdrjwUWRSfm8TSYGUSEdWIAL9ciz+ck4Mu104EETHU+J/0fEDDVrzuc7BLwKVIMnCq+kwnM+lSii+tUQqoxe3EKwV6cRrQXpxFTzakEezFLANWcRrDu2QIeraegGuB569n/o5r0pk8loprTJVLN6cRUczqBMcz5f5BqzsjjaTBziKrmM4RRzZlAqpkNpBqq8znz/+AhlOPyaPJeygVzlsQL5iziC+YsggtmrpCHUJAG1hM4F/JlM+RlNZfIDHsG8BDK2cCHUKZvz/Oyojqfsy3ng35GAPjQif4E+DlSFUBfD/JzpCqILtF4HmHA8Tz8vAmgMVOtO5G3aYNB8wb6OVKfCPkcqXeJPkcqmUf4OVIJILp6Xb066P8/PFpY6SZQVR7B50iZA0gSOFOS+I0a1LrrEa7bb4y9mL/ZZYTZiwCxehPhZm/CN7uqiPaiD9Fe9CF8s8vsQ2+CvVjA/M0us+4+BOteKOARvl4EXgo8b73wf292pTfdmwij+lK+FtmLyBD7Er4WaWLuS2AMi4S82dULWBT1y+NpMIuIXp/qF8CbXcjz6Q98s2sh8PVDqvPp/3/wCN8nRKQ5wCXNgVIMnCq+AQRmPYjo4hpESDVmLwYS7MVgor0YTEw1gwj2YokAqhlMsO6lzKnmEyKqAZ63Xvo/qklvehAR1QyRSDVDiKlmCIExLPt/kGqG5vE0mGVEVfNQYVQzDEg1S4FUQ3U+w/4PHuHrnUeT91IumOESL5jhxBfMcIILZrmQR/iQBjYCOBfyZTPkZbWcyAxHBPAI30jgI3wLt+d5WVGdz8j/H70Ed477Etwo28Meyl/TmR56QD7F43cu4IMjJJ9bVL2H6GdEqfbQ71yjmZ+HSZjRBEXCGKKCaQzhy7WjiPbiXKK9OJfw5VqzD2MI9mIl85drzbrPJVj3QwJerh1N8HIt8Lz1Q/97uTa9abTPVrfzKGl6NJEhnkdI0ybm8wiM4WEhL9eOBhZFY/N4GszDRIQ1NoCXa5Hncz7w5dqHgARMdT7n/x8QMNWvO1zgEvCFUgycKr4LCMz6IqKL6yJCqjF7cSHBXlxMtBcXE1PNRQR78agAqrmYYN2PCXi0noJqgOetH/sf1aQ3fRER1VwikWouIaaaSwiM4fH/B6nm0jyeBvM4UdV8qTCquQxINY8BqYbqfC77P3gIZUweTd5LuWAul3jBXE58wVxOcME8IeQhFKSBXQGcC/myGfKyeoLIDK8I4CGUK4EPoTy0Pc/Liup8riR8BaTYuf0aNcR70FXEr4IhvOcqy7MWyl9D3kP6KqCnXc38PMxnCl5NcBdeA37GBP18k3kVBhnjR+58WVhdk7wC9bEbK/rMrwVqPcjPnruWqPC+Lo8w4Ovy8PNeDzQ+qnVf//94kt1ARLNog0Vq6Ubml8nrzlkjYzRnfKMQnb/cQE5OvhJgrH419SpRrOZiLc7aVIB7G4U2kHuc3jBzh+jm1psKAvNnc/fnm5xzvdnptzj9Vqff5vTbnX6H0+90+l1Ov9vp9zj9Xqff5/RxTh/v9Pud/oDTJzh9otMnOX2y06c4farTpzl9utNnOH2m02c5fbbT5zh9rtPn5bnBVFOuCaZh2tjNlrFbLGO3WsZus4zdbhm7wzJ2p2XsLsvY3Zaxeyxj91rG7rOMjbOMjbeM3W8Ze8AyNsEyNtEyNskyNtkyNsUyNtUyNs0yNt0yNsMyNtMyNssyNtsyNscyNtcyNs8d87YW7p/7uH8qfy3FdPya8E2AIqayyjSlbwbNZdZ4C2Suf/frVv9zharff7/N71zhTe/l3+5vLuV9LuAOP3OFUp8xuLPuc6n05xXuquNczouomz37cHfd5oranqO4py5zRe3PZNxb+7kimZ7vuK+2c0UyPysyrnZzhbb03Mn42swV2fIzLPfXfK6tPmP1QE3nimzVC/WEms2lauCremJN5lI18mg9aetzda+h3+vJW5srXOO7Q0/Z4lzhqlrcQ3rqluaK1OpO09MyzxWt5f2op2eYK1ZV67tWz7DPpepwb+uZtrlUnWoAPWvzuXQd6wk9O32uZJ1rEz0nda4yH3WOnuuZK1Tlq2bS84S+CjwPVusltTfe+XmEAZvJUa9mVQc/H3eAegFgUylfUTZ7uAD4Km31Hi4AJ0FpVjDPSuGSN0n6qop3Lxa6CbYo/ZWNhe7BescWWQgU/V40zkmUXghMoEXgw0WLzyTNQmAy/vfD9oXeSHNhOoolvfEuziMMeDH8RoolFwNvpCXMbySzh0vgN1IsuUTojTQXFncsYQmX5EZa6ibYsvQbaanlRloWwI00F3gjLQUm0DKiw0W/wYtc83KgmWVl4W/LBa4B1QNrEIkCDwLNzLaHyl/T5owfJKhkHhRaycyB+U+8zBvvijzCgFfAK5l42Qpg8q9kXsmYPVwJr2TiZSuJkx9hoA8yN9CHwHtY3dAXL1LjDwNzL8gKeA4s7njIEi5JBfyIa8yPplfAj1gq4EcDqIBxN5DSjwBF+SjR4aITEbnmx4grYOWvaWOODxNUb48zr1rNuTwuYN1UGn8cqPEnmGs8U5GCKH5Qcz0JvrCDop3ZsLsmWuWN96k8woCfgtNOtOop4AE+zZx2zB4+DaedaNXTzGnHGN2TebzN+BmwGVc39JqRGn9WKO3MhsUdrbSES0I7z7nG/Hw67TxnoZ3nA6Ad3A2k9HNAUT5PdLjoRESu+QXmlaAxx2cJqv4XmdOOOZcXBaybSuMvAjX+EnONZypSlL+mkUXKy0Lf25kFu2tCKb89/0oeYcCvwGknpF4BJsGrzGnH7OGrcNoJqVeZ044xupfzeJvxa0JoB6nx14XSzixY3LrKEi4J7bzhGvOb6bTzhoV23gyAdnA3kNJvAEX5JtHhohMRuea3mFeCxhxfJ6j632ZOO+Zc3hawbiqNvw3U+DvMNZ6pSFH+mkYWKe8KpZ2ZsLsmmUI77+URBvwenHaS6j1gErzPnHbMHr4Pp52kep857RijezePtxl/IIR2kBr/UCjtzITFnQiMdj5yjfnjdNr5yEI7HwdAO7gbSOmPgKL8mOhw0YmIXPMnzCtBY44fElT9q5jTjjmXVQLWTaXxVUCNf8pc45mKFOWvaWSR8plQ2pkBu2vKUz4T4/M8woA/h9NOuf4cmARfMKcds4dfwGmnPGXdymezrRthdJ/l8TbjL4XQDlLjXwmlnRmwuMsD+yyV1a4xf51OO6sttPN1ALSDu4GUXg0U5ddEh4tOROSav2FeCRpz/Iqg6l/DnHbMuawRsG4qja8Banwtc41nKlKUv6aRRcq3QmlnOu69nag33nV5hAGvw7+3E10HTILvmNOO2cPv8O/tRL9jTjvG6L7N423G64XQDlLj3wulnemwuJMRS7gktLPBNeaN6bSzwUI7GwOgHdwNpPQGoCg3Eh0uOhGRa/6BeSVozPF7gqr/R+a0Y87lRwHrptL4j0CN/8Rc45mKFOWvaWSR8rNQ2pkGu2vCMW+8v+QRBvwLnHbCsV+ASfArc9oxe/grnHbCsV+Z044xup/zeJvxb0JoB6nx34XSzjRY3OGoJVwS2vnDNeY/02nnDwvt/BkA7eBuIKX/AIryT6LDRScics1/Ma8EjTn+TlD1/82cdsy5/C1g3VQa/xuo8X+YazxTkaL8NY0sUrLyZdLOVNhdE095km2bfMKAzeRY2nGCxx2grpfPm3bMHpoYwZ9AnbJu5bPZ1o0wuqx83mZcPx9rxtUNvWakxrOBaw6SdqbCLs54YE+y5bjGnJuflUo2Ofmb0475R9S0MxVIOzlAUebm0xwuOhGRa24ANh90whlzzM7HXwwNiS8u5a9pcy4NBaybSuMNgRrPY67xTEWK8tc0skjJF0o7U3C0k/DGW5BPGHABnnYSBcAkKGROO2YPC/G0kyhkTjvG6PLzeZtxkRDaQWq8WCjtTMHRTtwSLgntlLjGXJpOOyUW2ikNgHamAGmnBCjK0nyaw0UnInLNjZhXgsYciwmq/m2Z0445l20FrJtK49sCNb4dc41nKlKUv6aRRcr2QmlnMu5Jtrg33h3yCQPeAU474fgOwCTYkTntmD3cEU474fiOzGnHGN32+bzNeCchtIPU+M5CaWcy7mGnCku4JLSzi2vMu6bTzi4W2tk1ANqZDKSdXYCi3DWf5nDRiYhc827MK0FjjjsTVP2NmdOOOZfGAtZNpfHGQI03Ya7xTEWK8tc0skhpKpR2JsHummjKJ1A3yycMuBmcdqKqGTAJmjOnHbOHzeG0E1XNmdOOMbqm+bzNuIUQ2kFqvKVQ2pkEo51IYJ9A3co15tbptNPKQjutA6CdSUDaaQUUZet8msNFJyJyzW2YV4LGHFsSVP1tmdOOOZe2AtZNpfG2QI23Y67xTEWK8tc0skhpL5R2JhLRTod8woA7ENBOB2ASdGROO2YPOxLQTkfmtGOMrn0+bzPuJIR2kBrvLJR2JgqknS6uMXdNp50uFtrpGgDtTATSThegKLsKoR3kmrsxrwSNOXYmqPoVc9ox56IErJtK4wqocc1c45mKFOWvaWSREhJKOxNgd01FymeyleUTBlwGp52KWBkwCcLMacfsYRhOOxWxMHPaMUYXyudtxt2F0A5S4+VCaWcCjHYqAvtMtohrzNF02olYaCcaAO1MANJOBCjKaD7N4aITEbnmGPNK0JhjOUHV34M57Zhz6SFg3VQa7wHU+O7MNZ6pSFH+mkYWKXsIpZ0HcLQT9sa7Zz5hwHviaSe8JzAJ9mJOO2YP98LTTngv5rRjjG6PfN5mvLcQ2kFqfB+htPMAjnbKLOGS0M6+rjHvl047+1poZ78AaOcBIO3sCxTlfvk0h4tOROSa92deCf7HHAmq/gOY0445lwMErJtK4wcANX4gc41nKlKUv6aRRcpBQmnnfty3i6a8t3NwPmHAB8NpJxk7GJgEhzCnHbOHh8BpJxk7hDntGKM7KJ+3GR8qhHaQGj9MKO3cj/sCysDe2zncNeYj0mnncAvtHBEA7dwPpJ3DgaI8Ip/mcNGJiFzzkcwrQWOOhxFU/Ucxpx1zLkcJWDeVxo8Cavxo5hrPVKQof00ji5RjhNLOeNhdk6j0xntsPmHAx8JpJ1F5LDAJjmNOO2YPj4PTTqLyOOa0Y4zumHzeZny8ENpBavwEobQzHkY7iaQlXBLaOdE15pPSaedEC+2cFADtjAfSzolAUZ6UT3O46ERErvlk5pWgMccTCKr+U5jTjjmXUwSsm0rjpwA1fipzjWcqUpS/ppFFymlCaWcc7K7RKe/tnJ5PGPDpcNrRsdOBSXAGc9oxe3gGnHZ07AzmtGOM7rR83mZ8phDaQWr8LKG0Mw5GOzqw93Z6usZ8djrt9LTQztkB0M44IO30BIry7Hyaw0UnInLNFcwrQWOOZxFU/XHmtGPOJS5g3VQajwM1nmCu8UxFivLXNLJISQqlnftw3y6aQjuV+YQBV8JpJx6rBCZBFXPaMXtYBaedeKyKOe0Yo0vm8zbjXkJoB6nx3kJp5z7ct4sGRjt9XGPum047fSy00zcA2rkPSDt9gKLsm09zuOhERK65H/NK0Jhjb4Kqvz9z2jHn0l/Auqk03h+o8QHMNZ6pSFH+mkYWKQOF0s69uE+gjnrjHZRPGPAgOO1Eo4OASTCYOe2YPRwMp51odDBz2jFGNzCftxkPEUI7SI0PFUo798JoJxqxhEtCO8NcYx6eTjvDLLQzPADauRdIO8OAohyeT3O46ERErnkE80rQmONQgqp/JHPaMecyUsC6qTQ+Eqjxc5hrPFORovw1jSxSRgmlnXtgd004hXZG5xMGPBpOO+HoaGASjGFOO2YPx8BpJxwdw5x2jNGNyudtxucKoR2kxs8TSjv3wGgnHBjtjHWN+fx02hlroZ3zA6Cde4C0MxYoyvPzaQ4XnYjINV/AvBI05ngeQdV/IXPaMedyoYB1U2n8QqDGL2Ku8UxFivLXNLJIuVgo7dwNu2ti2hvvJfmEAV8Cp52YvgSYBJcypx2zh5fCaSeWsm7ls9nWjTC6i/N5m/FlQmgHqfHLhdLO3TDaiSlLuCS0c4VrzFem084VFtq5MgDauRtIO1cARXllPs3hohMRuearmFeCxhwvJ6j6r2ZOO+ZcrhawbiqNXw3U+DXMNZ6pSFH+mkYWKdcKpZ27YHdNRHnjvS6fMODr4LQTUdcBk+B65rRj9vB6OO1E1PXMaccY3bX5vM34BiG0g9T4jUJp5y4Y7ZRXWcIloZ2bXGO+OZ12brLQzs0B0M5dQNq5CSjKm/NpDhediMg138K8EjTmeCNB1X8rc9ox53KrgHVTafxWoMZvY67xTEWK8tc0ski5XSjt3In7lIKUT6C+I58w4DvgtBOvvAOYBHcypx2zh3fCaSdeeSdz2jFGd3s+bzO+SwjtIDV+t1DauRP3KQWBfQL1Pa4x35tOO/dYaOfeAGjnTiDt3AMU5b35NIeLTkTkmu9jXgkac7yboOofx5x2zLmME7BuKo2PA2p8PHONZypSlL+mkUXK/UJp5w7YXRNKeW/ngXzCgB+A005IPQBMggnMacfs4QQ47YTUBOa0Y4zu/nzeZjxRCO0gNT5JKO3cgfsE6sDe25nsGvOUdNqZbKGdKQHQzh1A2pkMFOWUfJrDRScics1TmVeCxhwnEVT905jTjjmXaQLWTaXxaUCNT2eu8UxFivLXNLJImSGUdm7H3TUJb7wz8wkDngmnHZWYCUyCWcxpx+zhLDjtqMQs5rRjjG5GPm8zni2EdpAanyOUdm6H0Y6KW8IloZ25rjHPS6eduRbamRcA7QBvID0XKMp5+TSHi05E5JrnM68EjTnOIaj6FzCnHXMuCwSsm0rjC4AaX8hc45mKFOWvaWSRskgo7dwGu2vKU55kW5xPGPBiOO2UVy4GJsES5rRj9nAJnHbKK5cwpx1jdIvyeZvxUiG0g9T4MqG0cxvu93YCe5JtuWvMD6bTznIL7TwYAO3cBqSd5UBRPphPc7joRESueQXzStCY4zKCqn8lc9ox57JSwLqpNL4SqPGHmGs8U5Gi/DWNLFIeFko7t8LuGp3ymWyP5BMG/AicdrR+BJgEjzKnHbOHj8JpR6esW/lstnUjjO7hfN5m/JgQ2kFq/HGhtHMr7km2wD6T7QnXmJ9Mp50nLLTzZAC0cyuQdp4AivLJfJrDRScics1PMa8EjTk+TlD1P82cdsy5PC1g3VQafxqo8WeYazxTkaL8NY0sUp4VSju34B7GSPm9nefyCQN+Lh8/7/PMCcWs+/n8TRsMmpeEKoyhPJvP2/ReEEIVSF2+SGz0iDN5kUDjQRrqzUSG+lI+YcAvERjqy8wN1az75YAMVflr2iTGy/k0CYdad5BJdlMebg+88b6STxjwKwQ34itAR3+VecKaPXyVIAleZf4arUnSVwnw5wXgeb/G/OUCo53XiMy+uqFz+zXg+bzOHPEzEYPy1zSSGN5grnFzxm8QFHJIHZoioThr00vm3oaOu3EWTZ5nQeMMkb7PsY1nb5u7P7/pnOdbTn/b6e84/V2nv+f0953+gdM/dPpHTv/Y6Z84fZXTP3X6Z07/3OlfOP1Lp3/l9NVO/9rp3zh9jdPXOv1bp69z+ndOX+/0752+wekbnf5D+nssb7rvp3jH3rKMvW0Ze8cy9q5l7D3L2PuWsQ8sYx9axj6yjH1sGfvEMrbKMvapZewzy9jnlrEvLGNfWsa+soyttox9bRn7xjK2xjK21jL2rWVsnWXsO8vYesvY95axDZaxjZaxH/I3f++uhfvnPu6fyl9LMR2/ZvkmwHir3wd8CzSXWePbkLn+3a93/M8VcvdLv+t3rvB/916/528u5TlH/b6fuUIpmtAf1H0ulaYv/WEd5yqv2kyr+qO6zRW16F5/XJe5otYc0p/Ufq5IhnzUq2o7VyRjbutPazdXaAs+oT+rzVyRLXqO/rzmcyW24l/6i5rOFdmqF+ovazaXqoGv6q9qMpeqkUfr1Vufq3sN/V5/vbW5wjW+O/Q3W5wrXFWLe0iv2dJckVrdaXpt5rmitbwf9bcZ5opV1fqu1evsc6k63Nv6O9tcqk41gF6/+Vy6jvWE/j59rmSdaxO9IXWuMh91jt7omStU5atm0j8IfUX7B1itl0x56vjHfMKAf8xHP3Wc1D/iDlD/BNhUyle0zR7+BHxFu3oPfwInQVBPj+KSNxnY06M/uwn2S/orGz/nb/706C/59E+P4pxE6Z+BCfQL+HDR4jNJ8zMwGavX/bPQG2kjTEexpDfeX/MJA/4VfiPFkr8Cb6TfmN9IZg9/g99IseRvQm+kjbC4YwlLuCQ30u9ugv2RfiP9brmR/gjgRtoIvJF+BybQH0SHi34jGLnmP4FmlpWFvy1/cg0I/UYwEgX+ApqZbQ+Vv6bNGf9FUMn8JbSS2QDzn3iZN96/8wkD/hteycTL/gYm/z/MKxmzh//AK5l42T/EyY8w0L+YG2hWAc2TGeiLF6nxbXBrDvQ3ejfA9B4PWcIlqYDrFfz7Z/2CrNRq1/wP6RWw+UfUFfAGYAVcrwAnyvoFNIeLTkTkmrOBiZiVhU84Y47bFOAvhpwC2otL+WvanEuOgHVTaTwHqPFc5hrPVKQgih/UXA3AF3ZQtPM97K6JVnnjbVhAGLCZHEs70aqGwAPMAyYn1R7mFaBpJ1qVR3xpIIyuQQFvM84Hm3F1Q68ZqfECobTzPYx2opWWcElop9A15qJ02im00E5RALTzPZB2CoGiLCqgOVx0IiLXXMy8EjTmWEBQ9Zcwpx1zLiUC1k2l8RKgxkuZazxTkaL8NY0sUhoBdRMk7ayH3TWp3zu+bQFhwNvCaSektgUmwXbMacfs4XZw2gmp7ZjTjjG6RgW8zXh7IbSD1PgOQmlnPYx2gvve8R1dY94pnXZ2tNDOTgHQznog7ewIFOVOBTSHi05E5Jp3Zl4JGnPcgaDq34U57Zhz2UXAuqk0vgtQ47sy13imIkX5axpZpOwmlHa+w/2WWArtNC4gDLgxnHaSqjEwCZowpx2zh03gtJNUTZjTjjG63Qp4m3FTIbSD1HgzobTzHYx2EoHRTnPXmFuk005zC+20CIB2vgPSTnOgKFsU0BwuOhGRa27JvBI05tiMoOpvxZx2zLm0ErBuKo23Amq8NXONZypSlL+mkUVKG6G0sw5215SnfCZG2wLCgNvCaadctwUmQTvmtGP2sB2cdspT1q18Ntu6EUbXpoC3GbcXQjtIjXcQSjvrYLRTHthnqXR0jblTOu10tNBOpwBoZx2QdjoCRdmpgOZw0YmIXHNn5pWgMccOBFV/F+a0Y86li4B1U2m8C1DjXZlrPFORovw1jSxSugmlnW9x7+1EvfGqAsKAFf69nagCJoFmTjtmDzX+vZ2oZk47xui6FfA245AQ2kFqvEwo7XyL+3DBiCVcEtoJu8bcPZ12whba6R4A7XwLpJ0wUJTdC2gOF52IyDWXM68EjTmWEVT9Eea0Y84lImDdVBqPADUeZa7xTEWK8tc0skiJCaWdtbC7JhzzxtujgDDgHnDaCcd6AJNgd+a0Y/ZwdzjthGO7M6cdY3SxAt5mvIcQ2kFqfE+htLMWRjvhqCVcEtrZyzXmvdNpZy8L7ewdAO2sBdLOXkBR7l1Ac7joRESueR/mlaAxxz0Jqv59mdOOOZd9BaybSuP7AjW+H3ONZypSlL+mkUXK/kJpZw3uE6hTnmQ7oIAw4APgtBPXBwCT4EDmtGP28EA47cRT1q18Ntu6EUa3fwFvMz5ICO0gNX6wUNpZg/sE6sCeZDvENeZD02nnEAvtHBoA7awB0s4hQFEeWkBzuOhERK75MOaVoDHHgwmq/sOZ0445l8MFrJtK44cDNX4Ec41nKlKUv6aRRcqRQmnnGxztJLzxHlVAGPBReNpJHAVMgqOZ047Zw6PxtJM4mjntGKM7soC3GR8jhHaQGj9WKO18g6OduCVcEto5zjXm49Np5zgL7RwfAO18A6Sd44CiPL6A5nDRiYhc8wnMK0FjjscSVP0nMqcdcy4nClg3lcZPBGr8JOYaz1SkKH9NI4uUk4XSzte4J9ni3nhPKSAM+BT8k2zxU4BJcCpz2jF7eCr+Sbb4qcxpxxjdyQW8zfg0IbSD1PjpQmnna9yTbBWWcElo5wzXmM9Mp50zLLRzZgC08zWQds4AivLMAprDRScics1nMa8EjTmeTlD192ROO+ZcegpYN5XGewI1fjZzjWcqUpS/ppFFSoVQ2lmN+3bRlE+gjhcQBhyH005UxYFJkGBOO2YPE3DaiaoEc9oxRldRwNuMk0JoB6nxSqG0sxpGO5HAPoG6yjXmXum0U2WhnV4B0M5qIO1UAUXZq4DmcNGJiFxzb+aVoDHHSoKqvw9z2jHn0kfAuqk03geo8b7MNZ6pSFH+mkYWKf2E0s5XRLTTv4Aw4P4EtNMfmAQDmNOO2cMBBLQzgDntGKPrV8DbjAcKoR2kxgcJpZ2vBNLOYNeYh6TTzmAL7QwJgHa+AtLOYKAohwihHeSahzKvBI05DiKo+ocxpx1zLsMErJtK48OAGh/OXOOZihTlr2lkkTJCKO18CbtrKlI+k21kAWHAI+G0UxEbCUyCc5jTjtnDc+C0UxE7hzntGKMbUcDbjEcJoR2kxkcLpZ0vYbRTEdhnso1xjfncdNoZY6GdcwOgnS+BtDMGKMpzC2gOF52IyDWfx7wSNOY4mqDqH8ucdsy5jBWwbiqNjwVq/HzmGs9UpCh/TSOLlAuE0s4XONoJe+O9sIAw4AvxtBO+EJgEFzGnHbOHF+FpJ3wRc9oxRndBAW8zvlgI7SA1folQ2vkCRztllnBJaOdS15gvS6edSy20c1kAtPMFkHYuBYrysgKaw0UnInLNlzOvBI05XkJQ9V/BnHbMuVwhYN1UGr8CqPErmWs8U5Gi/DWNLFKuEko7n+O+XTTlvZ2rCwgDvhpOO8nY1cAkuIY57Zg9vAZOO8nYNcxpxxjdVQW8zfhaIbSD1Ph1Qmnnc9y3iwb23s71rjHfkE4711to54YAaOdzIO1cDxTlDQU0h4tOROSab2ReCRpzvI6g6r+JOe2Yc7lJwLqpNH4TUOM3M9d4piJF+WsaWaTcIpR2PoPdNYlKb7y3FhAGfCucdhKVtwKT4DbmtGP28DY47SQqb2NOO8bobingbca3C6EdpMbvEEo7n8FoJ5G0hEtCO3e6xnxXOu3caaGduwKgnc+AtHMnUJR3FdAcLjoRkWu+m3klaMzxDoKq/x7mtGPO5R4B66bS+D1Ajd/LXOOZihTlr2lkkXKfUNr5FHbX6JT3dsYVEAY8Dk47OjYOmATjmdOO2cPxcNrRsfHMaccY3X0FvM34fiG0g9T4A0Jp51MY7ejA3tuZ4BrzxHTamWChnYkB0M6nQNqZABTlxAKaw0UnInLNk5hXgsYcHyCo+iczpx1zLpMFrJtK45OBGp/CXOOZihTlr2lkkTJVKO2swn27aArtTCsgDHganHbisWnAJJjOnHbMHk6H0048Np057Rijm1rA24xnCKEdpMZnCqWdVbhvFw2Mdma5xjw7nXZmWWhndgC0swpIO7OAopxdQHO46ERErnkO80rQmONMgqp/LnPaMecyV8C6qTQ+F6jxecw1nqlIUf6aRhYp84XSzie4T6COeuNdUEAY8AI47USjC4BJsJA57Zg9XAinnWh0IXPaMUY3v4C3GS8SQjtIjS8WSjufwGgnGrGES0I7S1xjXppOO0sstLM0ANr5BEg7S4CiXFpAc7joRESueRnzStCY42KCqn85c9ox57JcwLqpNL4cqPEHmWs8U5Gi/DWNLFJWCKWdj2F3TTiFdlYWEAa8Ek474ehKYBI8xJx2zB4+BKedcPQh5rRjjG5FAW8zflgI7SA1/ohQ2vkYRjvhwGjnUdeYH0unnUcttPNYALTzMZB2HgWK8rECmsNFJyJyzY8zrwSNOT5CUPU/wZx2zLk8IWDdVBp/AqjxJ5lrPFORovw1jSxSnhJKOx/B7pqY9sb7dAFhwE/DaSemnwYmwTPMacfs4TNw2omlrFv5bLZ1I4zuqQLeZvysENpBavw5obTzEYx2YsoSLgntPO8a8wvptPO8hXZeCIB2PgLSzvNAUb5QQHO46ERErvlF5pWgMcfnCKr+l5jTjjmXlwSsm0rjLwE1/jJzjWcqUpS/ppFFyitCaedD2F0TUd54Xy0gDPhVOO1E1KvAJHiNOe2YPXwNTjsR9Rpz2jFG90oBbzN+XQjtIDX+hlDa+RBGO+VVlnBJaOdN15jfSqedNy2081YAtPMhkHbeBIryrQKaw0UnInLNbzOvBI05vkFQ9b/DnHbMubwjYN1UGn8HqPF3mWs8U5Gi/DWNLFLeE0o7H+A+pSDlE6jfLyAM+H047cQr3wcmwQfMacfs4Qdw2olXfsCcdozRvVfA24w/FEI7SI1/JJR2PsB9SkFgn0D9sWvMn6TTzscW2vkkANr5AEg7HwNF+UkBzeGiExG55lXMK0Fjjh8RVP2fMqcdcy6fClg3lcY/BWr8M+Yaz1SkKH9NI4uUz4XSzvuwuyaU8t7OFwWEAX8Bp52Q+gKYBF8ypx2zh1/CaSekvmROO8boPi/gbcZfCaEdpMZXC6Wd93GfQB3Yeztfu8b8TTrtfG2hnW8CoJ33gbTzNVCU3xTQHC46EZFrXsO8EjTmuJqg6l/LnHbMuawVsG4qja8Favxb5hrPVKQof00ji5R1QmnnPdxdk/DG+10BYcDfwWlHJb4DJsF65rRj9nA9nHZUYj1z2jFGt66Atxl/L4R2kBrfIJR23oPRjopbwiWhnY2uMf+QTjsbLbTzQwC0A7yB9EagKH8ooDlcdCIi1/wj80rQmOMGgqr/J+a0Y87lJwHrptL4T0CN/8xc45mKFOWvaWSR8otQ2nkXdteUpzzJ9msBYcC/wmmnvPJXYBL8xpx2zB7+Bqed8srfmNOOMbpfCnib8e9CaAep8T+E0s67uN/bCexJtj9dY/4rnXb+tNDOXwHQzrtA2vkTKMq/CmgOF52IyDX/zbwSNOb4B0HV/w9z2jHn8o+AdVNp/B9kQVXIW+OZihTlr2lkkbINbg8DpZ13YHeNTvlMtnqFhAGbybG0o3U9YBLUL+RNO2YPTYxY2tEp61Y+m23dCKPbppC3GWeDzfi/CQleM1LjOcA1B0k77+CeZAvsM9lyXWNuUJiVSja5hZvTjvlH1LTzDpB2coGibFBIc7joRESuuSHzStCYY04h/mLII764lL+mzbnkCVg3lcbzgBrPZ67xTEWK8tc0skgpEEo7b+Mexkj5vZ3CQsKACwvx8xYxJxSz7qLCTRsMmpeEKoyhFBTyNr1iIVSB1GUJsdEjzqSEQONBGupbRIZaWkgYcCmBoTZibqhm3Y0CMlTlr2mTGI0KaRIOte4gk+zNfNweeOPdtpAw4G0JbsRtgY6+HfOENXu4HUESbMf8NVqTpNsR4E8x8Ly3Z/5ygdHO9kRmX93Qub098Hx2YI74mYhB+WsaSQw7Mte4OeMdCQo5pA5NkVCcteklc29Dx71NFk2eZ0HjDJG+z7GNZ2+buz/v5Jznzk7fxem7On03pzd2ehOnN3V6M6c3d3oLp7d0eiunt3Z6G6e3dXo7p7d3egend3R6J6d3dnoXp3d1ejenK6drp4ecXub0sNO7O708/T2Wndz3U7xjO1vGdrGM7WoZ280y1tgy1sQy1tQy1swy1twy1sIy1tIy1soy1toy1sYy1tYy1s4y1t4y1sEy1tEy1sky1tky1sUy1tUy1s0ypixj2jIWsoyVWcbClrHulrHyws3fu2vh/rmP+6fy11JMx69Z7gQw3ur3AXcGzWXWuAtkrn/3a1f/c4Xc/dK7+Z0r/N+91439zaU856ib+JkrlKIJ3bTuc6k0felmdZyrvGozrermdZsratG9blGXuaLWHNItaz9XJEM+6la1nSuSMbd169rNFdqCT+g2tZkrskXP0W1rPldiK/6l29V0rshWvVC3r9lcqga+qjvUZC5VI4/WHbc+V/ca+r3utLW5wjW+O3TnLc4VrqrFPaS7bGmuSK3uNN0181zRWt6PuluGuWJVtb5rtbLPpepwb2ttm0vVqQbQoc3n0nWsJ3RZ+lzJOtcmOpw6V5mPOkd398wVqvJVM+lyoa9ol8NqvWTKU8eRQsKAI4Xop46TOoI7QB0FbCrlK9pmD6PAV7Sr9zAKToKgnh7FJW8ysKdHY26C9Uh/ZSNWuPnToz0K6Z8exTmJ0jFgAvUAHy5afCZpYsBkrF53TOiN1B2mo1jSG+/uhYQB7w6/kWLJ3YE30h7MbySzh3vAb6RYcg+hN1J3WNyxhCVckhtpTzfB9kq/kfa03Eh7BXAjdQfeSHsCE2gvosNFvxGMXPPeQDPLysLfllHXgNBvBCNRYB+gmdn2UPlr+j9nTFDJ7CO0kgnD/Cde5o1330LCgPeFVzLxsn2Byb8f80rG7OF+8EomXrYfcfIjDHQf5ga6P3gPqxv64kVq/ABg7gVZAYdhccdDlnBJKuADXWM+KL0CPtBSAR8UQAWMu4GUPhAoyoOIDhediMg1H0xcASt/TRtzPICgejuEedVqzuUQAeum0vghQI0fylzjmYoUSPEDmusw8IUdFO2Uwe6aaJU33sMLCQM+HE470arDgQd4BHPaMXt4BJx2olVHMKcdY3SHFfI24yPBZlzd0GtGavwoobRTBos7WmkJl4R2jnaN+Zh02jnaQjvHBEA7uBtI6aOBojyG6HDRiYhc87HMK0FjjkcRVP3HMacdcy7HCVg3lcaPA2r8eOYaz1SkKH9NI4uUE4S+txOC3TWp3zt+YiFhwCfCaSekTgQmwUnMacfs4Ulw2gmpk5jTjjG6Ewp5m/HJQmgHqfFThNJOCBZ3cN87fqprzKel086pFto5LQDawd1ASp8KFOVpRIeLTkTkmk9nXgkaczyFoOo/gzntmHM5Q8C6qTR+BlDjZzLXeKYiRflrGlmknCWUdjTsrkmm0E7PQsKAe8JpJ6l6ApPgbOa0Y/bwbDjtJNXZzGnHGN1ZhbzNuEII7SA1HhdKOxoWdyIw2km4xpxMp52EhXaSAdAO7gZSOgEUZZLocNGJiFxzJfNK0JhjnKDqr2JOO+ZcqgSsm0rjVUCN92Ku8UxFivLXNLJI6S2UdhTsrilP+UyMPoWEAfeB00657gNMgr7MacfsYV847ZSnrFv5bLZ1I4yudyFvM+4nhHaQGu8vlHYULO7ywD5LZYBrzAPTaWeAhXYGBkA7uBtI6QFAUQ4kOlx0IiLXPIh5JWjMsT9B1T+YOe2YcxksYN1UGh8M1PgQ5hrPVKQof00ji5ShQmmnG+69nag33mGFhAEPw7+3Ex0GTILhzGnH7OFw/Hs70eHMaccY3dBC3mY8QgjtIDU+UijtdIPFnYxYwiWhnXNcYx6VTjvnWGhnVAC0g7uBlD4HKMpRRIeLTkTkmkczrwSNOY4kqPrHMKcdcy5jBKybSuNjgBo/l7nGMxUpyl/TyCLlPKG00xV214Rj3njHFhIGPBZOO+HYWGASnM+cdsweng+nnXDsfOa0Y4zuvELeZnyBENpBavxCobTTFRZ3OGoJl4R2LnKN+eJ02rnIQjsXB0A7uBtI6YuAoryY6HDRiYhc8yXMK0FjjhcSVP2XMqcdcy6XClg3lcYvBWr8MuYaz1SkKH9NI4uUy4XSThfYXRNPeZLtikLCgK+A005cXwFMgiuZ047ZwyvhtBNPWbfy2WzrRhjd5YW8zfgqIbSD1PjVQmmnCyzueGBPsl3jGvO16bRzjYV2rg2AdnA3kNLXAEV5LdHhohMRuebrmFeCxhyvJqj6r2dOO+ZcrhewbiqNXw/U+A3MNZ6pSFH+mkYWKTcKpZ3OONpJeOO9qZAw4JvwtJO4CZgENzOnHbOHN+NpJ3Ezc9oxRndjIW8zvkUI7SA1fqtQ2umMK4jjlnBJaOc215hvT6ed2yy0c3sAtIO7gZS+DSjK24kOF52IyDXfwbwSNOZ4K0HVfydz2jHncqeAdVNp/E6gxu9irvFMRYry1zSySLlbKO10wj3JFvfGe08hYcD34J9ki98DTIJ7mdOO2cN78U+yxe9lTjvG6O4u5G3G9wmhHaTGxwmlnU64h50qLOGS0M5415jvT6ed8RbauT8A2sHdQEqPB4ryfqLDRScics0PMK8EjTmOI6j6JzCnHXMuEwSsm0rjE4Aan8hc45mKFOWvaWSRMkko7XSE3TXRlE+gnlxIGPBkOO1E1WRgEkxhTjtmD6fAaSeqpjCnHWN0kwp5m/FUIbSD1Pg0obTTERZ3JLBPoJ7uGvOMdNqZbqGdGQHQDu4GUno6UJQziA4XnYjINc9kXgkac5xGUPXPYk475lxmCVg3lcZnATU+m7nGMxUpyl/TyCJljlDa6UBEO3MLCQOeS0A7c4FJMI857Zg9nEdAO/OY044xujmFvM14vhDaQWp8gVDa6SCQdha6xrwonXYWWmhnUQC0g7uBlF4IFOUiIbSDXPNi5pWgMccFBFX/Eua0Y85liYB1U2l8CVDjS5lrPFORovw1jSxSlgmlnfawu6Yi5TPZlhcSBrwcTjsVseXAJHiQOe2YPXwQTjsVsQeZ044xumWFvM14hRDaQWp8pVDaaQ+LuyKwz2R7yDXmh9Np5yEL7TwcAO3gbiClHwKK8mGiw0UnInLNjzCvBI05riSo+h9lTjvmXB4VsG4qjT8K1PhjzDWeqUhR/ppGFimPC6WddjjaCXvjfaKQMOAn8LQTfgKYBE8ypx2zh0/iaSf8JHPaMUb3eCFvM35KCO0gNf60UNpphyuIyyzhktDOM64xP5tOO89YaOfZAGgHdwMp/QxQlM8SHS46EZFrfo55JWjM8WmCqv955rRjzuV5Aeum0vjzQI2/wFzjmYoU5a9pZJHyolDaaQu7a5Ip7+28VEgY8Etw2knGXgImwcvMacfs4ctw2knGXmZOO8boXizkbcavCKEdpMZfFUo7bWFxJwN7b+c115hfT6ed1yy083oAtIO7gZR+DSjK14kOF52IyDW/wbwSNOb4KkHV/yZz2jHn8qaAdVNp/E2gxt9irvFMRYry1zSySHlbKO20gd01iUpvvO8UEgb8Dpx2EpXvAJPgXea0Y/bwXTjtJCrfZU47xujeLuRtxu8JoR2kxt8XSjttYHEnkpZwSWjnA9eYP0ynnQ8stPNhALSDu4GU/gAoyg+JDhediMg1f8S8EjTm+D5B1f8xc9ox5/KxgHVTafxjoMY/Ya7xTEWK8tc0skhZJZR2WsPuGp3y3s6nhYQBfwqnHR37FJgEnzGnHbOHn8FpR8c+Y047xuhWFfI248+F0A5S418IpZ3WsLh1YO/tfOka81fptPOlhXa+CoB2cDeQ0l8CRfkV0eGiExG55tXMK0Fjjl8QVP1fM6cdcy5fC1g3lca/Bmr8G+Yaz1SkKH9NI4uUNUJppxXsromn0M7aQsKA18JpJx5bC0yCb5nTjtnDb+G0E499y5x2jNGtKeRtxuuE0A5S498JpZ1WsLjjgdHOeteYv0+nnfUW2vk+ANrB3UBKrweK8nuiw0UnInLNG5hXgsYcvyOo+jcypx1zLhsFrJtK4xuBGv+BucYzFSnKX9PIIuVHobTTEnbXRKPeeH8qJAz4JzjtRKM/AZPgZ+a0Y/bwZzjtRKM/M6cdY3Q/FvI241+E0A5S478KpZ2WsLijEUu4JLTzm2vMv6fTzm8W2vk9ANrB3UBK/wYU5e9Eh4tOROSa/2BeCRpz/JWg6v+TOe2Yc/lTwLqpNP4nUON/Mdd4piJF+WsaWaT8LZR2WsDumnAK7fxTSBjwP3DaCUf/QSZBEW/aMXtoYsTSTjjqXbfy2WzrRhjd34W8zXibIqwZVzf0mpEarwdcc5C00wLmGeHAaKd+0b9/ZhdlpZJN/aLNacf8I2raaQGknfpAUWYX0RwuOhGRa84Bmw864Yw51ivCXwy5xBeX8te0OZdcAeum0nguUOMNmGs8U5Gi/DWNLFIaAnUTJO00h901Me2NN6+IMGAzOZZ2YjoPmAT5zGnH7GE+nHZiKetWPptt3Qija1jE24wLhNAOUuOFQmmnOYx2YsoSLgntFLnGXJxOO0UW2ikOgHaaA2mnCCjK4iKaw0UnInLNJcwrQWOOhQRVfylz2jHnUipg3VQaLwVqvBFzjWcqUpS/ppFFyrZCaacZ7K6JKG+82xURBrwdnHYiajtgEmzPnHbMHm4Pp52I2p457Rij27aItxnvIIR2kBrfUSjtNIPRTnmVJVwS2tnJNead02lnJwvt7BwA7TQD0s5OQFHuXERzuOhERK55F+aVoDHHHQmq/l2Z0445l10FrJtK47sCNb4bc41nKlKUv6aRRUpjobTTFPcpBSmfQN2kiDDgJnDaiVc2ASZBU+a0Y/awKZx24pVNmdOOMbrGRbzNuJkQ2kFqvLlQ2mmK+0X2wD6BuoVrzC3TaaeFhXZaBkA7TYG00wIoypZFNIeLTkTkmlsxrwSNOTYnqPpbM6cdcy6tBaybSuOtgRpvw1zjmYoU5a9pZJHSVijtNIHdNaGU93baFREG3A5OOyHVDpgE7ZnTjtnD9nDaCan2zGnHGF3bIt5m3EEI7SA13lEo7TTBfUhxYO/tdHKNuXM67XSy0E7nAGinCZB2OgFF2bmI5nDRiYhccxfmlaAxx44EVX9X5rRjzqWrgHVTabwrUOPdmGs8U5Gi/DWNLFKUUNppjLtrEt54dRFhwBpOOyqhgUkQYk47Zg9DcNpRiRBz2jFGp4p4m3GZENpBajwslHYa4z7ZJG4Jl4R2urvGXJ5OO90ttFMeAO0AbyDdHSjK8iKaw0UnInLNEeaVoDHHMEHVH2VOO+ZcogLWTaXxKFDjMeYaz1SkKH9NI4uUHkJpZzfYXVOe8iTb7kWEAe8Op53yyt2BSbAHc9oxe7gHnHbKK/dgTjvG6HoU8TbjPYXQDlLjewmlnd1wv7cT2JNse7vGvE867extoZ19AqCd3YC0szdQlPsU0RwuOhGRa96XeSVozHEvgqp/P+a0Y85lPwHrptL4fkCN789c45mKFOWvaWSRcoBQ2tkVdtfolM9kO7CIMOAD4bSj9YHAJDiIOe2YPTwITjs6Zd3KZ7OtG2F0BxTxNuODhdAOUuOHCKWdXXFPsgX2mWyHusZ8WDrtHGqhncMCoJ1dgbRzKFCUhxXRHC46EZFrPpx5JWjM8RCCqv8I5rRjzuUIAeum0vgRQI0fyVzjmYoU5a9pZJFylFDa2QX4PUHeeI8uIgz46CL8vMcwJxSz7mOKNm0waF4SqjCGclQRb9M7VghVIHV5HLHRI87kOAKNB2moOxMZ6vFFhAEfT2CoJzA3VLPuEwIyVOWvaZMYJxTRJBxq3UEm2U7ILzjzxHliEWHAJxLciCcCHf0k5glr9vAkgiQ4iflrtCZJTyLAn2OB530y85cLjHZOJjL76obO7ZOB53MKc8TPRAzKX9NIYjiVucbNGZ9KUMghdWiKhOKsTS+Zexv8t+qzaPI8CxpniPR9jm08e9vc/fk05zxPd/oZTj/T6Wc5vafTz3Z6hdPjTk84Pen0SqdXOb2X03s7vY/T+zq9n9P7O32A0wc6fZDTBzt9iNOHOn2Y04c7fYTTRzr9HKePcvro9PdYTnPfT/GOnW4ZO8MydqZl7CzLWE/L2NmWsQrLWNwylrCMJS1jlZaxKstYL8tYb8tYH8tYX8tYP8tYf8vYAMvYQMvYIMvYYMvYEMvYUMvYMMvYcMvYCMvYSMvYOZaxUZax0UWbv3fXwv1zH/dP5a+lmI5fszwNYLzV7wOeDprLrPEMyFz/7teZ/ucKufulz/I7V/i/e697+ptLec5Rn+1nrlCKJnRF3edSafrS8TrOVV61mVZ1om5zRS2618m6zBW15pCurP1ckQz5qKtqO1ckY27rXrWbK7QFn9C9azNXZIueo/vUfK7EVvxL963pXJGteqHuV7O5VA18VfevyVyqRh6tB2x9ru419Hs9cGtzhWt8d+hBW5wrXFWLe0gP3tJckVrdaXpI5rmitbwf9dAMc8Wqan3X6mH2uVQd7m093DaXqlMNoEdsPpeuYz2hR6bPlaxzbaLPSZ2rzEedo0d55gpV+aqZ9Gihr2iPhtV6yZSnjscUEQY8pgj91HFSj8EdoD4XsKmUr2ibPTwX+Ip29R6eC06CoJ4exSVvMrCnR89zE2xs+isb5xVt/vTo2CL6p0dxTqL0ecAEGgs+XLT4TNKcB0zG6nWfJ/RGGgXTUSzpjff8IsKAz4ffSLHk+cAb6QLmN5LZwwvgN1IseYHQG2kULO5YwhIuyY10oZtgF6XfSBdabqSLAriRRgFvpAuBCXQR0eGi3whGrvlioJllZeFvy3NdA0K/EYxEgUuAZmbbQ+WvaXPGlxBUMpcIrWTOgflPvMwb76VFhAFfCq9k4mWXApP/MuaVjNnDy+CVTLzsMuLkRxjoJcwN9HLwHlY39MWL1PgVwNwLsgI+BxZ3PGQJl6QCvtI15qvSK+ArLRXwVQFUwLgbSOkrgaK8iuhw0YmIXPPVxBWw8te0MccrCKq3a5hXreZcrhGwbiqNXwPU+LXMNZ6pSEEUP6i5rgNf2EHRzkjYXROt8sZ7fRFhwNfDaSdadT3wAG9gTjtmD2+A00606gbmtGOM7roi3mZ8I9iMqxt6zUiN3ySUdkbC4o5WWsIloZ2bXWO+JZ12brbQzi0B0A7uBlL6ZqAobyE6XHQiItd8K/NK0JjjTQRV/23Macecy20C1k2l8duAGr+ducYzFSnKX9PIIuUOoe/tjIDdNanfO35nEWHAd8JpJ6TuBCbBXcxpx+zhXXDaCam7mNOOMbo7inib8d1CaAep8XuE0s4IWNzBfe/4va4x35dOO/daaOe+AGgHdwMpfS9QlPcRHS46EZFrHse8EjTmeA9B1T+eOe2YcxkvYN1UGh8P1Pj9zDWeqUhR/ppGFikPCKWd4bC7JplCOxOKCAOeAKedpJoATIKJzGnH7OFEOO0k1UTmtGOM7oEi3mY8SQjtIDU+WSjtDIfFnQiMdqa4xjw1nXamWGhnagC0g7uBlJ4CFOVUosNFJyJyzdOYV4LGHCcTVP3TmdOOOZfpAtZNpfHpQI3PYK7xTEWK8tc0skiZKZR2hsHumvKUz8SYVUQY8Cw47ZTrWcAkmM2cdswezobTTnnKupXPZls3wuhmFvE24zlCaAep8blCaWcYLO7ywD5LZZ5rzPPTaWeehXbmB0A7uBtI6XlAUc4nOlx0IiLXvIB5JWjMcS5B1b+QOe2Yc1koYN1UGl8I1Pgi5hrPVKQof00ji5TFQmlnKO69nag33iVFhAEvwb+3E10CTIKlzGnH7OFS/Hs70aXMaccY3eIi3ma8TAjtIDW+XCjtDIXFnYxYwiWhnQddY16RTjsPWmhnRQC0g7uBlH4QKMoVRIeLTkTkmlcyrwSNOS4nqPofYk475lweErBuKo0/BNT4w8w1nqlIUf6aRhYpjwilnSGwuyYc88b7aBFhwI/CaSccexSYBI8xpx2zh4/BaScce4w57Rije6SItxk/LoR2kBp/QijtDIHFHY5awiWhnSddY34qnXaetNDOUwHQDu4GUvpJoCifIjpcdCIi1/w080rQmOMTBFX/M8xpx5zLMwLWTaXxZ4Aaf5a5xjMVKcpf08gi5TmhtDMYdtfEU55ke76IMODn4bQT188Dk+AF5rRj9vAFOO3EU9atfDbbuhFG91wRbzN+UQjtIDX+klDaGQyLOx7Yk2wvu8b8SjrtvGyhnVcCoB3cDaT0y0BRvkJ0uOhERK75VeaVoDHHlwiq/teY0445l9cErJtK468BNf46c41nKlKUv6aRRcobQmlnEI52Et543ywiDPhNPO0k3gQmwVvMacfs4Vt42km8xZx2jNG9UcTbjN8WQjtIjb8jlHYG4QriuCVcEtp51zXm99Jp510L7bwXAO3gbiCl3wWK8j2iw0UnInLN7zOvBI05vkNQ9X/AnHbMuXwgYN1UGv8AqPEPmWs8U5Gi/DWNLFI+Eko7A3FPssW98X5cRBjwx/gn2eIfA5PgE+a0Y/bwE/yTbPFPmNOOMbqPinib8SohtIPU+KdCaWcg7mGnCku4JLTzmWvMn6fTzmcW2vk8ANrB3UBKfwYU5edEh4tOROSav2BeCRpz/JSg6v+SOe2Yc/lSwLqpNP4lUONfMdd4piJF+WsaWaSsFko7A2B3TTTlE6i/LiIM+Gs47UTV18Ak+IY57Zg9/AZOO1H1DXPaMUa3uoi3Ga8RQjtIja8VSjsDYHFHAvsE6m9dY16XTjvfWmhnXQC0g7uBlP4WKMp1RIeLTkTkmr9jXgkac1xLUPWvZ0475lzWC1g3lcbXAzX+PXONZypSlL+mkUXKBqG005+IdjYWEQa8kYB2NgKT4AfmtGP28AcC2vmBOe0Yo9tQxNuMfxRCO0iN/ySUdvoLpJ2fXWP+JZ12frbQzi8B0A7uBlL6Z6AofxFCO8g1/8q8EjTm+BNB1f8bc9ox5/KbgHVTafw3oMZ/Z67xTEWK8tc0skj5Qyjt9IPdNRUpn8n2ZxFhwH/Caaci9icwCf5iTjtmD/+C005F7C/mtGOM7o8i3mb8txDaQWr8H6G00w8Wd0Vgn8mWVezuRXFWKtmY/yGddsw/oqYd3A3kCL4YJ8ptimkOF52IyDXXK8aaDzrhjDn+Q1D11y+mvbiUv6bNudQv5r9uKo3XB2o8m7nGMxUpyl/TyCIlB6ibIGmnL452wt54c4sJAzaTg2knnAtMggbA5KTawwbFcNoJNyC+NBBGl1PM24wbgs24uqHXjNR4HnDNQdJOXxztlFnCJaGdfNeYC9JpJ99COwUB0E5fIO3kA0VZUExzuOhERK65kHklaMwxj6DqL2JOO+ZcigSsm0rjRUCNFzPXeKYiRflrGlmklAilnT6wuyaZ8t5OaTFhwKVw2knGSoFJ0Ig57Zg9bASnnWSsEXPaMUZXUszbjLcVQjtIjW8nlHb6wGgnGdh7O9u7xrxDOu1sb6GdHQKgnT5A2tkeKModimkOF52IyDXvyLwSNOa4HUHVvxNz2jHnspOAdVNpfCegxndmrvFMRYry1zSySNlFKO30ht01iUpvvLsWEwa8K5x2EpW7ApNgN+a0Y/ZwNzjtJCp3Y047xuh2KeZtxo2F0A5S402E0k5vGO0kkpZwSWinqWvMzdJpp6mFdpoFQDu9gbTTFCjKZsU0h4tOROSamzOvBI05NiGo+lswpx1zLi0ErJtK4y2AGm/JXOOZihTlr2lkkdJKKO30gt01OuW9ndbFhAG3htOOjrUGJkEb5rRj9rANnHZ0rA1z2jFG16qYtxm3FUI7SI23E0o7vWC0owN7b6e9a8wd0mmnvYV2OgRAO72AtNMeKMoOxTSHi05E5Jo7Mq8EjTm2I6j6OzGnHXMunQSsm0rjnYAa78xc45mKFOWvaWSR0kUo7VTB7pp4Cu10LSYMuCucduKxrsAk6MacdswedoPTTjzWjTntGKPrUszbjJUQ2kFqXAulnSoY7cQDo52Qa8xl6bQTstBOWQC0UwWknRBQlGXFNIeLTkTkmsPMK0Fjjpqg6u/OnHbMuXQXsG4qjXcHarycucYzFSnKX9PIIiUilHYqcZ9AHfXGGy0mDDgKp51oNApMghhz2jF7GIPTTjQaY047xugixbzNuIcQ2kFqfHehtFMJo51oxBIuCe3s4Rrznum0s4eFdvYMgHYqgbSzB1CUexbTHC46EZFr3ot5JWjMcXeCqn9v5rRjzmVvAeum0vjeQI3vw1zjmYoU5a9pZJGyr1DaScLumnAK7exXTBjwfnDaCUf3AybB/sxpx+zh/nDaCUf3Z047xuj2LeZtxgcIoR2kxg8USjtJGO2EA6Odg1xjPjiddg6y0M7BAdBOEkg7BwFFeXAxzeGiExG55kOYV4LGHA8kqPoPZU475lwOFbBuKo0fCtT4Ycw1nqlIUf6aRhYphwulnQTsrolpb7xHFBMGfAScdmL6CGASHMmcdsweHgmnnVjKupXPZls3wugOL+ZtxkcJoR2kxo8WSjsJGO3ElCVcEto5xjXmY9Np5xgL7RwbAO0kgLRzDFCUxxbTHC46EZFrPo55JWjM8WiCqv945rRjzuV4Aeum0vjxQI2fwFzjmYoU5a9pZJFyolDaicPumojyxntSMWHAJ8FpJ6JOAibBycxpx+zhyXDaiaiTmdOOMboTi3mb8SlCaAep8VOF0k4cRjvlVZZwSWjnNNeYT0+nndMstHN6ALQTB9LOaUBRnl5Mc7joRESu+QzmlaAxx1MJqv4zmdOOOZczBaybSuNnAjV+FnONZypSlL+mkUVKT6G0U4H7lIKUT6A+u5gw4LPhtBOvPBuYBBXMacfsYQWcduKVFcxpxxhdz2LeZhwXQjtIjSeE0k4F7lMKAvsE6qRrzJXptJO00E5lALRTAaSdJFCUlcU0h4tOROSaq5hXgsYcEwRVfy/mtGPOpZeAdVNpvBdQ472ZazxTkaL8NY0sUvoIpZ2zYXdNKOW9nb7FhAH3hdNOSPUFJkE/5rRj9rAfnHZCqh9z2jFG16eYtxn3F0I7SI0PEEo7Z+M+gTqw93YGusY8KJ12BlpoZ1AAtHM2kHYGAkU5qJjmcNGJiFzzYOaVoDHHAQRV/xDmtGPOZYiAdVNpfAhQ40OZazxTkaL8NY0sUoYJpZ2euLsm4Y13eDFhwMPhtKMSw4FJMII57Zg9HAGnHZUYwZx2jNENK+ZtxiOF0A5S4+cIpZ2eMNpRcUu4JLQzyjXm0em0M8pCO6MDoB3gDaRHAUU5upjmcNGJiFzzGOaVoDHHcwiq/nOZ0445l3MFrJtK4+cCNX4ec41nKlKUv6aRRcpYobRzFuyuKU95ku38YsKAz4fTTnnl+cAkuIA57Zg9vABOO+WVFzCnHWN0Y4t5m/GFQmgHqfGLhNLOWbjf2wnsSbaLXWO+JJ12LrbQziUB0M5ZQNq5GCjKS4ppDhediMg1X8q8EjTmeBFB1X8Zc9ox53KZgHVTafwyoMYvZ67xTEWK8tc0ski5QijtnAm7a3TKZ7JdWUwY8JVw2tH6SmASXMWcdsweXgWnHZ2ybuWz2daNMLorinmb8dVCaAep8WuE0s6ZuCfZAvtMtmtdY74unXautdDOdQHQzplA2rkWKMrrimkOF52IyDVfz7wSNOZ4DUHVfwNz2jHncoOAdVNp/Aagxm9krvFMRYry1zSySLlJKO2cgXsYI+X3dm4uJgz45mL8vLcwJxSz7luKN20waF4SqjCGclMxb9O7VQhVIHV5G7HRI87kNgKNB2mopxMZ6u3FhAHfTmCodzA3VLPuOwIyVOWvaZMYdxTTJBxq3UEm2WlFuD3wxntnMWHAdxLciHcCHf0u5glr9vAugiS4i/lrtCZJ7yLAn1uB530385cLjHbuJjL76obO7buB53MPc8TPRAzKX9NIYriXucbNGd9LUMghdWiKBJOG1S+Ze1uzTHFrVac2p8Fmc9VxJqXmps9V55mUmpc6l4+ZlJrfYAvnXMuZF2Seq9YxLsw0Vx1Wu8g+V532bXGDGuRFDWdesvW5ahzj0q3NVYvVLtvyXLXat+U12a8azvxgzefaaowrajpXDVa7smZz1WjfHqrNfm1l5odrP1fGGB+p7VxbWO2jtZtri/v2WF32K8PMj9d9rs1ifKKuc1lW+2Td5rLu21N+9itt5qf9z/XfGJ/xO5dntc/6mytl355D7Jc77wuouZwIX8TM9Z+1voRbI90zFypE+jxHdc1r/mzu/nyfU2iOc/p4p9/v9AecPsHpE50+yemTnT7F6VOdPs3p050+w+kznT7L6bOdPsfpc50+z+nznb7A6Qudvsjpi52+xOlLnb7M6cud/qDTVzh9ZfqzJPe5z414x8ZZxsZbxu63jD1gGZtgGZtoGZtkGZtsGZtiGZtqGZtmGZtuGZthGZtpGZtlGZttGZtjGZtrGZtnGZtvGVtgGVtoGVtkGVtsGVtiGVtqGVtmGVtuGXvQMrbCMrayePNnlPZ2/9zH/dObPHVp/4MrVav2P7iq3cz/g6vazfw/uKrdzP+Dq9rN/D+4qt3M/4Or2s0rAa78vvh9H+CF9OrnuseB5jLrHA+Z6989u9//XCF3v/QDfucK/3fv9QR/cynPOeqJfuYKpWhCT6r7XCpNX3pyHecqr9pMq3pK3eaKWnSvp9Zlrqg1h/S02s8VyZCPenpt54pkzG09o3ZzhbbgE3pmbeaKbNFz9Kyaz5XYin/p2TWdK7JVL9RzajaXqoGv6rk1mUvVyKP1vK3P1b2Gfq/nb22ucI3vDr1gi3OFq2pxD+mFW5orUqs7TS/KPFe0lvejXpxhrlhVre9avcQ+l6rDva2X2uZSdaoB9LLN59J1rCf08vS5knWuTfSDqXOV+ahz9ArPXKEqXzWTXin0CcWVsFovmfJb5A8VEwb8UDH6t8iT+iHcAeqHAZtK+YSi2cOHgU8oVu/hw+AkCOq3gXHJmwzst4EfcRPs0fR3cB4p3vy3gR8tpv9tYJyTKP0IMIEeBR8uWnwmaR4BJmP1uh8ReiOtgOkolvTG+1gxYcCPwW+kWPIx4I30OPMbyezh4/AbKZZ8XOiNtAIWdyxhCZfkRnrCTbAn02+kJyw30pMB3EgrgDfSE8AEepLocFEGVB0ncs1PAc0sKwt/Wz7sGlA9sAaRKPA00Mxse6j8NW3O+GmCSuZpoZXMgzD/iZd5432mmDDgZ+CVTLzsGWDyP8u8kjF7+Cy8komXPUuc/AgDfZq5gT4H3sPqhr54kRp/Hph7QVbAD8Lijocs4ZJUwC+4xvxiegX8gqUCfjGAChh3Ayn9AlCULxIdLjoRkWt+ibgCVv6aNub4PEH19jLzqtWcy8sC1k2l8ZeBGn+FucYzFSmI4gc116vgCzso2lkOu2uiVd54XysmDPg1OO1Eq14DHuDrzGnH7OHrcNqJVr3OnHaM0b1azNuM3wCbcXVDrxmp8TeF0s5yWNzRSku4JLTzlmvMb6fTzlsW2nk7ANrB3UBKvwUU5dtEh4tOROSa32FeCRpzfJOg6n+XOe2Yc3lXwLqpNP4uUOPvMdd4piJF+WsaWaS8L/S9nWWwuyaU8smOHxQTBvwBnHZC6gNgEnzInHbMHn4Ip52Q+pA57Rije7+Ytxl/JIR2kBr/WCjtLIPFrass4ZLQzieuMa9Kp51PLLSzKgDawd1ASn8CFOUqosNFJyJyzZ8yrwSNOX5MUPV/xpx2zLl8JmDdVBr/DKjxz5lrPFORovw1jSxSvhBKO0thd00yhXa+LCYM+Es47STVl8Ak+Io57Zg9/ApOO0n1FXPaMUb3RTFvM14thHaQGv9aKO0shcWdCIx2vnGNeU067XxjoZ01AdAO7gZS+hugKNcQHS46EZFrXsu8EjTm+DVB1f8tc9ox5/KtgHVTafxboMbXMdd4piJF+WsaWaR8J5R2lsDumvKUz8RYX0wY8Ho47ZTr9cAk+J457Zg9/B5OO+Up61Y+m23dCKP7rpi3GW8QQjtIjW8USjtLYHGXB/ZZKj+4xvxjOu38YKGdHwOgHdwNpPQPQFH+SHS46ERErvkn5pWgMceNBFX/z8xpx5zLzwLWTaXxn4Ea/4W5xjMVKcpf08gi5VehtLMY995O1Bvvb8WEAf+Gf28n+hswCX5nTjtmD3/Hv7cT/Z057Rij+7WYtxn/IYR2kBr/UyjtLIbFnYxYwiWhnb9cY/47nXb+stDO3wHQDu4GUvovoCj/JjpcdCIi1/wP80rQmOOfBFW/KbdAMZJc2OZcTIzc102lcW+cfufapoS3xjMVKcpf08gipR5QN0HSziLYXROOeeOtX0IYsJkcSzvhWH1gEmQDk5NqD7NL0LQTjmUTXxoIo6tXwtuMc8BmXN3Qa0ZqPBeZe1nB0c4iWHEYjlrCJaGdBq4xN6y+YarJpkHJ5rRj/hE17SwC0k4DoCgbltAcLjoRkWvOY14JGnPMJaj685nTjjmXfAHrptJ4PlDjBcw1nqlIUf6aRhYphUJpZyHsromnPMlWVEIYcBGcduK6CJgExcxpx+xhMZx24inrVj6bbd0Ioyss4W3GJUJoB6nxUqG0sxBGO/HAnmRr5Brztum008hCO9sGQDsLgbTTCCjKbUtoDhediMg1b8e8EjTmWEpQ9W/PnHbMuWwvYN1UGt8eqPEdmGs8U5Gi/DWNLFJ2FEo7C3C0k/DGu1MJYcA74WknsRMwCXZmTjtmD3fG005iZ+a0Y4xuxxLeZryLENpBanxXobSzAEc7cUu4JLSzm2vMjdNpZzcL7TQOgHYWAGlnN6AoG5fQHC46EZFrbsK8EjTmuCtB1d+UOe2Yc2kqYN1UGm8K1Hgz5hrPVKQof00ji5TmQmlnPu5Jtrg33hYlhAG3wD/JFm8BTIKWzGnH7GFL/JNs8ZbMaccYXfMS3mbcSgjtIDXeWijtzMc9yVZhCZeEdtq4xtw2nXbaWGinbQC0Mx9IO22AomxbQnO46ERErrkd80rQmGNrgqq/PXPaMefSXsC6qTTeHqjxDsw1nqlIUf6aRhYpHYXSzjzYXRNN+QTqTiWEAXeC005UdQImQWfmtGP2sDOcdqKqM3PaMUbXsYS3GXcRQjtIjXcVSjvzYLQTCewTqLu5xqzSaaebhXZUALQzD0g73YCiVCU0h4tOROSaNfNK0JhjV4KqP8Scdsy5hASsm0rjIaDGy5hrPFORovw1jSxSwkJpZy4R7XQvIQy4OwHtdAcmQTlz2jF7WE5AO+XMaccYXbiEtxlHhNAOUuNRobQzVyDtxFxj7pFOOzEL7fQIgHbmAmknBhRlDyG0g1zz7swrQWOOUYKqfw/mtGPOZQ8B66bS+B5Aje/JXOOZihTlr2lkkbKXUNqZA7trKlI+k23vEsKA94bTTkVsb2AS7MOcdv5z6HDaqYjtw5x2jNHtVcLbjPcVQjtIje8nlHbmwGinIrDPZNvfNeYD0mlnfwvtHBAA7cwB0s7+QFEeUEJzuOhERK75QOaVoDHH/Qiq/oOY0445l4MErJtK4wcBNX4wc41nKlKUv6aRRcohQmlnNo52wt54Dy0hDPhQPO2EDwUmwWHMacfs4WF42gkfxpx2jNEdUsLbjA8XQjtIjR8hlHZm42inzBIuCe0c6RrzUem0c6SFdo4KgHZmA2nnSKAojyqhOVx0IiLXfDTzStCY4xEEVf8xzGnHnMsxAtZNpfFjgBo/lrnGMxUpyl/TyCLlOKG0Mwv37aIp7+0cX0IY8PFw2knGjgcmwQnMacfs4Qlw2knGTmBOO8bojivhbcYnCqEdpMZPEko7s3BfQBnYezsnu8Z8SjrtnGyhnVMCoJ1ZQNo5GSjKU0poDhediMg1n8q8EjTmeBJB1X8ac9ox53KagHVTafw0oMZPZ67xTEWK8tc0skg5QyjtzITdNYlKb7xnlhAGfCacdhKVZwKT4CzmtGP28Cw47SQqz2JOO8bozijhbcY9hdAOUuNnC6WdmTDaSSQt4ZLQToVrzPF02qmw0E48ANqZCaSdCqAo4yU0h4tOROSaE8wrQWOOZxNU/UnmtGPOJSlg3VQaTwI1Xslc45mKFOWvaWSRUiWUdmbA7hqd8t5OrxLCgHvBaUfHegGToDdz2jF72BtOOzrWmzntGKOrKuFtxn2E0A5S432F0s4MGO3owN7b6ecac/902ulnoZ3+AdDODCDt9AOKsn8JzeGiExG55gHMK0Fjjn0Jqv6BzGnHnMtAAeum0vhAoMYHMdd4piJF+WsaWaQMFko703HfLppCO0NKCAMeAqedeGwIMAmGMqcds4dD4bQTjw1lTjvG6AaX8DbjYUJoB6nx4UJpZzru20UDo50RrjGPTKedERbaGRkA7UwH0s4IoChHltAcLjoRkWs+h3klaMxxOEHVP4o57ZhzGSVg3VQaHwXU+GjmGs9UpCh/TSOLlDFCaWca7hOoo954zy0hDPhcOO1Eo+cCk+A85rRj9vA8OO1Eo+cxpx1jdGNKeJvxWCG0g9T4+UJpZxqMdqIRS7gktHOBa8wXptPOBRbauTAA2pkGpJ0LgKK8sITmcNGJiFzzRcwrQWOO5xNU/Rczpx1zLhcLWDeVxi8GavwS5hrPVKQof00ji5RLhdLOVNhdE06hnctKCAO+DE474ehlwCS4nDntmD28HE474ejlzGnHGN2lJbzN+AohtIPU+JVCaWcqjHbCgdHOVa4xX51OO1dZaOfqAGhnKpB2rgKK8uoSmsNFJyJyzdcwrwSNOV5JUPVfy5x2zLlcK2DdVBq/Fqjx65hrPFORovw1jSxSrhdKO1Ngd01Me+O9oYQw4BvgtBPTNwCT4EbmtGP28EY47cRS1q18Ntu6EUZ3fQlvM75JCO0gNX6zUNqZAqOdmLKES0I7t7jGfGs67dxioZ1bA6CdKUDauQUoyltLaA4XnYjINd/GvBI05ngzQdV/O3PaMedyu4B1U2n8dqDG72Cu8UxFivLXNLJIuVMo7UyG3TUR5Y33rhLCgO+C005E3QVMgruZ047Zw7vhtBNRdzOnHWN0d5bwNuN7hNAOUuP3CqWdyTDaKa+yhEtCO/e5xjwunXbus9DOuABoZzKQdu4DinJcCc3hohMRuebxzCtBY473ElT99zOnHXMu9wtYN5XG7wdq/AHmGs9UpCh/TSOLlAlCaWcS7lMKUj6BemIJYcAT4bQTr5wITIJJzGnH7OEkOO3EKycxpx1jdBNKeJvxZCG0g9T4FKG0Mwn3KQWBfQL1VNeYp6XTzlQL7UwLgHYmAWlnKlCU00poDhediMg1T2deCRpznEJQ9c9gTjvmXGYIWDeVxmcANT6TucYzFSnKX9PIImWWUNqZCLtrQinv7cwuIQx4Npx2Qmo2MAnmMKcds4dz4LQTUnOY044xulklvM14rhDaQWp8nlDamYj7BOrA3tuZ7xrzgnTamW+hnQUB0M5EIO3MB4pyQQnN4aITEbnmhcwrQWOO8wiq/kXMacecyyIB66bS+CKgxhcz13imIkX5axpZpCwRSjsTcHdNwhvv0hLCgJfCaUcllgKTYBlz2jF7uAxOOyqxjDntGKNbUsLbjJcLoR2kxh8USjsTYLSj4pZwSWhnhWvMK9NpZ4WFdlYGQDvAG0ivAIpyZQnN4aITEbnmh5hXgsYcHySo+h9mTjvmXB4WsG4qjT8M1PgjzDWeqUhR/ppGFimPCqWdB2B3TXnKk2yPlRAG/BicdsorHwMmwePMacfs4eNw2imvfJw57Rije7SEtxk/IYR2kBp/UijtPID7vZ3AnmR7yjXmp9Np5ykL7TwdAO08AKSdp4CifLqE5nDRiYhc8zPMK0Fjjk8SVP3PMqcdcy7PClg3lcafBWr8OeYaz1SkKH9NI4uU54XSzv2wu0anfCbbCyWEAb8Apx2tXwAmwYvMacfs4Ytw2tEp61Y+m23dCKN7voS3Gb8khHaQGn9ZKO3cj3uSLbDPZHvFNeZX02nnFQvtvBoA7dwPpJ1XgKJ8tYTmcNGJiFzza8wrQWOOLxNU/a8zpx1zLq8LWDeVxl8HavwN5hrPVKQof00ji5Q3hdLOeNzDGCm/t/NWCWHAb5Xg532bOaGYdb9dsmmDQfOSUIUxlDdLeJveO0KoAqnLd4mNHnEm7xJoPEhDHUdkqO+VEAb8HoGhvs/cUM263w/IUJW/pk1ivF9Ck3CodQeZZPcV4/bAG+8HJYQBf0BwI34AdPQPmSes2cMPCZLgQ+av0Zok/ZAAf94BnvdHzF8uMNr5iMjsqxs6tz8Cns/HzBE/EzEof00jieET5ho3Z/wJQSGH1KEpEpxU/O9L5t6GjrtjFk2eZ0HjDJG+z7GNZ2+buz+vcs7zU6d/5vTPnf6F0790+ldOX+30r53+jdPXOH2t0791+jqnf+f09U7/3ukbnL7R6T84/Uen/+T0n53+i9N/dfpvTv/d6X84/U+n/+X0v53+T/p7LKvc91O8Y59axj6zjH1uGfvCMvalZewry9hqy9jXlrFvLGNrLGNrLWPfWsbWWca+s4ytt4x9bxnbYBnbaBn7wTL2o2XsJ8vYz5axXyxjv1rGfrOM/W4Z+8My9qdl7C/L2N+WsX9KNn/vroX75z7un8pfSzEdv2a5CmC81e8Dfgqay6zxM8hc/+7X5/7nCrn7pb/wO1f4v3uvv/Q3l/Kco/7Kz1yhFE3o1XWfS6XpS39dx7nKqzbTqv6mbnNFLbrXa+oyV9SaQ3pt7eeKZMhH/W1t54pkzG29rnZzhbbgE/q72swV2aLn6PU1nyuxFf/S39d0rshWvVBvqNlcqga+qjfWZC5VI4/WP2x9ru419Hv949bmCtf47tA/bXGucFUt7iH985bmitTqTtO/ZJ4rWsv7Uf+aYa5YVa3vWv2bfS5Vh3tb/26bS9WpBtB/bD6XrmM9of9MnytZ59pE/5U6V5mPOkf/7ZkrVOWrZtL/CH1F+x9YrZdMeer4P0/+UQVsJke96lUdvJkTFeM2pbxf0TZ7aGLEPnWcTFm38tmCfHoUl7zJwJ4erecmWP3SrFTarFe6+dOj5h9RPz2KcxKl6wETqH4p9nDR4jNJUw+YjNXrrlcq80b6G6ajWNIbb3YpYcDZ8BsplswG3kg5zG8ks4c58BsplswReiP9DbuRYglLuCQ3Uq6bYA3Sb6Rcy43UIIAb6W/gjZQLTKAGpTSHi34jGLnmhkAzy8rC35bmFs4pxb8RjESBPKCZ2fZQ+WvanHEeQSWTJ7SS+QvmP/Eyb7z5pYQB58MrmXhZPjD5C5hXMmYPC+CVTLysgDj5EQaax9xAC8F7WN3QFy9S40XA3AuyAv4LVgHHQ5ZwSSrgYteYS9Ir4GJLBVwSQAX8F7ACLgaKsqSU5nDRiYhccylxBaz8NW3MsYigemvEvGo159JIwLqpNN4IqPFtmWs8U5GCKH5Qc20HvrCDop0/YXdNtMob7/alhAFvD6edaNX2wAPcgTntmD3cAU470aodmNOOMbrtSnmb8Y5gM65u6DUjNb6TUNr5E0Y70UpLuCS0s7NrzLuk087OFtrZJQDa+RNIOzsDRblLKc3hohMRueZdmVeCxhx3Iqj6d2NOO+ZcdhOwbiqN7wbUeGPmGs9UpCh/TSOLlCZC39v5A3bXpH7veNNSwoCbwmknpJoCk6AZc9oxe9gMTjsh1Yw57Rija1LK24ybC6EdpMZbCKWdP2C0E9z3jrd0jblVOu20tNBOqwBo5w8g7bQEirJVKc3hohMRuebWzCtBY44tCKr+Nsxpx5xLGwHrptJ4G6DG2zLXeKYiRflrGlmktBNKO7/jfksshXbalxIG3B5OO0nVHpgEHZjTjtnDDnDaSaoOzGnHGF27Ut5m3FEI7SA13kko7fwOo51EYLTT2TXmLum009lCO10CoJ3fgbTTGSjKLqU0h4tOROSauzKvBI05diKo+rsxpx1zLt0ErJtK492AGlfMNZ6pSFH+mkYWKVoo7fwGu2vKUz4TI1RKGHAITjvlOgRMgjLmtGP2sAxOO+Up61Y+m23dCKPTpbzNOCyEdpAa7y6Udn6D0U65soRLQjvlrjFH0mmn3EI7kQBo5zcg7ZQDRRkppTlcdCIi1xxlXgkac+xOUPXHmNOOOZeYgHVTaTwG1HgP5hrPVKQof00ji5TdhdLOr7j3dqLeePcoJQx4D/x7O9E9gEmwJ3PaMXu4J/69neiezGnHGN3upbzNeC8htIPU+N5CaedX3CdHRizhktDOPq4x75tOO/tYaGffAGjnVyDt7AMU5b6lNIeLTkTkmvdjXgkac9yboOrfnzntmHPZX8C6qTS+P1DjBzDXeKYiRflrGlmkHCiUdn6B3TXhmDfeg0oJAz4ITjvh2EHAJDiYOe2YPTwYTjvh2MHMaccY3YGlvM34ECG0g9T4oUJp5xcY7YSjlnBJaOcw15gPT6edwyy0c3gAtPMLkHYOA4ry8FKaw0UnInLNRzCvBI05HkpQ9R/JnHbMuRwpYN1UGj8SqPGjmGs8U5Gi/DWNLFKOFko7P+M+gTrlSbZjSgkDPgZOO3F9DDAJjmVOO2YPj4XTTjxl3cpns60bYXRHl/I24+OE0A5S48cLpZ2fcZ9ArSzhktDOCa4xn5hOOydYaOfEAGjnZyDtnAAU5YmlNIeLTkTkmk9iXgkaczyeoOo/mTntmHM5WcC6qTR+MlDjpzDXeKYiRflrGlmknCqUdn7C0U7CG+9ppYQBn4anncRpwCQ4nTntmD08HU87idOZ044xulNLeZvxGUJoB6nxM4XSzk842olbwiWhnbNcY+6ZTjtnWWinZwC08xOQds4CirJnKc3hohMRueazmVeCxhzPJKj6K5jTjjmXCgHrptJ4BVDjceYaz1SkKH9NI4uUhFDa+RH3JFvcG2+ylDDgJP5JtngSmASVzGnH7GEl/km2eCVz2jFGlyjlbcZVQmgHqfFeQmnnR9yTbBWWcElop7drzH3Saae3hXb6BEA7PwJppzdQlH1KaQ4XnYjINfdlXgkac+xFUPX3Y0475lz6CVg3lcb7ATXen7nGMxUpyl/TyCJlgFDa+QH37aIpn0A9sJQw4IFw2omqgcAkGMScdsweDoLTTlQNYk47xugGlPI248FCaAep8SFCaecHGO1EAvsE6qGuMQ9Lp52hFtoZFgDt/ACknaFAUQ4rpTlcdCIi1zyceSVozHEIQdU/gjntmHMZIWDdVBofAdT4SOYaz1SkKH9NI4uUc4TSzkYi2hlVShjwKALaGQVMgtHMacfs4WgC2hnNnHaM0Z1TytuMxwihHaTGzxVKOxsF0s55rjGPTaed8yy0MzYA2tkIpJ3zgKIcK4R2kGs+n3klaMzxXIKq/wLmtGPO5QIB66bS+AVAjV/IXOOZihTlr2lkkXKRUNrZALtrKlI+k+3iUsKAL4bTTkXsYmASXMKcdsweXgKnnYrYJcxpxxjdRaW8zfhSIbSD1PhlQmlnA4x2KgL7TLbLXWO+Ip12LrfQzhUB0M4GIO1cDhTlFaU0h4tOROSar2ReCRpzvIyg6r+KOe2Yc7lKwLqpNH4VUONXM9d4piJF+WsaWaRcI5R2vsfRTtgb77WlhAFfi6ed8LXAJLiOOe2YPbwOTzvh65jTjjG6a0p5m/H1QmgHqfEbhNLO9zjaKbOES0I7N7rGfFM67dxooZ2bAqCd74G0cyNQlDeV0hwuOhGRa76ZeSVozPEGgqr/Fua0Y87lFgHrptL4LUCN38pc45mKFOWvaWSRcptQ2lmP+3bRlPd2bi8lDPh2OO0kY7cDk+AO5rRj9vAOOO0kY3cwpx1jdLeV8jbjO4XQDlLjdwmlnfW4bxcN7L2du11jvieddu620M49AdDOeiDt3A0U5T2lNIeLTkTkmu9lXgkac7yLoOq/jzntmHO5T8C6qTR+H1Dj45hrPFORovw1jSxSxgulne9gd02i0hvv/aWEAd8Pp51E5f3AJHiAOe2YPXwATjuJygeY044xuvGlvM14ghDaQWp8olDa+Q5GO4mkJVwS2pnkGvPkdNqZZKGdyQHQzndA2pkEFOXkUprDRScics1TmFeCxhwnElT9U5nTjjmXqQLWTaXxqUCNT2Ou8UxFivLXNLJImS6UdtbB7hqd8t7OjFLCgGfAaUfHZgCTYCZz2jF7OBNOOzo2kzntGKObXsrbjGcJoR2kxmcLpZ11MNrRgb23M8c15rnptDPHQjtzA6CddUDamQMU5dxSmsNFJyJyzfOYV4LGHGcTVP3zmdOOOZf5AtZNpfH5QI0vYK7xTEWK8tc0skhZKJR2vsV9u2gK7SwqJQx4EZx24rFFwCRYzJx2zB4uhtNOPLaYOe0Yo1tYytuMlwihHaTGlwqlnW9x3y4aGO0sc415eTrtLLPQzvIAaOdbIO0sA4pyeSnN4aITEbnmB5lXgsYclxJU/SuY0445lxUC1k2l8RVAja9krvFMRYry1zSySHlIKO2sxX0CddQb78OlhAE/DKedaPRhYBI8wpx2zB4+AqedaPQR5rRjjO6hUt5m/KgQ2kFq/DGhtLMWRjvRiCVcEtp53DXmJ9Jp53EL7TwRAO2sBdLO40BRPlFKc7joRESu+UnmlaAxx8cIqv6nmNOOOZenBKybSuNPATX+NHONZypSlL+mkUXKM0JpZw3srgmn0M6zpYQBPwunnXD0WWASPMecdswePgennXD0Oea0Y4zumVLeZvy8ENpBavwFobSzBkY74cBo50XXmF9Kp50XLbTzUgC0swZIOy8CRflSKc3hohMRueaXmVeCxhxfIKj6X2FOO+ZcXhGwbiqNvwLU+KvMNZ6pSFH+mkYWKa8JpZ1vYHdNTHvjfb2UMODX4bQT068Dk+AN5rRj9vANOO3EUtatfDbbuhFG91opbzN+UwjtIDX+llDa+QZGOzFlCZeEdt52jfmddNp520I77wRAO98AaedtoCjfKaU5XHQiItf8LvNK0JjjWwRV/3vMacecy3sC1k2l8feAGn+fucYzFSnKX9PIIuUDobTzNeyuiShvvB+WEgb8IZx2IupDYBJ8xJx2zB5+BKediPqIOe0Yo/uglLcZfyyEdpAa/0Qo7XwNo53yKku4JLSzyjXmT9NpZ5WFdj4NgHa+BtLOKqAoPy2lOVx0IiLX/BnzStCY4ycEVf/nzGnHnMvnAtZNpfHPgRr/grnGMxUpyl/TyCLlS6G0sxr3KQUpn0D9VSlhwF/BaSde+RUwCVYzpx2zh6vhtBOvXM2cdozRfVnK24y/FkI7SI1/I5R2VuM+pSCwT6Be4xrz2nTaWWOhnbUB0M5qIO2sAYpybSnN4aITEbnmb5lXgsYcvyGo+tcxpx1zLusErJtK4+uAGv+OucYzFSnKX9PIImW9UNr5CnbXhFLe2/m+lDDg7+G0E1LfA5NgA3PaMXu4AU47IbWBOe0Yo1tfytuMNwqhHaTGfxBKO1/hPoE6sPd2fnSN+ad02vnRQjs/BUA7XwFp50egKH8qpTlcdCIi1/wz80rQmOMPBFX/L8xpx5zLLwLWTaXxX4Aa/5W5xjMVKcpf08gi5TehtPMl7q5JeOP9vZQw4N/htKMSvwOT4A/mtGP28A847ajEH8xpxxjdb6W8zfhPIbSD1PhfQmnnSxjtqLglXBLa+ds15n/SaedvC+38EwDtAG8g/TdQlP+U0hwuOhGRa85qxLsSNOb4F0HVv00j2otL+WvanIuJkfu6qTTujdPvXPWYazxTkaL8NY0sUuoDdRMk7XwBu2vKU55ky25EGLCZHEs75ZXZwCTIASYn1R7mNELTTnllDvGlgTC6+o14m3Eu2IyrG3rNSI03AK45SNr5Avd7O4E9ydbQNea8RlmpZNOw0ea0Y/4RNe18AaSdhkBR5jWiOVx0IiLXnM+8EjTm2ICg6i9gTjvmXAoErJtK4wVAjRcy13imIkX5axpZpBQJpZ3PYXeNTvlMtuJGhAEXw2lH62JgEpQwpx2zhyVw2tEp61Y+m23dCKMrasTbjEuF0A5S442E0s7nuCfZlCVcEtrZ1jXm7dJpZ1sL7WwXAO18DqSdbYGi3K4RzeGiExG55u2ZV4LGHBsRVP07MKcdcy47CFg3lcZ3AGp8R+Yaz1SkKH9NI4uUnYTSzme4hzFSfm9n50aEAe/cCD/vLswJxax7l0abNhg0LwlVGEPZqRFv09tVCFUgdbkbsdEjzmQ3Ao0HaaifEhlq40aEATcmMNQmzA3VrLtJQIaq/DVtEqNJI5qEQ607yCRbVYLbA2+8TRsRBtyU4EZsCnT0ZswT1uxhM4IkaMb8NVqTpM0I8GdX4Hk3Z/5ygdFOcyKzr27o3G4OPJ8WzBE/EzEof00jiaElc42bM25JUMghdWiKhLysTS+Z/+fDgLNSGzr+eXn4fEfHOFdAjHMExDhbQIyzBMQ4U0CMMwTEOF1AjNMExDhVQIxTBMQ4WUCMkwTEOFFAjBMExPiAgBjvFxDjeAExjhMQ430CYrxXQIz3CIjxbgEx3iUgxjsFxHiHgBhvFxDjbQJivFVAjLcIiPFmATHeJCDGH/L5x7hRQIwbBMT4vYAY1wuI8TsBMa4TEOO3AmJcKyDGNQJi/EZAjF8LiHG1gBi/EhDjlwJi/EJAjJ8LiPEzATF+KiDGVQJi/ERAjB8LiPEjATF+KCDGDwTE+L6AGN8TEOO7AmJ8R0CMbwuI8S0BMb4pIMbyQv4xdhcQY1hAjGUCYgwJiFELiFEJiLGbgBi7Coixi4AYOwuIsZOAGDsKiLGDgBjbC4ixnYAY2wqIsY2AGFsLiLGVgBhbCoixhYAYmwuIsZmAGJsKiLGJgBgbC4hxNwEx7iogxl0ExLizgBh3EhDj6CL+MY4SEOM5AmIcKSDGEQJiHC4gxmECYhwqIMYhAmIcLCDGQQJiHCggxgECYuwvIMZ+AmLsKyDGPgJi7C0gxl4CYqwSEGOlgBiTAmJMCIgxLiDGCgExni0gxp4CYjxLQIxnCojxDAExni4gxtMExLiymH+MKwTE+KCAGJcLiHGZgBiXCohxiYAYFwuIcZGAGBcKiHGBgBjnC4hxnoAY5wqIcY6AGGcLiHGWgBhnCohxhoAYpwuIcZqAGKcKiHGKgBgnC4hxkoAYJwqIcYKAGB8QEOP9AmIcLyDGcQJivI8gxixsjFGaeRMxmnm7V9LMGy2jmbesnGZeFSLaB6JzU0T7W0Gk3zjR/oYraOatItKZJpo3rmnmLSPa34oqmnnLifwsTjRvBZWfJWjmTRLpLBKnmTdM5L/hCM28ld1p5tVhoniJ7qFyqvqMyM8iRDqLEO1D9L95jK7R/wF+IzpVjH8LiPEvATH+KSDGPwTE+LuAGH8TEOOvAmL8RUCMPwuI8ScBMf4oIMYfBMS4UUCMGwTE+L2AGNcLiPE7ATGuExDjtwJiXCsgxjUCYvxGQIxfC4hxtYAYvxIQ45cCYvxCQIyfC4jxMwExfiogxlUEMXobZu5KwrmVqufZ21L351aNsrJaO72N09s6vZ3T2zu9g9M7Or2T0zs7vYvTuzq9m9OV07XTQ43+naOskTtpffdPM2nztLHWlrE2lrG2lrF2lrH2lrEOlrGOlrFOlrHOlrEulrGulrFuljFlGdOWsZBlrMwd87b6WDHouagvJNVKzfPMVabKw+HKSKhSl+kKFYrFo91VuHu8PKqjunu0ezIULSurjIajkVg8FlExHS6r1FXdY2VV7nThRjjBe/c0bNnTesg91amx+92H7kT70D0Abc3Bfdmt7g7c03KiPS0PQFvlwH2IEO1DJABtzQZqKwLc0yjRnkaptWU+TJnpPlDqaCbw/psFvP9iRDqKBeBRMaCOehDtQ48APGoG0KN6APd0d6I93T0Abe0O3Ic9iPZhjwC0NR2orT2Ae7on0Z7uGcD915rpPlDqaCrw/psGvP/2ItLRXgF41F5AHe1NtA97B+BRU4AetTdwT/ch2tN9AtDWPsB92JdoH/YNQFuTgdraF7in+xHt6X4B3H9tmO4DpY4mAu+/ScD7b38iHe0fgEftD9TRAUT7cEAAHjUB6FEHAPf0QKI9PTAAbR0I3IeDiPbhoAC09QBQWwcB9/Rgoj09OID7ry3TfaDU0Xjg/Xc/8P47hEhHhwTgUYcAdXQo0T4cGoBHjQN61KHAPT2MaE8PC0BbhwH34XCifTg8AG3dB9TW4cA9PYJoT48I4P5rx3QfKHV0D/D+uxd4/x1JpKMjA/CoI4E6OopoH44KwKPuBnrUUcA9PZpoT48OQFtHA/fhGKJ9OCYAbd0F1NYxwD09lmhPjw3g/mvPdB8odXQH8P67E3j/HUeko+MC8KjjgDo6nmgfjg/Ao24HetTxwD09gWhPTwhAWycA9+FEon04MQBt3QbU1onAPT2JaE9PCuD+68B0Hyh1dAvw/rsVeP+dTKSjkwPwqJOBOjqFaB9OCcCjbgZ61CnAPT2VaE9PDUBbpwL34TSifTgtAG3dBNTWacA9PZ1oT08P4P7ryHQfKHW0MR+Xmz/k4/bvDCIdnRGAR50B1NGZRPtwZgAetSEfN9eZwD09i2hPzwpAW2cB96En0T70DEBb3wO11RO4p2cT7enZAdx/nZjuA6WOvgPef+uB918FkY4qAvCoCqCO4kT7EA/Ao9YBPSoO3NME0Z4mAtBWArgPSaJ9SAagrW+B2koC97SSaE8rA7j/OjPdB0odrQHef2uB918VkY6qAvCoKqCOehHtQ68APOoboEf1Au5pb6I97R2AtnoD96EP0T70CUBbXwO11Qe4p32J9rRvAPdfF6b7QKmjr4D332rg/dePSEf9AvCofkAd9Sfah/4BeNSXQI/qD9zTAUR7OiAAbQ0A7sNAon0YGIC2vgBqayBwTwcR7emgAO6/rkz3gVJHnwHvv8+B999gIh0NDsCjBgN1NIRoH4YE4FGfAj1qCHBPhxLt6dAAtDUUuA/DiPZhWADaWgXU1jDgng4n2tPhAdx/3ZjuA6WOPgbef58A778RRDoaEYBHjQDqaCTRPowMwKM+AnrUSOCenkO0p+cEoK1zgPswimgfRgWgrQ+B2hoF3NPRRHs6OoD7TzHdB0odvQ+8/z4A3n9jiHQ0JgCPGgPU0blE+3BuAB71HtCjzgXu6XlEe3peANo6D7gPY4n2YWwA2noXqK2xwD09n2hPzw/g/tNM94FSR28D7793gPffBUQ6uiAAj7oAqKMLifbhwgA86i2gR10I3NOLiPb0ogC0dRFwHy4m2oeLA9DWm0BtXQzc00uI9vSSAO6/EON92C5r8+9U9H6Xovc7FL3fnej9zkTvdyV6vyPR+92I3u9E9H4Xovc7EL3ffej9zkPvdx16v+PQ+92G+zXY9PP+np8P8Px8oOfngzw/H+z5+RDPz4e6P1/q/Hcuc/rlTr/C6Vc6/SqnX+30a5ye7fybvKxNuWj+v6uyUts2YE3Ny8PXQegY5wqIcY6AGGcLiHGWgBhnCohxhoAYpwuIcZqAGKcKiHGKgBgnC4hxkoAYJwqIcYKAGB8QEOP9AmIcLyDGcQJivE9AjPcKiPEeATHeLSDGuwTEeKeAGO8QEOPtAmK8TUCMtwqI8RYBMd4sIMabBMT4Qz7/GDcKiHGDgBi/FxDjegExficgxnUCYvxWQIxrBcS4RkCM3wiI8WsBMa4WEONXAmL8UkCMXwiI8XMBMX4mIMZPBcS4SkCMnwiI8WMBMX4kIMYPBcT4gYAY3xcQ43sCYnxXQIzvCIjxbQExviUgxjcFxFheyD/G7gJiDAuIsUxAjCEBMWoBMSoBMXYTEGNXATF2ERBjZwExdhIQY0cBMXYQEGN7ATG2ExBjWwExthEQY2sBMbYSEGNLATG2EBBjcwExNhMQY1MBMTYREGNjATHuJiDGXQXEuIuAGHcWEONOAmIcXcQ/xlECYjxHQIwjBcQ4QkCMwwXEOExAjEMFxDhEQIyDBcQ4SECMAwXEOEBAjP0FxNhPQIx9BcTYR0CMvQXE2EtAjFUCYqwUEGNSQIwJATHGBcRYISDGswXE2FNAjGcJiPFMATGeISDG0wXEeJqAGFcW849xhYAYHxQQ43IBMS4TEONSATEuERDjYgExLhIQ40IBMS4QEON8ATHOExDjXAExzhEQ42wBMc4SEONMATHOEBDjdAExThMQ41QBMU4REONkATFOEhDjRAExThAQ4wMCYvz/2LsOODeKq7/XbN/ZZ599BttUm2ZsmlbSnXQkBBMgoYUWetedJFPccAFTbMs23WBjjHsB03uvCcmX3hPSe6GFEggkIQkBUr4ZrNG9e/d2tDq9kfXA8/s9W7cz85//vHnzZnZ2dvZmARxvEsBxgwCO6x1w9Hg5Jt3gdnW4wW3LuMFNxtzgxtrd4EaijvTgqN0ijvSbcmS/nY70G0+5wc06sjPfEW6n7wY35ki/qawb3HZH/qzTEW7KlT/rcoObdmRniU43uHFH/jeecIObaXOD68cd8XU0DrW7mp858mcJR3aWcKSHZKEfc8/R/zek+u8j/iuA438EcPy3AI7vC+D4ngCO7wrg+C8BHN8RwPGfAjj+QwDHvwvg+LYAjn8TwPGvAjj+RQDHtwRwfFMAxz8L4PiGAI6vC+D4JwEcXxPA8VUBHF8RwPFlARz/KIDjSwI4viiA4wsCOD4vgONzDjjCwIOdcYgdj9QC3bbkf1871POuU7JYyRIl1ytZquQGJcuU3KhkuZIVSlYqWaVktZI1StYO3YSxbmgetC7/vwYdja5dR1xbTFxbQly7nri2lLh2A3FtGXHtRuLacuLaCuLaSuLaKuLaauLaGuLaWuLauvw1GOpYjYHxIHtfPfIAWLFIezyeSUQzfsxPRaIdncm2SLytsz3pJ/22ZFs6mozFMsl4MtHR2ZGIdPjxWMbPtnXEsnm49UP5OirU6XpCp7WcOvV7ci9XDxsc6WFDBWyL8QME/gZGnd7kSKc3VcC2bmLUw82O9HBzBWyL8cMR/s2MOt3oSKcbXduW0sO1VaoHl3bkM45/Ucbx7xZHdnRLBXzULYx2dKsjPdxaAR/F+MET/1ZGnd7mSKe3VcC2bmPUw+2O9HB7BWyL8UM1/u2MOr3DkU7vqMD4d12V6sGlHe3FOP7tzTj+3enIju6sgI+6k9GO7nKkh7sq4KMYP7Dk38Wo07sd6fTuCtjW3Yx6uMeRHu6pgG0xfhjLv4dRp/c60um9FRj/FlepHlza0TjG8W884/h3nyM7uq8CPuo+Rju635Ee7q+Aj2L8oJt/P6NOH3Ck0wcqYFsPMOrhQUd6eLACtsX4IT7/QUadPuRIpw9VYPxbUqV6cGlHuzKOf7sxjn8PO7Kjhyvgox5mtKNHHOnhkQr4KMYPSPqPMOr0UUc6fbQCtvUoox4ec6SHxypgW4wf/vQfY9Tp4450+ngFxr/rq1QPLu1oDOP4txPj+PeEIzt6ogI+6glGO3rSkR6erICPYvxgrf8ko06fcqTTpypgW08x6uFpR3p4ugK2xfihYf9pRp1+zpFOP1eB8W9plerBpR1tzzj+7cA4/n3ekR19vgI+6vOMdvSMIz08UwEfxfiBbP8ZRp1+wZFOv1AB2/oCox6+6EgPX6yAbTF+2Nz/IqNO/8+RTv+vAuPfDVWqB5d2NIpx/NuGcfz7kiM7+lIFfNSXGO3oy4708OUK+KiRjD7qy4w6/YojnX6lArb1FUY9fNWRHr5aAdsawWhbX2XU6dcc6fRrFRj/llWpHlza0exmvr55UTOf/r7uyI6+XgEf9XVGO/qGIz18owI+6kK+jy3632DU6Tcd6fSbFbCtbzLq4VuO9PCtCtjWBYy29S1GnX7bkU6/XYHx78Yq1YNLO5rJOP7NYhz/vuPIjr5TAR/1HUY7+q4jPXy3Aj5qBqOP+i6jTr/nSKffq4BtfY9RD993pIfvV8C2pjPa1vcZdfoDRzr9QQXGv+VVqgeXdjSNcfw7n3H8e9aRHT1bAR/1LKMd/dCRHn5YAR81ldFH/ZBRpz9ypNMfVcC2fsSohx870sOPK2BbUxht68eMOv2JI53+pALj34oq1YNLO5rEOP5NZhz/furIjn5aAR/1U0Y7+pkjPfysAj7qPEYf9TNGnf7ckU5/XgHb+jmjHn7hSA+/qIBtnctoW79g1OkvHen0lxUY/1ZWqR5c2tHZjOPfOYzj368c2dGvKuCjfsVoR792pIdfV8BHTWT0Ub9m1OlvHOn0NxWwrd8w6uG3jvTw2wrYVpbRtn7LqNPfOdLp7yow/q2qUj24tKM04/iXYRz/fu/Ijn5fAR/1e0Y7+oMjPfyhAj6qi9FH/YFRp8850ulzFbCt5xj18LwjPTxfAdvqZLSt5xl1+oIjnb5QgfFvdZXqwaUdncU4/qUYx78XHdnRixXwUS8y2tFLjvTwUgV81JmMPuolRp3+0ZFO/1gB2/ojox5edqSHlytgW2cw2tbLjDp9xZFOX6nA+LemSvXg0o5OYxz/Tmcc/151ZEevVsBHvcpoR6850sNrFfBRpzL6qNcYdfonRzr9UwVs60+MenjdkR5er4BtncJoW68z6vQNRzp9owLj39oq1kOr1/ubivBbivAbivDbifCbifBbifAbifDbiPCbiPBbiPAbiPDbh/Cbh/Bbh/Abh/DbhpeB35eD31eA31eC31eB31eD39eA34vyv/+s/n9TyVtK/qLkr0r+puRtJX9XUq/SNHrdffGDNSuvZ6hhtqmHGvnnQdwcHxTA8QEBHO8XwPE+ARzvFcDxHgEc7xbA8S4BHO8UwPEOARxvF8DxNgEcbxXA8RYBHDcK4HizAI43CeC4QQDH9QI4rhPAca0AjmsEcFwtgOMqARxXCuC4QgDH5QI43iiA4zIBHG8QwHGpAI5vN1U/x78J4PhXARz/IoDjWwI4vimA458FcHxDAMfXBXD8kwCOrwng+KoAjq8I4PiyAI5/FMDxJQEcXxTA8QUBHJ8XwPE5ARz/IIDj7wVw/J0Ajr8VwPE3Ajj+WgDHXwng+EsBHH8hgOPPBXD8mQCOPxXAsX1Q9XNsE8AxLoBjTADHqACOvgCOEQEc9xHAcW8BHPcSwHFPARz3EMBxvACO4wRw3F0Ax7ECOO4mgOOuAjjuIoDjzgI47iSA4xgBHEcL4LijAI47COC4vQCO2wnguK0AjtsI4DhKAMeRAjiOEMDxoubq5zhbAMcLBXC8QADHWQI4zhTAcYYAjtMFcDxfAMdpAjhOFcBxigCOkwVwnCSA43kCOJ4rgOM5AjieLYDjRAEcswI4ZgRwTAvg2CWAY6cAjikBHM8SwPFMARzPEMDxdAEcTxPA8VQBHE8RwPGZwdXP8fMCOH5OAMenBXB8SgDHJwVwfEIAx8cFcHxMAMdHBXB8RADHhwVwfEgAxwcFcHxAAMf7BXC8TwDHewVwvEcAx7sFcLxLAMc7BXC8QwDH2wVwvE0Ax1sFcLxFAMeNAjjeLIDjTQI4bhDAcb0Djh4vx6Qb3K4ON7htGTe4yZgb3Fi7G9xI1JEeHLVbxJF+U47st9ORfuMpN7hZR3bmO8Lt9N3gxhzpN5V1g9vuyJ91OsJNufJnXW5w047sLNHpBjfuyP/GE25wM21ucP24I76OxqF2V/MzR/4s4cjOEo70kCz0Y+45+v+GVP99xH8FcPyPAI7/FsDxfQEc3xPA8V0BHP8lgOM7Ajj+UwDHfwjg+HcBHN8WwPFvAjj+VQDHvwjg+JYAjm8K4PhnARzfEMDxdQEc/ySA42sCOL4qgOMrAji+LIDjHwVwfEkAxxcFcHxBAMfnBXB8zgFHGHiwMw6xk5FaoNuW/O9/DPW8fyp5R8m/lLyr5D0l7yv5t5L/KPmvkv8p8YapvEpqldQpqR+2CaNhWB60Lv+/Bh2Nrv2TuPYOce1fxLV3iWvvEdfeJ679m7imCY9GSq5jVTbji1J+JAJfDItF2uPxTCKa8WN+KhLt6Ey2ReJtne1JP+m3JdvS0WQslknGk4mOzo5EpMOPxzJ+tq0jls3D9RvG1xGgTvsROq3l1Knfk3u5eujvSA/9K2BbjC+4+f0ZdTrAkU4HVMC2BjDqodGRHhorYFuMLyb6jYw6bXKk0ybXtqUXfIdWpx5c2tGTjOPfU4zj30BHdjSwAj5qIGN/GuRID4Mq4KMYX6j1BzHqtNmRTpsrYFvNjHoY7EgPgytgW4wvQvuDGXU6xJFOh1Rg/Pvn0OrUg0s7epRx/HuMcfxrcWRHLRXwUS2M/WmoIz0MrYCPYnyB3x/KqNNhjnQ6rAK2NYxRD62O9NBaAdtiPHjBb2XU6XBHOh1egfHvnaHVqQeXdvQg4/j3EOP4t5UjO9qqAj5qK8b+tLUjPWxdAR/FeGCIvzWjTkc40umICtjWCEY9jHSkh5EVsC3Gg178kYw6HeVIp6MqMP79a2h16sGlHd3LOP7dxzj+bePIjrapgI/ahrE/betID9tWwEcxHlDkb8uo0+0c6XS7CtjWdox62N6RHravgG0xHizlb8+o0x0c6XSHCox/7w6tTj24tKM7Gce/uxjHvx0d2dGOFfBROzL2p9GO9DC6Aj6K8UA0fzSjTsc40umYCtjWGEY97ORIDztVwLYYD7Lzd2LU6c6OdLpzBca/94ZWpx5c2tGtjOPfbYzj3y6O7GiXCvioXRj7066O9LBrBXwU4wGM/q6MOt3NkU53q4Bt7caoh7GO9DC2ArbFeHCmP5ZRp7s70unuFRj/3h9anXpwaUc3MY5/NzOOf+Mc2dG4CviocYz9abwjPYyvgI9iPPDVH8+o0z0c6XSPCtjWHox62NORHvasgG0xHtTr78mo070c6XSvCox//x5anXqAda5hrvN/GOqcScTaU34i45Lnfxl4dnZk04n2rFOe/2PgGU/E051tkU6XPD2GPp/uiGe62tqiLnnWMPBM+nG/rSPb5pJnLQNPX13sbO9MueRZx8Azksp0+l0p3yXPegaembZkezKbtPrPcv383hx+PtnV0ZbpeaA7N899GHjG2iPRZEfEKc8IA89UsjMaT/U8YJybp8/A02/v9GOpngd1c/OMMvBsz3RmUu09D7zm5hlj4Jn2E53xjp4HR3PzjDPwzLT58Uys3alfauPwS6mEwk76H+zp93qfmQHPyoBnZMCzMeCZGPAsDHgGBjz7Yu9h3b/3Ab8j4LcPfkfB7xj4HQe/28DvP4Oy3gS/3wK//wJ+/xX8/hv4/Tb4/ff873ZVTkJJUkmHkn2VfEzJx5Xsp6RepWn0uu8Fdd7nvJ6Bexx9qJH/PoSb44MCOD4ggOP9AjjeJ4DjvQI43iOA490CON4lgOOdAjjeIYDj7QI43iaA460CON4igONGARxvFsDxJgEcNwjguF4Ax3UCOK4VwHGNAI6rBXBcJYDjSgEcVwjguFwAxxsFcFwmgOMNAjguFcDx7abq5/g3ARz/KoDjXwRwfEsAxzcFcPyzAI5vCOD4ugCOfxLA8TUBHF8VwPEVARxfFsDxjwI4viSA44sCOL4ggOPzAjg+J4DjHwRw/L0Ajr8TwPG3Ajj+RgDHXwvg+CsBHH8pgOMvBHD8uQCOPxPA8acCOLYPqn6ObQI4xgVwjAngGBXA0RfAMSKA4z4COO4tgONeAjjuKYDjHgI4jhfAcZwAjrsL4DhWAMfdBHDcVQDHXQRw3FkAx50EcBwjgONoARx3FMBxBwEctxfAcTsBHLcVwHEbARxHCeA4UgDHEQI4XtRc/RxnC+B4oQCOFwjgOEsAx5kCOM4QwHG6AI7nC+A4TQDHqQI4ThHAcbIAjpMEcDxPAMdzBXA8RwDHswVwnCiAY1YAx4wAjmkBHLsEcOwUwDElgONZAjieKYDjGQI4ni6A42kCOJ4qgOMpAjg+M7j6OX5eAMfPCeD4tACOTwng+KQAjk8I4Pi4AI6PCeD4qACOjwjg+LAAjg8J4PigAI4PCOB4vwCO9wngeK8AjvcI4Hi3AI53CeB4pwCOdwjgeLsAjrcJ4HirAI63COC4UQDHmwVwvEkAxw0COK53wNHj5Zh0g9vV4Qa3LeMGt+e33fhwY+2O2i3qSA+O2i3iSL8pR/bb6Ui/8ZQb3KwjO/Md4Xb6bnBjjvTb8xuAfLjtjvxZpyPclCt/1uUGN+3IzhKdbnDjjvxvz28u8uFm2tzg+nFHfB2NQ+2u5meO/FnCkZ0lHOkhWejH3HP0/w2p/vuI/wrg+B8BHP8tgOP7Aji+J4DjuwI4/ksAx3cEcPynAI7/EMDx7wI4vi2A498EcPyrAI5/EcDxLQEc3xTA8c8COL4hgOPrAjj+SQDH1wRwfFUAx1cEcHxZAMc/CuD4kgCOLwrg+IIAjs8L4PicA44w8GBnHGJ3RWqBblvyvz8xzPP2VzJByQFKPqnkQCUHKTlYyaeUfFrJIUoOVXKYksOVHKHkM8M2YRw5LA9al/9fg45G1/Ynrk0grh1AXPskce1A4tpBxLWDiWtH5q/BUMeqbMaFWj8SgQvTsUh7PJ5JRDN+zE9Foh2dybZIvK2zPekn/bZkWzqajMUyyXgy0dHZkYh0+PFYxs+2dcSyebijhvF1BKjTowid1nLq1O/JvVw9HO1ID0dXwLYYF9j9oxl1eowjnR5TAds6hlEPxzrSw7EVsC3GByP+sYw6/awjnX7WtW0pPXyiSvXg0o7eYxz/3mcc/45zZEfHVcBHHcdoR8c70sPxFfBRjA/0/OMZdXqCI52eUAHbOoFRDyc60sOJFbAtxgex/omMOj3JkU5PqsD4t3+V6sGlHf2Tcfx7h3H8O9mRHZ1cAR91MqMdneJID6dUwEcxbiDwT2HU6amOdHpqBWzrVEY9nOZID6dVwLYYN374pzHq9HRHOj29AuPfhCrVg0s7+hvj+Pc24/h3hiM7OqMCPuoMRjs605EezqyAj2LcsOSfyajTsxzp9KwK2NZZjHpIOdJDqgK2xbjRzE8x6rTTkU47KzD+HVClenBpR28yjn9vMY5/XY7sqKsCPqqL0Y7SjvSQroCPYtwg6acZdZpxpNNMBWwrw6iHrCM9ZCtgW4wbW/0so04nOtLpxAqMf5+sUj24tKM/MY5/rzOOf2c7sqOzK+Cjzma0o3Mc6eGcCvgoxg3Z/jmMOj3XkU7PrYBtncuoh/Mc6eG8CtgW40Z6/zxGnU5ypNNJFRj/DqxSPbi0o5cZx79XGMe/yY7saHIFfNRkRjua4kgPUyrgoxhfAPGnMOp0qiOdTq2AbU1l1MM0R3qYVgHbYnxxx5/GqNPzHen0/AqMfwdVqR5c2tELjOPfi4zj33RHdjS9Aj5qOqMdzXCkhxkV8FGML5z5Mxh1OtORTmdWwLZmMuphliM9zKqAbTG+KOjPYtTpBY50ekEFxr+Dq1QPsM41zHX+lBCenxbC8xAhPA8VwvMwITwPF8LzCCE8P8PIs97bNFbUAa4tXs/Azf8TDvTMzXF/ARwnCOB4gACOnxTA8UABHA8SwPFgRz6eg2PSEa4rvltwP1y4fNhR3x12JmJ8ApyrXKj69WwlFym5WMklSi5VMkfJXCXzlOSUzFeyQMlCJZcpuVzJFcO8nofLXDis94Ezs4lrFxHXLiauXUJcu5S4Noe4Npe4djlx7Yr8tfq8UmqJBuB2pvOGVbkx+pv+g7q4ctim/6/Cja4jBiAC3CtT8xhWUTKbllH8KxlXZK4ScucjhWdOCM/5QnguEMJzoRCelwnhyeEvE3ksyBOvjpfrPxlXNPwLHbUNd50ZV0j82ULqzLji4l8kpM6MKzj+xULqzLgi5F8ipM6MK0z+pULqzLhi5c8RUmfGFTB/boXqHOlb8M2Pyxnvla529BQf4jLrwQT/Csa2v5rlXlaFjoiv69/q9T55GJ44DE8ahicMw5OF4YnC8CRheILwbf27f99exm+4CHMF+N0OfifA7yT43QF+7wt+fwz8/jj4vV/+9yL1/7VKrlOyWMkSJdcrWarkhmGbFn8Ge93rFjBwz80XVfviz6YQd4btR3qsRNbnfy9TerlRyXIlK/Ai07L8IhO8diNxbTlxbcWw3gtUDbzK6tGo5TrKZVwOIhvxb2TC0nVczrgIt4L5UXylOu+1Wzov2XlXKr2sUrJayRrceVcSnXIVcW01cW1NBTrvtYyddyVj513F2HlXM3beNUI773VbOi/ZedcqvaxTsl7JBtx51xKdch1xbT1xbUMFOu91jJ13LWPnXcfYedczdt4NQjvv4i2dl+y8Nym93Kxko5JbcOe9ieiUNxPXNhLXbqlA513M2HlvYuy8NzN23o2MnfcWoZ13yZbOS3beW5VeblNyu5I7cOe9leiUtxHXbieu3VGBzruEsfPeyth5b2PsvLczdt47hHbe67d0XrLz3qn0cpeSu5XcgzvvnUSnvIu4djdx7Z4KdN7rGTvvnYyd9y7Gzns3Y+e9R2jnXbql85Kd916ll/uU3K/kAdx57yU65X3EtfuJaw9UoPMuZey89zJ23vsYO+/9jJ33AaGd94YtnZfsvA8qvTyk5GElj+DO+yDRKR8irj1MXHukAp33BsbO+yBj532IsfM+zNh5H2HuvE1eZTpvjeem8+4YxNOP9Cks663fPiJFIjdirD4jRSLLe2KVgRSJWB83loi8MhirZI6rgrD6UNvVNFaf9BbqCU9I5LXFsUJzXFcMq4TarrdjlaS3khbViyDfFB6rKMebw2KFqO3GcFih9NandcwA5FtLxwrkeFupWJba3l4allVvZS0dIeQ7+47Vi+NdfcUiant337BIvbHcreeR7y0fq8DxvnKxQG3vLw+rh94Yb5B6zCMj5QTF8GEerA/qyjmP9IhQDnYikmhrj7Z3tXe0x2oB5qPDNs1Lx+b/fkz9/biSJ5Q8qeQpJU8r+ZySzyt5RskXlHxRyf8p+ZKSLyv5ipKvKvmakq8r+YaSbyr5lpJvK/mOku8q+Z6S7yv5gZJnlfxQyY+U/FjJT5T8VMnPlPxcyS+U/FLJr5T8Wt+EVfLOeLxXvY3ZHaIJd9iRKLwzNgbyG9UQv1XyOyW/V/IHJc8peV7JC0peVPKSkj8qeVnJK0peVfKakj8peV3JG0r+rORNJW8p+YuSvyr5m5K3lfxdyT+U/FPJO0r+peRdJe8peV/Jv5X8R8l/lfxPG0ar4mh2KZs77d/kLRte+y1x7XfEtd8T1/5AXHuOuPY8ce0F4tqLxLWXiGt/JK69TFx7hbj2KnHtNeLan4hrrxPX3iCu/Zm49iZx7S3i2l+Ia38lrv2NuPY2ce3vxLV/ENf+SVx7h7j2L+Lau8S194hr7xPX/k1c+w9x7b/Etf8R1z4wfHStprXbGZqwe/7/Cfn/I+WFHs6x3BWm3wzjWmHKZn/Lh5X+HR9Wx+/5sPw/sGFl/OfYsLr859mwkv4LbFgR/0UurEzEf4kLqyvi/5ELKxnxX+bCUn37FSasjMJ6lQmrS2G9xoSVVFh/YsLSvvB1HqyMxnqDB6tLY/2ZB0sffeW/yYP1wdjxFgtW5gOsv7BgdX2A9VcWrA9OCvP/xoK1aax9mwMrswnr7xxYXZuw/sGBtelgNf+fHFj5uck7DFjpPNa/GLA681jvMmCZEzPeKx8rmp9/+e+Xj+UbrH+XjZXMGqz/lI/VabD+Wz6Wma/6/ysbK1HA0vP38rDaClg1rbwLFnhBpcAv0qd5vq+fApp7chK3j/cPR2xVkXr7feT3wQuSLur9GeZ6m1CPeBYSfYif/pb93bTKtcWH/il12d9gq3S/6FONZTxNL/s7cJujLUqusYyn/mV/P27ztkV3+BDsTij7G3abvy0+NLsoyv7mW7X0C2uNZez2KPv7cdXUFoE1lrErpexv2FVnW3QHQbtnyv72XfW2hbhdPmV/f4+5LfBJ5h/wS/eZ3weHKKFnqrEy6vvBQUrWZ7SJ0vBWOloPubAS7dLNL1mqHldZ9NiRLb1dVgfjRfrSzmsctcvsyrZLN79IuHqvLWbfm/DawupxXRi8ePh2We+oXS6qeLvEs6XY44Zw7dKNl7Dj3VQaXlcxfjc7apeLN1d/0fwSxdtlY3g9RsK08y2ltrPBS9J4tzpql0s2Z7t080sE6fG2vugxEdwut5eOF7W18x2O2uXS6miXbn7RnvW+s6/2vQkvgvV4Vxl47dne7XK3o3aZUz3tkqTs8Z7y2qXXPo17efAKz+Xvc9Quc6utv2h+8e52ub98PUZgOz/A1M5Gfw85apd51dguYB/lw2z9ZdO+uUcQXqS84D/mqF1yjtZeRiKekb6HXm8flVvnWr69JD7j/gyfcc+Dz/jM3md85uwzPjP1GZ/5+YzPrHzGZy4+4zMDn3HN22dcs/UZ1xx9xnUyn3Ftx2dcj/AZ76F9xvs+n/FexWecX/uMc0KfcR7juxp7B+f/5+L5GOPYW9fKhwXHXs79hpxr9Zzry5xropzreJxrT5zrJZz3+Jz3pZz3UtU0/9f3JspVFJ676r/1XPu/+d914Lf+opH5fdiATb9NvnqVrkFJPyX9W3vicfo1fRLAbx3cUy2pzJ7tPvPTda5v5ce9vtr3VGwKfj3jGDSA8V6S0W58KW3xOOPcorHVTR+upn5B+dgBwK82hvSxTSrdQCWDlDQ79LH6pJXfOfCxS6vcx+o6NznwsTcI6ddNjH1xMKOPZbQbX0pbPMHoY4e0uunD1dQvKB87GPjVISF9bItKN1TJMCWtDn2sPsnq9w587LIq97G6zi0OfOyNQvp1C2NfHM7oYxntxpfSFk8y+titWt304WrqF5SPHQ786lYhfezWKt0IJSOVjHLoY/VJgX9w4GOXV7mP1XXe2oGPXSGkX2/N2Be3YfSxjHbjS2mLpxh97LatbvpwNfULysduA/zqtiF97HYq3fZKdlCyo0Mfq09ifc6Bj11Z5T5W13k7Bz52lZB+vR1jXxzN6GMZ7caX0hZPM/rYMa1u+nA19QvKx44GfnVMSB+7k0q3s5JdlOzq0Mfqk66fd+BjV1e5j9V13smBj10jpF/vxNgXd2P0sYx240tpi88x+tixrW76cDX1C8rH7gb86tiQPnZ3lW6ckvFK9nDoY/WXBF5w4GPXVrmP1XXe3YGPXSekX+/O2Bf3ZPSxjHbjS2mLzzP62L1a3fThauoXlI/dE/jVvUL62L1Vun2URJT4Dn2s/lLLiw587Poq97G6zns78LEbhPTrvRn7YpTRxzLajS+lLZ5h9LGxVjd9uJr6BeVjo8CvxkL62LhK16akXUnCoY/VX8J6yYGPvanKfayuc9yBj71ZSL+OM/bFJKOPZbQbX0pbfIHRx3a0uunD1dQvKB+bBH61I6SP3Vel+5iSjyvZz6GP1V8a/KMDH7uxyn2srvO+DnzsLUL69b6MffETjD6W0W58KW3xRUYfu3+rmz5cTf2C8rGfAH51/5A+doJKd4CSTyo50KGP1V9yfdmBj721yn3sB99Nc+BjbxPSrycw9sWDGH0so934Utri/xh97MGtbvpwNfULysceBPzqwSF97KdUuk8rOUTJoQ59rP5S9isOfOztVe5jdZ0/5cDH3iGkX3+KsS8exuhjGe3Gl9IWX2L0sYe3uunD1dQvKB97GPCrh4f0sUeodJ9RcqSSoxz62C8P6/7mOcQtV6d3VrmP1XU+woGPvUtIvz6CsS8ezehjGe3Gl9IWX2b0sce0uunD1dQvKB97NPCrx4T0sceqdJ9VcpyS4x362K8osq858LF3V7mP1XU+1oGPvUdIvz6WsS+ewOhjGe3Gl9IWX2H0sSe2uunD1dQvKB97AvCrJ4b0sSepdCcrOUXJqQ597FcV2T858LH3VrmP1XU+yYGPvU9Ivz6JsS+exuhjGe3Gl9IWX2X0sae3uunD1dQvKB97GvCrp4f0sWeodGcqOUtJyqGP/Zoi+7oDH3t/lftYXeczHPjYB4T06zMY+2Ino49ltBtfSlt8jdHHdrW66cPV1C8oH9sJ/GpXSB+bVukySrJKJjr0sV9XZN9w4GMfrHIfq+ucduBjHxLSr9OMffFsRh/LaDe+lLb4OqOPPafVTR+upn5B+dizgV89J6SPPVelO0/JJCWTHfrYbyiyf3bgYx+uch+r63yuAx/7iJB+fS5jX5zC6GMZ7caX0hbfYPSxU1vd9OFq6heUj50C/OrUkD52mkp3vpLpSmY49LHfVGTfdOBjH61yH6vrPM2Bj31MSL+extgXZzL6WEa78aW0xTcZfeysVjd9uJr6BeVjZwK/Oiukj71ApbtQyWwlFzn0sd9SZN9y4GMfr3Ifq+t8gQMf+4SQfn0BY1+8mNHHMtqNL6UtvsXoYy9pddOHq6lfUD72YuBXLwnpYy9V6eYomatknkMf+21F9i8OfOyTVe5jdZ0vdeBjnxLSry9l7Is5Rh/LaDe+lLb4NqOPnd/qpg9XU7+gfGwO+NX5IX3sApVuoZLLlFzu0Md+R5H9qwMf+3SV+1hd5wUOfOznhPTrBYx98QpGH8toN76UtvgOo4+9stVNH66mfkH52CuAX70ypI+9SqW7Wsk1ShY59LHfVWT/5sDHfr7Kfayu81UOfOwzQvr1VYx98VpGH8toN76Utvguo4+9rtVNH66mfkH52GuBX70upI9drNItUXK9kqUOfez3FNm3HfjYL1S5j9V1XuzAx35RSL9ezNgXb2D0sYx240tpi+8x+thlrW76cDX1C8rH3gD86rKQPvZGlW65khVKVjr0sd9XZP/uwMf+X5X7WF3nGx342C8J6dc3MvbFVYw+ltFufClt8X1GH7u61U0frqZ+QfnYVcCvrg7pY9eodGuVrFOy3qGP/YEi+w8HPvbLVe5jdZ3XOPCxXxHSr9cw9sUNjD6W0W58KW3xA0Yfe1Ormz5cTf2C8rEbgF+9KaSPvVml26jkFiW3OvSxzyqy/3TgY79a5T5W1/lmBz72a0L69c2MffE2Rh/LaDe+lLZ4ltHH3t7qpg9XU7+gfOxt0K+G9LF3qHR3KrlLyd0OfewPFdl3HPjYr1e5j9V1vsOBj/2GkH59B2NfvIfRxzLajS+lLX7I6GPvbXXTh6upX1A+9h7gV+8N6WPvU+nuV/KAkgcd+tgfKbL/cuBjv1nlPlbX+T4HPvZbQvr1fYx98SFGH8toN76UtvgRo499uNVNH66mfkH52IeAX304pI99RKV7VMljSh536GN/rMi+68DHfrvKfayu8yMOfOx3hPTrRxj74hOMPpbRbnwpbfFjRh/7ZKubPlxN/YLysU8Av/pkSB/7lEr3tJLPKfm8Qx/7E0X2PQc+9rtV7mN1nZ9y4GO/J6RfP8XYF59h9LGMduNLaYufMPrYL7S66cPV1C8oH/sM8KtfCOljv6jS/Z+SLyn5skMf+1NF9n0HPvb7Ve5jdZ2/6MDH/kBIv/4iY1/8CqOPZbQbX0pb/JTRx3611U0frqZ+QfnYrwC/+tWQPvZrKt3XlXxDyTcd+tifKbL/duBjn61yH6vr/DUHPvaHUs6FZuyL32L0sYx240tpi58x+thvt7rpw9XULygf+y3gV78d0sd+R6X7rpLvKfm+Qx/7c0X2Pw587I+q3MfqOn/HgY/9sZR35Bn74g8YfSyj3fhS2uLnjD722VY3fbia+gXlY38A/OqzIX3sD1W6Hyn5sZKfOPSxv1Bk/+vAx/6kyn2srvMPHfjYn0rZL8TYF3/K6GMZ7caX0ha/YPSxP2t104erqV9QPvanwK/+LKSP/blK9wslv1TyK4c+9peK7P8c+NifVbmP1XX+uQMf+3MpcyfGvvhrRh/LaDe+lLb4JaOP/U2rmz5cTf2C8rG/Bn71NyF97G9Vut8p+b2SPzj0sb/SZB34ml9UuY/Vdf6tg3r/Uki//i1jX3yO0ccy2o0vpS1+xehjn29104erqV9QPvY54FefD+ljX1DpXlTykpI/OvSxv9ZzWAe+5ldV7mN1nV9wUO9fC+nXLzD2xZcZfSyj3fhS2uLXjD72lVY3fbia+gXlY18GfvWVkD72VZXuNSV/UvI68LEm1KJ2LlcHjYw282qrG9vm9odv8PFsgzwHIZ6Rvgdf//MIYx/8M6M/nMToDyczYk1hxJrKiDWNEet8RqzpjFgzGLFmMmLN2kqGT3qzzP6ZiCTa2qPtXe0d7TFqLHoDjD9/Br/fBL9/1L/nWPSWivuLkr8q+Vt+LNIyENTfppNIecF/y9F4Ugi1zIS3reMziLcZHbZumLp8A2nc0UUaruzDLdm4Rztd8vwHA89Ye6Qz2hb1XfL8Z995tuMLlHP4O3AC/wC/x3rdv//Z2tM5vKP+/peSd5W8R0xU65AOIuUFf3dGrHcYb0jed+SkuPU3jhHrX4z6+7cQ/Y1nxHqXUX//YdQf5RveB/7g3+D3f8Dv95Bv+K/6+39KvOEqfnj3xGEQaBcqTOCpR5vm1OCoDOzvuSc9Yz3+/sDNcXcBHMcJ4Djec+P7uHn+V9pE/G1GB1s73M1EXOOO9jY5xmav9wTKRUPWeB9tg+Pm+bYQnnVehTtw2dsNGCu/h6PKc9eZsXP6ewqpcy1jnfcSUmfGzujvXaE6R8oL/j6M+tu6TobTjXgyePpCeEaF8IwJ4RkXwrNNCM92ITwTQngmhfDsEMJzXyE8PyaE58eF8NxPCM9PCOG5vxCeE4TwPEAIz08K4XmgEJ4HCeF5sBCenxLC89NCeB4ihOehQngeJoTn4UJ4HiGE52eE8DxSCM+jhPA8WgjPY4TwPFYIz88K4XmcI57V/Fzw+ArVOVJe8E9g1N82Qp4XnejJ4HmSEJ4nC+F5ihCepwrheZoQnqcL4XmGEJ5nCuF5lhCeKSE8O4Xw7BLCMy2EZ0YIz6wQnhOF8DxbCM9zhPA8VwjP84TwnCSE52QhPKcI4TlVCM9pQnieL4TndCE8ZwjhOVMIz1lCeF4ghOeFQnjOFsLzIiE8LxbC8xIhPC8VwnOOEJ5zhfCcJ4RnTgjP+UJ4LhDCc6EQnpcJ4Xm5EJ5XCOF5pRCeVwnhebUQntcI4blICM9rhfC8TgjPxUJ4LhHC83ohPJcK4XmDEJ7LhPC8UQjP5UJ4rhDCc6UQnquE8FwthOcaITzXCuG5TgjP9UJ4bhDC8yYhPG8WwnOjEJ63COF5qxCetwnhebsQnncI4XmnEJ53CeF5txCe9wjhea8QnvcJ4Xm/EJ4PCOH5oBCeDwnh+bAQno8I4fmoEJ6PCeH5uBCeTwjh+aQQnk8J4fm0EJ6fE8Lz80J4PiOE5xeE8PyiEJ7/J4Tnl4Tw/LIQnl8RwvOrQnh+TQjPrwvh+Q0hPL8phOe3hPD8thCe3xHC87tCeH5PCM/vC+H5AyE8nxXC84dCeP5ICM8fC+H5EyE8fyqE58+E8Py5EJ6/EMLzl0J4/koIz18L4fkbITx/K4Tn74Tw/L0Qnn8QwvM5ITyfF8LzBSE8XxTC8yVHPGuZef4RYJV7RvxbrTLq/DJjnbcVci7+K54Mnq8K4fmaEJ5/EsLzdSE83xDC889CeL4phOdbQnj+RQjPvwrh+TchPN8WwvPvQnj+QwjPfwrh+Y4Qnv8SwvNdITzfE8LzfSE8/y2E53+E8PyvEJ7/E8JTA0rgWSOEZ60QnnVCeNYL4dkghGc/ITz7C+E5QAjPRiE8m4TwHCiE5yAhPJuF8BwshOcQITxbhPAcKoTnMCE8W4XwHC6E51ZCeG4thOcIITxHCuE5SgjPbYTw3FYIz+2E8NxeCM8dhPDcUQjP0UJ4jhHCcychPHcWwnMXITx3FcJzNyE8xwrhubsQnuOE8BwvhOceQnjuKYTnXkJ47i2E5z5CeEaE8PSF8IwK4RkTwjMuhGebEJ7tQngmhPBMCuHZIYTnvkJ4fkwIz4874lmLeJb7XmQNY533+wjW+RNC6lzHWOf9K1TnSHnBn1DDp7//Cnln+gDGOr/dKsPXflLImHCgEJ4HCeF5sBCenxLC89NCeB4ihOehQngeJoTn4UJ4HiGE52eE8DxSCM+jhPA8WgjPY4TwPFYIz88K4XmcEJ7HC+F5ghCeJwrheZIQnicL4XmKEJ6nCuF5mhCepwvheYYQnmcK4XmWEJ4pITw7hfDsEsIzLYRnRgjPrBCeE4XwPFsIz3OE8DxXCM/zhPCcJITnZCE8pwjhOVUIz2lCeJ4vhOd0ITxnCOE5UwjPWUJ4XiCE54VCeM4WwvMiITwvFsLzEiE8LxXCc44QnnOF8JwnhGdOCM/5QnguEMJzoRCelwnhebkQnlcI4XmlEJ5XCeF5tRCe1wjhuUgIz2uF8LxOCM/FQnguEcLzeiE8lwrheYMQnsuE8LxRCM/lQniuEMJzpRCeq4TwXC2E5xohPNcK4blOCM/1QnhuEMLzJiE8bxbCc6MQnrcI4XmrEJ63CeF5uxCedwjheacQnncJ4Xm3EJ73COF5rxCe9wnheb8Qng8I4fmgEJ4PCeH5sBCejwjh+agQno8J4fm4EJ5PCOH5pBCeTwnh+bQQnp8TwvPzQng+I4TnF4Tw/KIQnv8nhOeXhPD8shCeXxHC86tCeH5NCM+vC+H5DSE8vymE57eE8Py2EJ7fEcLzu0J4fk8Iz+8L4fkDITyfFcLzh0J4/kgIzx8L4fkTITx/KoTnz4Tw/LkQnr8QwvOXQnj+SgjPXwvh+RshPH8rhOfvhPD8vRCefxDC8zkhPJ8XwvMFITxfFMLzJSE8/yiE58tCeL4ihOerQni+JoTnn4TwfF0IzzeE8PyzEJ5vCuH5lhCefxHC869CeP5NCM+3hfD8uxCe/xDC859CeL4jhOe/hPB8VwjP94TwfF8Iz38L4fkfITz/K4Tn/4Tw9Gpl8KwRwrNWCM86ITzrhfBsEMKznxCe/YXwHCCEZ6MQnk1CeA4UwnOQEJ7NQngOFsJziBCeLUJ4DhXCc5gQnq1CeA4XwnMrITy3FsJzhBCeI4XwHCWE5zZCeG4rhOd2QnhuL4TnDkJ47iiE52ghPMcI4bmTEJ47C+G5ixCeuwrhuZsQnmOF8NxdCM9xQniOF8JzDyE89xTCcy8hPPcWwnMfITwjQnj6QnhGhfCMCeEZF8KzTQjPdiE8E0J4JoXw7BDCc18hPD8mhOfHhfDcTwjPTwjhub8QnhOE8DxACM9PCuF5oBCeBwnhebAQnp8SwvPTQngeIoTnoUJ4HiaE5+FCeB4hhOdnhPA8UgjPo4TwPFoIz2OE8DxWCM/PCuF5nBCexwvheYIQnicK4XmSEJ4nC+F5ihCepwrheZoQnqcL4XmGEJ5nCuF5lhCeKSE8O4Xw7BLCMy2EZ0YIz6wQnhOF8DxbCM9zhPA8VwjP84TwnCSE52QhPKcI4TlVCM9pQnieL4TndCE8ZwjhOVMIz1lCeF4ghOeFQnjOFsLzIiE8LxbC8xIhPC8VwnOOEJ5zhfCcJ4RnTgjP+UJ4LhDCc6EQnpcJ4Xm5EJ5XCOF5pRCeVwnhebUQntcI4blICM9rhfC8TgjPxUJ4LhHC83ohPJcK4XmDEJ7LhPC8UQjP5UJ4rhDCc6UQnquE8FwthOcaITzXCuG5TgjP9UJ4bhDC8yYhPG8WwnOjEJ63COF5qxCetwnhebsQnncI4XmnEJ53CeF5txCe9wjhea8QnvcJ4Xm/EJ4PCOH5oBCeDwnh+bAQno8I4fmoEJ6PCeH5uBCeTwjh+aQQnk8J4fm0EJ6fE8Lz80J4PiOE5xeE8PyiEJ7/J4Tnl4Tw/LIQnl8RwvOrQnh+TQjPrwvh+Q0hPL8phOe3hPD8thCe3xHC87tCeH5PCM/vC+H5AyE8nxXC84dCeP5ICM8fC+H5EyE8fyqE58+E8Py5EJ6/EMLzl0J4/koIz18L4fkbITx/K4Tn74Tw/L0Qnn8QwvM5ITyfF8LzBSE8XxTC8yUhPP8ohOfLQni+IoTnq0J4vuaIZy3iGYu0x+OZRDTjx/xUJNrRmWyLxNs625N+0m9LtqWjyVgsk4wnEx2dHYlIhx+PZfxsW0csm8fejbHOf6pQnSPlBf/1Wj791Q6X0c71jPp7Q4htNzDW+c9C6tyPsc5vCqlzf8Y6vyWkzgMY6/wXIXVuZKzzX4XUuYmxzn8TUueBjHV+W0idBzHW+e9C6tzMWOd/CKnzYMY6/1NInYcw1vkdIXVuYazzv4TUeShjnd8VUudhjHV+T0idWxnr/L6QOg9nrPO/hdR5K8Y6/0dInbdmrPN/hdR5BGOd/yekziM9vjp7dTLqPIqxzjVC6rwNY51rhdR5W8Y61wmp83aMda4XUuftGevcIKTOOzDWuZ+QOu/IWOf+Quo8mrHOA4TUeQxjnRuF1Hknxjo3Canzzox1Hiikzrsw1nmQkDrvyljnZsY6K6gP9ru8mK/wHkr2VLKXkr2V7KPLUOIriWo9KIkraVPSriShJKmkQ8m+Sj6m5ONK9lPyCSX75+t9gJJPKjlQyUFKDlbyKSWfVnKIkkOVHKbkcCVHKPmMkiOVHKXkaCXHKDlWyWeVHKfkeCUnKDlRyUlKTlZyipJTlZym5HQlZyg5U8lZSlJKOpV0KUkrySjJKpmo5Gwl5yg5V8l5SiYpmaxkipKpSqYpOV/JdCUzlMxUMkvJBUouVDJbyUVKLlZyiZJLlcxRMlfJPCU5JfOVLFCyUMllSi5XcoWSK5VcpeRqJdcoWaTkWiXXKVmsZImS65UsVXKDkmVKblSyXMkKJSuVrFKyWskaJWuVrFOyXskGJTcpuVnJRiW3KLlVyW1Kbldyh5I7ldyl5G4l9yi5V8l9Su5X8oCSB5U8pORhJY8oeVTJY0oeV/KEkieVPKXkaSWfU/J5Jc8o+YKSLyr5PyVfUvJlJV9R8lUlX1PydSXfUPJNJd9S8m0l31HyXSXfU/J9JT9Q8qySHyr5kZIfK/mJkp8q+ZmSnyv5hZJfKvmVkl8r+Y2S3yr5nZLfK/mDkueUPK/kBSUvKnlJyR+VvKzkFSWvKnlNyZ+UvK7kDSV/VvKmkreU/EXJX5X8TcnbSv6u5B9K/qnkHSX/UvKukveUvK/k30r+o+S/Sv6nRHewGiW1SuqU1CtpUNJPSX8lA5Q0KmlSMlDJICXNSgYrGaKkRclQJcOUtCoZrmQrJVsrGaFkpJJRSrZRsq2S7ZRsr2QHJTsqGa1kjJKdlOysZBcluyrZTclYJbsrGadkvJI9lOypZC8leyvZR0lEia8kqiSmJK6kTUm7koSSpJIOJfsq+ZiSjyvZT8knlOyvZIKSA5R8UsmBSg5ScrCSTyn5tJJDlByq5DAlhys5QslnlByp5CglRys5RsmxSj6r5Dglxys5QcmJSk5ScrKSU5ScquQ0JacrOUPJmUrOUpJS0qmkS0laSUZJVslEJWcrOUfJuUrOUzJJyWQlU5RMVTJNyflKpiuZoWSmkllKLlByoZLZSi5ScrGSS5RcqmSOkrlK5inJKZmvZIGShUouU3K5kiuUXKnkKiVXK7lGySIl1yq5TsliJUuUXK9kqZIblCxTcqOS5UpWKFmpZJWS1UrWKFmrZJ2S9Uo2KLlJyc1KNiq5RcmtSm5TcruSO5TcqeQuJXcruUfJvUruU3K/kgeUPKjkISUPK3lEyaNKHlPyuJInlDyp5CklTyv5nJLPK3lGyReUfFHJ/yn5kpIvK/mKkq8q+ZqSryv5hpJvKvmWkm8r+Y6S7yr5npLvK/mBkmeV/FDJj5T8WMlPlPxUyc+U/FzJL5T8UsmvlPxayW+U/FbJ75T8XskflDyn5HklLyh5UclLSv6o5GUlryh5VclrSv6k5HUlbyj5s5I3lbyl5C9K/qrkb0reVvJ3Jf9Q8k8l7yj5l5J3lbyn5H0l/1byHyX/VfI/JXoyUaOkVkmdknolDUr6KemvZICSRiVNSgYqGaSkWclgJUOUtCgZqmSYklYlw5VspWRrJSOUjFQySsk2SrZVsp2S7ZXsoGRHJaOVjFGyk5KdleyiZFcluykZq2R3JeOUjFeyh5I9leylZG8l+yiJKPGVRJXElMSVtClpV5JQklTSoWRfJR9T8nEl+yn5hJL9lUxQcoCSTyo5UMlBSg5W8ikln1ZyiJJDlRym5HAlRyj5jJIjlRyl5Gglxyg5VslnlRyn5HglJyg5UclJSk5WcoqSU5WcpuR0JWcoOVPJWUpSSjqVdClJK8koySqZqORsJecoOVeJ/ra8/m67/ia6/t64/pa3/k62/ga1/r6z/nay/i6x/uav/p6u/lat/g6s/saq/n6p/jao/u6m/qal/l6k/hZjTon+hqD+Pp/+9p3+rpz+Zpv+Hpr+1pj+jpf+Rpb+/pT+tpP+bpL+JpH+3o/+lo7+To3+Boz+vor+don+Loj+5ob+noX+VoT+DoP+xoH+foA+m1+fe6/PlNfnteuz0G9Wos/w1udj67On9bnO+sxkfR6xPutXn6Orz6jV57/qs1X1uaX6TFB93qY+y1KfE6nPYNTnG+qzA/W5fPrMO32enD6rTZ+Dps8Y0+d36bOx9LlT+kwnfV6SPovoS0r0GTr6fBp99os+V0WfWaLPA9FnbehzLPQZEfr8BX22gT43QL+Tr9931++S6/e09TvQ+v1i/e6ufi9Wv3Oq3+fU70rq9xD1O376/Tn9bpp+70u/U6XfV9LvAj2nRL/Dot8P0fNc/V6DfmdA78fXe931PnK9R1vvWdb7gfWeVr3HU+951HsA9Z44vUdM75nSe4j0nhq9x0TvudB7EPQzef2MWj+z1c8w9TM9/YxLP/PRz0D0MwG9Rq7XjPUaql5T1Gtses1Jr8HoNQl9j67vWfU9nL6n0XP82k1TB0/v19VhD6875N2Khv4gXu9v1fs99f5HvR9Q74/T+8X0/im9n0jvr9H7TfT+C70fQT+f18+r9fNb/TxTP9/Tz7v08x/9PEQ/H9Dr5Xr9WK+n6vVFvd6m159GKxmjZCcl+v5V38/p+xu9f3yskt2VjFMy3usd9Lhkwnb5/7d66YBR53/nzoNhuh0scTMaguNm5eO+e+Oz37jrqlQaxl1oyXeRJd8llnxzLXE5C+YCS77LLPmusOS72hK3yIJ5nSXfEku+pZZ8N1riVlgwV1nyrbHkW2fJd5MlbqMF81ZLvtst+e605LvHEnefBfMBS76HLPkeseR73BL3pAXzaUu+z1vyfcGS70uWuK9YML9myfcNS75vWfJ91xL3fQvms5Z8P7Lk+4kl388tcb+0YP7aku+3lny/t+R73hL3ogXzj5Z8r1jyvWbJ94Yl7k0L5l8s+f5myfd3S753LHHvWjDft+T7jyXf/yz5avsFx9X3C8bsZ8k3wJKvyZKv2RI3xII51JKv1ZJvK0u+vSxx+1gwfUu+mCVfmyVf0hK3rwXz45Z8n7Dkm2DJd6Al7mAL5qct+Q615Dvcku9IS9zRFsxjLfmOs+Q7wZLvZEvcqRbM0y35zrTkS1nypS1xWQvm2ZZ851ryTbLkm2qJO9+COcOSb5Yl34WWfBdb4i61YM615MtZ8i2w5LvcEnelBfNqS75FlnzXWfI9bsn3bv9N/19y0H6xZb+8Zx6Mqxuw6f+b7t7h8W1fqj0FxjVY4potcUMsccMsccMtcdtZ4nawxO1sidvVEjfOEreHJS5miWuzxCUtcfta4j5piTvIEneoJe5wS9zxlrgTLXFnWuJSlri0JS5riZtiiZtmiZtlibvQEneJJW6OJe5yS9yVlrhrLHHXWuJutMStsMSttcStt8RtzMd97uuXvL/xV186D8bdlY/7fPLrh/3yziFbw7i783HfP3btT08YdmELjLvHEnevJW7/1k3/U/7zgHwc5T8PtOQ72JLv05Z8h1nijrBgHmnJd7Ql37GWfMdb4k60YJ5syXeqJd/plnxnWeI6LZhpS76sJd/ZlnznWeImWzCnWvKdb8k3w5LvAkvcbAvmxZZ8l1ryzbXkm2+JW2jBvNyS70pLvqst+a61xC22YF5vyXeDJd+NlnwrLXGrLZhrLfnWW/LdZMl3iyXuNgvmHZZ8d1ny3WPJd78l7kEL5sOWfI9a8j1uyfeUJe5zFsxnLPm+aMn3JUu+r1rivm7B/KYl37ct+b5ryfcDS9wPLZg/tuT7qSXfzy35fmWJ+40F83eWfH+w5Hveku8lS9zLFsxXLfn+ZMn3hiWfPmsoKK5+eDBmP0u+AZZ8TZZ8zZa4IRbMoZZ8rZZ8W1nyjbTEbWPB3M6SbwdLvtGWfDtb4na1YI615BtnybeHJd/elriIBTNqyRe35Gu35OuwxH3MgrmfJd/+lnwHWPIdZIn7lAXzEEu+wyz5jrDkO8oSd4wF87OWfMdb8p1oyXeKJe40C+YZlnxnWfJ1WvJlLHETLZjnWPKdZ8k32ZJvmiVuugVzpiXfBZZ8sy35LrHEzbFgzrPkm2/Jt9CS7wpL3FUWzGss+a615FtsybfUErfMgrnckm+lJd9qS751lrgNFsybLfluseS7zZLvTkvc3RbMey357rfke9CS7wuWuP+zYH7Zku+rlnxft+T7liXuOxbM71ny/cCS74eWfD+xxP3MgvkLS75fWfL9xpLv95a45yyYL1jyvWTJ97Il32uWuNctmH+25HvLku+vlnx/t8T904L5L0u+9yz5/m3J9z9LXM1WwZh1WwXna7Dk62/J12SJG2TBHGzJ12LJN8ySL2KJi1ow45Z87ZZ8SUu+j1ni9rNg7m/Jd4Al34GWfJ+yxB1iwTzMku8IS74jLfmOscR91oJ5vCXfiZZ8J1vynWaJO8OCeZYlX6clX9qSb6Il7hwL5nmWfJMt+aZa8k23xM20YF5gyTfbku9iS745lrh5Fsz5lnwLLfkut+S735Lv+fzTqwt3/+RT//7m62/BuFe3DsZ8OyBuaP7/W3fe9H9j/u/a/P96S7XeBz4h/3ekvOA3Alxu/GQk1dbo9QzM/GONANMBftTg17vBj/Q37Z3rie+hcpvzf4Mt9YU8Jq4WxN2WjxuQjze/F+R/NyI8F+0OOXHrrZXgXwvqpsOBORdlR7sM/kF5fK8HdjaeiKUTqfauzmS6M9YVTyUT8VQi1dbR7vvpVCTd0RHpjHZFUolssi3Zlsn6nZmM39WRykaSbamYwT4YcK/3+PRm8D/lBr/gTz7tBj9q8A/JUbqPZToTkVhbqj3Z6WdT7dlIZzyRjKWyiUQ6le6IZxJtkbTf1e53Rf1sMplqa0t1tXX4fjbT0ZZNthvsQ0nsTDLZ1dGZyEayqWxHNBWJRqKdXelsW6RdlZHNdLVls7F4R6QtlkynutKJLr+jK5aMZrsyHdlIR6FdDyOx09G2VLYrne6MR7IdsUQqkVS205HoVABJP9bup7o6lE1l/UyqK9HVmcpEVFkZP5VO+OlErOBjDwc657P3bvwjAH4NG368oJvPOOEf7TT4R+Yo3ZcUfHzBYB/lhHt3fzraCb5f4H+ME/xYQffH5ijdJ/2U8o/pdNxPprvSsUgmllWeMZmKp9v9pO66sWRnOtaWyCiH6idTiWhbpq09lVJ9ONXlF3TzWRI7E03E47EOPxH3E+3pWHsmHUl2ZZPpmJ/y/U4/nc5mlV/uVE4h257oaFf9NtOVSWSSne3KORRs8jgSu7xgsI93onM/YfBPcIMfN/gnOsGPFPzNSW7wC217cs7r1bZ+MhaNJmL6XJdkWtU13RVNRqPaMSvD7IpmOuJ+RzYejce60mqAjydTvh4QujqyyU3gBvsUN9wL49+pbvALbXsawOfz9d3+7HQ3+IW2PcMNfkH/Z7rRf9bgn8WM356KdGTa2wu+IcWM39nZnkhlkoW+28mMH+tqz2RjiYL+u5jxU23xbLYtljL4aWb8Nj+SaYsmCu2bYcbv6Iy0tasZqsHPMuOr+XIs3ZEqjOcTufXTmYl0pf0Og382M/6mEC/453Oc4MeSBv9cgM/nf2KFe5Tz3PAv+P9JTvAjGYM/OY/vefzzhikuuPvdY/vUYO59nj4Y7GkEdjQV64qou8hUm5oCKx+r1KiWDzKdyUy2PZrq7IpHomnf9zNx9U80k453dKrpc2d7Rk2XO1VxBd7nu9BLxO8y60vTAXezLmPKnuGk7EhHDSrP83qun3mo/CbElft+rQaVB/lA/Zi1KqO7mbneXFuIODgvwHF1xDVTDoWVYsTqZMTqYsRKM2JlGLGyjFhmLKb6mg4T8v9HygyNqGzmuXUBfxbAr3OAf4Eb/RTubS7M47vAns2PXZhTX+RG74U5y8Vu8Av3NJe4wS/M6S51g1+Y885xg1+4p5nrBr9wTzDPDX7hnibnBj9t8Oc7wfcL+lkA8Pn8ZrTg1xa6wS/o5zIn+LEC/8vd4Bd85xVO8OMF/Cvd4Bfua65yg1/wz1e7wS/c813jBL+tcO+0yAl+e6F9r3WDXxh/r3ODX1gTXewGv7BmsMQNfsH+r3eDX7D/pW7wC/OTG9zgF+Yny9zgF+YnN7rBL4yPy93gF+YPK9zgF8bHlW7wC/5zlRv8gv9c7QQ/URjf17jBL/jPtW7wC/5znRv8gv9c7wa/4D83uMEv+M+b3OAX/NvNbvAL/m2jG/yCf7vFDX5an/ur9/YNHLUJj9oTyTjfipj9hmZvoikDlt0ArjPeS6XDrPfC8psQVxfrvbA8wwfrB6736rh+BNcWIg63YT+inH5EOS1EHJ6flYO1hhHrekasVYxYnHVcwYi1jBFrJSPWUkasBYxYnLrn7ENrqxRrESMWp01w6p7TvhYzYnH2bU6buI4Ri9NHb2DEqtbx0cx7Gz16fjAh/3ekzGDwB7jBjxld9LfoApZv5kpwblUT8L/BwnGmrCaExVw331Y3yB+3c3/AB+ogCKt/iViNRJyLNu1nqTcuPyg9NV826Rst+DD9EK+3DTciXTS50UXU1m7wPTtT/iDAM53pnDXxiKkTPRSC5v/boXTmmXmt11vfAwKwPPT3duhaHcCDQfMekv+dzczsOvu41MSJmbRiPwOl7JX1oBx9Hd8WwTSOTTjaV1fiyA37YdykDsbkdXMMzP+eNDWVPjA1bcasSZlapEp4B4zVCeFwtXFT1QBKniXdQbmef5s3ZOq84GBUafAGgDhKBQbT9Pogq8fNVU+Ua67VEun7I6z+RD7Dvc6SH2LAfNiUbN0hjLmaeuhArSrgt0ptKzluup0f62u3c72SY2srqFe3syU/ausDAwj9mLZsJOIMlhl5Gjx6ZBoA6ohHyibAowFd+1v+/xaEqYN5g8o2ksNrRr/aXt9AdYNtg+3UTTvE/bB2aspv8pwOV77NLqjZYaPXu505d9SHaVfI17RlExFnsMxwBu0Upm8EdYTp4W+Tv8e1fIO1eL1tGttpE1EfeA3a6Xv5340B9ZmQ/ztSVkgkcB83ZcCy3cxu/a6w/cCU3+S5tLvufkC1E+VPjO4GElxbiDg8Wx5IlDOQKKeFiMOrAeVgrWLEuo4Rawkj1toqxVrGiLWSEWspI9YCRqzljFicdl+N+rKNg6Vi6cBpq+sYsW5gxOK0Vc46LmLEqta+vZER6zJGLLPLAs8zDb4OjV7vvsd97wbLM/WA12D5TYgrL5/uuRKlV2pOa/QzyI1+CnwGEXwGEfoxbdlMxBmswfm/4T0DTD8I1BGmh79NfnjtsHyDtSBMHfA9QzNRH3gN3jMcVNOzbrBtsJ26bAdYnuENr8HymzyX/SZitQuq/zd6vduZUT+RMO0K+Zq2HEzEGSyzcg7tFKZvBnWE6eFvkx9eOwnZKbRpbKeDifrAa9BOj0V2CtsG26mTdvCzoe3UlN/kuew33XZK2cUgQo+NXu92ZtRPJEy7Qr6mLYcQcQbLvGkK7RSmHwzqCNPD3yY/vJZFdgptGr9ZOoSoD7wG7fSsPG5jQH0m5P+OlBXa4lRb8uEn/GainrifQV3z2XUsdD8z5Td5ve3CRT9rQXyC7MDobijBtYWIwzYylChnKFFOCxGH72vKwVrCiLWAEes6RqzljFiLGLGWMWKtYMTitInFjFjXMGKtZcKi/HM5vNYw8dJhHSMWZ9/eyIjF6Qs5++NKRizOdryFEYvTJjh1z9W3PeY6ctrEKkasavUTnLw+CnOmLWPa5tM9Z3+8nhGLs443VSkvzvkEZx3x8wF4b1mT/7/R6933GO+zMzWoPFMPeA2W34S48vLpvs+m9NpC6NXobhjBtYWIw/fZw4hyhhHltBBxeMwoB2sJI9YCRizOOi5jxFrJiLWOEYtT9xsZsba0Y2lYtzBicdrEYkasVYxYnP5rLSMWp+45bZVT99XqvzhtldO+VjBicbYjp31x9iFO+1rDiLWIEYuzjtU6l+OsI+d8olrbsVrncjcxYlXrPIdzjrllPvHh6EOcfoKTF5d96d94XbUcXuuZeOnAqXvOOYAZa/F+N4Ovg9s1tGjoPbZ4Dc3JHqwia2jU3rpGr7cdMurHD9POkK9py1YizmDlP0DfY08YTD8M1BGmh79NfnjtlLxSWhCmDnhPWCtRH3jN6FfvCTsu/0djQH0m5P+OlBeSeD3UlAHLhnpitLtQX0CB5Td5Lu2uux9Q7UT5F6O74QTXFq+37WB7GE6UM5woZwtWdWGdxoRl82EmXodGIh+3v4XlmXrAa7D8Js+pX/BteqX8pdHPVm70U9ijvBXBZytCP6YttybiDNaI/N9wPILptwJ1hOnhb5MfXpuLxqOtQVrcB7Ym6gOvwfFodm3PusG2wXbqph3Cv/Nhym/yXPabbjul7ILq/41e73Zm1E8kTLtCvqYtRxBxBmtk/m9opzD91qCOMD38bfLDa9ciO4U2je10BFEfeA3a6RX5P4Z4wf0zTH+GuJTfxjqE+XB/cNLefiYStj+Y8ps8l/2zuz9sHVKvRj8jnOgnnQ1jP5CvacuRRJzByh9U3aM/wPQjQB1hevjb5IfX1qP+APsO7g8jifrAa7A/rER+G7YNtlMn7RCJZMPaqSm/yXPpJ7vtlLILavxr9Hq3MyOfTJh2hXxNW44i4gzWNvm/oZ3C9CNBHWF6+Nvkh9fuRXYKbfq4XE8Oo4j6wGvQTm9H97u4PhPyf0fKChmfaks+/FThJNJRTvCjHY1Ee/HhdyYN/rZu8NsN/nZO8JOF9t3eCX5bQT87uMFPG/wd3dhPgf9oJ/ixmMEf4wQ/U+C/kxP8eAF/Zyf4nYX+u4sT/I6C/e/qBD/bZvB3c8O/YD9j3fAv+OdxAJ9zrcDg7+EEv/vU4vFed6gj6mTKN3OF3UH6moD/DRaOM2U1ISxX8zKqbpA/vi8bD/hAHQRhjS8Rq5GIc9Gm4yz1huU3W7jieuhwWY5HJzosZsS6mhFrDRMWNfcsh9flOT5eI5l4UfPTcrC2YcSqY8LS4cocH69tmXjp39tVKdb2jFg7MGLtyIg1mhFrDCPWTkxYOuCvzZXDa2dGXqsZee3CyOuIHB8vrrFD/96VEWs3RqyxTFg64LXNasEyz3jdrkfFO9yuR8VSbtej4mm361FtMbfrUfGE2/WoeNztelG8y9wLmDHSlAFtdzS4znffEg/9Lqgpvwlx5eXTff84GvHB+sH7d8YQXFuIOOwDxhDljCHKaSHi8F7ecrA2MGItYsRazoi1jBFrMSPWAkasFYxYSxix1lYpFqetLmXE4tK9/o3nBdViq5z9cR0jVrX2x/WMWJx9qFp1fwMjFqef4BxrOX00p+459VWt9sU5N+FsR07dfxT8xEYmLP0b3yOXw+tKRl7bMPHixNLhihwfr20ZeXHpXodrGLE4bQKv1ZeDVceEpQOXTehwNROW/o3Xd6qlHTl5cdmq/l2tvrCZkRen/+JsR05e1agvHThtFa+tVoOt6sDlv3S4hRGLc/51PSMW55oC55yc816Bc+3RzO/NOvb2IK4m/7/bZwCRPj8D2N4NH+szgO0JvVL7VRn5pMO0M+Rr2nInIs5g7Zz/G+7th+nHgDrC9PC3yQ+vPZNvuBaEqQPe278TUR94zehX7+1/oq5n3UaDdNhO3bRD+G/AmvKbPKf9xrfZxWhCj5RdmLwtRBye04dtL6rt8d66crBWMWJdx4i1hBFrbZViLWPEWsmItZQRawEj1mpGLM4+xNmOGxixFjFirWPE4uzbnPbF2Yc4/epHQfcrGLE4fbTxheb99TFeN3aD17OcMUQ5YyzlwPwmndv3tdqibt/Xamt3+75WPGvmXbsAvdYg3cF9mnxzxGTo8y5M+U2IKy+f7jnrrogP1g+es+5GcG0h4vD+qt2IcnYjymkh4rBvLQdrAyPWIkas5YxYyxixFjNiLWDEWs2ItYYRi1P31Wqr6xixljBicdoXp89ZxYj1UdD9CkYszjqurVIszr69lBGLS/f6N947WS22Wq1zAE6sLeP2lnFbytixZdzeMm5vGbc/nLqvVltdz4jFqS9On8Op+xsYsTj7EOe4Xa0+ulrnE5x15Jz7crYjp+4/Cn5iIxNWjdd7D0U5WGMYsbjWyfXvnZiwdLgix8ermZHXlTk+rGsYsa5mwtK/d/b4sD7sute/8f72crC2YcTalglLB05bPYIJi9NWdeDsQ9Vq99Vaxw+7L+TkpcOWsUP+2KHDVUxY+jfnngcufenfOzDx0r+3Y8TiGmt14JxPcOlLh2ocO3S4hRFrASPW9YxYnM90ONcBONcnOPfn4HeQ4N6wmvz/1JnhupwJ+b8jZYVo6Hc7TPlNiCsvn+59cpRedyX0anQ3luDaQsRhfzqWKGcsUU4LEYftvRystYxY1zFirWLE2sCItYQRa02V8lrMiLWAEWsjI9ZljFi3MGJx6mslIxZnf1zHiMVp95y+kLMdr2fE4vQ5nDaxghGLU/eLqpTXakYsTpvgnJtwjtuc7Vit/ovTvjj7Y7X6aE4sTvtayohldI/f6zH4OlDfb2K814vXoPJMPeA1WH4T4srLp/tej9IrdQ9tdDeO4NpCxOFn0NQ3gsYR5bQQcdg3l4O1ihHrOkasJYxYa6sUaxkj1kpGrKWMWAsYsVYzYi1ixOLsj+sYsTjti1NfyxmxOO2Lsw9x+lVOm+D0q9Xatzn7I2cf2sCIxdkfPwr2tYIRi3MOgM+JgPNtfE5EqXN+mN+kayby1eT/b0T8ajzOOXZH6HMQTPlNhE5czPnHhdRrKd/r1L85vz+Jx6ZysDYwYi1ixFrOiLWMEYvzW6kLGLG4vsOnA9d3V3Xg1H212uo6RqwljFic9sXpc1YxYn0UdL+CEYuzjmurFIuzby9lxOLSvf7N9d1oHThttVrnAJxY1Tpuc+qecw7A6aM55xPVaqtbxu3NN6ZtmZOXhrVlTr757GvLvHDz2Vc1zgt14NRXtdrqekYsTn1x+hxO3d/AiMXZhzjHjmr10dU6pnHWkXPuy9mOnLr/KPiJjUxYNV7vPU7l8Loix8drDBMv/buZEYvz+RCnvnZg5HUNEy8drmbC0r939viwuGxChytzfFhcuufs29z9kasP6d87MWHpwNkfPwr2hc9xKQdrG0asbZmwdOD0hUcwYXH6Qh04fXS12n211vHDPtZy8tJhy9xE/tihw1VMWJzzCR249KV/c83J9e/tGLG4xlodOOcTnPcw1Th26HALIxbnmsL1jFicz60415k4178WM2Lhc1zg3taa/P+NXu/+osuZkP87Ul4IfY6LKb8JcWXm49v0Su3TNvrZww2fzhqED/nsQejHtOWeRJzB2iv/N/yWNEy/B6gjTA9/m/zw2u/7bfq/BWHqcFyuJ4c9ifrAa0a/GvKX/XrWDbYNtlM37eCnw9qpKb/Jc9pvfJtdUP2fsguTt4WIw2s4YduLanu8N6EcrFWMWNcxYi1hxFpbpVjLGLFWMmItZcRawIi1mhGLsw9xtuMGRqxFjFjrGLE4+zanfXHy4mxHTl6cfoLTJjjbcQUjFqe/x+8bwrkVft/QNj+lyoH5TbpmIp+ZWzV69BxlQv7vSFkh2VaDyjP1gNdg+U2ETlzM7/YMqVeju70Iri1EHF672osoZy+inBYiDvfRcrA2MGItYsRazoi1jBFrMSPWAkas1YxYaxixOHVfrba6jhFrCSMWp31x8uJsR05enH6V0yY423EFIxan7tdWKRann1jKiMWle/0bv7tYLbZarfMJTqwtc4AtcwCXfnXLHGDLHGDLHGDLHKAYFqe+qtVW1zNiceqrWv3EDYxYnH2oWseOap37Vqt9cc6jOduRU/cfBT+xkQmrxuu9D6IcrDGMWFzr9/r3TkxYOlyR4+PVzMjryhwf1jWMWFy8uNuRU19XM2Fx2wRXO+rfo5h46d/bMGJty4SlA6fdH8GEpX/v7PFg6VCttrqlP26+OlajfemwZRzaYvc47iomLP2bc48Ip33twMRL/96OEYtr3NaBc27CpS8dqrE/6nALIxbnvej1jFicz6041yc410049zPh95vqQFxN/n+zr7AZXNfpJuT/jpQXQn+7zJTfhLgy8ynsK2z2euu1jtCr0d0IgmsLitPhuFx3OhxXR1yrrTAW1d5aJuT/jpQV2tqaibKxrcH9DXxt6yfD2popv8nr3bYubG0k4hPUbkZ3owiuLUQcbsNRRDmjiHJaiDj8nLUcrBsZsTh5rWLC0r8HeDxY3HVcwIi1ghFrLSPWUkYsTn2tY8S6mRFrNSPWEkYsTt0vY8RazIjFWceNjFiXMWKZew88t9BhQv7/SCQbT8TSiVR7V2cy3RnriqeSiXgqkWrraPf9dCqS7uiIdEa7IqlENtmWbMtk/c5Mxu/qSGUjybZU3O3coS3R6PX28YxzE9/gb+MGP2rwt3WDHzP4O7jBbzP4Y9zgtxv8ndzgJw3+zm7wO9y+/+WnDP5ebvDTBn9vN/gZg7+PG/yswY84wY9GDL7vBr/gf6Ju8Av+J+YGv+B/4m7wC+NLmxv8gn9rd4Nf8G8JN/iF8THpBr/gPzvc4Bf8575u8Av+82Nu8Av+8+Nu8Av+cz83+AX/+Qkn+LGC/9zfDX7Bf05wg1/wnwe4wS/4z0+6wS/4nwPd4Bf8z0Fu8Av+4WA3+AX/8Ck3+F0G/9Nu8Av+5xA3+AX/c6gb/IL/OcwJfrzgHw53g1/wD0e4wS/4h8+4wS/Mr450g1+YXx3lBr/g3452g1/wb8e4wS/Mr451g1/wn591g1/wn8e5we80+Me7wS/45xPc4Bf884lu8Av++SQ3+AX/fLIT/LbC/PAUN/gF/3+qG/yC/z/NDX7B/5/uBr/g/89wg1/w/2e6wS/4/7O87sCD3b02nHLB3c8WbL+T5B7LdCYisbZUe7LTz6bas5HOeCIZS2UTiXQq3RHPJNoiab+r3e+K+tlkMtXWlupq6/D9bKajLZssjFtdgHsNm26SBe5pJ/iRgl1mnOg+XfBrWUL30Xi6vTMVSWQTqVQyqwahaFr91640n22LpjpiXSnVEunOTEo9LumIdqWj6VgmqfpqJtbRnsl0+/yJZLuWwztS0PvZ3NiRWGGsPYfEziSTXR2diWwkm8p2RFNqbTTa2ZXOtkXalTayma62bDYW71BqSKZTXelEl9/RFUtGs12Zjmyko9Ce55LY6WhbKtuVTnfGI9mOWCKVSCr9diQ6FUDSj7X7qa4O9Ywq62dSXYmuzlQmosrK+Kl0wk8nuu9xz3Nii93PECax22Lyg3/1McKP5zcumDPtJoOy+qF6Tcn/bc5J1mFWrjvNZBAP0z82ZNP/Gu/pfHlh9qDVs9f7A7121KDyPI/eF2TKr9QetHrEB+sH7wtqILi2oDgd8HPiBqKcBqIcCusWRqwFjFirGbGWMGKtZMRazIi1jBGLs45LGbGq1b4WMWKtYcRax4jFaV+c+lrOiMVpX5x9aBUjFqdNcPpVvJcdxuF5BJzHMI7b0bDzCFN+k9d73HYxj+jnhdPrICUD878nTU2lD0xNmzFrUqYWqRJOw7A6IRyuNlQLjMNTPpzukFzPv4/K9c7nEdh1AK8RxFEqMJhm2gvr1BiQD+rCI67VEun7Iax+RD7Dvc6S3/Ocm3Nh2aHJDX7M1jawTqb8Zq+3zmsC/jdYOM6U1eTROp/ApDtb3SB/7NIaAR98u0VhNZaI1UjEuWjTfpZ6w/KbLVypeuBj1akhg7pFMumbLLxg+iFE2Sav0eFAEMc9jATpEPZFU7522+Z1g3Smc9bEI6bCFZ9CfqgHo7eRKJ3xg7We3Q9CLA/9PRJdqwN4MNhu+cP0Z8NThxYCyyxFbJkSFMKWKcGHe0pAuVpsSo1e77pOyP8fKSf43U9B+pHYST8VTyXT6bifTHelY5FMLNsVSSVTapnbT+qHCrFkZzrWlsikEyk/mUpE2zJt7amUerqQ6vKjGnNMXvGUe8ZuybhK+BW3RkK3DSj9aWB1ctd8Bt0NWvLxnbMmnXdsZub0czIXZJSnneGhUMx2j831/Puzud75qGCb/lSrG3M9vbLZvg4lujFsQq7dmGl6E7jcWD2BGcaN4eaiytWhlkhvc2N4obzOkl+HZuIaNnVHM9jQpo7vJFzdhdnaGeqnTFOH6oRwuNqbc8SmJu/9CEzb5N1mnh5xrdhE2DYK1QWU12gpz4xGVNdoQGk/mQdy3CUiwwAursOWUakQtoxKH+5RqY7Ih7mVu0Zl6qFDixdc/0avtz4m5P+PRDLRRDwe6/ATcT/Rno61Z9KRZFc2mY75Kd/v9NPpbDaeSnTGM4lse6KjvS2WzHRlEplkZ3vUz8apblvj8b0qpHGPt0zk8c0knsjrALcZNIJ4mP7UfIQu72QwkTevqF6QmnROOjUzc/CU82dlZmXSR06dmZlxwJT0wRdkpswseVp/aK7n34fleuejgnYARgtDAT7WAnTCdSi9DqZHmfSt+ev9vG4OMI3J24DSn5XXlF5RGpp/25myRMOnGeU38ToYSxqOuE/I/x0pL4QeAEz5TYirqwFgOOKD9VPiAADNAqsTwuFqb84BYCsQR6kADwCwTlsF5MMmj6/VEumHI6zhRD48AFD5IQbMh00Jdz+4+jCMKBt3v/NB9xs+KrjcYV5vPeAuWEeUZ7rrViitDqa7bo0wJuT/jpQV2hJhu6spvwlxddVdt0Z8sH5K7K7QxCD8CQjOpIFpYTgBUPIC0lHNfiaRDwc8X9kaxelgzMHN8Vd+aO9tym/yXJpntzlQx6hB/dQi/Tg6rsx6PNhIQj+mLbcn4gzWjvm/oVuC6UeCOsL08LfJD69dmXdbLQhTB3xM3fZEfeA1o189c5nf2LM807dWgbnd1WguCfsftJUgdz6cKLuFyG/SUeX0L7Oc/kQ5+NmoDjNyPeOaLHHw+eTWCHMQyIefk8HjeY5DcYMBZn+EOcSC2UJg6rbbc2A3npbdQDrKFeNpw66AD8wL/25AaXW4MNczzqS9C9jVemRXcBjC7b1VEd629jbpjK6gneA2hf0Ztyn0E1j/VH80cTsS9TJxo73ugDF3AXGwTXce2DMd1DseW3YD1xmnGu1hxxZTfpPX255cjC2UfUP94LFlrBv9tNUgfMhnLKEf05a7E3EGa1z+bzi2wPRjQR1hevjb5IfXnkBjy+4gLR5bdifqA6/BseWhxp51w/6D+t/g4mu4f0PdmPal5lqmT2k+n2/sWReTD+oTjkdngHiY/lDwAPOLFh+G229XVMdivndroo5h/fgpCGtXC6+xRbBOQlgw/1iEtXsRrFMRFsy/O8IaVwTrRIQF849DWOOLYF2EsGD+8QhrjyJYFyMsmH8PhHVWEaxLEBbMfxbCShXBuhRhwfwphNVVBGsOwoL5uxBWugjWXIQF8+PXDjNFsOYhLJg/g7CyRbByCAvmzyKsiUWwJiEsmH8iwjq7CNaZCAvmPxthnVsE62iEBfOfi7DOs2Dp3+boxiFEfpO3mcAyft7d63cfTBFC3w+b8psQV14+3XOWSV5vvUL94NfQJhNcW4g4fG82mShnMlEOhbUrI9ZujFhjGbF2Z8Qax4g1nhFrD0assxixUoxYXYxYaUasDCNWlhFrIiPW2YxYePyxzZ/1b3O0r23+bPJBH4TXO/F9I0wPMYLm5/AxxW5FOG+LOJczTz8h1xOrr/N0/XsHxKuv83T9ewzCKmeefnyuJ1Zf5+n6906IV1/n6fr3zgirr/N0/XtPhAXzYz9ZbJ4+P9cTC+YvdZ5+PsLq6zxd/97L64nV13m6/r03wurrPF3/3gdh9XWern9HEFZf5+n6t4+wbPP0SUWwoggL5p+EsCYXwYohLJh/MsKaUgQrjrBg/ikIa2oRrDaEBfNPRVjTimC1IyyYfxrCOr8IVgJhwfznI6zpRbCSCAvmn46wZhTB6kBYMP8MhDWzCNa+CAvmn4mwZlmwdPhMricWzD8LYV1QBOtAhAXzX4CwLvTsdfwYqiPMfyHCml0E6+MIC+afjbAuKoK1H8KC+S9CWBcXwfoEwoL5L0ZYlxTB2h9hwfyXIKxLi2BNQFgw/6UIa04RrAMQFsw/B2HNtWDpcF6uJxbMPxdhzSuCdTjCgvnnIaycZ6/jJ72eWDB/DmHNL4J1IMKC+ecjrAUWLB3OyfXEgvkXIKyFRXgdhHjB/AsR1mVFsA5GWDD/ZQjrcguWDsfkemLB/JcjrCuK8PoU4gXzX4GwriyC9WmEBfNfibCuKoJ1CMKC+a9CWFcXwToUYcH8VyOsayxYOpyd64kF81+DsBYV4XUY4gXzL0JY1xbBOhxhwfzXIqzrimAdgbBg/usQ1uIiWJ9BWDD/YoS1pAjWkQgL5l+CsK4vgnUUwoL5r0dYS4tgHY2wYP6lCOuGIljHICyY/waEtawI1rEIC+ZfhrBuLIL1WYQF89+IsJYXwToOYcH8yxHWiiJYxyMsmH8FwlpZBOsEhAXzr0RYq4pgnYiwYP5VCGt1EayTEBbMvxphrSmCdTLCgvnXIKy1RbBOQVgw/1qEta4I1qkIC+Zfh7DWF8E6DWHB/CZvM4FVk//fPDPaAK7zPaOJ+zWoPFMPeA2W34S48vLpfma0weutV6gf/MzoJoJrCxGH1xxvIsq5iSiHwhrLiLU7I9Y4RqzxjFh7MGKdxYiVYsTqYsRKM2JlGLGyjFgTGbHOZsQ6lxFrEiPWZEasKYxYUxmxpjFinc+INZ0RawYj1kxGrFmMWBcwYl3IiDWbEesiRqyLGbEuYcS6lBFrDiPWXEaseYxYOUas+YxYCxixFjJiXcaIdTkj1hWMWFcyYl3FiHU1I9Y1jFiLGLGuZcS6jhFrMSPWEkas6xmxljJi3cCItYwR60ZGrOWMWCsYsVYyYq1ixFrNiLWGEWstIxZec7Ttk9O/zSe2bPvkTL6g97HqQBpqbxzECNqHVwc4F9uPdwbiTJVJvd94Qa5nHHy/Ee/Jh+8843cf4TvM+H2rHUEcXrMdDeLwu267gDhTH+r9xkZLfeB5vfi9Xvh+Ln6HexCIG4nimkHc9igOvp+7I4obAuJGo7gWELcLqKt5P7cB1XWf/HXHJ7yQR4/Z3o+uCfjf83qvi+uA+y08h6gGlTOcsRyIZY7Gsx3N0ddyYB/Fa+5bM5aD3+WA5YwkyjF2A/sto92EfpfGlN/k9fYxLp6LUGcfjCT0GvKoEXy8A1QnhMPVhmqBcXXoGk7HcTLQjiCOUgF+zRTWaceAfFAXHnGtlki/PcIKOjajLqA8qilhPmxKNeh60MlAI0A8TH943h70yUAjRnWnDyoL6gMfDma4Bx0OhjmY9EcBDkNH0Zj1AfUaGYDZObCby7EDaUyPwKTqtSOqF+awPeJg0p8A6rUNOnVpRyK/F3DN6N8j8uK/KZsZhtKPLlIf3E4m/WmWdhpBcIB9Eut0NOKA0+wYwOEsggN0a11Tp12Ud2seCvj0xBr0N1Y5PgFpBIETFIwadPWMKdYhXOyicDkQB3PSVTYztnRmUmZmJqDS2FfXBBRW69EBT6E9r/dw62h4Cz3cmvKbPNoWJ/DwsR6dBPWDp0TUUUgtRBw0DGyAtnIGed1T+xkzp04PsoWw43ANwQfn94pgmb+32E/f7SfkdA2bDVQnhMPVDmqyYmbCcei2bZoDMc10zTbFgs3VSpRrrtUS6UcirJFEPsPdNh2DGDAfNSziIZYaguFBjzD9XDD8mYMccR7zdyf4jQ9qrPzdkx96V9mH9O6pBcGZNDAtDC2AkheQjjJ5c7hFmO7o9kCo9pQxt3MJDvhQDKg7Ewc3yeAFK7jppQH8xqGOqLupr+5G24/qxsXpMFfYtfFCIuw2k1AcnKFPRnGjQdwUFAcXC6eiOPjS9DQUBxdfzWYXfCbsSrTY5mjUIxfbTFlDvN56hQuY2L7riGt40Qjmb7WUM7jMcgYT5TjWpe+2v3Z/aM82Q4Hl435h4qn/DRaOw7Mv18do24ZsHXA7U6tBNqyRJWI5ngXH8JSDqjflXymuVD3w6od5OLFz/pZE3wLfb3m4gacfbj4MGgt9eKMpvwlxdWWP1PdnqA9wUg94TF7s+3S4KtedDsfVEddqLVirGLHWM2KtZMRazIi1gBGLs46c7chZx+sYsTjruIIRazUj1nJGrCWMWOsYsZYxYnHaBGd/5OxDnDbBqa+ljFhrGbE4dX89Ixan7tcwYnHqi9MXLmLE4tRXtfpCTn1x+pyPwpyJ0yY4x20u3evfAzweLB047Z5T9zcwYnHaPWcdOf0E5xyAU18bGbFuQVhh7+tN+mYiPbUuZdYy4WZOk9esocC1Se4nqkF6ghtITfmao/EH6UznrIlHTIVnERbyQz0YvbWhdEfluvWAfc6gACwP/d2GrtUBPBjgxyTDPDJzsx4bC/0E25RfqUdm1GZzat2T+sCHyduC4nQ4ItedDsfVEddqLVirGLFWMGKtZsRazoi1hBFrHSPWMkYsTptYyYi1gBGL0yY49bWUEYtTX9czYnHqaz0jFqetLmbE+ii04xpGLE59cY5DixixOPVVreMQp744/T2nfXH6HM7+yGkTnHMmLt3r3wM8HiwdOO2eU/c3MGJx2j1nHTn9RLXOvzYyYpk1GOqFYbxN2vaRSqocmH9sCCzqftikpz74YVvroT74YdYe9gBxLtZ6qPagPhrSl7UeozcfpcNrPdC3jQvA8tDfProWtNaD9y2tyC8mGf062o9G7ovE+xXhXqhdUP2o9UV4DdsvzN9kKWdgmeUMJMppJvKZejvWc7oGlWfqAa/B8psInbhYQ2sNqVfH+wO7arze/qqOKNPwNW1p862mv8LXG2B6/EF42L+hv2lA1+7J980Wr7ffPS7Xk0NY/67Xem8b1LNufd3PCnGpcSNMf+hrORDLfACYen0G+5FS97DC/CMDsEy762A+Tqrj8QcVTXvUE5g6mA+VN6D0T+bbS483l4H9+zoN3OcKP4T89CA7V5gXcsVvTO8BPoT8TB6T0rNpd8oO8FuATUS5FCb2zaW23UCCgw0LttcglB4eXkKlx29mm/TfAG23DXqLGH+cWgdoPyMDOED7gR/MC7Kf7/TBfr43yM4V288gr2fZhQNkgP08i+wH6thmP4NQHLQfoyNqbMfvPJQ6tsP8tjnEVigOct8axW1F1KsGxUF+W1n4DSI4mPETf6xwQv7vSFmh9HecBqM4+I7TEBQH33FqQXHwoF48rsCDd/G4PQ3E4cN84MG4o1EcPOh2EIqbAeLw66cw1KG/YbvovnhlCe9iQbs5D8XBfogPWja6gidKUH0e3xf8GbzP8N3mnuXZ5rXwgCRGu4uFmSfA8is1rx2C+AT5FOqQKJO3BcXpcEWuOx2OqyOu1VqwFjBirWbEWsSItYYRax0j1jJGLE59LWfE4rSvlYxYqxixOG1iCROW/t3P48HSYS0TLx04beI6RixOm1jBiMXpVzn7Npet6lCtfpXTJjj9F2cf4rQJTn0tZcTi1NdiRixOW+XktWXc3nz64pyvcvpozjnAekYsTv9VrTbB6SeqdRzivIfhrOPNjFhb/OqHw39xtuO1jFic+qpWn1Ot88LrGbE4+yPnWMvZjtU6X13IiMXJi9Ov3sCIxeknqtVHc/Li1H21+gnOOflH4b6Wc9zewIjFyYvzvpazHTn7I+c9DOe6LycWp03gPmSee8Kj5c3eFR3MB4AaUPrv5J9DN6IyajzWZ81x2744U/ZoR2XXoPI8j37ObcqnzlXFezthXH0ZXDsyibZYNJP2U13JzkxnYS/laMQVX8P7wXcl0tv2gjo6rzdq9l3U5brx4YevdKgHcaNRXAOIg2fs3jC6J39He3GiYfQPy28h0h+X605XSlsO83raGuyP1J4RuE8C9yU3/TgWes+IKb8JceXl071nhPKlQwgdN1t03ELEbQd+Y/9VR1wL2rurA57vl4O1lhHrOkasVYxYGxixljBiralSXosZsRYwYm1kxLqMEesWRixOfa1kxOLsj+sYsTjtntMXcrbj9YxYnO3I6b849bWaEWsRIxanvjj7EOd8glNfyxmxtvjVzedXuXSvf+PzBKrF7jl1fwMjFqfdc9aR008sZcSq1vnq5YxYZr6K1wr1b/j+idv1tEi0Ut+Qoda0YJ04vyFjyqrUN2SoutnsAK53jQa/g7B2LRHL7bpad5uO9oLrDctvtnCl6tHCqJPtEVbYtaVS23aI17s9TV7Hfaywzrm9RU+w/L6czWH0FkXpTsl16wHre3QAlof+jqJrdQAPBqNjuP6IPwpP+eRB4Jo5S2SI19vWWhHW1kWwTkFYrRZe2xfBOglhwfzYhkcXwToVYVFtYrNviHUiwoL5g97fD8K6CGFRtmmwdi+CdTHCgvl3R1jjimBdgrCo82UM1vgiWJciLOqsHoO1RxGsOQiLOmfHYJ1VBGsuwoL5z0JYqSJY8xAWzJ9C+VIgDp4pQL0rC9+vnzi4JyfqfAb47mrQF+1vG9yNee7gnrxhfnMW9xD0t/49HHGGujA+yvh4eO41t4+H5XkePfcx5Tchrsx8CnMf6pxyqB8zPob8XCo+0gKqE8LhakO1wLg6dA2/mt2I8pnhoc4LDkaVptzBIC7MkEMdjY7zQV14xLVaIn0zwmom8hnudZb8EIM6Vh3XHx5tYa4PI8puQOkvzVdeT0VGoKM/qLKgPoxOsZ2Y40dwGszBpM8BDkNH0Zj1AfUaFIC5ArichYNpTI/ApOo1GNULcyg8akfprwT12gZ9GRraK+4DF+Z6chtClOUFXIPYMC+Os5VbLK/+PRT8xnGU3Q5D6eFj+DD2atJfb7GVgQQHWF/crpgDTjM4gMONBAfoWrumTrso71o9FOBuIsoV4qbETTCQwAkKRg26eisG0zjmb5v5QRc2iChjUABHmHcQ+J3OTMrMzAQoCI8tTQGF1Xp0wJ/kNPl0aPScDsehpwem/CaPttsJPHx87McNH6wfvJVjMMG1hYiDhlFKOYNA2hkzp04PsoWw8wZqvML5PZS3hrimA/zMSKWOaqPKGVRmOYNCluPi+DKqnMFlljOYKAdjUbclOpyd646H6R8Ffnz9aBqzNgDTLBWY9GmiPtSxWCZ9hkifJupodNkF4jJe8bKhLvG4ly2R60QifRakSSOukN/EErmeUmGuIwmuzUTZeAyB9docY4gpv4moo4sxxKZXHUq8xYSmjtUJ4XC1oVpgHB4qhqB0h+Z6/t2XW8yzQRylAnyLCet0dkA+3CXwtVoi/USENZHIZ7jXWfJDDJgPmxKVT/99DpEnTNc5G+FPyP8dKSv4bWG7jim/Ul2nmN3g6de5BNcWIg7eFsI4WM65RDkU1o6MWF2MWC2MWK2MWFszYm3PiDWaEWtXRqyxjFi7M2KNY8Qaz4i1ByPWWYxYKUasDCPWSEasZkas3RAWddsTNI3qyy0yXi+aGFD+cCK/h/LWoGvDA7AMjr4G5zL4tsOMC/08+y1PA0pvKgWXUetQGswnzBdC8VxpQv7vSHkh9BTelN/k9bZhF/OQYrdeeB6SIbi2EHF4vO8KWQ6Hjetg5vY1BB+c30NYNcQ1GEfZeBO4ZmwcP0mFeeGTVOqpu5mXUE/RmxAf6ok8TD8CpR8HOFDp4VchYPpWos9RT9MHBpQH+cFrtuWjcQFYQae5jwrgPgpwx8s64wl+1BKlSU/tDoDjvOFD6QaP4eOJ+sD2NE/0G1D6HYn62N4KNcui9SCO0Z+kNY+bAQ+s14Zcz3rbdKgD1vlZRHqoS6OzFpQe6p/aMT0excG+heen1I4cuCMU93vqKxXwCwW2r1FUU7/3Q/b7XQLKg/xs/R7mL6Xf62B20WDuiRL7/S4Ev2rq9/uF7PfGprb0+/L7PTXeh+33cLx/OuDLJAYXYul4vJ5geEGbgXOGM0E8TP8ZSx+gfIhtKZ3q0/DeG38VB+pyHIqD3M090eYbw9raKVvu8ZWrXHhd6IB1R/kb6CNMe7d4vX3LWBQH7yHx2gc1TsEds9heoZ3Bcerz6JEnfLRq7HXLo/VCKPnResjHInjYx0+0y30sgtMdkuv5d18ei9h2rEFM6oNKzQH5oC484lotkX4QwhpE5DPc6yz5IQbMR+0ugtehq24kym5A6ScDVz18VHC5eHck1QU7ifI230ZZ3w/bXYVvlMXd1cC3IDiTBqaFoQVQ8gLS4WbX4ehc73w4GFW6/aZn6d/cwmY6CcThb1lNBnEN4DcOdUTdTX11N9u+hG9Zwe6Ov2UFu80kFAc3qkxGcfCJ3RQUB590TUVxcLPlNBQHN02ab4VhV3NlvmBjA46+N0V+Pxe385bZw4dm9nBsrufffZk9UK+KhZ09tAbkg7rwiGvVMHug8um/+xF5wnQdR6/Xhj6ezJRfqa5TzG7ww4zhBNcWIg73i+FEOcOJcigs/CCx2Ey53AcjNejvQQHl1xL5PQsWzFND8LY9GMG+qJ9n7x/4/ZTbLA//qPw6bBlqeveXUveAU5v+W4g4POY0hSyHw8Z1MGNQDcEH5/eKYNWEqAu8G8M2burZzyvtTvARwsaNruuI/Bp/DFqwmQXS4c/tXQD+rkPpqXpciOqB08xC9TDpnwb1GIrqATkZPs0ov4nXwfTT2Yj7hPzfkfJC6H5qym9CXF3109mID9ZPiVNCaBZYnRAOVzuoaxTrjgflev7dlynhRSCOUgGeEsI6XRSQD5s8vlZLpJ+NsGYT+Qz3Okt+iAHzYVPC3Q8uKF1AlI2733csC0qw3Au83nrAXbCZKM9014tQWh1Md70Y1WlC/u9IWaEtGba7mvKbEFdX3fVixAfrp8TuCk0Mwp+I4EwamBaGEwElLyAd1ewjiXw4GFU2IM4v5s1Pe/qf5n8P8Xqbej3iAznYPF4Lkd+ko8rpX2Y5/Yly8IKUDuZQeOoj8PUo31SQbxbKNw3EHYfizifqhT8CT2HOsGDOJOJ02x2ZX22yjUjQxLE7plxg2O6CD3OB+S9GWJcUwcKHucD8lyCsS4tg4cNcYP5LEdacIlj4MBeYfw7CmlsECx/mAvPPRVjzimDhw1xg/nkIK1cECx/mAvPnENb8Ilj4MBeYfz7CWlAECx/mAvMvQFgLi2Dhw1xg/oUI67IiWPgwF5j/MoR1eRGsHMKC+S9HWFcUwZqEsGD+KxDWlUWwzkRYMP+VCOuqIlhHIyyY/yqEdbUFS/822wiHEPmvRljXFMHaBmHB/CZvM4FVk//fTKMWgeuMz+VCr+aZ8psQV14+3dOoRV5vvUL94NWJawmuLUQcHItgHCznWqIcCms2I9bFjFiXMGJdyog1hxFrLiPWPEasHCPWfEasBYxYCxmxLmPEupwR6wpGrCsZsa5ixMJjmW1er39vm/9tm9ebfNCf4WUNavmEug8Ium+ASyPF7h9OyPXk3Nf7B/17B68nVl/vH/TvMQirnPuH43M9sfp6/6B/74R49fX+Qf/eGWH19f5B/94TYZVz/zA/1xML5sc+t9j9w/kIC+Yv5f5B/97L64nV1/sH/XtvhNXX+wf9ex+E1df7B/07grD6ev+gf/sIq6/3D/p3FGGVc/8QQ1i2+4dFRbDiCAvmX4Swri2C1YawYP5rEdZ1RbDaERbMfx3CWlwEK4GwYP7FCGtJEawkwoL5lyCs64tgdSAsmP96hLW0CNa+CAvmX4qwbrBg6fCZXE8smP8GhLWsCNaBCAvmX4awbvTsdfyY1xML5r8RYS0vgvVxhAXzL0dYK4pg7YewYP4VCGtlEaxPICyYfyXCWlUEa3+EBfOvQliri2BNQFgw/2qEtaYI1gEIC+Zfg7DWWrB0OC/XEwvmX4uw1hXBOhxhwfzrENZ6z17HT3o9sWD+9QhrQxGsAxEWzL8BYd1kwdLhnFxPLJj/JoR1cxFeByFeMP/NCGtjEayDERbMvxFh3WLB0uGYXE8smP8WhHVrEV6fQrxg/lsR1m1FsD6NsGD+2xDW7UWwDkFYMP/tCOuOIliHIiyY/w6EdacFSwdz8t0QIv+dCOuuIrwOQ7xg/rsQ1t1FsA5HWDD/3QjrniJYRyAsmP8ehHVvEazPICyY/16EdV8RrCMRFsx/H8K6vwjWUQgL5r8fYT1QBOtohAXzP4CwHiyCdQzCgvkfRFgPFcE6FmHB/A8hrIeLYH0WYcH8DyOsR4pgHYewYP5HENajRbCOR1gw/6MI67EiWCcgLJj/MYT1eBGsExEWzP84wnqiCNZJCAvmfwJhPVkE62SEBfM/ibCeKoJ1CsKC+Z9CWE8XwToVYcH8TyOszxXBOg1hwfyfQ1ifL4J1OsKC+U3eZgKrJv+/ef70DLjO97wnHvq9MFN+E+LKy6f7+dMzXm+9Qv3g509fILi2EHF4zfELRDlfIMqhsC5hxLqUEWsOI9ZcRqx5jFg5Rqz5jFgLGLEWMmJdxoh1OSPWFYxYVzJiXcWIdTUj1iJGrGsZsa5jxFrMiLWEEet6RqyljFg3MGItY8S6kRFrOSPWCkaslYxYqxixVjNirWHEWsuItY4Raz0j1gZGrJsYsW5mxNrIiHULI9atjFi3MWLdzoh1ByPWnYxYdzFi3c2IdQ8j1r2MWPcxYt3PiPUAI9aDjFgPMWI9zIj1CCPWo4xYjzFiPc6I9QQj1pOMWE8xYj3NiIXXHIvtkzsj/9u2T87kg+tO+FXBOpQHpocYQfvw6gDnYvvxzkSc+7ofT//GX2qi9uNR741dkOsZB98bw+8KTAVx+F20aSBuNoqD743h9d/pIO5iFDcDxF2C4maCOFNX+N5YA6rrMfnrjt/oJg8fwvqA+q8J+N/zeq9J64D7DDyUqgaVM5uxHKgvvA59EWM50KZxfS5mLAdiHZTb9D/VD/HX/Sg/dImlHJjfpKPKmVJmOVOIcjCWeZVbB/OOJuzXDSh9Nt9n9KvcT4zuiUn5tingGn4fk/Jtpi/OAXGcz1UM/jw3+DGjC2p/M6yTKb+Z0F0pdgzLavJ6+3kXz6SoukH+2A7hsxOogyCsuSViNRJxLtp0jqXesPxmC1eqHkF9E5bTSOjEpJ9n4QXT2/a/Gx3mQByjDqM2HVJ76Ad5m3yMDulM56yJR0yFX3kr5Id6MHrbFqUzfqfW622DcwOwPPT3tuhaHcCDoVJ+nCqnqcxymohymol85Y6zFGfqxB0zHuk53JXo3X9j3/AoEviezigQD9O/O7Ib85o8JvUeUVCfrAHlwTMT8ElFcP5ZR6SZGsBvCRhf8VfEpxJ1HmXhbDDhuRSQszkfAnO4Ec2LHY3F5LzYlDUE8dW/J6M4OM+djeLg3BS/a0u9XwavYXu1nRth/g6aR8F5Fky/rsR5VNhjhkxe6p4P64EqxzaOXxiynIFlljOQKKfceRJVDsUZ3/PqAP3Q3cgPGXuFfRLmNecBNKD0rwA/dJ/FD+F7fjy3w74Z+yFTXpAfwvZp0j9s8UPUvcPRuWDOBhP6IcgZ+yGT/gnkhxzN70g/ZMqixtlBHq0Pzws3zg4i9OB6nMUHV89hLAdimb5CzTWx/yl17g/z47l2UH/92lC6TKq/QtttQOkfBP31m6i/Qnu3zc/w2DaHKBf3Gc/rff+og82XzQnACjtGmfTPWsYo272QDrZ7/SB+9R7dp2bmuuschOUR10x6OD7i9a+5KO0cS9qge1f9+6z8b7frC8mIsfec1zuYuPkEZxO3AKQ/OdedDoc69Desk7aHp0d34+J0mA/U0/wATMonXJjrmdb8WUvgzkO4sJ9jfZkzxXAffzNv77qPvziUxsN2osPkPJ7be+ikj9sXBty+WD84UO2by//W7fvq6G5cnA6XCdtwAYqDfhmfRwf9ucHQuv8XGverrS/1pb+Uok+qv1D6xM9pqPER6rMBYWw7rDvNe8jeTRo8Juhg+o/ps/k/e8zvqHbHffG/YHyJj6HLt/U3z6P9AtQDPkdyvkdzoeps0o7M68nYI+xjfPYYL/TvhYgzLPsyR2XXoPI8j15rNuU3E3wM7yYirr4Mrm1+IhFtj6fbsp3tyba2TA3CN1zxNbxOSp0v0UKkN7q+womuY2nq83KXA73qUA/iLkNxDSDOcNR96IbRPflf7oh/GP3D8luI9LNz3elKacsWohx8X1EO1pw+Yg3zevYBaiyEcxs8FsL5CzzzNDGs+zrlF22+Lg/Ty+/DemI/GEe+bj7Iw2hDcWo+in3dQkdlh/V1pvxmL7htm4i4cnxdui3ux7MdbZ3pbCyTTmRrvN5jQh1xDfs6ym6HEOkd+4oI5euwP6sHcQtRHPR1hiPl69yMi7FIGP3D8luI9NjXhW3LFqIc7OvKwZrTRyzj6+A8aH7+N+Xr8Dx1HlEf6Ovwfdm+yCc5+tIBuQ6IfSrkqwO8h54H9IT1i3HgNThvhnnwuoxJ/0kwb99/GM3P1OE4gh+1rwvW66BhwenmEen02qLxLRMzMz97dmp6Jv3ZTNf0zMw6j6aHq4irj2+nPJROh3p0bSb6Gy/fTEE4Zgiu94oHaBIQi2o6iI2H3kPyKtMuLDFm029q+5kOE/L/R8oM1K0jHmrdPOKLhr6tMOU3eb1NzsUWFmr5EuoHD49uHj1EI/oOGC9v6zAl11s3mAfeQkh9rCaM/mF9qaV2bDemXMoFBj3uTAOXdcKw7vTYB4TZNgb7iW3rTA2RvgvFwcdjNRZ8vAxyGujH26Bvd8KpjqmH26+GR33qq+HQ/8FpVJD9w/RG5/gRD9SJ7fG41qdpc9sjeeqRJ/xOKbZr6nE4tt3BRDmu+8hgVB9ol3jLQKmPCyl7LPbYa1pAHwt67BUB8TD9zeCx1wzUntT0YTP2gWipfYBqB6hrc6xnC5H+3FzPOKoPUHrCtjCF4ECNQ5QtTAkoR4fpub6Xg/Pj7wHb5hFupubhP9ttyq/UPOLCkHo1+rnEjX4iYXwL5Q+pWxSDRT0qp8YB6nEcvP3Dt3NL8n7Etn3ANk5Rj8G1f7oa3ba4ng/Z+kNfy4FY5lM15rvi5p5iNZhLrRwWnN98nqYfyENtPcD1gTYEx5R1aEyBj0soW8NLjCb9RDCm3NTHOQL2o6XOEWzbA23jgg74sz9hto0O9Ohtquflf5s2Nksl94A2vivgdlwH2D73o/aBvpBqH/zt+KDlgPvBsgzk+DDg+KCl70GOjwak078neb3TYV/kefT8BbchXKag0uPtASb9kyHn9cYe3M5pfHJeD9sfz2mKjUfGdm1bqnA7fx+08/+h/kr5xb72yaD5ZJAvd/zaXkfYOUc1fIiVmnME9R0dzPyOSk+9TkK1m167wH67BWCZcgeAa/PQNTzm2OYoOkBf8sNhNAasHzXPiXq9McL48lLtmapTNfSbMHZNlWObA7l6rRS/4uXotb240X0O8KTmvHi72nxQhzqEQaXH64gYfz5Kb/LXe/QWWdMf8DjW2rrp/w+2sqGxNGepow7mk5I1BKc6Ig0+GtE8FuoXwPlUxNmkfxWMvXjLOXUvkgOYeJu9Sf86wFw/mubpeeH86EIiPXwElsv/prY+L0T54GM43OYUNn4UTuEsQDi4nrXg2lACm3oUrGVC/u9ImcHgmUelcLvv5QSfBpT+XWTHVyKd2nSm5QqiXHhU4lBU7hWoXG1D+47piWm4wfk9bHfcJnjeiXmmUbxJ/z8wB/sPGvfgeA3Hx4ZWumx4P3CZhetCgivsMwtyPeMLNp4vV+trvzE0V8gHct1864f0XLvHOkaup34o/0G9vlCq/6Ae1c9DcdS8vcbr7cPCjDGwHaj0eFukST8UtLO5V7KtU2p8My5R6xBBr9YVG6eo+1f4HGJEK40b9MqW+bQsfoZ1Eli32KaVLlsH2Ae3K7HsUwLKbgFl74h0SK1lcM7/qLZq9XrWq9TXVWB+/IqCi1eTYJnU+Izn+qW+mgTzBx0DYOJ1cDyfDX3vaspvInTi4t6VurekXr016XNE+kss6ecT6al2g/eu0Ld6qFx47zofXSvntbT2Ev0CXAuG6V8a0Y3ZgfwC5IVfPYM+Y7hHc/E8exu1EPnxngRX94XDUX0usdSn1OetMH+lXs8cjsoJsptDkN309fXjrwO7OdxiN7bX6m2vOoZZU7e1wYUhy7m0zHLCvrr5YbapU5ls6lFgU2dY5nkfdj3PZSyHWuvB4xbWL4wz5eBrtnlS0DZRyEG38eRWusywdmPSrwV2My2E3VBtEHS8Eiy3UntzKuUPbVjU3Nukp+a2tjlY2OcB1OuUxrbdvk4Sfn+IKb8JceXl0z3fpdYIcoTuBnndax+pzAw/mjwo0zX9omkzcWMYwBak5PkI0KT30N84nyZVj9JcQpShAzzjAxpSC8qPJ9QYPwynYmmLxVOdMOfR9fS8cJ0Q5i/1PMX5IB6mvwosooQ5YyEHroU5Y8G2cQfr2lxvCsgHF41hHKzzUZY6m/RLLHWeW6TOp6A6B53lBv/G6eqIOgzw6E0StnNgtvJ6ci/VnmD+Sk1WtkLlBA3uawMWj4M2kGZAPEx/FRjcN6DBnZp8u65/0HlKsF4ZkCbozI96AlMH/OKHSX9nvu6OF37Id5hs7/3ADfB3txbXja3NTfqLQZvfF6LNbf2HOifM5itET2T8TCSMjcPyxU9k/lDTU8nzEaBJ76G/cT7bRAanDerU5U5kKE5BaUudyMA7gBxKW+qOEZjfpHO7myraa4cyfKozH5SJ78guBXWgBuignaA1Afh4ADD56wN0h3dYmPRfApOYCWM2/abaausAfp4Xrq1g/krt7tkaleNiFVcHvKJR6cl6kA1G8r+LTZKeLXHAxG+TmfTjwYD5YzRght1FFmalFtu854Vb4bf1t7D9B+uonsDUIehQ2jfRBMrNG6ttkc331K4t9OCPJ3TUroomIq6sQ3gSWT/S3p6IZaOpZKatHY+Rhiu+FuaJ3o5EercrRnHyEJ4c0KsO9SBuHoprAHGGI3UwRc4R/zD6h+W3EOkvBHUopS0prKP6iGUOk6Bu1jeXLwtaxLkQxMP0f7csaFCHH1MH9toOc8Y3Q7iO2CfqMCH/fzFLyhYJpjzTPv0JLvhNH5P2faCXA8f0rEvQzp/6gPraDvqs8YJ1h8ugDufIej25zQ3BjVp4ghizA3hqjErtQKHK2b7McrYnynH55AuWWWw+1jy8Ow/0N0FPpHK57niYfiSYj7XkMam3efHOO2phlTq4Heve7LzDabC/Mem3ynOidkpfiOoM62mzMzgfg5yDFrS2yXPYnAtauM71XvfuXugfD87RdS52ILJtzmI7oYIafzFW0KJ50KE/7+RXbrWtjEF2PjmfJqj+n8r1xDTpJwDMXUrE/HQA5v7DuzHHor4DP9gwwqPL06GOuIb9A8xv0hlbdPXWt8Gf5ga/8KGhqYQuYJ1M+c2Enkrxu7CsJq93G7lYSKTqZmtn+AEQ/KYUhTW1RKxGIs5Fm06x1BuW32zhStUDz4GockYQOjHpz7fwgulNH4a2b/IaHU4HcYw6jNraG35I0pTfl49HGb2NQOnwx6Og7qcFYHno7xHoWp1HfzxK+8z5+cW3IUT9xiNcqu3gNWz/ML9JR5XTUGY5DUQ5NqzxBBYe22H6BiK9qQf8QGhl1ra77XM6wZVao+uLfRq9bYfSmXlLrde7D84IwPLQ39uha0H2WUeUgT9IY+uXOgwhMLBfn24p09RVB+oNWJMOH2ybQfNVN74qmTD+ewbga/To9pScZCLsmB/0HAHypt5mL2f9MJrKxru6YhG/w2/LpmIdtv5NPQ8x6an1nj2I9EbXbj6GmYzbToWg1g/xCVkNIM5wpNYP3fisZDyM/mH51CmFeP2w1GdbtnvjsFhm/RD6fdO3K+VrbFjUWl8N4tzPo59tYl9m0k8C9//mzbs6L1gPHnGt1uvtp47MbfqfGkvxGDKDqCu8hvUG85t0m89XRtpK9ZVNATqZwMPHeqIYpVf8bBbmpZ614o92lLpuXu1Y0Labvd72XxPwvykHX8Pl4PkCLMfVc/gw/aSv5UAsM4d0/bzfrCW6HZsTaepNUhPwWjVlN9QB5XhTGNU+80EcfhNuAYg7G/zGoQ79jecHnxrTjYvTmUBttsPjXqkf5aQ+kketP8H1+NXD6TLhejxcAwnaH7E7WKdcZ1lTDNo7BNe2IdegvQYb0b3C5vgAbiNRP8Y+0tXs9W5zE6hTk3AfoT7sSPUf3EdyIA6feA4D1Q+MLnQ/mFdCP5hM1MP2gVxqc7mpBzUeTEZx0IdfiuLg/AG/tQR9pTl9rQaVpwPVX/EzCFudXc+HG4m6bk7bxadVzSX0FtYGTZ20DT4ZwgbxXARzwzrsy30DToP9qEn/Fctzwxkgj8GcBzCDTimDvhXOKbBvNem/iXyrozU50reGOTG/EmuFsDzPo+87quFUQep+W69dmo9lT5qaSh+YmjZj1qRMLVIl7PqUq8fpYVqPiKtD16aidIflev5tugPuwhi7DpRLbTGllihs25KoJZQZRLnmWi2RfjbCmk3kM9xtSzYQg1oWNxhUPv33uQF5gnQFhwmsK9sLrJcWwcLvfNne55lTBOskhGX7bvLcIlinIqygD3VomVcE60SERX3b1mDlimBdhLBs2xHmF8G6GGHB/PMR1oIiWJcgLJh/AcJaWAQLH8IM8y9EWJcVwZqDsGD+yxDW5UWw5iIs6nuIBuuKIljzEBbMf0VAPjhU60BtmcJDnZvvXPqxsEOdKb9Sh/ZTeqcOfjS6u5Lg2kLEwUfDMA6WcyVRDoV1PiPWhYxYlzBiXcqINYcRay4j1jxGrBwj1nxGrAWMWAsZsS5jxLqcEWs6I9ZkRqxpjFgzERa1vY/yuYPyosOMmVOnZ/L3Fx4KtvsB/ffsgPKHEfk9lLcGXRsWgGVw9DU4x8e36/AATGo+bvDwhzK2zy97Uo/5phD5dbBtCXS8fTH0ra0pv1JbDqchPlg/eLw/n+DaQsThJZEpIcvhsHEdzD1vDcEH5/cQVg1xTQdqCxq1lFaD4kx5+JptuRC/NmLmA3sBuw96nYZ6hKAD3tJv0kcAJj4IPOzHIE36uZY6Qz7UPabJ6/bRQiJDLXWaQC3T4+X9HIjDy/vzQRxe3odzAbzcBsd2qBMcqGVXeE5LmEdg2F4MLrYX46ux34R54aMsahvsbqhMyt/Aa7hPwPwmHVVOQ5nlNBDl2LB2I7BMemr7h21bJrUt0fEWj8K2TGrLKbUe1pdtmUZvO6N0eFsmtR0SY3no753RtTqP3pZJ2cqUAJ6m3GK2Qr1ugLHgowKzRqfj8eMHkz6T98Gm3c9HdZuQ/ztSVuiI2bZ/uH001RF6zSNoawfkTW05KmsLZjLm+8mIn8lE4pFUOmLry9SWI5Oe2qI0lkjv9lFKR4Tagom3WdaDuBkorgHEGY7UFkw3/qkjlP5h+dTWHbwFs9RteTDulD5imS2Y0Mfj1wtc+yb8euK5xByy0lxy+b+nWuaz1NhEfRDA9voN9QoHrlepr3BMCVnOuDLLGUeU00zkqwn435SDr+FyKM7Fti9dulV3HmjfQfceZu2/AaV/CWxfmpf/TW3TwGu+xbYF4P5q8sNtAbZx2aS/DNgn3hZwPqozrCdlZ6bO9US9dMDbAkz6q9HcwNE2W3JbAB6LKz9vCL92gl/PcPTKnW8bA6jtQCG3BWATh+qEcLjaUC0wrtgSySG5nn/3ZVsANd2xPeqmhm7qMd35RLnmWrG3uXA5eCpdZ8kPMajbEoNB5dN/dwbkCdIVdbtN3Rbix1Szi2DhoZHaAmGwLimChbcF2E6cmVMEC28LoI7lNVhzi2DhbQG2LQa5Ilh4WwDMn0NY84tglbstAGKVuy0AYpW7LQBilbstgJoa2LYF4HxweNUhzKN8+JiK8VF+6PPVTfmVepRP6d32KP8KgmsLEYeXPKgtA1cQ5VBY8xixLmXEms6IdSEj1mxGrEsYseYwYs1lxMoxYs1nxFrAiLWQEesyRqzJjFib+5H5jIDyW4j8Hspbg661BGAZHH0Nzn/DPDKHc9WgR+a/2vLInGVc/bA+Mjf3gzUEH5zfQ1g1xDUd4CNzk456i4a6dzHp8dsXGAM/1jbpX7U81qbuxWyPtW1vAEA+1H0uPn2Yus+lluvhG0M61IM4Rrvuor7tC/XTkAuvCx2w7qh7QjiPwW+I2d4sg/0Fz6uK2ZXtcbbJC5c2qfvd0ajMUt/Ihvltp1I3lFlOA1GODWs0gWXSU/eotsfZ80F+k9eMFXCuwj1WBNkadZ/bl8fZRm/bonT4cTb1PWmM5aG/t0XXij3Ohm16fgBPU24xW4H5bTY5pcxyqG9Q48dBO+THCscnvMSot+DxvGa+o7JrUHlGf/AaLJ/aWmR4NxFx5TwGzyajka5YNhNpi3V2dkUKJ2nPR1zxtTA+YxcivVu/kCQfgy8AetWhHsTNR3Fw7DMcqcfgCxzxD6N/WH4LkR4/Bg/blhTWUX3EMo/BqZOtK+1rzPrCznlfQz0Gd83F7RbHZARvVYSB8if4LXDYf0t9CxxuRyzlLXCoc8gN65B63IvtEn66q45Igx/3mvRRYBP4cS/1GUPbW+AGEz7uhZzx416TPoHGQEffnScf99o+6efie7Bu61h6P8DbLKBfx9uA4ZiFH5PDdbTJKA4+h8An21Jr49SrdviUmatAHN5afDWIw/f0MFB92bSL7g9XjurGxek8VCa0m/koDvo8o19qy8eu4DeMM1zxNWxvMP/kgHyQjw6OT+v13Z7u1H2ism1rAmU/fd1OBMtqQljcurPVzbaNito+asMKsyUQYjne/lJo0+mWelM+iOJK1QOv01P9bFdCJyb9pRZeMD21NmbyOh7rrKcQU6+g9GV9wOhtD5QOn5IdtG8FYnno7z3QtaD1AZOe2mo4m+AUZqvd9CJYeK9J0L6ZoP4GsfBeE0pXNruDWHivCWV3BqvY51LxXhPKZgxWrghWuXtNIFa5e00gVrl7TSBWuXtNIFa5e00gVrlHUECsUo6goO4ndaDW2+E22zno2YnJC5+FwHVw/NqgSf/5rbsxc+A3fp0R+oGLvJ5xcO54MeIPn4kZn+T2VZbwzwdN+U2IKzMf3+Z7qW3yIbeF4pMzoDohHK42VAuMw48B8aPdKShfX7aFUkPGNALTNmTgfFAXHnGtlkh/PsI6n8hnuNdZ8kMM6iMXuP74LTB97QKibPwW2DKw/DACLT9QZUF94CUQasc7TIM5mPQrLUsgJk19QL2mBWDeD1zOmq1pTI/ApOo1HdULczgfcTDpN4B6me0PntfbXnEfMMun+PYAc6euQWyYF8fZyi2WV/+eBX7jOMpuL0DpzfaaIJ1iWzHp77TYylSCA7U1PIgDTjM9gMO9BAfoWrumTrsoYEdEPfhNuULclLgJphI4QcGoQVfPdAeMY/62mR+1m8QLuIabweSFH6JPZyZlZgZtGcFjy+SAwmo9OjR7dAV1qNbtQ44+dmXdPkR9mAu/cQPzthBx+LYtbDl93T4UNG+gxiuc30N5a4hrOujO8viAnulsU2Adzs51x8P0XwR+Am8HMmlqAzDNbalJT53+Qy19m/RXEenhcq4p38yH4DLwVV7xsqkPLpr0V5fI9RoiPVxCvhJxhfyuKZHrKRXmOoXg2kyUjX0UrNfm8FGm/Caiji58lE2vOpR4CwNNHasTwuFqB7kF7IrwbcGhuZ5/9+UWZhGIo1SAb2FgnRYF5MNdAl+rJdJfg7CuIfIZ7nWW/BAD5sOmROXTf59D5AnTdRYh/An5vyNlBT/0N2pM+ZXqOsXsBg/v1xJcW4g4vAxwLVHOtUQ5FNY8RqwrGLEmM2Kdz4g1nRFrBiPWpYxYcxmxcoxY8xmxFjBiLWTEuowR63JGrNmMWFcxYk1hxJrGiIXfUqLe4AiaRg3K/y7nLaVrAsofTuT3UN4adG14AJbB0dfgXAbfdphxoZ9nv+VpQOkHjtj0P/WW0hVEfh3CvP2L50oT8n9Hyguhp/Cm/Eq9/Vvs1gvPQ64iuLYQcXi8D3tgONdbSmZuX0Pwwfk9hFVDXINxlI1TH7nAT+1gXuqpHfWBA9ste/7PHkscEGNSrjsept8O9B28xDGf4GC7taaeFsOx2PChnjzjXV0wn5lnUDuzTTrHbzxlqDeeYH0bcj11sZDQBUyPdUc90YbzBfzNejj+51AcnJfBnevYh5j20PbXPLxnOuothzB+C9athcA6LteznLmM5UCsGagcuPMDPi2PjujGhTqB/QjOmSMgHqY/ckQ3Zlv+t23nBz5QNwn64ZtjgvMbXVInmODvrUE7wPMyqp5Qf9hfmPSfADz/mudJ9Uv43T0d6kEcY7/MUv0S+j3cLykfBdPjfmnrx1BnLV7vPovvtajdR0HfToM67Eekh3h4N/ihxHzI8IPjzzzEfXaJ3KnxiPIz8ODfZ1s3/Q7zMR1qDKTaqoXIPy8Aq5bgD/s1bvc6omwqvbEJ+Jib8t8NKP0JoK32HUNjegEcLg3g3C8g/QLEwaQ/hbAXm5+A9j8fYZr0pwNMfEhjMcxMAOZZlrkK1U9z4Fqp4y2ej0A9XobiIHc8bi4E5eO0E1H5MA7aOS7Xs/DFY24xvng8MnEXgvHsvPzvRoTH7MtjtrbcnahP2La81FJ/jGXy1Xu97dXWh6C+po+gMRtKxJxFzAmouY75tmk/wMPmQ6nvnOJ5EswL50nU3CLoO8NziP5KzRXgIf461IM4NvvyMxFqrgB10QDKDaM77FNyRHrYzngOD9PPzPWMs32Uj2ssvru1J+5cC67+PQrxsM0h9e8UiIfpr7X48RzBwabz+UT6HEiD306D7TEfxVE2XW32mi/qg4Dt1aYLHUq9X8f2So1PlL3mUDk2u9LBZq8mr7bXtZa5oymfWlvAzymK2QxeK14AOFDpDR4eQzda5lXUGEd96CXsGIe3g4QZ42C/hTo5OtezPib9nSH9uWkXt/d+vk/1D6hX3D9sOtQB65x6MwDq0uisBaWH+qf6x0IUZ3ubI+w6YLH1ncnI1xf7SA++F4XzRGyvlK836Z+0+Hru8RWvjVB6tfmOarPlfFEfhM3p6/EaB+XrKfuD6xenhphr2E6EomxlLsGfWhfD687UuthmG+cD2t62hpUjdGFbw7LZCtX20C7moDi4RoTXWIr5lKNRPYr5FLzWatL/rESfYrOrHJG+rz4Fcrf5lMqsjVa3Xdl8Sql2ZRsDoQ86BM0fYZn4ZDjKjmzPvnJEeurez2ZHdQQv6CcbCVwdJuT/j5QZbM9kGr3e7cu49hN6b54pv4nQo4tn4jnEB+unFulnvhs+8aFe776iw5Rcb91gHrg/XQK4Gx2fCnDwyT7wDVb47OzvIZ6dUW9X4/WA98Da2TsIkzo5KWzfN3k1bnsrzRXi2k6uyQEsKj2sO0z/X8s94HyCA2VbJn2xORw+HSsH4mzP1+cElEPtJaDG5UL6kd11td0fmrLdjn9Rf3M/s8drJLZn9tQJNzZbpU5mwP0V5qX662xQL6pvQZ8AORoeOkwCafC6CTW/o04PwPO7rQg7suliGLhW6riM+0yp9+JUO9h8BtU2vfbkgPpjn5EDeag5GtapSb+jRafzvd71sumUY59PWJ3i131MOWF1atLvZtHpfJAnjE5N+nEWnVI6sunU5nsonUJ9L0RYxXSKX02j1jdtOjXpIxadwhMUw+jUpI9tRp3COi9E+aDPwHNO7O+aAvINtWDmAjDNdZhvLlEHW1tSPg235X6WtqTqlQtZr/lM9ZpfYr1M+gMd1Wt2QL1ml1ivXJF6BZ16fChRL2oMC7qvpdZcdMBr/yb9Z0LO7T4qa2Z4XQza+WwUR+25stlLX+5vtkNrG9A+sQ3AE39s63R4X9lpIW0AnlirQz2Ic20D0JaxDVBrzrZnbmHXnFuI9OY+mbIBfL/FZQMjWnumc7W31tQN6wneR8A1CnwfMR+US/VFnD7/Z4+9dbC/4f0nJv1UYK9mbx313gdc0zh/JF12UF/Baxom/WUjuzFn5n9Tr5Tj/Qml+m6o5yDffdEW393DdxudUb4b92mb76be/aBOmKZOuIXvfqwbVpw/tZZs0lNzPmoOhud8V1nmRtQaENSTH4B5HbD7RSN71j/ndQez30mnWz6Sp+zrLfcOC0HZ1D1RqWs7ho9tvwWuN26r5cgvwDriPSsmH5yrwvR4rgrjcuB3sTk4tbcX67BfQHqDh/eNrCPsLMzehxzBL+y4mANcsU+3fV1IB2wLtnkDLJd6roT9O/W+xuZ7RhiNUr4Y1hf7YtucSAeuPZGUn4a+GPcP6mT5sLZi8mpbmZb3xdTa1YUh6gav1Vr4m3R47fMx0FfwvnlqPdU2by/swbH4xRxRB9vz8vlecJ2pvgDbab4lH/WcE5Y1If9/JJItK5jyjN/qT3AJGi//D+jxwDE015pefMsL1NhZg/QEfTCjb4jUoPI8r/e9Ah6bqPFmAguf7mey1DpgDlzDz2QXOuHjZ+EzWWi/8JksbBtq/kDNf+H9yLfR2EX5AOhP9wHxMP2zYF72vQBMzyvdd8L9uV8b2hPX5it0KPe5AvWeKzWXwnuDqfd1DAfTRkHvJqVAPEz/C+AbbO9FGl5u945nN/veWLz/Fe6NxWM3ZX/QFoK+IBU0D8XvNJn0L1jmobb9uXNK5D6P4I77Oe473w4xRy1nf+4oEA/Tv17is9ZK7aWj3nPcsj833P5c+L5QzuvJOWhv3N3Id1PvGFHnWmB7DXpvfhsQD9P/x2J/xcalUtdr8XuAYfcIb/Z3gSJ+dHOvmZm2D7NHmNoXRZ1/At9FuzJvfy71mEhGCnNa04bwy2ww1IN4mL4l70ibQD3M//Vl8MwmUn42lsqm2lLpdLwrhb+0poNps4EOyo8mk+0d0c5IPJHuyqbjsUqX39XZ3hnPdHa1+/H2WDySrnj90+mMH/cTHclMPJ7uaKt0+fG2VKIrlfD9jrififtFy9f+YGDeFuF7xTq056/rfjUafIGtBuGZ3+Y+CfoExvu2rhpUnufR95Gm/CbElZlP4T6yFvGpCdB3I+DggE9nDcKHfOoI/Zi2HEjEGSxzbhYcjwci/qaOMD38bfLDa3ujefNAkNac7VNDxNUR1wxnbae7IzutB+nwWT4NRJkmrp8lrr8lzny5C9qAiWsE+WahfE0E5gdfhEfPU6i2hfaHzwbGtg+xBhbBwl/XgvkHIqxBRbDw17Vg/kEIq7kI1qkIC+ZvRliDi2Dhr2vB/IMR1pAiWPjrWjD/EITVUgQLf10L5m9BWEOLYF2CsGD+oQhrWBEs/HUtmH8YwmotgoW/rgXztyKs4UWw8Ne1YH58nuRWRbDw17Vg/q0Q1tZFsHIIC+bfGmGNKII1CWHB/CZvM4GFx+eR4PrmGJ9N+U2Iq6vxeaTXW69QP3g8HEVwbSHisN8aRZQziiiHwmpmxBrMiDWEEauFEWsoI9YwRqxWRqzhjFhbMWJhv1VsvD4zt+l/23ht8kHbhengHi9qjIYYQfMBODcvNi84GnGmyqTmmOYMJTzHNOXCuH6IG4zrD+IGojg4x8R+vxHEDUJx8F7T1AfOMfG9HawbrivkSHFuQnHwvqIBxUEdDUBxcPzoh+Kg/ky9XdxTd6bbuyIdMT+dSiUiifZkKffU+B4L5jPjMbbzCX3k2TN0+TUET2o8NuU3Ia68fLrHY+pegbqfM/ppdqOfiM1/NRP6MXwGO+ETiRlbaSHKNlzNuAfvx2H6ZqBDmB7+NvnhtXXIXqn7jRYUpwO+V6fukeC12s2ERd1vQb2ZNtU+ZSnSBbTXmoD/DS6+hjnC9sR+fSBjORDLrDVQ/UnLhPzfkbJCLGrqMZiohykb2hVf32lLhPV1pvwmz2lf9m02DPWD7z1aCK4tXm8bviLXna6YfcNyKKx1VYq1hBFrBSPWakYsTn0tY8RayYi1lBFrASMWZx1XMWJx8rqOEYuzP3K242JGLM4+tJYRi7MdOW11AyMWp32tYcS6mRGL0+6r1edw1nEjI9ZljFi3MGJx6otzbsJpX9U6L+S0+2qdyy1ixFrOiPVRmMtVq91zzk22jGmlYVXrXK5afSHnXI7TF3K2I6e+qnX+dTkjVrXOv65nxOLs25x9iFNfnOMQZx+qVt1z+i/OdblqXRvitC/OuW+1zjGrcezQv/EzK46xY0gANvxtezZMlVNDcKaeKcO9Jo1e7/pyPlc2+MMc4Zt6U/tQYZ1M+fgZs4mn/jdYOM6U1YSwmOvm2+pmexYNn7tDHQRhDS0Rq5GIc9GmLZZ6w/KbLVypejQz6qSBEasfwqL6P/X81qSn9k9TdmLbP23aFu4lZGzbqK1tqT3Yes+C2ZeVznTOmnjE1IkeCnVID0ZvJ6B05j2AWq933xgagOWhv09A1+oAHgyV8u/NRD6TzvGeoWhYf2nKbyJ04sJfDg6pV2q/0WCkc9h/Zue6f8O0Zj+T7d0carxxO/a2x8K2jym/UuOZza/rgNsnjF/X4cpcd7pyfLEONzFirWbEWsKIdR0j1jpGLM46LmbEWsCIxWkTixixOG3iRkasj4JNrGTEWsWIVa19m1P3nPq6nhGLs47LGbE425HT7pcyYnHa/Q2MWJw2sZERi9Mmtsy/Phw+mnOsvYYR66PgC29hxOL0OdcyYq1nxOLsQ5z64hzTqnVeWK1jWrXeW3HqnrMPceqL00dvGTs+HGMH570Vpy9cw4i1ZU1h8/UhTt1z1vFmRqxqvR/i1P0yRqxqXS/knOds8RObbz6xxU9sPt1Xq58IM/8aAK7hsxepvQ0Ga1gRLHz2Iswf5pw9iIXPXqT2eJh8wwPKgeeNUGfr6dDs9a5bTf7/RgKfe78SLM/UCV6D5TcRdXTxnJ06t5D61rDR3VYE1xYiDu8po8403Iooh8IaijhAO69Q+0X72n5D3fCxth/lP0ptv6CzrEy8V8U677cZdN6vTJ3rcGFu0//UuZ543x/FYTjBoYXIb9JR7VfDpq9ECtfflAHLhmf18bVVPPRZn6b8Jq93W7mwHeo8VsoP4nNSYd4WFKfD1bnudDiujrhWa8FaxYi1jhFrCSPWAkasGxixFjFirWXE4tQXZx25eFF+sFpsdQ0jFmff5rSJlYxYW/zXFv/lso6cur+OEYvT7tczYnH27Wrtj5w+ulrHWs52XMyI9VEYhz4KdeTkxelXq3XcXsiIxcmLU183MWItY8TinJtU65i2pT9uvjpW67j9UbhP47SJaxmxqtXuVzNiVetaxwZGLBc+mnpmgJ/DlvrMAOY36ahyhpZZztCQ5VTiGYgOE/L/R8oLcbOGD9f8a1C5I8D1zfHszJTfhLgy8/Fttg71g59/jCS4thBxFWjP2Gb8dl3o9vywfLsO+wGoV/x9L4rDSIJDC5F/pKWcEWWWM4Iop5HINyH/f6SsEItjHZuyYbnbgOuM9pAJa5+m/Cavd5u7sM9tEB+sn1qkn23d8EnXIHzIZ1tCP6YttyPiDNb2+b/h3ieYfltQR5ge/jb54bVIHqSFwByJOGxH1AdeM/rVY+/4fIS7PhDJNnu92x33AUdtHNpHm/KbPKd90rfZ3DZEG1E2Z/LabKGE9ox2Zf1YWybRFmlPxdvS7bFoOpqIpONtWd9P+tGOeDIWy3bFk+lkNJaNJqJdzUQdcHtu50Z/8bDtacpv8pzal2/rc1A/uD23J7i2eL39gNl/VEPE1RHXagOwKD/RVywdZuQ2/e9w7GzDtm+4w3Jh/TaH3zDlN3lO7d63tRnl243udiC4thBxI1E+2J6V0Xmss686dzS/t+qcmmOWonMdrsp1p8NxdcS1WgvWIkasZYxYyxmxljBiLWbEWsCItY4RaxUjFmcdr2PE4qzjCkas1YxY6xmxOO2Lsz9y2henL+TktZIRi9PuPwo2cQMjFqd9rWXE4qwjp+6vZ8TitPs1jFhb/MSHw09w1vFmRizO+US16n4jI9aWPlQa1jWMWFv60ObTPee9O+c9Mv5+ClxDws8OS12XhPlNOqqcEWWWM4Iop5HINyH/f6S0kMYXDPYOBLYfi/kqS8LPprOxtkRHtNNvj7W3Z+PZRHsyns62xVPpRMaPp2LRjkwikvWTGbXCH+tKtGc70l3tWYO9Y/m8Y/iCWQdrAtizcpv+18+cfrhdz3aoz6eBz8yagK5rQTxMf+T23Zg/yWM2A1wPYMC2qgXX+dYLo6HfbzXlNyGuvHy61y9rER+sH7x+WUdwbUFxOuD1yzqinDqiHAprFSPWekaslYxYixmxFjBibWDEWsSItZwRaxkjVrW2I6etcvZHTl7XMWItYcRay4jFaRPXM2Jx2sQaRixOfXH6L05e6xixONuRk1e1jh2c7cipe86+zVnHjYxYlzFi3cKI9VEYtzn7toux1tzjw/u5QV7PuDoQNxDF1YM4iAHjIL96Cz+Yvz4gH66HuR91dTaWwR/gBr/wvc/+hK5gnUz55v6yAaSvCfjfYOE4U1YTwuLWna1ukD+2g/6AD343hsLqXyJWIxHnok37WeoNy2+2cKXqUY90QvWzGkIn5voACy+YfghRtslrdNgI4hh1GLXpEPZFU35fvpVq9LYHSmfOE631ettg/wAsD/29B7pWB/BgGIIwKD+K+3NQ+7YE5Neh2VJOM5HP1G8g4LgTiB+AytiJ4LiThSPMb9JR5dSUWU4NUQ7GotZMdTg71x0P05+YXzPVdVg/uifmzgQ/W1/chUi/M0hj+FC6MXmbibJrAv435Xie3YYgB+yndmEsZxeQpgGVsytjObuCNINQObsxlrMbSDMQ5NN/jwVx0M4Mj90JHsbPjgPXuccqWJ7hi3Vgym9CXJn5FOYM4xAfrB/su8YTXFuIOOy3xxPljCfKobBMew7xercv/vb1WKKcsZZymoly3NpCNIV1CYOJ24Ooo4nbE8RB+8ChDv0N66R96t/HdOPidJgP1LnhVm16Govi9gTpzRnhJm4vEGfeD+mLDgfs1I2L02GusK0MbzPmme98XwOeE16xfc/89QRnEzcaxB2H4sYQcRr/7fwDVdOvYJ/D845S+y/MPz4Aqx5gNQIs01YNKP2deX0Yu4Ntz2d37QnKfvA4sZejssOOE6b8ZoKP4d1ExNWXwTXblVQP0Nvb05n2eGdbPFvj9e5LdcQ1PBfbm0hPfZvd6Hofz4muo6bP1uW68fcGetWhHsTtheIaQJzhqO3+htE9+e/tiH8Y/cPyW4g4fGZt2LZsIeJOyvFgQX/AgdW/j1jDvN7jrfE5lM/E56WU6jNh/vGWcoaWWc5Qohy3PrX7PVzoU02gfNgwFLd3QP1xoMZrUyfdN48vYbyGOjfchni99YTXzvZAfPA13B79CK6mPaDtMbZHmpoH4frvTdTRxEGfDPWEA9Uepk66Pc4poT2gzg03t+NxNIN14RG8oC72QHERkP7UXM84H8SVOgc19dU6XF6CDqE97YPi9iLyuh3Dwt8Xm/KpOY2L+2JqjkKNEZQN4PEWxkH9wzhYzj5EORSW+U7REAIb+6Q9iXL2tJTTj+Ds1haiWaxLGHB/onySD+KgfeBA9SdTp1Lvi6HODbdq09OeKA76HXxfHAVxpfokqMNS7othW0VQWsPd3AvCtSlzL9uA0r4B7qFfQ/fQcC3o9FzPOLiOYcrRGHU7dF+H5VD34zpcEMDLbI52ax/xNGUf2J9HHJUd1p+b8il7NbybiLhy7l87/WwsE+nsjEc7023t7e01Xm+bqyOu4ftXn0hPfYPH6DrqOdF1J3X/6gO96lAP4iIorgHEGY7U/avviH8Y/cPyW4j0x4E6lNKW5t6OGrcpXzEz1zNuHMEB+oohXu8+ju8PqTnG3gRX6v7QpKPKGVpmOUNDljO+zHLGW8qBcXguU+r9bj+CM1XOHmWWswdRTrXNBfD9CfRl+P6Eay6wvI/33HiM2IPIW633J27WUez3J9QaQ6n3J7hPc96fuO7Tku5PoH3gwHl/QvWnatPTeBRXbfcnsK0gb8i9Hlyj7jHws6z98vMEbSMf26FnedR6s043B6UbT/CuVn843g0fqz+k/Eep/hDuIyzXH+JnB9Cu8HvFpa4hb02UU239fGsUB/1hqWvIffWHVF+WNEerBn9IjSnYbsP6Q5P+jIqsjUQiw1C9YFlb5pmF4HyeCdfayvWrtns6fI5CqfPMEUQ51eYvRqC4LfPMD888M+ycMKz/PSO36X/sfxeA+WguYJ4Jeeh0X9mB5m/S6rDFb/L6Tc75qGlL6vkhno+W+vxwa6IcSfPRSvnNLc8Pu9O4uD+Hz+rC+EOT/tYqmo+OJervdn9QeL+K95qOdcPHt/khan8/tYfJ5G0h4vB8tNRnGRAL3+dDbDwfpd6/GGcpZwTB2fHevZL3QOH5KOyT0D5wKLZ3rxS/CnVuuFWbnsahOPicEvvVcvaKQR2W4ldhW+G9YtT7OdSccBxRhtt2CP8tKVN+k9fbZlz4LmpNj+rr+r05c47exMzMo2d1Tjqn6/DMRTMOmJI+OjV95jmpSQek09MzM2bA2sASmonaYmvBaczvFuI6xNizSC3MW73UKife/bZ3EaxTEBbMvzfC2qcI1kkIC+bHO2XM3w1eb57maX9tCBzcqylepyJe0EPg2YxfBOtEhEXtojBY0SJYFyEsmB/mhX83eL15Yn3ZcLTEi/C6ONeTVwzkjyOstiJYlyAsmL8NYbUXwboUYcH8MC/8u8HrzRPry4ajJVGE15xcT17tIH8CYSWLYM1FWDB/EmF1FMGah7BgfpgX/t3g9eaJ9WXD0bJvEV65XE9eHSD/vgH5gnwZ9A1U390XxFO2Ctse1rmZuIZH14+B64yjWegdfqb8Jq93u7gYXT/m9dYf1A++M/g4wbWFiMO7gj5OlPNxohwKa09GrHGMWPswYkUYsfZmxIoxYsUZsfZlxGpnxEowYhk/Rs29RqFySr3zhvnxygnMVxPwvykHX7Pd4Y9C5cAVCHh6dOuO3XmgDcKTUGBeMyY2oPS50d2YW6O3tqFd47eiYBvy+dxY4c18OJZ6SCdw/IEnm+NA3bEa3vqO9YUS7lhhG30MxcE++3EUB8fZ/VAc7FOfQHEJgk9f7Qu2VaXsOI7KiTOWQ82lsb45yqHmx9RcF/t/aj7fbiknRpRTrP9Hd6TLDOr/Zu7ZgNJPG92N2ZbHbCTquDn7eALFUeO4idsPxGEb/ASIg22LA+U3jC4+OH1i525cnA7XA7Yt9htU32v0etv45lh9N+U3eb37tos5NnVvTo3NlF81eal+i/um7V4IlkNhmfs1anzEX0CPEeXELOVsQ3B2awvdXxaG9TeBGqPwF+CpcSVsfzJ1KnX1nfKV1aanGIqDYzlefYf3kaWuvkMdDujjXKYd4GMdwnRwXKHWxSheNQRODKU1cbVEXrNSTa2hbYvKoPwHvIb727YEX9tcxdgY9Aebwy+b8ps8p+OEb/OXlF6pftCGdM45Z4JYYea0jUS5jPqKh20/U36lxlVqHNqW0Gsl7DuoneMWPm7uM7tPp6XWpal5h35zsZ/X24aoewTMOwnwzbUwcx78vKvU5xEQCz/vKvV5BMTCz7soHeDnD4vz9xZah3N37JnGPKtZANLk8r+pMcvoQae7FqXDz310cHs/E77vm/KbEFdXfZ9qR6gfaNv9PbuNwTYOeo7oE3XFNh8pwgnbPFUWZRMmHWUTcLfB3iDd9ZZ0+xDpMIaxX/hceyyKM2mX5TH0XG1U/v7R7VvwsSjVJzykQ9jeO4LfOFDzT8O71LU0qGc8V7atIUFbwOs+0A7xGopP8AnTZ3XA8w7YVmMD6sVRDmWzrtfs8E6cfRjLofqx2xNDSrd/H8VB/4fbGvpD3D5wnME6hfOCUncCGz3p/rZdiDUot7uhql+/8JkoDsV2s23Rb3H9wufEOGzRb3dcGP32RYelrEPDtjJ10rsBzY7aiZmZh2cuOiE16Zx0auY5U6ccmzl/VmbGzHoEOzaAjvkbH2xsqg5xPAtdHWpR3DgUD7flUKGZyGfKcHvwb/hlHHwQlesNosW2MOJlHOrQrBYiDh/qEfaQJArLdlDPdqicUl+23I7gXG0vw2yH4uBUs1RXu+Vly96uvVIvDcG2wres0A9egLiOBvn2QvnGgDiDTx20D28b8qNDrw+GN47O/4/SMQ+v6TB+eLyjssP6YWxL1EdIqINGyjksMJrp7GpPpbKxrmykK5XNlOrTTHpq0/9IIr3bF7o2Pc7/gEOuGx+/LlAP4sajuAYQBw9wxocFOpoGpsLoH5bfQqS/MNedri/jE/XSS6lY5uBB6H9M36Y+9hjm41ONKC2v7sPPl0z5TZ5Ln9U9X7J91Mvzes+XxhJcqaUc/OG/Uj8qBLFG539TbYtfsi71Q55bE5zd2kK0gxovTKD8M37JGvoHaB84UGO9qVOp8yWoczyvrBY91aM4OG7g+RK8fyt1vgR1WMp8CbYVHo/ribzV6pPq3fCx+iSqD5fqk+DHo8r1SXi8gW2LX1DemShnZ0s5I4hyqq2v4ReUoU+C9oEDp0+i+lO16WlnFFdtPony65h7A5F2JxRn0n569Kb/9T3b5Pxvatw2H7mkPha6G4qD7VyP4nYhONWgMuCWLuhb8EdTTfojR2/6X+vyr2NozNoATNimOsB7BdiXdagHcXw22uVr3jeP7uYBdfpBfXM960T5QZge349RBy5A32h01ILSUz6Y8o3wY6rmMTmlT8Nxc+gTcgyjT5ge63N3Ij011rR4vXU4GmGNJrCgjm36NBw3hz4hR6zP3YrUCevTZs9QR9S4PgZhjSawYH8/CnE1+fsR6SFeA0p/bj5C62abUT35Qb+JbWEnAhv63hqEAevRRNSjGcXBvBr3h9v1xKW2lVHbv0166tVh+For/lAtfIRk8jYS+bjXeTBXEyr92oaJ2x/EQZ3gQM0NjJ7CPo6sQeUYXNy3sM2MJThSr/DEQuKa9NSWP+q1ZBtv+JgS21ic4E1t+ds7oBxqy7gOQa8iXTV60//wo+yUPzZlu/XHkQzlj6EOsT+mjkugtjDb+jx8vG501oLSw7ahtvEEvUIGMfErpDr0z/Xk88H/ud71NW0yAKZHcY0grj7Xs5ym/N/mI70Yy/BoQOnXjd70/5D89X4gj8nfQpTfD5XfgzdxDbYTxqojrpn0WqfLR2/6PdDrOVaY/8t5btDV1t7ZFW9LRTK+/jOKD3iDXHT5lJ5gP9LB6Bq2RT+ibg0o/W2ju+t8R/43Xs+H5el0j1vS1QT8/wEGca0+1/Ma1UbQdk16U3ZTrjdHEzcQxME+rsOg/N9QXxDL8GhA6R8Zvel/0ybQ3kz+FqL8Aaj8HryJa9h2BxLpBxLpdfvcOzqPl78G6869nvVBmQgfXsPcjO246FeZznhHorOjqy2SjnT4HbFi/UqPCwPzc1HbOmVYW8brXBDLPFcyczv4cRLGNoka/P6IHxO+b/TU4PXWkyl7gJO6ZbNh2gGW34S4urB/WJ7hg/WDn982utFPRm//N7YH/Uc/QjeYR3/EsckRR2oeaDhRz5gNjw8+zLxzT461jji67aPZwn4KeC8DjwT4wejucmHbwHk4tHs4tsP0Pxndjfmj/O8hANfkN35qIIjvT8Sbv0171RJp8YfU+yMdUnqF6Y1N9guoaz9UV5P+V6M3/a+5DR1FY0L9QV61AZi/BZjmPsZgwrUFW5836QcS6WEfM3yGeL375kCUD3Jv9HoGeI1qnxqUFo/BcP9Df5S2f0A5WB8UhwEEDrX+04i4wjKxPeiA79HriHJgn4JjfiNRPuP40EaNlSaYOPyRMxgH6z41150OB2pNxNRJ1/fp0d24OB3mQ/U1zrmRud4AruNy61DafigtPuAecmxg4NhClNMP4fa38K9BOPVEvmaP7o/U/2H51hB8qbGm3HIg1rRcz3JgO8MxrXZMNy7243VE3vm57niYvv+YbsyG/O9iYxr2JbAO5+e6r2GfjeexuE/idTw8duE0cByH6Qfl6wHHLuwfIJa+Nhjpk5ojUPM+PEfYG+hzKNInNQcY4vXWDbbhRlQWnB+b8QXrYBTgsfWY4LKMXpstddTXth1Dp4McYDqMQY2dBoPq1ybfEIIX7nvYd/SzlEGNZ1QZDSiu3Pahxm0416DmMFQ8HM9hOfhaLZG+2PyjKQCbwu1H4FB+fgCKqyHisA+D9YU+DM9NqHsy6BupfhfUdra5N8U9zLyqn4U7pT/oh7jXciLJiB/pSrRls366PdUZL7aWw11+tK0jmerojPjRbDQaS7ZXuvz2eLufTKaSXe1d2Y54V2ely+/qaM92xGKdfqwjnenwK17/TDzWmfWzaj0vlo3Ekn6ly1er89FM3O/sbPMzqY6ObClriZR/xvuFTR+C12H/M/uj8Hh9RL6/uV1roz86E2aMo+pH+ZeTAuo3EcwDjh5TvDybz6TGwloUB/0ibqPC+nnIOpj0J+Z5F3v+CdfcdKjP9azfhPz1SHkhTj3/hPfrDbme9batVeiA58mDiPQDQRo8pxkE4vC9XAOBRY1L2M76efS81+BhO+sEbYT3o0Cbb0LcYd3xXKGOKNe2xvHBETqoPzt6LpCg1hRMaPbo+Q2Mg/0E70/Ga8UwDtpBqftmjS40r3ljunFxOhMoP4F9AbXuR/kJuNf+A3653rw2R7+Fc2zcb6k1SZje9J0Wr3e7YXuFfaARxcE+gOecdZbyqPsl2AeCnslBnwDXFBaM6caD7QL9NcyL/bVJvxqMOZejMQf6J2wvlJ/BXDyP9mNh1pqoe1fTLtRzPs61yxpUnqkHvAbLb/Kc+i8f+3uoV9uzNkfzo7jhQ93zUu2sn80N9nq3GXV/DddZ8ad/qLVPyrfh+RHl26i+jv0Adc9qW5uw9XX4fCnM3JHqx7ifw/Trx2z6X8c/hvoxLC9onc/z7G1oa3OoX7wWQz2vsa3T2Pz5AAuvYs+YMC/qGZNHlF2sDja7o+bXm3FMbaPGVFh3PKba5rY64DZoJtJT890WlB7q3Lb2RPXLgSgubL+E89DHAsZSWA/oZ/H6ENU/4RgNx/UaxAWWAdfPzKcualAZ/Yj0EK8BpX8GcNhmFI1pfI0OuVxvTMwZXod6wfftJt2XAIezd970O8y7kY72roQ+V6Gwd5PQh4vxnbr/o96NdHy/1GXrB9S8D99f4baDfThoHwJ+zgnHBuj38br9D/K21YIwdTBnLNUQcdQzLbhX71tjetbN1bNV/F5z0L6YnyAfBfs7tTcAfyrHpP/lmG7Mn6N5AmX7Az27z6L24mD7CdrPgn2WSf9bi8+i7nMgL7wv36T/A8DE+1kou6DaD9syTG97Xkg9p6Pem4T96QPsXG9Mx3OENDVHgPrBcwSbLnQodf5o7KMFpYd6pPoRXgO12aoOtr0z8J0o0+/Y1/h938+2xzuT7V3RSDbdVek1/ng2kWrPJiJt0XQ8E02nSlnjt+m4htDxEIuObVi1FqwaC1ZDESx8jHhQH8T5KjQ/CX0UN56fuNkTap+fQP3gtVFqrtBCxOF74FLXj6g1Tw4sPDZD7KC+Qd2zQx15Hj3fgbo9Mrfpf7f7kSOd1D2gh+o8iOBcQ6Sn1rDh/uVSjtaGuhuE4qCfb0ZxcBwZjOLgODIExVFrjGH6oA42+2kIqBdHOdTYR43X5ZZDrddhfXOUQ60FUusouH/b9t1Q5dQQ5VD3onDuvdtOdJlBc1C81m7SH7BTN+a4nXqmMTraA6Rpz/9uJLgz+oEO6vmKh3QDfRBeo4fPubDNQ/+B7RSu/2DbGgw4wH3ZOFB+x6QL+040pWtHY2lV6TqsPo0uSj2uGdqrqRO8n7T1I1gu7kcHgT5yLOqb1Lox5XfM9WLrxvhejlo3rtZxmmp7bDODQRy2mSEgDvdP+LkQqBMcis0LwvbPYwN8sCkD+2B8fxe09mt8u+v7m4YiWGHuSWxYYe+Vttzf9Aqi7m/qGbFqUH2g7ovd+xezZ2yDtntsmK9CNhj6GT+2wRo3fPyweu2rDXLaTbVjuXyfneo3QWv2c9GYZfIFrdnj+waTfiGY78zP/w773g+uJy4T7ykstq8fz59se+lhWdQeDts7HUF7hqHuYN3MXhG8L2IRGN9t+1E35zP4Sq6vG51R6+u2fZt4blhHYEKb37ImtmVNbMuaGP1/2HKqeU3s0RLXxLB/Nul/AMa2JwLWxJ4Cab66ZU3sg1CJNbGvblkT+yBIWBP7Eegjf9iyJhY4Tn+Y1sT+4GhN7FFiDhdmvQiOaZtjvchcq9R6UZ3XW9+29aJ6git1Xhret0atQ1L7AiuFRd33Yltwda5MWFsw5Td5Tm3Tt+m1jtArNZ/H7yTAOTFuP2p9iHoHRAqWya+DbR0S+x+oX9s6DDWPNfuUg95dptrG8DLjSNg90IU9kHmf7vjdJfLdZXy+naM11Xbq3tEE6l4Vtzv1rjJ1r4rbnZqb1BAcqHHX6EKXfV6IcTfMu0jU+za290Uq8S6SDuZbjTUI0/PotVbbcySXexMT0a62VKytI9KVaUuk2hPVcv7ATqgPf9jOH9gvX78PnovuXLy8ajx/YK887y3nD9C+ohrOH0iCNtqc5w8ch/qzo/dpxJ8/UMq4SD1f3nL+QPWeP2D6wEBQVr9cd1pGnUZrkO7qAOf6XDd3U75pf3jOvElnuDa64RoxXM259GYcgmXCutSi9Ph3A7o2cedu3rCOsB1t33OgzsSvA9cMR+r7CQNzpWENQFj9y8AyvKjvBPTvIy8Kqx/CaiSw4DWjX90nTgZ9gntum0pkOuLtsWhXLNuRSkaSfTmnH47T8JnMFGBT0FdSZwnoEHQmyOVgHng+mgdSz3C3nAnS/f+WM0F689lyJsjmORPkatCPb7bcz+F7ii1ngmw5E8QEPM/9qJwJcnPAWArr0ZczQcwYfWC+MvBMW8/jHyfwc0hO/GSkM4Of2TPzj7l9ntTe7nhNPGLs7dO5bnzq2UEdSofzQDs+BKQ5JCDNoSDNoQFpDgNpDgtIczhIc3hAmiNAmiMC0nwGpPlMQJojQZojA9IcBdIcFZDmaJDm6IA0x4A0xwSkORakOTYgzWdBms8GpDkOpDkuIM3xIM3xAWlOAGlOCEhzIkhzYkCak0CakwLSnAzSnByQ5hSQ5pSANKeCNKcGpDkNpDktIM3pIM3pAWnOAGnOCEhzJkhzZkCas0CaswLSpECaVECaTpCmMyBNF0jTFZAmDdKkA9JkQJpMQJosSJMNSDMRpJkYkOZskObsgDTngDTnBKQ5F6Q5NyDNeSDNeQFpJoE0kwLSTAZpJgekmQLSTAlIMxWkmRqQZhpIMy0gzfkgzfkBaaaDNNMD0swAaWYEpJkJ0swMSDMLpJkVkOYCkOaCgDQXgjQXBqSZDdLMDkhz0f+3dy5AclVlHj93unuSTE/mkUl4g0EQEHW3b0/PTI/FllNLHkstbm1tWWvVbon2zHSHaEggD3lDB0ISQiAkARIggYRAHkBEFEF54xNFxReKoigqiOIDFZ+obM7kft3//vr77vRk+sx0Z+dUdd3b9/7ud77zuOeex3fOAeZ8hbkAmAsU5kJgLlSYi4C5SGEuBuZihbkEmEsU5lJgLlWYPDB5hVkOzHKFuQyYyxTmcmAuV5gVwKxQmCuAuUJhVgKzUmFWAbNKYVYDs1phrgTmSoVZA8wahbkKmKsUZi0waxXmamCuVphrgLlGYdYBs05hrgXmWoVZD8x6hdkAzAaF2QjMRoW5DpjrFOZ6YK5XmBuAuUFhNgGzSWE2A7NZYW4E5kaFuQmYmxTmZmBuVpgtwGxRmK3AbFWYW4C5RWFuBeZWhdkGzDaF2Q7MdoW5DZjbFGYHMDsU5nZgbleYO4C5Q2F2ArNTYXYBs0thdgOzW2H2ALNHYe4E5k6FuQuYu4CJAHM3MHczxuU8iXQi1eO2/dydCpvL6XbcvrviPn/yf6zWCZX6oiQbXqlf0WP3ovnycNC9GNxDO7lVwPG8xefgoo0Z5V/JXpPyrZW/AfzaZEp1x2cizH9jysc7XKRFOpEZdJvv/YSUdhGIW+uicI/3JVeSdtY9AhyPu4jjuHPznvh+h6A/t3+ZlDcFF2FxjfEn2SBE2D0cR47mS/2h8X6yxeOySA9uH7A++C+N3/Nxb/Sfj3uX6C1c43YFIxknXxOco+3IqfmivGqWfYW1f5zI9xMkf7Yb/VMkf44T+akE2QocGSSk637t8RuL9/1Kv8u1MBYvjZu6HYv3Ex6Tj/pMFuJHsjPkNr2SPS7yfM9JHGctsXdl13YFx7D1CDx2zwg6kN/W2TjfzsLmav43t3eUbG6kOSvc5uZR0H0vkymlI9aDsEzBOGkUeJTH55DeGxzt/WM9WaYWLk3m/aDLfcG5VHZQGOy1h40Rw++Z8DitNPzaHNoHTTH8x3uyrqgP6irN8cNx38dDuJjAeUzXiJHr+vS9cr1uAy+7+HycvuB/YnQuxcsbKdzcf/uLQxgiprwM4ryUp1B+nPFoiySVpdzWvTAvOzjauHxK0cGY8nxtHdaltHxdyTv4dHDE91pKY8zXpLdkl4O2KVyGdX3BMTE657vNa90paY66Vz39EyQ/7kZ+WpoTiWXJs8xfsruptAwn/nmQ+VxwLs0J4/UJlI1rU/E5+MaMvqyS5vOTfi3wjPSeURlKfBv4G2EyJJ7aaFg24FoA/HtD/EvB0cb7iex7I9lI2fh/2ch+Y5o2C7pyv18Hma8E562C31PZPYxnXkdsEXTBeJ6VL9WF+FdNMR5OhniwDvs/Cu3t4BiFe9VsX1g93sHSA9M/li8Ndyvck/ILt4lrE3hcV4LnbcxLzewepkEL80ey1ZO+L9L7Ss9K5UhbSHh5/rG/dpAl8SQvxvg3gqNUH22HZ6R3LqrIjHpFXRpYGmMaNIHObYrfGP6IEB7ipwnhR76d6Ur8ZE8Pf5sQ/naQOYXJLMyRAJkne7KeGC4PrvF83CHw04RwtZryeKFnpbgnDuNekjGV6UP+NRk5T8SZrngP/cewS+92u6BrWFq3C/7wtD5USGvp29bK/JP0w/eev+PNgiz8rrgsW3vSxXlVVK7jvCp0UbiP/MxAQLXn5eR6Mn6uM5PLdGUGB1MDmTHfj6cr0zOQ6fH93pSfTfldY+1/Mp3u7k327xvRGxzIDaY6x9r/7lS3n05n0gPdA7ne1ED/WPs/0NXdP7AvERJZfyg6hvNf6pfHuop11LePff/IY70QeR++UZ3wjRpiBf8s968hnKcch2QI16L50mvSmACOlRBPfjcJOtI9nKOH9SjrmoP/GF8oi/SIMf5d8I2wDsc36HlpjiDOueR+Sf5XMgczLvA2fdKs3MKwV7sveshPJh+vcd0o79h8TXWC+p6X0D1Q3/MS/ORYzUtAu/+weQnaXIEIMNpcAWS0uQLIaHMFkNHmCiCjzRVARpsrgIw2VwAZba4AMtpcAWS0uQLIaHMFkNHmCiCjzRVARpsrgIw2VwAZba4AMtpcAXvfsR1TZizsOfAdMxAWt3ZMlY+X/n+zY0oCx/NWmB0T5V/JjonyrZX/L+DXbFOqO8oLa2u7tcXpGnD8HRPtmHi6RvOlfuM9TLsoxGeSxY+LegrGj4v4t/HToehP59ZRu8AYuf5NcTRetkqnBP9r2VapKzifsFUa1nW6tVVKJEn+XDfyC7ZW/+ZGfmHO82ku5O/rfiBbLur/Dqs7VPJtt46PKfD19tCfWBX9kdaLcbxWS8GGYDLoKY138vErbPNKY/yc5/U1Lr+wRpXb8JbZe0nrPqL/0ri6MdUt/6xMR+Pq6RgL7+rgaMP638xP7PPnaWQdlkH218zSiDPc3msq+M3jHJ+NMf5/g6MNQ8wrlSnZkOEaG7OYTOLPAJmTPVlPY8Lrm3S9ReBxHIL0kdaTaWHPhY0NSrKRjyhy+NgPD2cDXGsSZFMe5eM3fcH/xCgdyUPbAE/wE8fMkV/A9JrG4jQszuyvXfAX+7SbmL/tzN+hdcdYHiLd4kYuX3B8XnpX+oL/idG5FI/HmCnPt/w9Qn5JcBxa3yw4l9bhxPVNL2BhwbayNIbP46LFSVwky/IZxoWUP3g+Oy842nC3eHpcNApxEdYuHwsbjXamL5a7MaaTVP6FrWlVafnXZsrTl69NJNmEYpnF/ZHsMHi+02wASR7/NqwMjmhrFLYWv32Ovqutgj/a2sHDfWelvha0b1rL5OIYmfTdojp+jPGvgsx1wbnLvoJ9Ls3jQrI3Iz9RH1friPM8o9muRkxpHBK/2ZSmBeVFTOOYIIf4uOAv5mduFxdn/uI3KCL4ge0Ux7aoibC2keN07PWYfxQfeA39bzJy2vRVR59C/61kvxy29mTcjT5pW3eR1kDG9jmmjbQ+ulQu4fd/B1zn74xULlHfSYzxu0HmzuC80r1cSUaD4idvy/D+dev4emF4Lq0zifmMv6/E7w2OUruj0jzCywzkpbJKWmuR21kPN2+G29fT85XOmyGe5rXgt5XLjCnh0crAB0Amj1PJrjMsTodbg5HvLYHxyNtZI52LhHaklcQp8TQfSopTyY49LE6JfwJkVtI+DovT4eqHPE4xvnlbYLg4nZ2Xda00Tol/0hTDz+NUKs/C4pT4p0DmWMcphpn3OWj9dlhu4vxQ6bmmEJlxRaZUfmnrG2tpKZVpPC2fCY5SWkrhilcYruYqhat5hOEi/jlH4Yoo4YqMMFzxYcLF69LEvyCES/qG8X55fJelduusfKl/xL8I/tF7KbXXx2YfHLm9juVeLF8a7rB6gHW87BjNPjgRdk9aqzssv3hwjdtbe4I/WJ+U2tY8D+DcQsnPWfnifeRfC47D5QGsp1sXzZfq3BdcT4zKyXkAvwc8D0j2IWHfD+k7yvtbrJP21w5bF5r3dQxnuxGWB3BMmvo6at3mnubMHGw29+Nt8z5Sm/ODzua+tzvX29nZ73f2DmZ7/e7xtLmfEQiw7+WhrKyMCf5Z7oQQzlOOQzKEa9F86bVat7k/Duow1tWizf1RrNzCsFe7P2zITyYfr3HdKO/Uwlyi+cF5fdv8d43ZXgQRJ/L9jFtbzKLN/6x8qXzD/I0wjj+Dz80GZrbCzAFmjsLMBWauwkzse1B6zpmJfQ9KzzlTT/seOJ7vkHJs990r2cYX6jamvF1VzXLUY/4ZU17nQv+bjMtyvTheFmP68Pg50PkOMXYP6zloM38KcFLess6xPb3jtT8T/vjlu+L+pgdTvgubq3Gg+U6yhbDcXDg/LTh3Ww7urzO6yu/WdQj68zYNtUGNkdt6FK/jNb9jTvC/lud3vCs4H4v5HWSfP0A6Gaflis/rDRET3h/q2N68k/QJ659F/0c7fwH9qrW5idI6ery/WJLVOEJZ45mmGNd8DoS05m2DELawsafRzOE8hekzXN98QwX6S+ks2bnz+RSO7L+SYd9xaayyGc4Hs/3L5p2+aJ5hLsLigcJ5OOOoDG0w5Xm7UZFl2P/D2bUIyEOHZXc0X8r3BdcTo3DVGAs5M/g/3mMhOP8V71W7PHTbZ5eq83U6ivJdr9OB/WZh63RofWT2Pm/3oVxeN7duLruH7wnJtuVMYb26fb9DTPEZ63gfHN7Dvjf+neDrh1jndk+PVK/jtOzsMHr61fec5OKc4dlu5Cepzv1WyCf8W11oN7hNx5TH/DOmsna+6zqrVD+Q6jK2fkC2MUuWLlqcmZf9r2xmEFWXihZ+3zDvjClPDl4daGD/+ad3Vr5cDneeKe8yCav+oSx6vSST6wb2HK8qkuPDQNb1BUctjXIVOvKvMDwt6EL+cnOf44OjfU3+mekeGSZeZrN4kfyrNJvNYrLweXq2Hqp6/xT8P9jMXroyieS+YeH+/i4/m+ntzQ3n/zuD8/quavZ01vfwcCJZL8PDWlWTGKmqSeWPLbuOMMXzI03xGev48DHemwv3eHWSV4XxHlZR+TZqWEXl3Tq1sN3Pvmprv7ScQ/XyRTI90q6byexeDO6RjliVc9m1tS9+ut12zyQHOwT9yS+qtqYgTvA+8RgPjtKx4mmE5H+T03grVlulbZ0kU29bbZ0enM/LLv3PZf0L5g/MyizNvHf+0oXZJUv41jd8CJDXTflUTv68tjzMScER+eEcr6eiI3m8bqzVncPq0GFDu7wZj3HAzbH5O87rhHx5PGmKO5+Wz98L0rHWh786g/+1PPz19uC8HurVvcH/8a5XU7d0nXeh9kzUa8NdpfXa0dRZafqhPW8FedZJdVa3ZjbFOo8r05KwZSupzoPbg+D9RlP+jcL6uvb9qoey7bDg/3iXbccE5xNlW6jrdGz+4zt+D8WyTXonw8q24cqv2SCbt7nnCP66XbI41eX4e5EM2z6cyjZ6zyMCi+8CTtmU0sUI1zyjl4/cHM5AuP3OTj+RGOzxc4O5zq6e3mS/393Z3Z1L5Xq606nBXFcqM9iT9VOZzmRvtieR89PZbE9X50BPd653cKA7x8PaEBK2sKmNYe2FeijDjw7+j3cZfmxwPlGGh7qJ+qmZqJ8yV1H9lPqWeTzHjF62xRhL5g62TtuhyKukvhtRnsM2Kpdhqhhfkh6eoEe9189nBv/Hu2x/LLhR12W735mpb/Ot7Jhts4RjU2HmW8TxZ/A9m5gGWXrOmYlpkKXnnKmnaZDEvA+Y9ynMGcCcoTDvB+b9CvMBYD6gMBlgMgrTD0y/wgwAM6Awg8AMKkwWmKzC5IDJKcw8YOYpzJnAnKkw84GZrzAfBOaDCvMhYD6kMAuAWaAwZwFzlsIsBGahwiwCZpHCnA3M2QpzDjDnKMxiYBYrzBJglijMUmCWKswyYJYpzIeB+bDCnAvMuQpzHjDnKcz5wJyvMBcAc4HCXAjMhQpzETAXKczFwFysMJcAc4nCXArMpQqTByavMMuBWa4wlwFzmcJcDszlCrMCmBUKcwUwVyjMSmBWKswqYFYpzGpgVivMlcBcqTBrgFmjMFcBc5XCrAVmrcJcDczVCnMNMNcozDpg1inMtcBcqzDrgVmvMBuA2aAwG4HZqDDXAXOdwlwPzPUKcwMwNyjMJmA2KcxmYDYrzI3A3KgwNwFzk8LcDMzNCrMFmC0KsxWYrQpzCzC3KMytwNyqMNuA2aYw24HZrjC3AXObwuwAZofC3A7M7QpzBzB3KMxOYHYqzC5gdinMbmB2K8weYPYozJ3A3KkwdwFzl8LcDczdCrMXmL0K8xFgPqIw9wBzj8J8FJiPKsy9wNyrMB8D5mMK83FgPq4w9wFzn8J8AphPKMz9wNyvMA8A84DCfBKYTyrMp4D5lMI8CMyDCvMQMA8pzMPAPKwwjwDziMI8CsyjCvMYMI8pzOPAPK4wTwDzhMJ8GphPK8xngPmMwnwWmM8qzOeA+ZzCfB6YzyvMF4D5gsI8CcyTCvNFYL6oMF8C5ksK8xQwTynMl4H5ssJ8BZivKMxXgfmqwjwNzNMK8zVgvqYwXwfm6wrzDWC+oTDfBOabCvMtYL6lMM8A84zCfBuYbyvMd4D5jsI8C8yzCvNdYL6rMN8D5nsK8xwwzynM94H5vsL8AJgfKMzzwDyvMD8E5ocK8yNgfqQwLwDzgsL8GJgfK8xPgPmJwvwUmJ8qzIvAvKgwLwHzksL8DJifKczLwLysMD8H5ucK8wtgfqEwrwDzisL8EphfKsyvgPmVwvwamF8rzG+A+Y3CvArMqwrzW2B+qzC/A+Z3CvN7YH6vMK8B85rC/AGYPyjMH4H5o8L8CZg/KcyfgfmzwvwFmL8ozF+B+avCvA7M6wrzN2D+pjB/B+bvCvMPYP6hMG8A84bCmOVFhs454wHjKUwDMA0KEwEmojBRYKIKEwMmpjCNwDQqzCRgJinMZGAmK8wUYKYoTBMwTQoTByauMM3ANCvMVGCmKkwLMC0K0wpMq8K0AdOmMO3AtCvMNGCmKUwHMB0KMx2Y6QozA5gZCnMIMIcozKHAHKowhwFzmMIcDszhCnMEMEcozJHAHKkwRwFzlMIcDczRCnMMMMcozJuAeZPCzARmpsIcC8yxCvNmYN6sMMcBc5zCHA/M8QrzFmDeojAnAHOCwpwIzInARIA5CZiTGCPZ6djrfcH/xCgc2dJZmW7sFbKJSpbVaHTjt+8x/4yB7x0ca3UpuJEu21rpEmcRr8jxvMVtA9H+j/KvtHwP5Vvc9ndozoZXqjs+E2H+G1Nul+xkaR4/6XhpHj8hpV3h2x0co3CPzxOvJO2s64XyYkzs5SHuHC317IfZy1NemZQ3BVeoe8I1ir/xmuM5NRBQy3M8G4OHxmKJU7fLRfkJx8tFpUj+HCfyUwmyId4UpIlrO0I+l5r8QL/dLA3qV/xdxu353NUTit/lWlh/w+Zlj8lHfaQtxigtpwj3SFZhyxqQhfxkCCPyeE7P4zXatqdNkMnXN5HWZcBrWDYdzeoomDaeciS5/BrJbTPlccO3c2uEcJKOks0/39r8nV5R97eyOs9It7ilOKl0O1bi3wH1rq2eLFMLlyYzCeFKsDRpFMJgr6WV8HsmPE4rDX+Doms3hH+boivqg7qGrTthj6eEcDGB85iuESPX9el7FVYeH2g+xzDzssvNmjD7lzLE8kEKN/ff/uIQhogpL4M4L+UplM+37i7MIzFyWYpbYiL/bsj/cyt4r7G9xLcDl/J1Je/gvwvvtZTGmK9J71YhrPSM1P62ri84JkbnfLd5LZsg+ZhPvOrpX5AfdyM/Lc1rxbLkPSy/SduUh+Uf4v8H8vB7Wb7AsqWS9XnicJ/aT8aMvqyaCgyvN7TAM9J7RmUo8W3gb4TJkHhqo2HZ0AY68O8N8f3wXu5g34dmITw2/gc92W9M02ZBV+73uZCm81iaot8Ur62mPJ55HbFF0AXjeVa+VBfiF0A87IR4sA77Pwrt7eAYhXvVbF9YPfaw9MD0j+VLw90K96T8gu8B5g3kW4HheRvzUjO7h2nQwvyRtqCWvi/S+4rbpfNypC0kvDz/2F87yJJ4khdj/IXCd4vLxLyG8RRVZOYh31/C0hjToAl0Xqv4jeGPCOEhfpoQfuTbma7ErwgJf5sQ/naQOYXJJH6V8K5xPTFcHlzj+bhD4KcJ4Wo15fFCz0pxTxzGvSRjKtOH/Gsycp6IM13xHvqPYZfe7XZB17C0bhf84Wm9UUhr6dvWyvyT9MP3nr/jzYIs/K7U+nzpLYGAg20N5JFukXuwbT0+7lt/j3Drc5dbf++Fb9Q98I0aYgX/LPdoCOcpxyEZwrVovvSaNCZQS1t/PwTfCOtqcevv+1i5hWGvdl/0kJ9MPl7julHeOXi28enO1fc6EGO3jc+sfFG+1Cd5oGv8SGP81MeL2/LY80PBL+vm5ot6YP7g8qQ2zZiM/ydSabfpk+xxNf5/LIsfJ2P8YBfk5v1IpitZE+/tECcYD8RjPLgZG0ymK/nmov9Nxul7H2pDJG3dadsLtP/BvOzS0/33LDo9+e7sWf3ZxUvOnH92sNJ5A4tZTHX07UQm3TAO3Ymgncbxtx9zhNSqQDcS6yWMnXpaKfxtwf9atiI5Pjivh9W6/OD/eLc+6etZ5ysxdk2sphvuqrWaLvX6TDalveie47R1GPehG5lTDYDKNht+emcWLlo6P3f+qYuzmaXZwf9YtmDB/Nz87GLDHP/KSN9x8qnWS60Zwf/xLrVon4U6L7X667xt2VMrbcsI4/gz9n5YyeZ4Tdgux/HU5dZOMnwL9bB9daS5FgfajqmVuRBhW9mHyWocoazxTFOMa74fGvYjNLB7UbhX6RyQmcDxd5C3ovBbRet6WhlvA3nUVndcK+kfz1pJvbQaTw7+13Kr8bjgPG6Ktb1OkKe9I1JfIY0tY3nAbdwcvc9J0jUq6IrlC/lva7JUn7NbJWdPWzj7vOzAsqXzFy08NTNwZtYwp3WfNBj9w4wBlWRE4HnJ1UOlOB38H+9KMS36XueV4vRYVYpd7aHutiNYrhRLBQ7lYRoswXPSiZi5wOCgiXUuBm6kCiL5awtgMnSx55TvHX/Q07XQzUAFsi2cZwbn+7sZZi88Z1l2WXZw/96gc5YtHNhfUC9YYJgbzUb1mCYj2aiewlDrZTUNQIx3WU35G43rqh1f1qGhvwP5hW+Bq0YKTrYyzC+MN54X8Zx0msLivMq6ZgqVctAhwvzkOiIjvW98eCvKrkcqYKW6Fd0rVL5DnuOT5fg13tAzAl+oyAfHmCJrEtxHfhJjXaVhh6CTp/g9w40OhXdquhv5CemdmgHn01k4MV/1VUkHkkd5IGbKHTdqKzT8mH5e9fXzuS5S+UKO8sx0uDZD0RW/O9Vs/JH8uBv5Yp7Bybhxdo/STirTPOV/AzuGsV6IXKkcIpmUVqgvheP/ALAe1MT4BR8A",
      "debug_symbols": "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bAqbwqawGWwGm8FmsBlsBpvBZrAZbAabw+awOWwOm8PmsDlsDpvDhizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLBnIkoEsGciSgSwZyJKBLBnIkoEsGciSgSwZyJKBLBnIkoEsGciSgSwZyJKBLBnIkoEsGciSgSwZyJKBLBnIkoEsGciSgSwZyJKBLBnIkoEsGciSgSwZyJKBLBnIkoEsGciSgSwZyJKBLBnIkoEsGciSgSwZyJKBLBnIkoEsGciSgSwZyJKBLBnIkoEsGciSgSwZyJKBLBnIkoEsGciSgSwZyJKBLBnIkoEsGciSgSwZyJKBLBnIkoEsGciSgSwZyJKBLBnIkoEsGTNLOLABCchAASowbBbowB6fFzmCBzjuXS5uhakwF5bCWtgKh3YEduC40I8ZKhMbkIAMnEIK1sJW2Av3wgPcjsJzRTWYCnPh6Y1laFrYCnvhXniA56yfF7fCVJgLFy8VLxUvFS8VLxUvFy8XLxcvFy8XLxcvFy8XLxcvF68UrxSvFK8UrxSvFK8UrxSvFK8UrxavFq8WrxavFq8WrxavFq8WrxavFa8VrxWvFa8VrxWvFa8VrxWvFa8XrxevF68XrxevF68XrxevF68Xby/eXry9eHvx9uLtxduLtxdvL95evKN4R/GO4h3FO4p3FO8o3lG8o3gHvDGGL7kVpsJcWAprYSvshXvh4m3F24q3FW8r3pJXreRVK3nVSl61klet5FUredVKXrWSV63kVSt51UpetZJXreRVK3nVSl61klet5FUredVKXrWSV63kVSt51UpetZJXreRVK3nVSl61klet5FUredVKXrWSV63kVSt51UpetZJXreRVK3nVSl61klet5FUredVKXrWSV63kVSt51UpetZJXreRVK3nVSl61klet5FUredVKXrWZV+foJ28zry6mwuE9B0t5m3l1sRYO7znoyNvMq4t74fCeY4m8zby6uBWmwlxYCmthKxxeiuWZeXXxAM+8urgVpsJcWApPb6zLzKuLvXB4OZZn5lUwzby6OLznuBinmVcXc2EprIWtsBfuhQd45tXFxduKtxVvK95WvDOvztE1TjOvLu6FB3jm1cWtMBXmwuE9B9E4zby62Ap74V54gGdeXdwKU2EuXLxcvDOvzkEyTjOvLu6F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Xi5eLl4uXi5eLl4uXi5eLl4uXpleDW6FwyuTubAU1sJW2Av3/7+pO9rRZLcOK/wuup6LJjfJvZlXMQTDdpRAgGAZih0gCM67u7vIf+q7EdaZqa5VZHWvqerZ6oH3y0+vPtxgvBPvxDvxTrwT78Q78S68C+/Cu/AuvAvvwrvwLrwLb+JNvIk38SbexJt4E2/iTbyFt/AW3sJbeAtv4S28hbfwbrwb78a78W68G+/Gu/FuvPv1nuHzDze4wwEPeMILTrhgvA1vw9vwNrwNb8Pb8Da8DW/D2/F2vB1vx9vxdrwdb8fb8Xa8gTfwBt7AG3gDb+ANvIE38A68Ay+92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92m+v+tfbq/719qp/vb3qX2+v+tfbq/719qp/vb3qX2+v+tfbq/71hbfhbXgb3oa34W14G96Gt+FteDvejrfj7Xg73o634+14O96ON/AG3sAbeANv4A28gTfwBt6B9/YqH368P+/O/cy3f3jAE368P/80QT/z7R9+vD/v1P3Mt4/5/DDO06vLDX686+vhgB/ves55enV5wY93PWs5vbr8eH/+rYd+5ts/3ODH+/wU7TPf/uHHm8+1nV7Vcz2nV5cfbz37cHp1+fHWcw2nV5cb/Hjr2fPTq8uPdz/XcHp1ecGPdz/Xdnp1+cc7v55re3r14fbwfrjDAf9458+7Wz/z7R9eDz979fRqtucanl59eL/89Gq253qeXn348fbnnE+vPjzgx9ufe/r06sOPN569fXr14f2bz3z7/PnXhPqZb//w4/35p336mW+f8fzo1adXH368P9/76me+/cOPd8TDBe+Xn17N5+vozLd/+PHO5xqeXn14wI/3+Ro58+0ffrzz/DjZgh/vzz8X0M98+4cb/Hh/fnJ+P/PtH368z+f8mW//8IITfrz5rOXp1eWnVzPPD7V9vM/XQnt69eGAH+/zdXHm2z/8eOucM+GCH+/zdXHm2z/8eJ+vhTPf/uGAH+8+P3F3wj/e9XxdnPn29fVcz9OrD++Hn314evXh9vBzDU+vPhzwePjZ86dXH3687fzY34QLfrz9ubanVx9+vP25tqdXH368P/8KTT/z7R+e8OON53P16dWHH+/5unh6tc7XwtOrDzf48Z6vi6dXH36852vh6dWHF/x4z9fF06sPP97ztfD06sMNfrzn6+Lp1Ycf7/m6eHq1nj8vznz7hx/vevbq6dWHH+/zZ8SZb/9wgx/v+Zp6evXhx/v8GXHm2z+84Md7vkaeXn348T5fF2e+/cOP9/lptWe+/cMBP96fn2nXz3z7hx/vjocf789PYOtnvv37bwQe3i8/vVrP18iZb/9whwM+3nx4wgs+3ucHR7eC98tPr/L5Ojrz7R/ucMADnvCCEy54vxx4A2/gDbyBN/AG3sAbeAPvwDvwDrwD78A78A68A+/AO/BOvBPvxDvxzuN97vWc8IKP97nXs+D98vqCG9zf86yA8a7J8QvGu/AuvIk38SbexJt4k/Um6028iTfxFt7CWx0OeMCst/BWwgXvl/cXjHfj3Xg33o13s8+b9W7Wu9/1nvn24z3z7R/ucMADnpxnwQkXjLd9wQ3ucMB424QXnHDBeDvejrfj7Xj7gFlvZ72d9Xa8/b2/EexzsM/BPgfewBt4A2/gDfY5WO9gvYP1DryD+zvY58E+D/Z54B14B96Jd+Kd7PNkvZP1TtZLr2Jyfyf7PNnnxT7Tq1h4F96Fl14FvQp6FfQq6FUk3uT+0qugV0GvIvEmXnoV9CroVdCroFdBr4JeReEt7i+9CnoV9CoK78ZLr4JeBb0KehX0KuhV0KvYePd7fwe9GvRq0Kvx9XrH14AnvOCEC37XO+jVoFej4W0BD3jCC8bb8NKrQa8GvRr0atCrQa8GvRodb0+4YPaZXo3AG3jp1aBXg14NejXo1aBXg16NgXdwf+nVoFeDXo2Bd+ClV4NeDXo16NWgV4NeDXo1eL4aPF8NejXo1aBXg+erwfPVoFeDXg16NejVoFeDXg16NRbexf2lV4NeDXo1Em/ipVeDXg16NejVoFeDXg16NQpvcX/p1aBXg16Nwlt46dWgV4NeDXo16NWgV4NejY13c3/p1aBXk17Nr9c7vzoc8IAnvOCEC37XOxve1uAOBzxgvA0vvZr0atKrSa8mvZr0atKr2fH2CS844YLxBl56NenVpFeTXk16NenVpFcz8Ab3l15NejXp1Rx4B156NenVpFeTXk16NenVpFdz4p3cX3o16dWkV5P3wcn74KRXk15NejXp1aRXk15NejUX3sX9pVeTXk16NXkfnImXXk16NenVpFeTXk16NenVLLzF/aVXk15NejV5H5yFl15NejXp1aRXk15NejXp1dx4N/eXXk16NenV5H1wfX3BDe5wwAOe8IITfr3r672/i14terXo1eJ9cDW89GrRq0WvFr1a9GrRq0WvVsfbAx7whBeMt+OlV4teLXq16NWiV4teLXq1Am8kzD7Tq0WvFu+Da+ClV4teLXq16NWiV4teLXq1Jt7J/aVXi14terV4H1z0avF8tXi+WvRq8T64Fl6+f7Xo1aJXi14tnq/W7dV++PH+zEP2M99++fTqcoM7HPCAJ7zghPEm3sJbeAtv4S28hbfwFt7CW3g33o134914N96Nd+PdeDfe/XrPfPuHG3y84+GAB3y88+EFJ1zwfvn06pzn9Ooy3tOre/yA8Ta8DW/D2/B2vB1vx9tZb2e9HW/H2/F2vB3v6dXlBneY9Qbe06vLC064YLwD78A78A68g30erHew3sF6B97Tq8OTfZ7s82SfJ96Jd+KdeCfeyT5P1rtY72K9C+/i/i72ebHPi31eeBfehTfxJt5kn5P1JutN1pt4k/ub7HOyz8U+F97CW3gLb+Et9rlYb7HeYr0b7+b+bvZ5s8+bfd54N96Nd+Pdr7e+vuAGdzjg11tfE15wwgXjbXgb3oaXXhW9KnpV9KroVTW87b2/Ra+KXhW9qo6346VXRa+KXhW9KnpV9KroVQXeCJh9pldFryrwBl56VfSq6FXRq6JXRa+KXtXAO7i/9KroVdGrmngnXnpV9KroVdGroldFr4pe1cK7uL/0quhV0ataeBdeelX0quhV0auiV0Wvil5V4k3uL70qelX0qhJv4aVXRa+KXhW9KnpV9KroVRXe4v7Sq6JXRa9q49146VXRq6JXRa+KXm16tenV5vlq83y16dWmV5tebZ6vNs9Xm15terXp1aZXm15terXp1W54W8IFv/u86dXueDteerXp1aZXm15terXp1aZXO/BGg9lnerXp1Q68gZdebXq16dWmV5tebXq16dUeeAf3l15terXp1R54J156tenVplebXm16tenVpld74p3cX3q16dWmV3vhXXjp1aZXm15terXp1aZXm17txJvcX3q16dWmVzvxJl56tenVplebXm16tenVple78Bb3l15terXp1d54N156tenVplebXm16tenVfnsVX1+/vfH11eAOBzzgyXkWnHDBeN9exdfbq/h6exVfb6/iq+FtE15wwgXj7Xg73o634317FV+d9XbW21lvx9v3y8E+B/sc7HPgDbyBN/AG3mCfg/UO1jtY78A7uL+DfR7s82CfB96Bd+CdeCfeyT5P1jtZ72S9E+/k/k72ebLPi31eeBfehXfhXXgX+7xY72K9i/Um3uT+Jvuc7HOyz4k38SbexJt4i30u1lust1hv4S3ub7HPxT4X+1x4N96Nd+PdeDf7vFnvZr2b9W68+72/jV41etXoVXvfB6PRq/Y+X0V7n6+i0av2vg9G+8Lb8NKrRq8avWrv81W026t8+PH+zDPHmW//cMH75dOryw3ucMADnjDejrfj7XgDb+ANvIE38AbewBt4A2/gHXgH3oF34B14B96Bd+AdeAfe06ufefI48+0f7vDxxsMDnvCCEy7Os19eeE+vzvGnV5fxLrwL78K78C68C2/iTdabrDfxJt7Em3gT7+nV5f3y6dVl1lt4T68uD3jCC8ZbeAvvxrvxbvZ5s97Nejfr3XhPry6zz/vd5zPf/uHXe+bbPxzwgCe84IQLftd75tuvtzW4wwEPGG/D2/A2vA1v/4JZb2e9nfV2vH3CC064YLyBN/AG3sAb7HOw3mC9wXoDb3B/B/s82OfBPg+8A+/AO/AOvIN9Hqx3st7JeunVnW+/zD5P9nmyz/Tqzrdfxrvw0qtOrzq96vSq06s73368i/tLrzq96vTqzref8yReetXpVadXnV51etXpVadXd779eIv7S686ver06s633/PgpVedXnV61elVp1edXnV6defbj3dzf+lVp1edXt359uc8d779coM7HPCAJ7zghF/vnW8/TK+CXgW9uvPt5zwNL70KehX0KuhV0KugV0Gv7nz78faABzzhBePteOlV0KugV0Gvgl4FvQp6defbjzcSZp/pVdCrO99+zjPw0qugV0Gvgl4FvQp6FfQqeL4Knq+CXgW9CnoVPF8Fz1dBr4JeBb0KehX0KuhV0Ks73368i/tLr4JeBb268+3nPImXXgW9CnoV9CroVdCroFd3vv14k/tLr4JeBb268+3nPIWXXgW9CnoV9CroVdCroFd3vv14N/eXXgW9Cnp159vvefDSq0GvBr0a9GrQq0GvBr268+2P9863Xy743edBr+58+zlPw0uvBr0a9GrQq0GvBr0a9OrOtx9vb3CHAx4w3o6XXg16NejVoFeDXg16NejVnW8/3pgw+0yvBr268+3nPAMvvRr0atCrQa8GvRr0atCrO99+vIP7S68GvRr0avA+OHgfHPRq0KtBrwa9GvRq0KtBr+58+/Eu7i+9GvRq0KvB++Cdb7+Ml14NejXo1aBXg14NenXn2483ub/0atCrQa8G74N3vv0yXno16NWgV4NeDXo16NWdbz/ezf2lV4NeDXo1eB+88+2X8dKrQa8mvZr0atKrSa/ufPvjvfPtlxeccMF4G156NenVpFeTXk16NenVpFd3vv1423t/J72a9GrSq8n74J1vv4yXXk16NenVpFeTXk16defbjzcCZp/p1aRXk/fBO99+GS+9mvRq0qtJrya9mvTqzrcf7+D+0qtJrya9mrwPTno1eb6aPF9NejV5H7zz7Zfx0qtJrya9mjxf3fn2Ph8+3np4wgtOuOD98u3V4QZ3OGC8iTfxJt7Em3gLb+EtvIW38Bbewlt4C2/h3Xg33o134914N96Nd+M9vYqvh/dvvvPtlx/vz8/TiDvffjngAU94cZ6EC97v8adXl/E2vA1vw9vwNrwNb8PbWG9nvR1vx9vxdrwd7+nV5YQLZr2B9/TqcocDHjDewBt4A2/gHezzYL2D9Q7WO/CeXl1mnwf7PNjngXfinXgn3ol3ss+T9U7WO1nvxDu5v4t9XuzzYp8X3oV34V14F97FPi/Wm6w3WW/iTe5vss/JPif7nHgTb+ItvIW32OdivcV6i/UW3uL+Fvtc7PNmnzfejXfj3Xg33s0+b9a7We9+15v06s63X+5wwAOenGfBCReMl14lvUp6lfQqG9424QUnXDDejpdeJb1KepX0KulV0qukV3e+/Xj7e3+TXiW9Snp159vPeQIvvUp6lfQq6VXSq6RXSa/ufPvxDu4vvUp6lfTqzrff8+ClV0mvkl4lvUp6lfQq6dWdbz/eyf2lV0mvkl7d+fZznoWXXiW9SnqV9CrpVdKrpFd3vv14k/tLr5JeJb268+33PHjpVdKrpFdJr5JeJb1KenXn24+3uL/0KulV0qs7337Os/HSq6RXSa+SXiW9SnqV9Cp5vkqer4peFb0qelU8XxXPV0Wvil4VvSp6VfSq6FXRqzvffrwt4AFPeMF4G156VfSq6FXRq6JXRa+KXt359uPtCRfMPtOrO99+zhN46VXRq6JXRa+KXhW9Knp159uPd3B/6VXRq6JXd779ngcvvSp6VfSq6FXRq6JXRa/ufPvxTu4vvSp6VfTqzref8yy89KroVdGroldFr4peFb268+3Hu7i/9KroVdGrO99+zpN46VXRq6JXRa+KXhW9Knp159uPt7i/9KroVdGrO99+z4OXXhW9KnpV9KroVdGrold3vv14N/eXXhW92vRq8z64eR/c9GrTq02vNr3a9GrTq02v7nz78bYGdzjgAeNteOnVplebXm16tenVplebXt359uPtE15wwgXjDbz0atOrTa82vdr0atOrTa/ufPvxBveXXm16tenV5n3wzrdfxkuvNr3a9GrTq02vNr268+3HO7m/9GrTq02vNu+Dd779Ml56tenVplebXm16tenVnW8/3sX9pVebXm16tXkfvPPtl/HSq02vNr3a9GrTq02v7nz78Rb3l15terXp1eZ98M63X8ZLrza92vRq06tNrza9uvPtx7u5v/Rq06tNr/b7Pji+3l6Nr/f5any9z1fj6+3V+HrfB8edb7+84OT4gvG+z1fjzrf//LzZcefbf37e7Ljz7ZcHPOEFJ1zwfvn26nCD8Xa8HW/H2/F2vB1vxxt4A2/gDbyBN/AG3sAbeAPvwDvwDrwD78A78N5e1cMJF3y8+4dvrw43uMMBj/c8t1eH8d5eneMLxrvwLrwL78K78C68C+9ivYv1LryJN/Em3sR7e3V4wgtmvYn39urh26vDDe4w3sJbeAtv4S32uVjvZr2b9W68t1eH2efNPm/2eePdePfrvfPtlxvc4YAHPOHXe+fbLxf87vOdb7+Mt+FteBvehrctOOGCWW/H2xvc4YAHjLfj7Xg73o432OdgvcF6g/UG3pgw+xzsc7DPgXfgHXgH3oF3sM+D9Q7WO1gvvbrz7Ycn+zzZ58k+06s7334Z78RLrxq9avSq0atGr+58+/Eu7i+9avSq0as7337Pg5deNXrV6FWjV41eNXrV6NWdbz/e5P7Sq0avGr268+3nPIWXXjV61ehVo1eNXjV61ejVnW8/3s39pVeNXjV6defb73nw0qtGrxq96vSq06tOrzq9uvPtj/fOt19ecMIF42146VWnV51edXrV6VWnV51e3fn2423v/e30qtOrTq/ufPs5T8dLrzq96vSq06tOrzq96vTqzrcfbwTMPtOrTq/ufPs9D1561elVp1edXnV61elVp1ed56vO81WnV51edXrVeb7qPF91etXpVadXnV51etXpVadXd779eBf3l151etXp1Z1vv+fBS686ver0qtOrTq86ver06s63H29yf+lVp1edXt359nOewkuvOr3q9KrTq06vOr3q9OrOtx9vcX/pVadXnV7d+fZzno2XXnV61elVp1edXgW9Cnp159sf751vvzzgCS84OU/BeOlV0KugV0Gvgl4Fvbrz7cfbEi743eegV3e+/Zyn46VXQa+CXgW9CnoV9Cro1Z1vP95oMPtMr4Je3fn2ex689CroVdCroFdBr4JeBb268+3HO7i/9CroVdCr4H0weB8MehX0KuhV0KugV0Gvgl7d+fbjndxfehX0KuhV8D5459sv46VXQa+CXgW9CnoV9OrOtx9vcn/pVdCroFfB++Cdb7+Ml14FvQp6FfQq6FXQqzvffrzF/aVXQa+CXgXvg3e+/TJeehX0KuhV0KugV0Gv7nz7473z7Zc7HPCAJ+dZcMIF46VXg14NejXo1Z1vP9424QUnXDDejpdeDXo16NWgV4NeDXo16NWdbz/e/t7fQa8GvRr0avA+eOfbL+OlV4NeDXo16NWgV4Ne3fn24x3cX3o16NWgV4P3wUGvBs9Xg+erQa8G74N3vv0yXno16NWgV4PnqzvfPn6+F3rn28d4uMEdDnjAE15wwgXvlxNv4k28iTfxJt7Em3gTb+ItvIW38Bbewlt4C2/hLbyFd+PdeDfejff0aqyHJ7zg482HC96/+c63X25w/32eO99+ecCT4xeccMF4G96Gt+FteBveNuEF4214G96Ot+M9vboc8IBZb8d7enW54P3y6dVlvIE38AbewBvsc7DeYL3Begfe06vL7PNgnwf7PPAOvAPvwDvwTvZ5st7JeifrnXgn93eyz5N9nuzzxLvwLrwL78K72OfFehfrXax34V3c32Sfk31O9jnxJt7Em3gTb7LPyXqL9RbrLbzF/S32udjnYp8Lb+EtvBvvxrvZ5816N+vdrJde3fn2y+zzfvf5zrdffr13vv1ywAOe8IITLvhd751vP97W4A4HPGC8DS+9WvRq0atFrxa9WvRq0as73368fcILTrhgvIGXXi16tejVoleLXi16tejVnW8/3uD+0qtFrxa9uvPt5zwDL71a9GrRq0WvFr1a9GrRqzvffryT+0uvFr1a9OrOt9/z4KVXi14terXo1aJXi14tenXn2493cX/p1aJXi17d+fZznsRLrxa9WvRq0atFrxa9WvTqzrcfb3F/6dWiV4te3fn2ex689GrRq0WvFr1a9GrRq0WvFs9Xi+erRa8WvVr0avF8lTxfJb1KepX0KulV0qukV0mv7nz7473z7YfpVdKrpFd3vv2cp+GlV0mvkl4lvUp6lfQq6dWdbz/eHvCAJ7xgvB0vvUp6lfQq6VXSq6RXSa/ufPvxRsLsM71KenXn2895Bl56lfQq6VXSq6RXSa+SXt359uOd3F96lfQq6dWdb7/nwUuvkl4lvUp6lfQq6VXSqzvffryL+0uvkl4lvbrz7ec8iZdeJb1KepX0KulV0qukV3e+/XiT+0uvkl4lvbrz7ec8hZdeJb1KepX0KulV0qukV3e+/Xg395deJb1KepW8Dybvg0mvil4VvSp6VfSq6FXRqzvf/njvfPvlgt99LnpVvA/e+fbLeOlV0auiV0Wvil4Vvbrz7cfbG9zhgAeMt+OlV0Wvil4VvSp6VfSq6NWdbz/emDD7TK+KXhXvg3e+/TJeelX0quhV0auiV0Wv7nz78Q7uL70qelX0qngfvPPtl/HSq6JXRa+KXhW9Knp159uPd3F/6VXRq6JXxfvgnW+/jJdeFb0qelX0quhV0as73368yf2lV0Wvil4V74N3vv0yXnpV9KroVdGroldFr+58+/Fu7i+9KnpV9Kp4Hyx6VTxfFc9XRa8274N3vv1yh4PjBzzhBR/vfvjxzvHwfvn06nKDOxzwgCe84ITxNrwdb8fb8Xa8HW/He3o1nzWeXl0+3np4v3x6dY45vbrcOSbgwTETfryrPYz39Ooy3tOry3hPry7jPb26jHew3tOrcw0D7+nV4Yn39Ooy3tOry3hPry7jnaz39Opcw8S72OeFd7HPC+9inxfe06vLeBfrPb0615B4k31OvMk+J95knxPv6dVlvMl6T6/ONRTeYp8Lb7HPhbfY58JbfD4X3s16T6/ONWy8m33eeDf7vPFu9nnj3b8/n+edb/85Zt759sv9cw3zzrffXx/w5DwLTo4pGG/7gvG2Dsd7DQ1vmzDeljDetl/ueHuD8XbWe3p1rqHjfXs173z7PU/BeIN9Drxvr+adb7/HsN7Tq3MNgTfY58Ab7PPAO9jngfft1bzz7fcY1jvWew0D72CfB97JPk+8k32eeN9ezTvffo9hvTPfa5h4J/u88C72eeFd7PPCu/h8XngX6131XsPCm+xz4k32OfEm+5x4k8/nxJusN/d7DYW32OfCW+xz4S32ufAWn8+Ft1jv/nqvYePd7PPGu9nnjXezzxvv5vN5v95Gr+58+3MNd7599Yd/P2/MO99+ecILTrjg/fL7fDXb+3w12/t8NVvD2/A2vA1vw9vwNrwdb3/3udGrO9/+7NWdb788OWbByTEFs8/06s63n30OvPTqzref88SE8dKrRq8avWr0qtGrO99+rmHgpVd3vv2eZ8F46VWjV41eNXrV6NWdbz/XMPHSqzvffs/DPtOrRq8avWr0qtGrRq/ufPu5hoWXXt359nse9pleNXrV6FWjV41eNXrV8v3z6M63319nnxNvss/0qtGrRq8avWr0qtGrO99+rqHw0qs7337Os9lnetXoVaNXjV41etXo1Z1vP9ew8dKrO9/+nOfOt1/uHBPw4JgJL45J+P3z6M63n19vXzDe1mG8PF/d+fZ7zILx8nx159vPNXS89OrOt5/z0Ks7336PmTBeenXn2+8xrDfeP4964KVXPfDSqx546dWdb7/HFIyXXt359nMNAy+96gMvveoDL7268+33mPfz+c63n2Po1Z1vP9cw8dKrPvHSqz7x0qs7336OoVd3vv0cQ6/ufPu5hoWXXvWFl171hZde3fn2cwy9uvPt9xjWm28ne+KlVz3x0queeOnVnW8/x9CrO99+j2G99XayF1561QsvveobL7268+33GD6fN156defbzzXcXvWH3+eNO9/+8J1vv9zgDgc84AkvOOH3/ga9Ct4Hg14F74NBr+58+z1mwotjEn47GbwPBr0K3geDXgXvg0Gv7nz7PWbBeOnVnW8/18DzVdCr4H0w6FXwPhj06s6332MSxkuv7nz7uQaer4JeBe+DQa+C98GgV3e+/R5TMF56defbzzXwfBX0KngfDHoVvA8Gvbrz7feY9+soFl56defbzzXwfBX0KngfDHoVvA8Gvbrz7ecYehWJl17d+fZzDTxfBb0K3geDXgXvg0Gv7nz7OYZeReGlV3e+/VwDz1dBr4L3waBXwftg0Ks7336OoVex8dKrO99+roFeBc9Xd7798vt1dOfbLze4wwGP3w288+2XF5xwwfvl06vLDe7w8cbDA57wghMueL98enW5wR0+3np4wMebDy84Oabg/R5zn68Ot/eY06vLjze/HsZ7v391GO/p1WW8p1eHB977fHUY72C9p1fnGgbe+/2rw3hPry7jPb26jPc+Xx3GO1nv6dW5hol3ss8T72SfF97FPi+89/nqMN7Fek+vzjUsvIt9XniTfU68yT4n3vt8dRhvst7Tq3MNiTfZ58Jb7HPhLfa58Bafz4W3WO/p1bmGwrvZ5413s88b72afN97N5/PGu1nv6dVzDXe+/fn1O99++fXe+fbLg2MmvDgm4eKYd713vv1cw+lVjoc7HPCAJ7zghAs+610/fHp1ucEdDnjAE15wwgXjPb2q9nCDO/x4qz/8eGs+POEFJ1zw461n/0+vaj/c4A4HPOAJLzjhx7vj4f3y6dV+ruf0aj/X8/Sqvp41Pr368IAnvOCEC94vP736cIPxLrwL78K78C68C+/Cm3gTb+JNvIk38SbexJt4E2/hLbyFt/AW3sJbeAtv4S28G+/Gu/FuvBvvxrvxbrwb7369Z7692nr48bb9cIcDHvCEF5xwwfvl9gXjbXgb3oa34W14G96Gt+HteDvejrfj7Xg73o634+14O97AG3gDb+ANvIE38AbewBt4B96B9+lV/fz8sXnm2z884AkvOOGC98tPrz7cYLwT78Q78U68E+/EO/EuvAvvwrvwLrwL78K78C68C2/iTbyJN/Em3sSbeBNv4k28hbfwFt7CW3gLb+EtvIW38G68G+/Gu/FuvBvvxrvxbrz79Z759g83uMMBD3jCC064YLwNb8Pb8Da8DW/D2/A2vA1vw9vxdrwdb8fb8Xa8HW/H2/F2vIE38AbewBt4A2/gDbyBN/AOvAMvvUp6lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdKrpFdJr5JeJb1KepX0KulV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdKrpFdJr5JeJb1KepX0KulV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0qm6v4uHH+/P//Z9nvv3y6dXlBj/eUQ8/3vn18IAf7zzHLDjhgh/v+nnnPfPtH25whx/v8/2QM9/+feTDE368GX/8+tP//Zd//PVf/vVvf/k/f/of///7P//Xf/37v/3nX//+7/c///P//cfnd/71H3/929/++r//+T/+8fd/+8v//K9//OWf//b3f/v5vT993f/5p+/Pof7r+xMm/vzrT99X90/7a8xf+2v9/Hc8vx/1/fujfn7/5wO+H8bbr+//WT+/8PMR39e9f30vuf35j+cU57zff0f36/vvqu5ZWsxfbczPOb7/YvLX918wfs7w/XeHv77/nvDn4/vn47//zvT5tfPx37dhff3+6Dl/9fOfz0d/f//8+292fz46fj765/j19St/H7/3r/b1nH38/P7za6P9Gr9XMPLX2D+/Pz8f//3bs30+/nuDZv789vr94d+vIv05Y/7+pT6+r/fnl+r9pfzegp9f2p9VfX+n+9d4xPEs5Ps0a38839/e//X9bfrfV/X9bvv93fZnV78+F/b9OT7i9weMe92tvVe2fvVzJ/rvj+m/Rv+9mO+Vref3473Onw388x9//PHnP/4b",
      "brillig_names": [
        "discover_new_messages",
        "build_msg_block",
        "attach_len_to_msg_block",
        "debug_log_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "get_l1_to_l2_membership_witness",
        "notify_created_nullifier_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_to_radix",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "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\n0wjG1j0HkTruZrSFZmQJ4zJievrMBCtdWDUY"
    },
    {
      "name": "claim_shielded",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17288131482828810359": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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OWWdU9Y5ZZ1T1jllnVPWeUwh8iOoJ3GSJGmSJXnSmHTW+U0tKT1Geoz0GOkx0mOkx0iPMT1iUtFNLYmSehInSZImWZInpUdLj5YeLT1aerT0aOnR0qOlR0uPlh6UHpQelB6UHpQelB6UHpQelB6UHj09enr09Ojp0dOjp0dPj54ePT16enB6cHpwenB6cHpwenB6cHpwenB6SHpIekh6SHpIekh6SHpIekh6SHpoemh6aHpoemh6aHpoemh6aHpoelh6WHpYepx17i2IkyRJkyzJk8aks85vakmUlB6eHp4enh6eHp4enh4jPUZ6jPQY6THSY6THSI+RHiM9xvSIiUs3tSRK6kmcJEmaZEmelB4tPVp6tPRo6dHSo6VHS4+WHi09WnpQelB6UHpQelB6UHpQelB6UHpQevT06OnR06OnR0+Pnh49PXp69PTo6cHpwenB6cHpwenB6cHpwekRdS5BY1LU+UWnhwdRUk/iJEnSJEvypDEp6vyi9ND00PTQ9ND00PTQ9ND00PSw9LD0sPSw9LD0sPSw9LD0sPSw9PD08PTw9PD08PTw9PD08PTw9PD0GOkx0mOkx0iPkR4jPUZ6jPQY6TGmR0yOuqklUVJP4iRJ0iRL8qT0aOnR0qOlR0uPlh4tPVp6tPRo6dHSg9KD0oPSg9KD0oPSg9KD0oPSg9Kjp0dPj54ePT16evT06OnR06OnR08PTg9OD04PTg9OD04PTg9OD04PTg9Jj6xzyTqXrHPJOpesc8k6l6xzyTqXrHPJOpesc8k6l6xzyTqXrHPJOpesc8k6l6xzyTqXrHPJOpesc8k6l6xzyTqXrHPJOpesc8k6l6xzyTqXrHPJOpesc8k6l6xzyTqXrHPJOpesc8k6l6xzyTqXrHPJOpesc8k6l6xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtes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uMPb+/0nNMqd3e7nJ5skvF4+vbpc4AoH3OAOb+/3J7eVO8V9eXvHvrbTq7Gv7fTqcoG3d+61n15dbnCHBzzhhNfLp1eXC4w38AbewBt4A2/gDbwNb8Pb8Da8DW/D2/A2vA1vw9vxdrwdb8fb8Xa8HW/H2/F2vAPvwDvwDrwD78A78A68A+/Ae3qV+2vp9Or7M9fLHf5ehwP+en++E7K5wwOem2Nzwmvzdu1ePVzgunluDrjBx7uvJwc84e2tuw+7V63ua9u9erjA21v3Z3D3qu3n4TMS/vD27vaeofCHt/f7407LGQtvu6VnLvzwGQx/uMAVDrjBHR7whBPGW/AWvAVvwVvwFrwFb8Fb8Ba8FW/FW/FWvBVvxVvxVrwVb8UbeANv4A28gTfwBt7AG3gDbzvevrnA29sPB9zgDg94wgmvl3evHi4w3o634+14O96Ot+PteAfegXfgHXgH3oF34B14B96Bd+KdeCfeiXfinXgn3ol34p14E2/iTbyJN/Em3sSbeBNv4l14F96Fd+FdeBfehXfhXXjX6z3D5w8XuMIBN7jDA55wwngL3oK34C14C96Ct+AteAvegrfirXgr3oq34q14K96Kt+KteANv4A28gTfwBt7AG3gDb+BteBteerXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXo1aJXi14terXeXtXP26v6eXtVP2+v6uftVf28vaqft1f18/aqft5e1c/bq/r54C14C96Ct+AteAvegrfgLXgL3oq34q14K96Kt+KteCveirfiDbyBN/AG3sAbeANv4A28gbfhvb2am7f3++5cz3z7ww3u8PZ+f+56PfPtD2/v9526nvn2n/8P2pdPry4XeHu//y5DPfPtD2/v3Oc8vbo84O2dey2nV5e3N9uXT68uF3h790/RPvPtD29v7ms7vVr7ek6vLm/v2vtwenV5e9e+htOrywXe3rX3/PTq8tfbP/sadq8eHvDcvK9t9+rhr7eXfW27Vw+XP91/Iqye+faHA97e77tbPfPtD29v3Xu1e9Xrvobdq4fXy7tXve7r2b16eHtjn3P36uEGb2/se7p79fD2tr23u1cPr18+8+39+6Pe65lvf3h7v//uQj3z7T//n6DNDd7e7/e+6plvf3h7e2xOeL28e9X35+jMtz+8vWNfw+7Vww3e3v0ZOfPtD2/vOD9ONuHtnd+vkzPf/nCBt/f7b8rVM9/+8Pbur/kz3/7wgCe8vbnXsnt1efeq5/mhttu7Pwtnvv3hgLd3fy7OfPvD27vOOSec8Pbuz8WZb3/46x37s3Dm2x8OuG0+P3G3w1/v2J+LM9++/0GzeubbH16b9z7sXj28vWVfw+7VwwFv7/5Mnfn2h7e3nh/7O+GEtzf2te1ePby9sa9t9+rh7f3+Kwn1zLc/3OHtbftrdffq4e09n4vdq3E+C7tXDxd4e8/nYvfq4e09n4Xdq4cHvL3nc7F79fD2ns/C7tXDBd7e87nYvXp4e8/nYvdq7L8vznz7w9s7917tXj28vfvviDPf/nCBt/d8pnavHt7e/XfEmW9/eMDbez4ju1cPb+/+XJz59oe3d/+02jPf/nDAX+/8/ky7eubbHx6bY/Pc3Dbn5r55vbx7Nfdn5My3P1zhgI93bu7wgI93/+DokvB6efdq7s/RmW9/uMIBN7jDA55wwuvlwBt4A2/gDbyBN/AG3sAbeBvehrfhbXgb3oa34W14G96Gt+PteDvejrcf777XvcMDPt59r3vC6+XxgQtc3/OMgPGOzvEDxjvwDrwT78Q78U68E+9kvZP1TrwT78SbeBNvVjjgBrPexJsTTni9vD4w3oV34V14F97FPi/Wu1jvetd75tuP98y3P1zhgBvcOc+AJ5ww3vKBC1zhgPGWDg94wgnjrXgr3oq34q0NZr2V9VbWW/HW9/5GsM/BPgf7HHgDb+ANvIE32OdgvY31Ntbb8Dbub2OfG/vc2OeGt+FteDvejrezz531dtbbWS+9is797exzZ58H+0yvYuAdeAdeehX0KuhV0KugVzHxTu4vvQp6FfQqJt6Jl14FvQp6FfQq6FXQq6BXkXiT+0uvgl4FvYrEu/DSq6BXQa+CXgW9CnoV9CoW3vXe30avGr1q9Kp9Xm/7NLjDA55wwu96G71q9KoVvCXgBnd4wHgLXnrV6FWjV41eNXrV6FWjV63irRNOmH2mVy3wBl561ehVo1eNXjV61ehVo1et4W3cX3rV6FWjV63hbXjpVaNXjV41etXoVaNXjV41nq8az1eNXjV61ehV4/mq8XzV6FWjV41eNXrV6FWjV41etYF3cH/pVaNXjV61iXfipVeNXjV61ehVo1eNXjV61RJvcn/pVaNXjV61xJt46VWjV41eNXrV6FWjV41etYV3cX/pVaNXnV71z+vtnwoH3OAOD3jCCb/r7QVvKXCFA24w3oKXXnV61elVp1edXnV61elVr3hrhwc84YTxBl561elVp1edXnV61elVp1c98Ab3l151etXpVW94G1561elVp1edXnV61elVp1e94+3cX3rV6VWnV533wc77YKdXnV51etXpVadXnV51etUH3sH9pVedXnV61Xkf7BMvver0qtOrTq86ver0qtOrnniT+0uvOr3q9KrzPtgTL73q9KrTq06vOr3q9KrTq77wLu4vver0qtOrzvvg+HzgAlc44AZ3eMATfr3j897fQa8GvRr0avA+OApeejXo1aBXg14NejXo1aBXo+KtATe4wwPGW/HSq0GvBr0a9GrQq0GvBr0agTcmzD7Tq0GvBu+Do+GlV4NeDXo16NWgV4NeDXo1Ot7O/aVXg14NejV4Hxz0avB8NXi+GvRq8D44Bl6+fzXo1aBXg14Nnq/G7dXavL3fech65tsvn15dLnCFA25whwc8YbwTb+JNvIk38SbexJt4E2/iTbwL78K78C68C+/Cu/AuvAvver1nvv3hAh9v2xxwg4+3bx7whBNeL59enfOcXl3Ge3p1j28w3oK34C14C96Kt+KteCvrray34q14K96Kt+I9vbpc4Aqz3sB7enV5wBNOGG/D2/A2vA1vY58b622st7Hehvf06nBnnzv73Nnnjrfj7Xg73o63s8+d9Q7WO1jvwDu4v4N9HuzzYJ8H3oF34J14J97JPk/WO1nvZL0T7+T+TvZ5ss/JPifexJt4E2/iTfY5WW+y3mS9C+/i/i72ebHPi31eeBfehXfhXa83Px+4wBUO+PXmp8MDnnDCeAvegrfgpVdJr5JeJb1KepUFb3nvb9KrpFdJr7LirXjpVdKrpFdJr5JeJb1KepWBNwJmn+lV0qsMvIGXXiW9SnqV9CrpVdKrpFfZ8DbuL71KepX0KjvejpdeJb1KepX0KulV0qukVznwDu4vvUp6lfQqB96Bl14lvUp6lfQq6VXSq6RXOfFO7i+9SnqV9Con3sRLr5JeJb1KepX0KulV0qtMvMn9pVdJr5Je5cK78NKrpFdJr5JeJb1a9GrRq8Xz1eL5atGrRa8WvVo8Xy2erxa9WvRq0atFrxa9WvRq0atV8JYJJ/zu86JXq+KteOnVoleLXi16tejVoleLXq3AGwVmn+nVolcr8AZeerXo1aJXi14terXo1aJXq+Ft3F96tejVoler4e146dWiV4teLXq16NWiV4terY63c3/p1aJXi16tgXfgpVeLXi16tejVoleLXi16tSbeyf2lV4teLXq1Jt6Jl14terXo1aJXi14terXo1Uq8yf2lV4teLXq1Ft6Fl14terXo1aJXi14terXeXsXn8+uNz6fAFQ64wZ3zDHjCCeN9exWft1fxeXsVn7dX8Sl4S4cHPOGE8Va8FW/FW/G+vYpPZb2V9VbWW/HW9XKwz8E+B/sceANv4A28gTfY52C9jfU21tvwNu5vY58b+9zY54a34W14O96Ot7PPnfV21ttZb8fbub+dfe7s82CfB96Bd+AdeAfewT4P1jtY72C9E+/k/k72ebLPk32eeCfeiXfinXiTfU7Wm6w3WW/iTe5vss/JPif7nHgX3oV34V14F/u8WO9ivYv1Lrzrvb+FXhV6VehVed8Ho9Cr8j5fRXmfr6LQq/K+D0b54C146VWhV4Velff5Ksrt1dy8vd955jjz7Q8nvF4+vbpc4AoH3OAO4614K96KN/AG3sAbeANv4A28gTfwBt6Gt+FteBvehrfhbXgb3oa34T29+s6Tx5lvf7jCxxubG9zhAU84Oc96eeA9vTrHn15dxjvwDrwD78A78A68E+9kvZP1TrwT78Q78U68p1eX18unV5dZb+I9vbrc4A4PGG/iTbwL78K72OfFehfrXax34T29usw+r3efz3z7w6/3zLc/HHCDOzzgCSf8rvfOtx9vKXCFA24w3oK34C14C976gVlvZb2V9Va8tcMDnnDCeANv4A28gTfY52C9wXqD9Qbe4P429rmxz419bngb3oa34W14G/vcWG9nvZ310qs7336Zfe7sc2ef6dWdb7+Md+ClV5VeVXpV6VWlV3e+/XgH95deVXpV6dWdbz/nmXjpVaVXlV5VelXpVaVXlV7d+fbjTe4vvar0qtKrO99+z4OXXlV6VelVpVeVXlV6VenVnW8/3sX9pVeVXlV6defb93nufPvlAlc44AZ3eMATfr13vv0wvQp6FfTqzref8xS89CroVdCroFdBr4JeBb268+3HWwNucIcHjLfipVdBr4JeBb0KehX0KujVnW8/3pgw+0yvgl7d+fZznoaXXgW9CnoV9CroVdCroFfB81XwfBX0KuhV0Kvg+Sp4vgp6FfQq6FXQq6BXQa+CXt359uMd3F96FfQq6NWdbz/nmXjpVdCroFdBr4JeBb0KenXn2493cn/pVdCroFd3vv2cJ/HSq6BXQa+CXgW9CnoV9OrOtx/v4v7Sq6BXQa/ufPs9D1561ehVo1eNXjV61ehVo1d3vn1773z75YTffW706s63n/MUvPSq0atGrxq9avSq0atGr+58+/HWAlc44AbjrXjpVaNXjV41etXoVaNXjV7d+fbjjQ6zz/Sq0as7337O0/DSq0avGr1q9KrRq0avGr268+3H27i/9KrRq0avGu+DjffBRq8avWr0qtGrRq8avWr06s63H+/g/tKrRq8avWq8D9759st46VWjV41eNXrV6FWjV3e+/Xgn95deNXrV6FXjffDOt1/GS68avWr0qtGrRq8avbrz7ce7uL/0qtGrRq8a74N3vv0yXnrV6FWnV51edXrV6dWdb9/eO99+ecATThhvwUuvOr3q9KrTq06vOr3q9OrOtx9vee9vp1edXnV61XkfvPPtl/HSq06vOr3q9KrTq06v7nz78UbA7DO96vSq8z5459sv46VXnV51etXpVadXnV7d+fbjbdxfetXpVadXnffBTq86z1ed56tOrzrvg3e+/TJeetXpVadXneerO98effPx5uYOD3jCCa+Xb68OF7jCAeOdeCfeiXfinXgTb+JNvIk38SbexJt4E2/iXXgX3oV34V14F96Fd+E9vWqfzeuX73z75e39/jyNuPPtlwNucIcH55lwwus9/vTqMt6Ct+AteAvegrfgLXgL662st+KteCveirfiPb26POGEWW/gPb26XOGAG4w38AbewBt4G/vcWG9jvY31NrynV5fZ58Y+N/a54e14O96Ot+Pt7HNnvZ31dtbb8Xbu72CfB/s82OeBd+AdeAfegXewz4P1TtY7We/EO7m/k32e7PNknyfeiXfiTbyJN9nnZL3JepP1Jt7k/ib7nOzzYp8X3oV34V14F97FPi/Wu1jvetc76dWdb79c4YAb3DnPgCecMF56NenVpFeTXt359uMtHR7whBPGW/HSq0mvJr2a9GrSq0mvJr268+3HW9/7O+nVpFeTXs3AG3jp1aRXk15NejXp1aRXk17d+fbjbdxfejXp1aRXd779ngcvvZr0atKrSa8mvZr0atKrO99+vJ37S68mvZr06s63n/MMvPRq0qtJrya9mvRq0qtJr+58+/FO7i+9mvRq0qs7337Pg5deTXo16dWkV5NeTXo16dWdbz/e5P7Sq0mvJr268+3nPAsvvZr0atKrSa8mvZr0atKryfPV5Pkq6VXSq6RXyfNV8nyV9CrpVdKrpFdJr5JeJb268+3HWwJucIcHjLfgpVdJr5JeJb1KepX0KunVnW8/3jrhhNlnenXn2895Ai+9SnqV9CrpVdKrpFdJr+58+/E27i+9SnqV9OrOt9/z4KVXSa+SXiW9SnqV9Crp1Z1vP97O/aVXSa+SXt359nOegZdeJb1KepX0KulV0qukV3e+/XgH95deJb1KenXn2895Jl56lfQq6VXSq6RXSa+SXt359uNN7i+9SnqV9OrOt9/z4KVXSa+SXiW9SnqV9Crp1Z1vP97F/aVXSa8WvVq8Dy7eBxe9WvRq0atFrxa9WvRq0as73368pcAVDrjBeAteerXo1aJXi14terXo1aJXd779eGuHBzzhhPEGXnq16NWiV4teLXq16NWiV3e+/XiD+0uvFr1a9GrxPnjn2y/jpVeLXi16tejVoleLXt359uPt3F96tejVoleL98E7334ZL71a9GrRq0WvFr1a9OrOtx/v4P7Sq0WvFr1avA/e+fbLeOnVoleLXi16tejVold3vv14k/tLrxa9WvRq8T5459sv46VXi14terXo1aJXi17d+fbjXdxferXo1aJX630fbJ+3V+3zPl+1z/t81T5vr9rnfR9sd7798oAnxyeM932+ane+/fvzZtudb//+vNl259svN7jDA55wwuvl26vDBcZb8Va8FW/FW/FWvBVv4A28gTfwBt7AG3gDb+ANvA1vw9vwNrwNb8N7e5WbJ5zw8a4v314dLnCFA27veW6vDuO9vTrHJ4x34B14B96Bd+AdeAfewXoH6x14J96Jd+KdeG+vDnd4wKx34r292nx7dbjAFcabeBNv4k28yT4n612sd7Hehff26jD7vNjnxT4vvAvver13vv1ygSsccIM7/HrvfPvlhN99vvPtl/EWvAVvwVvwlgFPOGHWW/HWAlc44AbjrXgr3oq34g32OVhvsN5gvYE3Osw+B/sc7HPgbXgb3oa34W3sc2O9jfU21kuv7nz74c4+d/a5s8/06s63X8bb8dKrQq8KvSr0qtCrO99+vIP7S68KvSr06s633/PgpVeFXhV6VehVoVeFXhV6defbj3dyf+lVoVeFXt359nOexEuvCr0q9KrQq0KvCr0q9OrOtx/v4v7Sq0KvCr268+33PHjpVaFXhV5VelXpVaVXlV7d+fbtvfPtlwc84YTxFrz0qtKrSq8qvar0qtKrSq/ufPvxlvf+VnpV6VWlV3e+/Zyn4qVXlV5VelXpVaVXlV5VenXn2483Amaf6VWlV3e+/Z4HL72q9KrSq0qvKr2q9KrSq8rzVeX5qtKrSq8qvao8X1Weryq9qvSq0qtKryq9qvSq0qs73368g/tLryq9qvTqzrff8+ClV5VeVXpV6VWlV5VeVXp159uPd3J/6VWlV5Ve3fn2c57ES68qvar0qtKrSq8qvar06s63H29yf+lVpVeVXt359nOehZdeVXpV6VWlV5VeBb0KenXn27f3zrdfbnCHBzw5T8J46VXQq6BXQa+CXgW9uvPtx1smnPC7z0Gv7nz7OU/FS6+CXgW9CnoV9CroVdCrO99+vFFg9pleBb268+33PHjpVdCroFdBr4JeBb0KenXn24+3cX/pVdCroFfB+2DwPhj0KuhV0KugV0Gvgl4Fvbrz7cfbub/0KuhV0KvgffDOt1/GS6+CXgW9CnoV9Cro1Z1vP97J/aVXQa+CXgXvg3e+/TJeehX0KuhV0KugV0Gv7nz78Sb3l14FvQp6FbwP3vn2y3jpVdCroFdBr4JeBb268+3be+fbL1c44AZ3zjPgCSeMl141etXoVaNXd779eEuHBzzhhPFWvPSq0atGrxq9avSq0atGr+58+/HW9/42etXoVaNXjffBO99+GS+9avSq0atGrxq9avTqzrcfb+P+0qtGrxq9arwPNnrVeL5qPF81etV4H7zz7Zfx0qtGrxq9ajxf3fn2/v1e6J1v721zgSsccIM7POAJJ7xenngn3ol34p14J96Jd+KdeCfexJt4E2/iTbyJN/Em3sSbeBfehXfhXXhPr/rY3OEBH+/cnPD65TvffrnA9fc8d779coM7xw94wgnjLXgL3oK34C14S4cHjLfgLXgr3or39OpywA1mvRXv6dXlhNfLp1eX8QbewBt4A2+wz8F6g/UG6214T68us8+NfW7sc8Pb8Da8DW/D29nnzno76+2st+Pt3N/OPnf2ubPPHe/AO/AOvAPvYJ8H6x2sd7DegXdwfyf7PNnnyT5PvBPvxDvxTryTfZ6sN1lvst7Em9zfZJ+TfU72OfEm3sS78C68i31erHex3sV66dWdb7/MPq93n+98++XXe+fbLwfc4A4PeMIJv+u98+3HWwpc4YAbjLfgpVeDXg16NejVoFeDXg16defbj7d2eMATThhv4KVXg14NejXo1aBXg14NenXn2483uL/0atCrQa/ufPs5T8NLrwa9GvRq0KtBrwa9GvTqzrcfb+f+0qtBrwa9uvPt9zx46dWgV4NeDXo16NWgV4Ne3fn24x3cX3o16NWgV3e+/Zxn4qVXg14NejXo1aBXg14NenXn2483ub/0atCrQa/ufPs9D156NejVoFeDXg16NejVoFeD56vB89WgV4NeDXo1eL6aPF9NejXp1aRXk15NejXp1aRXd759e+98+2F6NenVpFd3vv2cp+ClV5NeTXo16dWkV5NeTXp159uPtwbc4A4PGG/FS68mvZr0atKrSa8mvZr06s63H29MmH2mV5NezYa34aVXk15NejXp1aRXk15NenXn24+3c3/p1aRXk17d+fZ7Hrz0atKrSa8mvZr0atKrSa/ufPvxDu4vvZr0atKrO99+zjPx0qtJrya9mvRq0qtJrya9uvPtxzu5v/Rq0qtJr+58+zlP4qVXk15NejXp1aRXk15NenXn2493cX/p1aRXk15N3gcn74OTXiW9SnqV9CrpVdKrpFd3vn1773z75YTffU56lbwP3vn2y3jpVdKrpFdJr5JeJb268+3HWwtc4YAbjLfipVdJr5JeJb1KepX0KunVnW8/3ugw+0yvkl4l74N3vv0yXnqV9CrpVdKrpFdJr+58+/E27i+9SnqV9Cp5H7zz7Zfx0qukV0mvkl4lvUp6defbj3dwf+lV0qukV8n74J1vv4yXXiW9SnqV9CrpVdKrO99+vJP7S6+SXiW9St4H73z7Zbz0KulV0qukV0mvkl7d+fbjXdxfepX0KulV8j6Y9Cp5vkqer5JeLd4H73z75QoHxze4wwM+3rV5e0fbvF4+vbpc4AoH3OAOD3jCeAveirfirXgr3oq34j29GnuNp1eXjzc3r5dPr84xp1eXK8cE3Dimw9s7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06vc13N6dXl7c+/D6dXl7c19DadXlzu8vbn3/PTq8vaufQ2nV4dPry5v79rXdnp1+cdbf54KNje4f/n7vvbDA55wbq6b18vfXv3w3qtvr354X8O3V78c8PaWfT3Z4e2t55wTTnh7676n6wNvb+y9XRUOeHtjX+fq8PbGvra1vbGvZyW8vd/vCYw93/7L29va5goHvL37c7Tn2395e3vfPOGEt3d/RvZ8+y9v7/5c7Pn2X97e7+zZ2PPtv9zh7Z2fzRPe3v01v+fbH64fuMDbO/daasDbuz8Xe779Z0F7r+qAJ7y9+3Ox59sfju3dn4U93/7LFd7e/bnY8+2/vL37s7Dn2395wtu7Pxd7vv3hb69+Nntf27dXP7yv59urX47Nex++vfrlvnlfw7dXvzzhr7fsz9Seb3+4b+/+LOz59l+u8PbWfW29wdtb97X1AW/v99+gH3u+/ZfXy2N7Y3+tjgJv7/5c7Pn2H97XMBrc4e09n4sx4e09n4WxXp4feHvP52JWeHvPZ2H36uEOb+/5XOxePby953Oxe1X23xd7vv2Xt3fsvdq9enh7998Re779lzu8vecztXv18PbuvyP2fPvDu1cPb+/5jOxePby953Oxe/Xw9q79dbJ79fCEt3fte7p7dXjPt/9w27y93xmesefbf3hsDnh792dkz7f/8oAnfLy5eb1cPvDxrs1fb/2cX/966/d7fWPPt/9y37zPv3tVy/mzE/56f060eb28e1X33xd7vv0nTufXKxxwg7d3f83v+fZfnnDC29v2n929qm1f/+7Vw9vb+t//+NP//qe//eWf/vmv//q//vTf/u/P//wf//Vv//Kff/n3f7v/8z//z388v/PPf/vLX//6l//5j//xt3//l3/97//1t3/9x7/++798f+9Pn/t//uHne/T1j59vyMef//jTj+0ffr7v2P/4+Sbj93/H/v3In99v+f397x8Y7ed7sD//Z3x/4fsnfr6zvP74+ZZy+fPf9ynOeX++Rv742at7lp8nvz9+nsKec/x8MP74+QJ/zvDztfvHz9fp98/X58//fGb3r50/3z9/jM/vn/75wNbzP/ef/vkM/pTl+6fj+6e/x/98W3z+Hv/z9fLztP/9/fb9/f1rP01pvyto84+2vr/fnz//89u9PH/+Z4P6/P72+P3jP186dZ9x/v7SzxNE3SfJ95fmzxZ8f2k9q2q1/9G2OPZCfk4z1uNpP98wb6X+XtXP96Jbyb2rn+fCfp5BWvz+gXavu5T3ysYf9dyJ+l5H/hF7f8rvBv00u9XfBf6sduzffzfoZwdH/73F8488ov7/OcG7RfV7V/7897///c9//38=",
      "brillig_names": [
        "discover_new_messages",
        "build_msg_block",
        "attach_len_to_msg_block",
        "debug_log_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "get_l1_to_l2_membership_witness",
        "notify_created_nullifier_oracle_wrapper",
        "storage_read",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_to_radix",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "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\n0wjG1j0HkTruZrSFZmQJ4zJievrMBCtdWDUY"
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "l1_portal",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_contract_class_id",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::contract_class_id::ContractClassId",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "shield_gateway",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "3263449651635518104": {
            "error_kind": "string",
            "string": "Shield gateway address cannot be zero"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "8459146718181593566": {
            "error_kind": "string",
            "string": "L1 portal address cannot be zero"
          },
          "8606784891595333955": {
            "error_kind": "string",
            "string": "Token contract class cannot be zero"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tZvbbhRJDIbfZa5zUQfXwbwKQihAWEWKAsqSlVYo7762q2xPsqrS0AM39Neerr/tKtexyc/Tl7tPz399vH/8+u3v07v3P0+fnu4fHu7/+vjw7fPtj/tvj2T9eQr8T8z19A5uThHi6V3jaxnXEuZ13td5X+d9S6d3na49zCvMK44rznvsck0hzyvdx0AQ64QUFUg6ZgackEFBLaAWUEthHYogVVDoE1pWaBN6UmBLJcAyIIegwDrI0CfErKCWpJakFq7HRFFk9nAA/ZQSQckKbKG355oU2oSmlsY6VMGZK3ZAmYBqwWmBEBRYmdyAmBTaBK7enBjqhBwUygRQC6ilqKWAQp9Qs0KbwM4P0Fd0fWlXQc4LAZyCJbCFWrCIP8DAP1GSFE46Ac66AfoTN64AN+4AtXDjDqgTUIujFsf5cA1JoU2IUWG+vaagAApaPGcFLQ5aHObbq9QhMoACTmhq4aYEypbGTTkAFPoEbtMBdULSh5MWz2rJWjxz8UgASYGLU7Y0bjgBbrgB+hNn3YAyAdXCdTigD+ghKcziPQYFUMAJ3GUGzLf3rMWzFgctDkVBixctXvTt3ImgM7QJTS0SDoOEIwAKfQLqwzgfxhAV1BKDQlHACRKOwHw7Zi2e9eGsDwMoqKVo8TL9QQ0Hq7696dubFm/6cNeHu75dw0EJh1IrBolnUDFCJR7UJjWlZCWSqWSzZVPhwEpg4sgGlWREeiUx8WRRChPHUpoQ23hmCNw4k7oSkleVVSJ7X6MQKrGngxK9rfI7Imf+pK7EmT6osAoIsQr7EjlfBrEvg9iXxiUSv3dSVYr2K+f1JFRKZuPhYRDn9iRTAVMBKwFWgjNiUlOq5ks1lWYqzVSa+dJNpZsKmi+cG42GXKq0aGQ2iXIQGHUlrvFJViJbCc6NQWA2MBVO+0HFbMWUqylXU26m0qxEsxIS5SCzSZQg1CaBRDmoGKES94BJViIlI7NlU5EoZZXEPaBznQJHOakrcV+Y1JSq2TjKQRzlJFNpptKtRLcSGI2KkfpSAhipSonJSH0pKRqpiszCk1glC6ESZKOmxH1rUjGyEtVK8JQ9qJmtmYpEOagq8ZwzyXxBVZGpe5KWkMl7ktlSMCpG6p/M4JPUF5nDJ1kJsBIFjMwmUYJQV5Kl8aCqJMvkQWBkJdBUUG0tJCNWkTU399BJRSmZLZktm03aclBXkrYc1JQkYwfZ23j0GSRx8MjfuG8hRy6TP1YhtvFznXMNZRfAuYZconOPmmS2LEv+KMgL8cAjfuf6pZlHEA2rW2VhH+TtsrSf2Ax7dCyOaIheDK0YciiKbo0mhrLKD9wYmGXbwnMGQnR0K6/6FMGwJsPmD/D8k0VWFsyDuhI7OwkHpcA9fJLZYlZq8pYqWA1HrQx0K7oVzRplFzTRrTE6NsOUHKWCGmNOjs0Q3ApuLW6VbdzA6tbqz44WH+hv6+CIijI3R9neJdmpRbFK1k1EQ9lRTmTd2GUrmh2bYY2OxRENmxdrLtbd2l0MXQxdDE0sh+xoxXKMjmJFRtk7D8yS+fKAhBnEOmpdsBTDGhzBUVznLXmWSo1RtuDZsSnKFKtYDKM9K/tPRW7jmBglSyai4WgLQelGE4thdav4O44CJO0nNkMZAeZZQXD0YtgVSzCFMuoXBKthCo7g2A1HQAO9GLgYuLW4WHGx4mLSA2IR7IatGPbgWA1HbAO71nodsQ2shtGssiWKfGSRkAcVWtoyShNObIbS5ydWzTPMwdGyD8Gt4Nbi1uLW6tbqus2tDRy7oZznTPRi6MWkZ43YpGfJOUwYAQlKenJAWfY8E7NbJaCJopDljAgc3SqjhhzjBGnNgdKaE/0VLTmioYxnAyWKiebDGKAngmM3jMnR3hbTUHh5uTnpIeDHH093d3wGeHYqSGeF32+f7h5/nN49Pj883Jz+uX14lof+/n77KNcft0/0K9Xo3eMXupLg1/uHO6aXGy8d1kVpy8EHU1KcNxhgEuT7K5G4ESm89hgatORziYCvJNJago6k2pSgAcIlWnmlkNcKnY7SpkIHWCrswqjZqqL2tAyjrCVozItTggak7BL1tRd140XnZc7wgg5alhIXe1GXEhfXBS7rAtcSrWoctGQ1Abg8q1qyimitLV2IG42cmqZVps3wuiY2qUmLmaS1SRPkWuNiP/KhFjmvjvN++rY6yh9skg7Bc3Pd0XkFt9IouakTtKVNy37aN27Q+ZYmOHFdi+z8gGx+0GnBMQnehqgEriTSpkYram7RWbMJ0ILq8iap3iQ9rsfezdCJRYdvRFdI/XIFWi9ZZdawrolNbvbYtTJ7OmuPt/NQqr8hMbaOJD79HI7QGmDtSP+zGrSK0jqlFYyPXf21RA67OuVAhxt0nGEStMp5rRF3SR49yc+mNDr3u1yjBM0wwnZQI3bTyHGtsa2PZvVB++R1fezGULRYGp7Nz//T2ORpLtrr4Wy5RBvS1wptNymhTfHprMP9kkbKrgHpmEaLWhu03w5Ljf3g0YINHjEcWbn1mHwQXM+NsJnmaSOi+UVH7huNfH1+AVyfX1CuzS+o1+fXViN1XUPSoUk6pnFhfm2Tw7YWdGKY14uWjQRtXdWLENeTbNmNXxls/Mo1L6fZjUQKtsVJ4XyKfOvGrrMF72yhLZc9BXY7LavQXmI60F+T97V0PrX9L5B67aJl36jgTqwbNex6SbAGoWNLkyivl29ls0uiGdo2WvQR0QPBi/fw1D/RvcCVF9s4bE2ezsetX1BIllZ0bLpUqPn6DrL1oqJ7AUfiyNBszGrrOHaTew5ne72zieRNi9bdtFptHUtJgWuNfv1kVPH6yaiFayejFq+fjLYaF05GW40LJ6N9dti4lXnpumrZtpne6XjHqrTlthqA2270rFH7K1ZYjuHbSKBoq1CnietItjv5DGf7tbMaja81fkOO9qtztP+GHO2/IUf7n85RCMVaNq9btu920TlE2wGfLZneJFjfdhWwDTA10DI5tm6k6qcKfXkq3Psuv2xyJISVxPaQPfv+hKaEsjwPwI1KaTo91rBerWC8+pAd09Wn7Ls4fOSpeX3IjnD1+Ifl6vFvlxc92FePHkM9JtHjtRLybW1KxHbMi9pcYn0SGnYpzv+zSFM8bo4At4cJ2T59pPMx49cONS4bQ/dHTXZsRkdN4eBxlc1s9F15fWy26/D2Za5sBvKdgHX3GssRgRiSjVuhHpOINmDQ9/R+TKKaF/TZ4ZBE9jOAjMe8KMkCKdCOSdj2JJaOxwIJ/rk2HQskg625cjkUyKWLjJ0X1b9b1HYskNb8iximQxLo1YnpkEQD+4ID9YgAgg42WA7VA9p+E9MxD6x/YStXhvBW4APd3n6+f3r1504vLPV0f/vp4W7efn1+/Hz2649/v+sv+udS35++fb778vx0x0r+N1P0z3vqjjc0/Xy4OfH/yXwP9CWWlvF8G+m20mBeU/vwws78Bw==",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "get_config_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6006283915776163582": {
            "error_kind": "string",
            "string": "Function get_config_private can only be called statically"
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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bL7+gRcJ7v+c14vcbL67RbbN1z/wIkE93h4y8M1y3Gu+erz/IsF26IIJzWeb+dW2RRrfgGrLjBY/LBKfxHgUeXVJeszlnQ95PuHifurHarEkdfmAwA+nT2X24l9uUfywCpO5nL/taZXd3nowlfTRn89te00r/3xHOdhRlk+WtNsT5NYSkwbVdZ71/2I5dgNcGMxh6zc/vs48XNNutBxHC8nLKmm/Lcn2RlbEa14/qvN7ke2lVouZ7x7cnn+i61Fndy/r5qc3kn+J+WmVm9+9+KbKzU9ffLdmesy4+OBfplz8umZk+7hOmGR6mWP696XZvbN1f83crbL7lsY3VW6v3+16EV0mbtytl207SkS/rd/l+K0dt1MURt6uX4FIen+ieInPnOgaCh4t/+Pxf//8T3/5+z/+9V/+6c//9pd/+du/nn8z9fNfn8koR1ByemwikaDs9Fh6KU6PRZXqsf1YuaJ+RDrJgtpJ50qTPikfQcnpkStZgrLTo3IuQTXIHedpS7agFuSOc0OXIygFuePcmYo75LEEpQTVIHecA4yLO85ZSksLcsc5PVM9gi7HY71Ud5xvsdQcVIJqkAZZUAvqk/QISkHh0HBoODQcGg4Nh4ZDw2HhsHBYOCwcFg4Lh4XDwmHhsHC0cLRwtHC0cLRwtHC0cLRwtHC0cPRw9HD0cPRw9Mvx2Fq9BrnjvMPWLagF9UnpOMAECpjBAlZQQQMbiC1hS9gStoQtYUvYEraELWFL2ASbYBNsgk2wCTbBJtgEm2DL2DK2jC1jy9gytowtY8vYMraCrWAr2Aq2gq1gK9gKtoKtYKvYKraKrWKr2Cq2iq1iq9gqNsWm2BSbYlNsik2xKTbFptgMm2EzbIbNsBk2w2bYDJtha9gatoatYWvYGraGrWFr2Bq2jq1j69g6to6tYyNIEkmSiJJElghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClsjIkn6i286v+8iVJRf2ifnKkgvddj4WzVeWXOi280PB+cqS86tj+cqSCxV02/lZo3xlyYVuO7+/ka8suTCBbjM7MYNuOy8f8pUlFyrotvNaIl9ZcqHbzttB+cqS88M6+cqSC912fuImX1lyodv6Kb6y5EIF3XZ+BCFfWXLhacvnTbfsWTIwgactnx+KyJ4lA4vjuTieJQNPm39cKnuWDGyg285rjexZMtBt5wV69izJ4hdBGSyg285p3bNnyUC3ZS/WwB7oWZLPRwzZs2Sg286hTtmzZGAB3XY+t8ieJQPdVvz6zG3nFMrZs+RCzxKfOzl7lgx02zmdb/YsGVhAt50dkD1LBrrtnIQpe5YM7IGeJdl3cM+SgW7zvdqzZKDbzC8jK6ig287vmGXPkoFu853Ws2RgAgV023mtnD1LBrrN92rPkuy7smfJwAa6zfdqz5KBbvNd2bNkYAbd5nt1r+BpK74re5YMbOBpK+deXTxLBqY/jacexbOknHcSi2fJwOKoJ1bQbeclefEsGdhAt13X5wfotnNXLp4lAzPoNr8M9ywZ6LZz/oniWTLQbefEFsWz5ELPkoFuO68Ii2fJQLede3XxLCnnrlw8SwYq6LZzry6eJQPddu7KxbNkYALddu7VxbNkoNvOXbl4lgxU0G3nXl08Swa67dyri2dJObO6eJYMdNs5zrB4lgx02xnQxbNkoIJuO5uheJYMdNsZ0MWzZGAC3Xbu4MWzZKDbzr26eJYMPG31vE1UPEsGNrA7+j2ZA0yO55r0LKnnU4HiWVLPV3OKZ8nA6ngumSpoYAMv2/kz7QAT6DbvC8+SgQV0mzgq6Lbz0VLxLBnoNh9f8f/+/Pe//Pl//vWf//VxL+68Xffvf/uneWvu8X//7f/7v/Pf/M+//+Wvf/3L//nH//v3f/mnf/5f//73fz5v4/kdvGP8z39vZ8i2R9b9j8e1xuP/9+OxVz+em5z/P/u/z+3x70s7//35F/R8NePxP3r+g/NvNH08427a03mvMPntwfO/e9znKvHfPG6ZlH7+ezn/fb7+dU2z5mMRqp3/Osdff3S9lPMflfhHjzts4kUq/8j+Icv5j3TWfTR4kaj7kOj/+M/zNub/Dw==",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "get_config_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "config::Config",
            "fields": [
              {
                "name": "l1_portal",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::eth_address::EthAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "shield_gateway",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "token_contract_class_id",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::contract_class_id::ContractClassId",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "2550444873539515884": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15520311074722577191": {
            "error_kind": "string",
            "string": "Function get_config_public can only be called statically"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tZnbbhs5DIbfxde+0IHUIa9SFIWbuoUBwwncZIFFkXdfUqOfY3choZ20N/ZnjvSPKFKUZvxj9+X4+fXbp9Pl69P33cOHH7vP19P5fPr26fz0eHg5PV3E+mPn9MOHsHugvXzn3UOW7yi/vRMgue69QunAUUDbslpYIEUALDl1KH73ELRxSR2qA/ACwTkALB4WT4DSIURA7qBDXUBvITcNnDskD8ClDEuGpcBSGFA7VAKUBaKLgH6L6ANABaNAcAAG1A4xAkoHCgB0Zw/IHRIsCW2y9koKuUOBpc2zQpvnBgQoC5ALgN6YvAfAEhyAAbVD86JBvzsRuhMaExozAWDRbAlFQbtXgcwdSgSUDlWGGp1CXoCdBzCgdvARgMYhAGCJ6B7RPaI7oTuhMaMxo7HGInqF2iFrL1KQMUdZO6whiOIg68wvII0p7HdJ82eB0sHD4mEJsOiYG+iYF0gddFUuwADcgtGdIagjJEmbpOMhUtBLEousCdBAVxx7Be7AAZA7JFzKrvfSwDUosBTqoIFTKBomlmGUdouooBZZMiWIX0wKvAysNE8blA4alAVqByYALAltNKMUqq4UlrtXHSpnhdJBo9OgegADRJAlXt5p9nNtREYFpBWnUwKRtWO7qjOXtIg6HeFCOqBODNIS1CmBqtl0eEkLr9fs6VRAumAX0tnsZD10zS4Ura+WnBQaZZAmeic2qqA2+oWsRzaVbLZiKsVUiqlUVYmNaqeg+beQVqBOGdT8WKj2OQ3qR6cMIrPpqkxtH9Pyl7gRGZVOrY53ykum+FbJOyVQy9CFzBbNFs1GZiOzsemx2ZIzIqMCytYjW482p9RIZyO1LTka5e4H6eg7ma1lxELaV/d1is5otemsad6TZnGnAmJTZswfaSlYKDujBCp232I2iwdZPMjiwQ734JYH/Pa23+GU8unlejzqIeXm2CKHmefD9Xh52T1cXs/n/e6fw/m1Nfr+fLi075fDVa7KCjpevsi3CH49nY9Kb/u1txt31bhR7y5RqtUkZF3difiJiAsBGo7CKuHqnUQYS1CpuUvILCaTyHynEMcKUkQxD4VoqDB1o1a4Iet36Aa/2430d93Q8t6jUcbRKBMJzgwJ2ZhHg6hjhcoOg6hywninG1Ibh27MkjuUaH7I0TePk3uSmjlGxDRHjkNXJrlZfUZm1eDCSOI3XBmv04lISMF3jSCnK5PgdO/JJD1jrrFLSNW+iUq9Lzk+TxZJ9Iis1Gcea5RfcyVTHWtMcrR4y3I5pa2+yHZ5X7YmU5pllSM56k1y/E9jkumRUT3lycQUQij3CpMUDb7abARXxxqTHOWAFOXotilY7Uuet/khj6XwI96sk9/SyD5ZZsw8yX9Xw6fkrIbmsk0jZ6w2qSBhm0Z1tqvVMNaYrliyak7yZDxcbfEP7PB/YIuf1p5ko4g1jT3hd++OMb1/e/zlSkzjCjjTKBnDkDcofjwbdbYz2d4mDx+3tcffadCsihaPEphLHG6xNCmiWQ7kkKASNkmsQRGs2yQsKIJjielcuHUuqAwlJgkqR4wET4Tzmhzx56BMz7IOaS7vrMpYY7Lc6rpSnLupoz/lF012+mz7Uk5hrDDLUE9WReXt7VCDJ1FhK8TJr3748uuZkeLqB21LrhTo3RLeVkliN5LQ91WT2eT1MYnqptPs7QNjGp8VZhLe9gIZRdkmkWwU8jJnk0S0TU1w2yg4mCPyUnabRLKIcKnbHFlPCTFscyTS+iaBNzmSyUofpS0Cldi21U1OVJftQW3bCCynpPa904WfBT7Kz8Pj6Xr339abSl1Ph8/nY//59fXyeHP15d9nXMF/Y8/Xp8fjl9frUZXWP8jk44Ns4Xv5d+ejvpSVn3J03ctrUP3p29W0lzeMH990MP8B",
      "brillig_names": [
        "get_config_public"
      ]
    },
    {
      "name": "get_l1_token_unconstrained",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "aztec_token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::address::eth_address::EthAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_l1_token_unconstrained"
      ]
    },
    {
      "name": "get_l2_token_unconstrained",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_l2_token_unconstrained"
      ]
    },
    {
      "name": "is_registered_l1_unconstrained",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "vb3brizLcWX5L3zWQ/rFzM31K4WCoFKxCgQIqsCSGmgI+vfOsAiz4Xttpe9Ymfv0CznIc5aNuNnMuHh4/Mef/uef/8e//+9/+svf/te//t8//eN/+48//Y+//+Wvf/3L//6nv/7rv/zzv/3lX//2/H//40+P4z9KHX/6x/YPz/+2P/2jHP89//SP4/nf7fmP5/Hf5U//WMoB9QnHv9laQA+QAA0YARYwL+iPgBIQlXtU7lG5R+UelXtU7lG5R2WJyhKVJSpLVJaoLFFZorJEZYnKEpU1KmtU1qisUVmjskZljcoalTUqa1QeUXlE5RGVR1QeUXlE5RGVR1QeUXlEZYvKFpUtKltUtqhsUdmiskVli8oWlWdUnlF5RuUZledR+TiOpgRowAiwgHlCfTwCSkANaAE9QAKOynbACLCAeUF5BJSAZ+VaDnhWrnJAD5AADRgBFvCsXPUJ9RFQAmpAC+gBEqABI8AConKLykcP1mNNjx48oQUcldsBEqABR2fXAyxgXnD04AkloAa0gB4gARoQlXtU7lFZorJEZYnKEpUlKktUlqgsUVmiskRljcoalTUqa1TWqHz0YOsHaMAIsIB5wdGDJ5SAGtACekBUHlF5ROURlUdUtqhsUdmiskVli8oWlS0qW1S2qGxReUblGZVnVJ5ReUblGZVnVJ5ReUbleVVuj0dACagBLaAHSIAGjAALiMolKpeoXKJyicolKpeoXKJyicolKpeoXKNyjco1KteoXKPy0YNtHKABI8AC5gVHD55QAmpAC+gBUblF5RaVW1Q+erA/D9F29OAJJaAGtIAeIAEaMAIsICpLVJaoLFH56MEuB/QACdCAEWAB84KjB08oATUgKmtU1qisUfnowT4PsIB5wdGDJ5SAGtACeoAEaEBUHlF5RGWLyhaVLSpbVLaobFHZorJFZYvKFpVnVJ5ReUblGZVnVJ5ReUblGZVnVJ5X5f54BJSAGtACeoAEaMAIsICoXKJyicolKpeoXKJyicolKpeoXKJyico1KteoXKNyjco1KteoXKNyjco1Kteo3KJyi8otKreo3KJyi8otKreo3KJyi8o9Kveo3KNyj8o9Kveo3KNyj8o9KveoLFFZorJEZYnKEpUlKktUlqgsUVmiskZljcoalTUqa1TWqKxROXqwRw/26MF+9KCUA0pADWgBPUACNGAEWMC8wKKyRWWLyhaVLSpbVLaobFHZorJF5RmVZ1SeUXlG5RmVZ1SeUXlG5RmV51VZHo+AElADWkAPkAANGAEWEJVLVC5RuUTlEpVLVC5RuUTlEpVLVC5RuUblGpVrVK5RuUblGpVrVK5RuUblGpVbVG5RuUXlFpVbVG5RuUXlFpVbVG5RuUflHpV7VO5RuUflHpV7VO5RuUflHpUlKktUlqgsUVmiskRlicoSlSUqS1TWqKxRWaOyRmWNyhqVNSprVNaorFE5elCiByV6UKIHJXpQogclelCiByV6UKIHJXpQogclelCiByV6UKIHJXpQogclelCiByV6UKIHJXpQogclelCiByV6ULwH5QALmCeo96BDCagBLaAHSIAGjAALiMolKh89qPWAGtACeoAEaMAIsIB5wdGDJ0TlGpVrVK5RuUblGpVrVK5RuUblFpVbVG5R+ehB7Qf0AAnQgBFgAfOCowdPKAE1ICr3qNyjco/KRw/qsTGPHjxhXnD04AkloAa0gB4gARoQlSUqS1TWqHz0oNoBNaAFPCuPxwESoAEjwALmBUcPnlACakALiMojKo+oPKLy0YOjHTAvOHrwhBJQA1pAD5AADRgBUdmi8ozKMyofPTiOvXP04Ak9QAI0YARYwDxhHD14QgmoAS2gB0iABowAC4jKJSqXqFyiconKJSqXqFyiconKJSqXqFyjco3KNSrXqFyjco3KNSrXqFyjco3KLSq3qNyicovKLSq3qNyicovKLSq3qNyjco/KPSr3qNyjco/KPSr3qNyjco/KEpUlKktUlqgsUVmiskRlicoSlSUqa1TWqKxRWaOyRmWNyhqVNSprVNaoPKLyiMojKo+oPKLyiMojKo+oPKLyiMoWlS0qW1S2qGxR2aKy96AeMAIsYF7gPehQAmpAC+gBEhCVZ1SeUXlele3xCCgBNaAF9AAJ0IARYAFRuUTlEpVLVC5RuUTlEpVLVC5RuUTlEpVrVK5RuUblGpVrVK5RuUblGpVrVK5RuUXlFpVbVG5RuUXlFpVbVG5RuUXlFpV7VO5RuUflHpV7VO5RuUflHpV7VO5RWaKyRGWJyhKVJSpLVJaoLFFZorJEZY3KGpU1KmtU1qisUVmjskZljcoalUdUHlF5ROURlUdUHlF5ROURlUdUHlHZorJFZYvKFpUtKltUjh606EGLHrToQYsetOhBix606EGLHrToQYsetOhBix606MEZPTijB2f04IwenNGDM3pwRg/O6MEZPTijB2f04IwenNGDM3pwRg/O6MEZPTijB2f04IwenNGDM3pwRg/O6MEZPTijB2f04IwenNGDM3pwRg/O6MEZPTijB2f04IwenNGDM3pwRg/O6MEZPTijB2f04IwenNGDM3pwRg/O6MEZPTijB2f04IwenN6D84AW0AMkQANGgAXMC7wHHUpAVNaorFFZo/LRg/Y4YARYwLzg6METSkANaAE9QAKi8ojKIyqPqGxR2aKyRWWLyhaVLSpbVLaobFHZovKMyjMqz6g8o/KMyjMqz6g8o/KMyvOqXB6PR1JJqkktqSdJkiaNJEtKR0lHSUdJR0lHSUdJR0lHSUdJR0lHTUdNR01HTUdNx9Gd1p00aSQdjuE0g44Wvagk1aSW1JMkSZNGUjpaOno6ejp6Ono6ejp6Ono6ejp6Ono6JB2SDkmHpEPSIemQdEg6JB2SDk2HpkPToenQdGg6NB2aDk2HpmOkY6RjpGOkY6RjpGOkY6RjpGOkw9Jh6bB0WDosHZYOS4elw9Jh6ZjpmOmY6ZjpmOmY6ZjpmOmY6ZjhKI9HUkmqSS2pJ0mSJo0kS0pHSUdJR0lHSUdJR0lHSUdJR0lHSUdNR01HTUdNR01HTUdNR01H9nnJPi/Z5yX7vGSfl+zzkn1ess9L9nnJPi/Z5yX7vGSfl+zzkn1ess9L9nnJPi/Z5yX7vGSfl+zzkn1ess9L9nnJPi/Z5yX7vGSfl+zzkn1ess9L9nnJPi/Z5yX7vGSfl+zzkn1ess9L9nnJPi/Z5yX7vGSfl+zzkn1ess9L9nnJPi/Z5yX7vGSfl+zzkn1ess9L9nnJPi/Z5yX7vGSfl+zzkn1ess9L9nnJPi/Z5yX7vGSfl+zzkn1ess9r9nnNPq/Z5zX7vGaf1+zzmn1es89r9nnNPq/Z5zX7vGaf1+zzmn1es89r9nnNPq/Z5zX7vGaf1+zzmn1es89r9nnNPq/Z5zX7vGaf1+zzmn1es89r9nnNPq/Z5zX7vGaf1+zzmn1es89r9nnNPq/Z5zX7vGaf1+zzmn1es89r9nnNPq/Z5zX7vGaf1+zzmn1es89r9nnNPq/Z5zX7vGaf1+zzmn1es89r9nnNPq/Z5zX7vGaf1+zzmn1es89r9nnNPq/Z5zX7vGaf1+zzmn1es89r9nnNPq/Z5zX7vGaf1+zzmn1es89r9nnNPq/Z5zX73AcT2XRqST1JkjRpJFnSvMgHFV1UkmpSS+pJkqRJI8mS0lHSUdJR0lHSUdJR0lHSUdJR0lHSUdNR01HTUdNR01HTUdNR01HTUdPR0tHS0dLR0tHS0dLR0tHS0dLR0tHT0dPR09HT0dPR09HT0dPR09HTIemQdEg6JB2SDkmHpEPSIemQdGg6NB2aDk2HpkPToenQdGg6NB0jHSMdIx0jHSMdIx0jHSMdIx0jHZYOS4el4+jz+XDqSZKkSSPJkmbQ0ecXlaSalI6ZjpmOmY6ZjpmOGQ4fuHRRSapJLaknSZImjSRLSkdJR0lHSUdJR0lHSUdJR0lHSUdJR01HTUdNR01HTUdNR01HTUdNR01HS0dLR0tHS0dLR0tHS0dLR0tHS0dPR09HT0dPR09HT0dPR09HT0dPh6RD0iHpkHRIOiQdkg5Jx9HnszvNoKPPLzocw6kmtaSeJEmaNJIsaQYdfX5ROkY6RjpGOkY6RjpGOkY6RjosHZYOS4elw9Jh6bB0WDosHZaOmY6ZjpmOmY6ZjpmOmY6ZjpmOGQ4fHHVRSapJLaknSZImjSRLSkdJR0lHSUdJR0lHSUdJR0lHSUdJR01HTUdNR01HTUdNR01HTUdNR01HS0dLR0tHS0dLR0tHS0dLR0tHS0dPR09HT0dPR09HT0dPR09HT0dPh6RD0iHpkHRIOiQdkg5Jh6RD0qHpyD6X7HPJPpfsc8k+l+xzyT6X7HPJPpfsc8k+l+xzyT6X7HPJPpfsc8k+l+xzyT6X7HPJPpfsc8k+l+xzyT6X7HPJPpfsc8k+l+xzyT6X7HPJPpfsc8k+l+xzyT6X7HPJPtfsc80+1+xzzT7X7HPNPtfsc80+1+xzzT7X7HPNPtfsc80+1+xzzT7X7HPNPtfsc80+1+xzzT7X7HPNPtfsc80+1+xzzT7X7HPNPtfsc80+1+xzzT7X7HPNPtfsc80+1+xzzT7X7HPNPtfsc80+1+xzzT7X7HPNPtfsc80+1+xzzT7X7HPNPtfsc80+1+xzzT7X7HPNPtfsc80+1+xzzT7X7HPNPtfsc80+1+xzzT7X7HPNPtfsc80+1+xzzT7X7HPNPtfsc80+1+xzzT7X7HPNPtfsc80+1+xzzT7X7HPNPtfsc80+1+xzzT7X7HPNPtfsc80+1+xzzT4f2ecj+3xkn4/s85F9PrLPR/b5yD4f2ecj+3xkn4/s85F9PrLPR/b5yD4f2ecj+3xkn4/s85F9PrLPR/b5yD4f2ecj+3xkn4/s85F9PrLPR/b5yD4f2ecj+3xkn4/s85F9PrLPR/b5yD4f2ecj+3xkn4/s85F9PrLPR/b5yD4f2ecj+3xkn4/s85F9PrLPfWjY84GMo4AKDtDAmeivz15YwAo2EJtiU2yKzV+nfRTHmeiv1F5YwAo2sIMCKjhAbAObYTNshs2wGTbDZtgMm2EzbBPbxDaxTWwT28Q2sU1sE9tMmw87CyxgBRvYQQEVHKCB2Aq2gq1gK9gKtoKtYCvYCraCrWKr2Cq2iq1iq9gqtoqtYqtuO16q9yFrgQV023BsYAcFVHCABs5Ef8X+wgJi69g6to6tY+vYOraOTbAJNsEm2ASbYBNsgk2wCTbFptgUm2JTbIpNsSk2xabYBraBbWAb2Aa2gW1gG9gGtoHNsBk2w2bYDJthM2yGzbAZtoltYpvYJraJbWKb2Ca2iW2mbT4eYAEr2MAOCqjgAA3EVrAVbAVbwVawFWwFW8FWsBVsFVvFVrFVbBVbxVaxVWwVW8XWsDVsZMkkSyZZMsmSSZZMsmSSJZMsmWTJJEsmWTLJkkmWTLJkkiWTLJlkySRLJlkyyZJJlkyyZJIlkyyZZMkkSyZZMsmSSZZMsmSSJZMsmWTJJEsmWTLJkkmWTLJkkiWTLJlkySRLJlkyyZJJlkyyZJIlkyyZZMkkSyZZMsmSSZZMsmSSJZMsmWTJJEsmWTLJkkmWTLJkkiWTLJlkySRLJlkyM0vqI7OkPjJL6iOzpD4yS+ojs6Q+MkvqI7OkPjJL6iOzpD4e2Aq2gq1gK9gKtoKtYCvYCraCrWKr2Cq2iq1iq9gqtoqtYqvYGraGrWFr2Bq2hq1ha9gatoatY+vYOraOrWPr2Dq2jq1j69gEm2ATbIJNsAk2wSbYBJtgU2yKTbEpNsWm2BSbYlNsim1gG9gGtoFtYBvYBraBbWAb2AybYTNshs2wGTbDZtgMm2Gb2Ca2iW1im9gmtoltYpvYyJJClvhQw1IejhVsYAcFVHCABs5Ez5ILsZ1Zoo4N7KCACg7QwJl4ZsmJBcRWsVVsFVvFVrFVbBVbw9awNWwNW8PWsDVsDVvD1rB1bB1bx9axdWwdW8fWsXVsHZtgE2yCTbAJNsEm2ASbYBNsik2xKTZNm4/J8umefExWOaZqqz4Aq5Tz/zVwJvr6XFjACjawgwIqiE2wCTbFptgUm2JTbIpNsSk2xabYBraBbWAb2Aa2gW1gG9gGtoHNsBk2w2bYDJthM2yGzbAZtoltYpvYJraJbWKb2Ca2iW2mzUdtPQPHsYAVbGAHBXTbcByggTPxzMYTC1jBBnZQQGwFm2ejT/nmA7ku9Gz0+d98KFdgBRvYQQEVHKCBM7Fha9gatobNs7H6fG2ejRcqOEADZ6JnY+2OBayg23zreGpcKKCCAzTQbb4lPUsuLGAFG9hBARUcoIHYFJtnSZ2OFWygFxPHo1g7fm3bOdOib6hzrkX/F87ZFk/soIAKDtDr+rF+zrzoeM69eGIBK9jADgqo4ACxGbZzPkbfLeeMjCcetu5r7KFwYQcFVHCAh637Memh4OhDvAILWMEGdlBABQdoIDYPhX5OVVhAtzXHBnZQQLcNxwEaOBM9FC4soNvMsYEdFFDBARo4Ez0ULiwgtobNQ+GYpan6KLBABd0mjgbORO/5C49i8nA8/kx8Q3l3ixfz7j7Ru/vCAlawgR0UUMEBYhNsik2xKTbFptgUm2JTbIpNsQ1sHgrqm8RD4cIGdlBABQdo4Ez0ULgQm2EzbIbNsBk2w2bYDNvE5qGg3k4eChc2sIMCKjhAA2egjwcLdFt3rGADO3jYxvlnCg7QwJnooXDhYTve5a0+NizwsA1zPGxjOGoc9j4qrBwv4VYfFhY4Ez0JLizgobDm2MAOCqjgAA+b+cp7EpzoSXBhASvYwA4KqOAAsTVsfnpg4ljACrrNt6RHxYUCus23rweI+dbxAJm+WzxATvQAubCAFWzgYZuu8AC5UMEBGjgTPUAuLGAFG4hNsSk2xeZRMX2NPSourGADOyiJ3sfTN5T38YVPRX34MTlZ9Mmiz1x0H4JVj0eL1cdgBTawgwIqOEADZ+LRWYHYCraCrWAr2Aq2gs0nSX6ck/Z6heboFcRRQAUHaOBM9CmSLyxgBRuIrWFr2Bq2hq1h69g6to6tY+vYOraOrWPr2Do2wSbYBJtgE2yCTbAJNsEm2BSbYlNsik2xKTbFptgUm2Ib2Aa2gW1gG9gGtoFtYBvYBjbDZtgMm2EzbIbNsBk2w2bYJraJbWKb2Ca2iW1im9gmtpk2H7kVWMAKNrCDAio4QAOxFWwFW8FWsBVsBVvBVrAVbAVbxVaxVWwVG1kyyJJBlgyyZJAlgywZZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyxMgSI0uMLDGyxMgSI0uMLDGyxMgSI0uMLDGyxMgSI0uMLDGyxMgSI0uMLDGyxMgSI0uMLDGyxMgSI0uMLDGyxMgSI0uMLDGyxMgSI0uMLDGyxMgSI0uMLDGyxMgSI0uMLDGyxMgSI0uMLDGyxMgSI0uMLDGyxMgSI0uMLDGyxMgSI0uMLDGyxMgSI0uMLDGyxMgSI0uMLDGyxMgSI0uMLDGyxMgSI0uMLDGyxMgSI0uMLDGyxMgSI0uMLDGyxMgSI0uMLDGyxMgSI0uMLDGyxMgSI0uMLDGyxMgSI0uMLDGyZJIlkyyZZMkkSyZZMsmSSZZMsmSSJZMsmWTJJEsmWTLJkkmWTLJkkiWTLJlkySRLJlkyyZJJlkyyZJIlkyyZZMkkSyZZMsmSSZZMsmSSJZMsmWTJJEsmWTLJkkmWTLJkkiWTLJlkySRLJlkyyZJJlkyyZJIlkyyZZMkkSyZZMsmSSZZMsmSSJZMsmWTJJEsmWTLJkkmWTLJkkiWTLJlkySRLJlkyyZJJlkyyZJ4NedyPmmdDnlhAX5zp2MAOCqjgAA2cF7bH2ZAnFrCCDTxsxzPA5oOmAhUcoIEz0RuydMcCVrCBHRRQwQEaOBMrtorNG7KIYwM76DZ1VHCAbhuOM9Eb8sICus0cva5vSW+9Cwdo4FH3ePDXfHhUPZ7gNR8eVatvSW+9CxvYwcNWfY299S4coIFu83Xzfqu+vN5v1RfH+6354ni/XV/5EVDBARo4E73fLjxszbe699uFbnOx99uFAio4QAMP2/G4qvmYqMACVrCBHRRQwQEaiM2w+W93923mv90XNtBtvmP9t/tCBd3mG8p/u7vvIY+KEz0qLixgBRvoNj8mPSouVHCABs5AHxMVWMAKNrCDAio4QAPdduxCHxMVWEA/StSxgR0UUMEBHjapjjPRo+LCAlawgR0UUMEBYqvYGraGzX+lj4duzUc/BSo4QANnokfFhQWsYAOxdWwdW8fWsXVsgk2wCTbBJtgEm2ATbIJNsCk2xabYFJtiU2yKTbEpNsU2sA1sA9vANrANbAPbwDawDWyGzbAZNsNm2AybYTNshs2wTWwT28Q2sU1sE9vENrFNbDNtPpdbYAEr2MAOCqjgAA3EVrAVbAVbwVawFWwFW8FWsBVsFVvFVrFVbBVbxVaxVWwVW8XWsDVsDVvDRpZUsqSSJZUsqWRJJUsqWVLJkkqWVLKkkiX1zJLuqOAADZyJZ5ac6IqHYwM7KKCCAzRwJp4BcmIBsSk2xabYFJtiU2yKbWAb2Aa2gW1gG9gGtoFtYBvYDJthM2yGzbAZNsNm2AybYZvYJraJbWKb2Ca2iW1im9hm2trjARawgg3soIAKDtBAbAVbwVawFWwFW8FWsBVsBVvBVrFVbBVbxVaxVWwVW8VWsVVsDVvD1rA1bA1bw9awNWwNW8PWsXVsHVvH1rF1bB1bx9axdWyCTbCRJY0saWRJO7NkOCo4QLeZ40w8s+TEAlawgYdN3eZZcqGCbpuOBs7EM0tOLGAFD5s2xw4KqOAADZyJniUXFrCC2AybYTNsniXHt6iaj1IMnImeJRcWsIJuE8cOCug2dRyggTPQxyM+s9vRK5ijggM8KhxfbGo+8vBCz4cLj+U9xhs1H3kY2MAOHrZxftdVwQFaoifB8bGm5qMJ6/GlmeajCQMV9OV1xfml6BNn4vm16BMLWMEGdtBt4qjgAA2cid7zFxawgg3sILaOrWPr2Do2weY9P3wfe3dfKKCCAzRwJnp3X0hd7+4LG4hNsSk2xabYFNvANrANbAPbwDawDWwD28A2sBk2w2bYDJthM2yGzbAZNsM2sU1sE9vENrFNbBPbxDaxzbT5cMPAAlawgR0UUMEBGoitYCvYCraCrWAr2Aq2gq1gK9gqtoqtYqvYKraKrWKr2Cq2iq1ha9gatoatYWvYGraGrWFr2Dq2jq1j69g6to6tY+vYOraOTbCRGj7yMBAbWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZAlQpYIWSJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWaJkiZIlSpYoWXIOxjwGordzMOaFAzRwJp5ZcmIBK9jADmJTbIpNsSm2gW1gG9gGtoHtDJDhOEADZ+IZICcWsIIN7KCA2AybYTNsE9vENrFNbBPbxDaxTWwT20zbOQLzwgJWsIEdFFDBARqIrWAr2Aq2gq1gK9gKtoKtYCvYKraKrWKr2Cq2iq1iq9gqtoqtYWvYGraGrWFr2Bq2hq1ha9g6to6tY+vYOraOrWPr2Dq2jk2wCTbBJtgEm2ATbIJNsAk2xabYFJtiU2yKTbEpNsWm2Aa2gW1gG9gGtoGNLBlkySBLBlkyyJJzBObxak47R2BadWxgBwVUcIAGzkTPkgsLiG1im9gmtoltYvMsOd4JaucITMdzBOaFBaxgA932cDxs80QFB2jgTPQsubCAFWxgB7EVbAVbwVawVWwVW8VWsVVsFVvFVrFVbBWbp8bxVlE7R1Uerz61c1TlhV5BHA2ciZ4PFxawgr686thBARUcoIEz0fPhwgJWEJtg83w45uls56jKCwfoNnOciZ4PF7ptOlawgR182trDt++RBO3h2/dIgguPJAgsYD3QD9ojCZ437x37gb4lh9f15T2S4HnH3nEc6OJh4Ey0B3jYii/ZkQSBDezgYSvV8VD4aCEfNNl8XJAPmmw+AsgHTTYf1eODJpuP1PFBk4EN7KCACg7wsPlYHx80eeI5UtIP2nOk5IUN7KCACg7QwJl49vyJ2Aq24ivUHTsooK+QOA7QwJl49HxgASvYwA4KiK1iq24zx5nYHmABK9hAt01HARUcoIEzsT/AAlawgdg6tiMf2jEpQfORkoEGHrbmh4Zkep4jJS+sYAM7KKCCAzQw0/McKXkhNsWm2BSbYlNsik2xKbaBbWAb2Aa2gW1gG9gGtoFtYDNshs2wGTbDZtgMm2EzbIZtYpvYJraJbWLzAGnNUUE/SrwLPUAunBd2H+QZeByTx1QQ3Qd5BjawgwIqOEAD3WYHlgfoZyvi6Gd4zVFArzsdB2jgTPTUuLCAFTzW4hhb1304Z6CAh+0YW9d9OGeggYftGL7XfThnYAH97NW35HnVcWIHBVRwgAbOxPOq48QC+gMZ375+/nChr4VvPs+HCw2cifIAC1hB32a+h6SDArpNHQdooNt8efUBFtAfNvnx4PlwYQcFVHCABs5Ez4cLC+hr4RvKzx8uVHCAvhbnn81EP3+4sIA+JNq32fn+xYkdFFDBARo4E8/h3ic+6/psNN1HazbxY9J7/kIFB2jgDPTRmu0Yk9N9tGZgBRvYQQEVHKCBM7FgK9iK27pjAzvoNnFUcIBuG45uO/aFj9Zsx8Pz7qM1AyvYwA4KeNiOR53dR2sGGjgTPQkuLGAFG9hBAbE1bA1bw9ax+fmD+pb084cLG+g23zp+/nChggM0cCZ6Pnjj+BjOwAo2sIMCKjhAA2eiYlNs6rbp2MAOHrbhm+TIh+bh6GM4Aw2ciX7VcWEBK9jADrrNjz5PjQvdpo4GzkRPjQvd5ovuVx0XNrCDAio4QAMPm/nx6xcgFx42863jFyAXNrCDAj4VPi9g94GbzTw1PEAcfeBmYAEr6Apx7KCACg7QQLcd28wHbgYWsIIN7KCACg7QQGwVmwfI8XnT7gM3AxvoNnMUUMHDdpyfdR+42Y4Lpu4DN5+XIQd6gFxYwAo2sIN+qeFkSTPovM5wKkk1yDt4+kb2Dr6wgwIqOEADZ6J38IUFxKbYFJtiU2yKTbEptoFtYBvYBraBbWAb2Aa2gW1gM2yGzbAZNsNm2AybYTNshm1im9gmtoltYpvYJraJbWKbafNBlIEFrGADOyigggM0EFvBVrAVbAVbwVawFWwFW8FWsFVsFVvFVrFVbBVbxVaxVWwVW8PWsDVsDVvD1rA1bA1bw9awdWwdW8fWsXVsHVvH1rF1bB2bYBNsZEkjSxpZ0siSRpY0sqSRJY0saWRJI0saWdLIkkaWNLKkkSWNLGlkSSNLGlnSyJJGljSypJEljSxpZEkjSxpZ0siSRpY0sqSRJY0saWRJI0saWdLIkkaWNLKkkSWNLGlkSSNLGlnSyJJGljSypJEljSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0skSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSJUuULFGyRMkSJUuULNGz0YejggP0G8ZOM8jb/KSSVJNaUk+SJE0aSemo6WjpaOlo6WjpaOlo6TjbejoO0MCnph+P5LuPngwsB3qFo60DG9hBARUcoIEzUR4gNsEm2ASbuM13mCg4QANnoj5At6ljBRvoN+icJEmTRpIlzaDhFU/0JTVHX1Lf3mOABs7Eo0m735rzYZGBFWxgB/1mupMmHa5jUEP3QZGBM3G6y7frLGAF3eVbZXbwWLPiK3m0aOAAD9tpmBf5kMiLSlJNakle0Rx9SY+t4kMcn+fnjgWsYAOPJa1e7OjpQAUHaOBhO7abj3C8qCQdqu7UknqSJGnSSHJJc5yJ7QE20BfT/6wN8Khw/vMZ5O16km8RdaxgA32L+Db1br3QVb55vVsvdJVvSO/WY+KX7kMVu99d9KGK3Q8wH6oY2MAOCqjgAA10my+vd6s3lA9V7P482Qcldn/Y64MSuz+U9UGJgQM0cCYeP7eBBfRivpreqBcO0MCZ6I16YQH9z3xDec9dOBO95y70P/Nd6D13Hi1Hz4nXOlruIknSpJFkSfMiHzV4UUmqSS2pJ0mSJo0kS0pHSUdJR0lHSUdJR0lHSYd3mzeZjwE8pnrpPgTwopbUkyRJk0aSJc0gb7aT0tHS0dLR0tHS0dLR0tHS0dLR09HT0dPR09HT4b3mT6N92N+F3msXev5URz9CzPEo5Q9ZfYBf98epPmjveXLpePy7/rTUB+0FdvBYOX/O6FMhBg7QwJno/XNhASvoNl+30UEB3ebr5q3kDwF90F6g1/V/13/zLmxgB4U/U3CABmKb2LwDL2zgcbz6Ael9d5ImjSRLmhf5HIf9eEW4+8i9wAoKeCyeP9r00Xj9eAO4+2i8wAJWsIEdFPDYGD7ExkfjBRrotuOo8dF4gQV0mzo2sIMCKjhAA2eit+GFBcTWsDVsDVvD1rA1bN6Px1Dw7qPxAgvodc3Ri03Hmeid5o9XfQBd90emPoAuUMCjgj8R9QF0gcfi+BNGHxTX/VGhD17r5grvkws7KKBnji+D/xBdaOBM9O65sICeMr6Q3icXKuh1fXm9Ty6cid4nFxawgg3sF4oPMnvuBscKNrCDAiroS9YdDZyJ3iIXFrCCbhPHDgqooNv0QG+G42JPHudPkTlWsIEdFFDBAfpaTMeZeP4mnXj8fh6DqMUHmQU28Iikh2+doxkCFRyggTPxaIbAArrNt1l3m2+H7hV8O/SZKA+wgL5kvpoioIIDNHAm6gMsoC+Zbx1tYAcFVNDPU3yb6UwcflZSHP2Uxo9U8/MX3w7mJzC+HayCT7Ge1JMkSZNGkiXNoKOPLipJLvHj7zzfO7GDAio4QANnYDlP+070uuroFYbjsajnP7ekGXQ01kUlqSZ5RXPsoIAKDtASq2/m6XhUOC7YxIdmBR4VqtNIsqQZdPTORSXp2Kb1xAZ2UEAFR6L3yHEdJj7QSo6LL/GBVuqLf1w8XaRJxwb1TXt0zUUz6OiZi0pSTXKJ7yJvowsFtERvjep/5q1xYQOPxTz/VUnSpJFkSTNo+Ir7+owCVrCBHRRQwQEaOBMNm2Hzvmt+FBx9F9jBw9Z8Rx2tF3jYmu+zo/mk+T47uk+ar9vRfoEFdJuLvQEvdJsfn96A3cVHA46TRpIlzYt80NRFJemoeFwaig+DkuPKT3wYlByXe+LDoC7066kLjyU9LorEh0EFNrCDAnrdYwV9aJMcVxHiQ5vkuHQQH9oU2EEBFRyggTPRm/BCt03HCjbQz6l9k3gbXqjgAP282reZ/4Cd6M154bF5m1NNaklP1fDNfPTrRZo0kixpBvlvnJxYwAo2UEFfTLf7r9mFXsH3p7fshQ08ltT31tGyF2nSSLKkGXS07EUlqSa1pHSMdIx0jHSMdIx0WDosHZYOS4elw9Jh6fAOFT8+vUMvnIneoeKHqnfohRX0TebH0XltduJxHKlvf/+JvHCABs5AHw0lxxBa8dFQgYfNf5t9NJT4L56PhhKPSB8NFaig24ajgTPx6OnjskJ8MNRFNakl9SRJ8opHf/nYJlH/f72bPVx8bFNgBwU8ltSPbB/bFGjgTPRuvvBpMy/gzTx8s3gz+x71oU2BLvNlPNp2+l+dX98ujv1P52eppeV3tqXld7bFxyWJnf+ugTPRW/LCAlawgR0UUEFsgk2wKTZvX/MN4u17YQM7KKCCltvBPzF5on837kLfUH6o+XfjLmygK/wI9R/bCxUcoIEz0X9szYv5j+2FvkK+X/3H9sIO+s7yQ9g/TXfhAA2cif7BugsLWMEGdhDbxDaxTWwzbed3Zy8sYAUb2EEBfUuq4wAN9C3p/67/PF9YwAr6ljRH35LT8bD5Zcj53dkLB3jY5okz8bgWDSxgBRvYQQEVHCC2iq1h869N+sXU+d3ZCxvYQQEVHKCBM9G/Nnkhto7Nz76P2xTig5ECBVRwgAbORA+QCwtYQbdVxw4KaIkeCn6TwQcYid9D8AFGgR0U0JfXjygdoIEz0U/GLyxgBRvYQQGxDWwD28Bm2Ayb54PfCfEBRoFu8z3kJ+MXKnhcZfgdCx9gFDgT/Vr4wgJWsIEdPK5oPDJ9gFHgAA1025F9PsAosIAVbKDbzFFABQdo4Ez0i2c/fn2AUWAFG9hBARUcoIEzsWKr2I58UI8VH2AU2MHD5rc/fICR+r0CH2AUaOBMPPIhsIAVbGAHBcTWsDVsDVvH1rF1bB1bx9axdWwdW8fWsQk2wSbYBJtgE2yCTbAJNsGm2BSbYlNsik2xKTbFptgU28A2sA1sA9vANrANbAPbwDawGTbDZtgMm2EzbIbNsBk2wzaxTWyeJX7bywcYBbptOAqo4AAPm9+O8gFGJ/oAo8ACVrCBHRTwsB1TPYjPCRc447fFJ4ILLKArmmMDXSGOAiroCnU0cCZ6gPitIx+7FFjBBnZQQAUHaOBMbNiOqPBTDR+xdJEkPYv676sPWLrIkrziEbc+XCmwgBVsYAd9+aejggM8ZL6gR0acdETERSWpJrWkniRJmjSS0iHp0HRoOjQdmg5Nh6ZD06Hp0HRoOjwO/G6aT+sWWMEW13s+rVugX+T5ceenFhcO0OIq0IcyXehx4HfpfChToNv8zzwOLuygn1T64pyXHicO0MCZeF56nOh1fdG9xZt3hLe43/3zAUqBM9CHKAX68ppjBRvYQQH9kUB1HKCBM9FPFy4s4GE7xoSID2kK7KCACg7QwJno3X5hAbFVbN7tfh/SBzYFKug231De7X6Lz8c2XejdfmEBK9jADgqo4ACxNWwdW8fWsXVsHVvH1rF1bB1bxybYBJtgE2yCTbAJNsEm2ASbYlNsik2xKTbFptgUm2JTbAPbwDawDWwD28A2sA1sA9vAZtgMm2EzbIbNsBk2w+anC34r2QdeXeinC37/2AdeBVawgYfN79H60KtABQdo4Az08VeBBXSbODbQFeqo4AANdMUR5nY+rDuxgBVskX0+BCtQQAUHaOBM9AC5sID9ulPoY7Iu0qRnUb+d5GOyLppBHhLHeCTxQVmBFWxgBwU8TMVpJFmSb6rjiPChWYEFfKr8zo0PzrqoJ0mSJo0kS5pBRzJcVJLSIemQdEg6JB2SDkmHpEPToenQdHgYqG/783HgiQL6A8HqOEB/JOg75Xwm6OhhcOGx0fyWuI/2CmxgBwVUcIAGus0PbA+DCwtYQbf5fvcwuFBABQfoNt/fHgYnehhceGzHk2pSS+pJkqRJI8mS5kU+FuyiklSTWlJPkiRNGkmWlA4PAb/Z76PF1M/HfLRYYAM7KKCCAzRwJnoIXIitYqvYKjY/i/BTSR8tFjhAA2eiB8SFh83b2keLBTawgwIqOEADZ6JnxIXYOraOrWPr2Dq2jq1j69gEm2ATbIJNsAk2P1/w5ww+CZufgPpws4v8j9RRQAUHaOBM9P73XPEp2AIr2MAOCqjgAA2ciYbNsHn/+y11n4ItsINu81bw/r9wgIfNLy19bNuF3v8XFvCw+T1hn2xN/QLcJ1sLHKCBXvd5nKpPtqbHLV/1cXB63E1VHwenx1Aw9XFwetwsVR8HN44LFvVxcIEKDtCHGxTHmegPFy8s4PF48bipqT74bTx8cfyx4sMXp7hiOLrCF+fo+HHcGVSfd+3Co+MDC1jBBnbwsBVfhqPjA13hi1NnYnuArvCFbBVsYAcFVHCABs7E/gCxdWw+kKD4JvGRBBcKqOAADfThBL7fjjYPLGAFG9hBARUcoIHYFJu6zY8HrWAD3ea7RSNU9KEKDtDAmTgeYAEr2MAOYhvYBraBbWAzbIbNsBk2w2bYDJthM2yGbWKb2Ca2iW1im9gmtoltYptp81F7gQWsYAM7KKCCAzQQm6fGMbRNfZRfoB8l4tjADgrox6Q5DtDAmegBcmEBK9hAt01HAf2UQR2PusedKvURgIEFrKAPCPI19tS4UEAFxzW8Qn1itsCZ6IOPLixgBRvYwWPrHLe91EcHBs5Ez4cLC1hBX97m6BV8Z3nPN98X3vMXFtAr+Dbznr/Qt8NwFFBBX17fFz7m6MKZ6KOOLixgBRvoNt8OPvToQgUHaOBMtBhLpT4k8NoOPtroQraOjzfqvueP7g40cCYe3R14rEX3g+Do7sAGdvCwdbf5kMALB+g23wE+KtDxHBZ4odvUsYINdFt1dNtwdJs5um06GjgTvY+POx7qwwUDOyjgUfe446E+P9p5cPn8aIEFrGAHfYygL3o1cCaeYwR9LVoBK9jADgqo4AAt0X/GxbeZ/4xf2MAO+so3RwUHaKCvhf+ZDyG4sIAVbGAHBVRwJPpoo+ob6hzfe6KvhW9fb94LOyigr4UfXN68Fxo4E715LyxgjCbWOhrYQQEVHKCBM/Ec5XtiAX0tfDW9eS9UcIC+FuefzURv3gsL6Gvhm2Q2sIMCKjhAA2egjwscx90m9XGBgR0U0NdiOg7QwJnoP8IXFrCCDfThlQ9HARUcoA/jLI4z0Vv6wgL6NvM/88FEF3ZQQAUHaOBMPAfnnxgvIagPGhzH/Sb1QYOBCvpaNEdfi/PPZqKful9YwAo2sIMCum04el3fb97Hxf9f/7n1324fNRg4QAOPCsNX03+ELyxgBRvYQQE1l8EHCF1o4Ez0AUIXFpC18D6+sIPHWgzf8/5zO3yr+8/tiT7c98IC+lr4bvEf4Qs76Gvh3eJ9fOEADZyJ3scXFtBt4tjADrrN96b/CF84QANnoA8VDCyg24ZjAzvoNnNUcIAGzkTv7gsL6Lbp2MAOHjY/SfehguMYwak+VHAct8zVhwqOYwSn+lDBC727LyzgYTNfCz/FNl8G/+02t/kp9oUKDvCwTV8cP/E+7naoDxUc05fMT7wvrGAD3fZwFFDBAfqxfv7ZTOwPsIAVbGAHBVTQ18K3pJ94X1jACvpa+Jb0C/MLBVRwgAbORM+HCwvodf1A9CS4UEGv67vQf9EvnIn+i35hAb2u727veb/d5MP/Amei9/yFBazXK7Dqw/8COyigggM0cCb6K6UXHre/Hyd2UEAFj1vgfnPLB+89H6M5NrCDXqE5KjgSj96045VH9WF65vfEfJie+T0xOQflT8cOCqjgAHP7+oA8OwYFqg/IC2xgB+V6CVzlfJP6xAEaOBPPN6lPLGAFG3jU9Vs9cs4pcqKBx+OEY3yg+tC7wGMt/HaeD70LbOCxFt5ZPvQuUEF/KieOBs5Ef2J2YQHd5lvHH5pd2EEBFRyggTPRn5P5LTofTudzq6gPnDM/W/GBcxcenRV4LJnfNPOBc4HHklXfDke/BQp4LNm5fY8uDDRwJtoDLGAF3ebLax0UUMEBGjhzjf05l9/J8SFygR0U0Ot6i3gXXmjgDPQhcj5fj/oQucAKNrCDAio4Er1j/fLBx8UFVrCBvhbmKKCCAzw64HHiTPSXwC8sYAUb2EFJvIa3N+ey8DnAXZzbwrr8O2NhW3jC/uTX7435ALHABnZQQAUHaOBMPA//E7H54e9313ygWGAHBVRwgAbORD/8LywgNsNm2PzJrd/A8zmrzO+Y+eCvwA4KqKAv2bFRffCX+U0NH/wVWMEGdlBABb2uOBo4E/2QvrCAFWyg29RRQAUHaOBMrA+wgK4Yjh0UUMEBGjgT2wMsYAWxNWzNbeao4AANnIn+K3UhO6uzszo7q7Oz/EfIby36gC7zW4A+oCuwgBU8ivktQB/QFSigggM0cCb6AI4LC1hBbIpNsSk2xabYvI/9BpMP6LrwHB/pZ4jjfDfr4rpwW7gvLAvrwmNhW3gm2+OxcFm4LozXBzA92Zzbwn1hWVgXHgvbwhOuj4XLwou3Lt66eOvirYu3Lt66eOvibYu3Ld62eNvibYu3Ld62eNvibYu3Ld6+ePvi7Yu3L96+ePvi7Yu3L96+ePvilcUri1cWryxeWbyyeGXxyuKVxSuLVxevLl5dvLp4dfHq4tXFq4tXF68u3rF4x+Idi3csXv9x8ttd59CiCxUcoIEz8BxfdGEBK9jADgqo4AANxFawFWwFW8HmP1l+V89HGgUqOEADZ6L/ZF1YwAo2EFvFVrFVbBVbxdawNWwNW8PWsDVsDVvD1rA1bB1bx9axdWwdW8fWsXVsHVvHJtgEm2ATbIJNsAk2wSbYBJtiU2yKTbEpNsWm2BSbYlNsA9vANrANbAPbwDawDWwD28Bm2AybYTNshs2wGTbDZtgM28Q2sU1sE9vENrFNbBPbxDbDNh6PB1jACjawgwIqOEADsRVsBVvBVrAVbAVbwVawFWwFW8VWsVVsFVvFVrFVbBVbxVaxNWwNW8PWsDVsDVvD1rA1bA1bx9axdWwdW8fWsXVsHVvH1rEJNsEm2ASbYBNsgk2wCTbBptgUm2JTbIpNsSk2xabYFNvANrANbAPbwDawDWwD28A2sBk2w2bYDJthM2yGzbAZNsM2sU1sE9vENrFNbBPbxDaxkSWFLClnlnRHtw3HBnZQQAUHaOBMPLPkxAJiK9gKtoKtYCvYCraC7cwScyxgBRvYQQF9pP/DcYAG+mB/32aeJRcWsIIN7KCAblNHt/laeJZcOBM9Sy4sYAUb2EEBFcTWsXVsgk2wCTbBJtgEm2ATbIJNsCk2xabYFJtiU2yKTbEpNsU2sA1sA9vANrANbAPbwDawDWyGzbAZNsNm2AybYTNshs2wTWwT28Q2sU1sE9vENrFNbDNtPngqsIAVbGAHBVRwgAZiK9gKtoKtYCvYCraCrWAr2Aq2iq1iq9gqtoqtYqvYKraKrWJr2Bq2hq1ha9gatoaNLKlkSSVLKllSyZJKllSypJIllSypZEklSypZUsmSSpZUsqSSJZUsqWRJJUsqWVLJkkqWVLKkkiWVLKlkSSVLKllSyZJKllSypJIllSypZEklSypZUsmSSpZUsqSSJZUsqWRJJUsqWVLJkkqWVLKkkiWVLKlkSSVLKllSyZJKllSypJIllSypZEklSypZUsmSSpZUsqSRJY0saWRJI0saWdLIkkaWNLKkkSWNLGlkSSNLGlnSyJJGljSypJEljSxpZEkjSxpZ0siSRpY0sqSRJY0saWRJI0saWdLIkkaWNLKkkSWNLGlkSSNLGlnSyJJ2Zsl0nIlnlpxYwAo28LAdb0UNH/cVeNiOt5qGzzcXaOBM9Cy5sIAVbGAH3SaOCg7QwJnoWXJhAd1mjg3soIAKDtDAw3YM4xk+ciywgIdtutiz5MIOCqjgAA2ciZ4lFxYQm2EzbIbNsBk2w2bYJraJbWKb2Ca2iW1im9gmtpm2/niABaxgAzsooIIDNBBbwVawFWwFW8FWsBVsBVvBVrBVbBVbxVaxVWwVW8VWsVVsFVvD1rA1bA1bw9awNWwNW8PWsHVsHVvH1rF1bB1bx9axdWwdm2ATbIJNsAk2wSbYBJtgE2yKTbEpNsWm2BSbYlNsik2xDWwDG1nSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyxEfFzWNI4PBRcRceWRJYDnw4VrCB/cDuKKCC48DhaOBM7A+wgBVsYAcPW/FlOLIkcIAGzkSfg+rCAlbwsBVfdJ+H6kIB3ebL4FNRXWjgYav+7/psVBcWsIIN7KCACg7QQGwD28A2sA1sw23qKKCCAzRwJtoDLKDbzLGBHRRQwQEaOBPnAywgtontyJLZfG8eWRKo4AANnIE+Bi+wgH6uLI4N7KCACg7QwJl4XuOcWEBsBVvBVrAVbAVbwVawVWwVW8VWsVVsFVvFVrFVbBVbw9awNWwNW8PWsDVsDVvD1rB1bB1bx9axdWwdW8fWsXVsHZtgE2yCTbAJNsEm2ASbYBNsik2xKTbFptgUm2JTbIpNsQ1sA9vANrANbAPbwDawDWwDm2EzbIbNsBk2w2bYDJthM2wT28Q2sU1sE9vENrFNbBPbTNs5JPLCAlawgR0UUMEBGoiNLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMsgSHx05j6Ghw0dHBgroqayOA7TEMxQejv5YaToaOBPPx7gnFrCCDeyggApi69g6NsEm2ASbYBNsgk2wCTbBJtgUm2JTbIpNsSk2xabYFJtiG9gGtoFtYBvYBraBbWAb2AY2w2bYDJthM2yGzbAZNsNm2Ca2iW1im9gmtoltYpvYJraZNns8wAJWsIEdFFDBARqIrWAr2Aq2gq1gK9gKtoKtYCvYKraKrWKr2Cq2iq1iq9gqtoqtYWvYGja/LDlGRA8f9jmPccfDR30GKjhAA2eiX5ZcWMAKNhBbx9axdWx+WXKMMB4+zvNCvyy5sIAVbKAHqTkKqInnmYLbzjOFEyvYwA4K6IveHAdooC/6cSXhIzYDC+iLLo4N7KCACg7QwJnoVx0XFhCbYfOrjmMCheET3AUqOEADZ6JfdVxYwAo2MEcO2BRQQbf54elXHRfOQB+JGljACjawg8e6HVNRDB+JGjhAA2fiERWBBaxgS6z+7xbHAlYwn1RMnotMnotMnotMnotMnotMnotMnotMnotMnotMnotMnotMnotMnotMnotMnrFOnrFOnrFOnrFOnrFOnrFOnrFOnrFOnrFOnrFOnrFOnotMnotMnouc40j9ocU5jvTCDvo+ro4KDtDAmej3Hy4sYAXzucjkucjkuYiPI53HTB7Dx5EGGjgTPQkuLGAFG3gcv+Ir70lwoYIDNHAmehJcWMAKus13gCfBhQIqOEADZ6InwYUF9Dtw3gHnvcwTO+g235J+/+HCARo4LzQfRxpYwAoe63bMP2E+jjRQQAUHaOBM9CS4sIBxd9F8QOg8xqSbDwi90EPhwgJWsIEdFFDBAWKr2Bq2hq1ha9gatoatYWvYznuOvsbnPccTG+j3HB+OAiroxbqjgTPRf9yPqTPMx3sGVtAXfTh2UMDDNtx2Tn9/ooEz8ZwB/8QCVrCBHTxsw9f4nAf/xAEaOBO95y8sYAUbGPeKzcd7Birotupo4Ez0nr+wgBVsYAd93fxQ9p6/cIAGzkTv+QsLWMEGus13lvfxMVeF+RjOwAJWsIEdFFDBAcaddPMxnBeWB+i26VjBBnZQQAUHaOBhO0YDmI/hDCxgBRvYQQEVHOBhOybqMB/DeaG3/4UFdJs4NrCDAio4QANnop/8XxhPCczHcAY20G3qKKCCAzRwJno+XFhAXzff6p4PF3ZQQAUHaOBM9Hy48Kh7/FCZj8Cc03eAd/eJ3t0XFrCCDeyggAr60xLfb97dF85E7+7j5WzzEZiBFWxgBwVUcIC+br5RvbtP9O6+sIAVbGAHBVTQbd6b/ot+4Qz0EZiBbpuOFWxgBwVUcIAGzkRPguNplPkIzMAKNv/Mx8O5LywL68JjYVt4wucroRcX5+ZcF24L94VlYV14LGwLT/h89fOYn9fq+ernxX1hWVgXHguf9dV5wuern56r9Xz18+LT6/v0fPXz4tPrO+J89fNi93po1PPVz4vde3xX3er56ufJ56ufxyQhVs9XPy92b/F1P1/9vNi93kr1fPXz4tPr63i++nnx6fV1PF/9PPl89fM8Ts5XPy8+vb6O56ufF59eX8fz1c+L3Vt9Hc9XPy92b/V1PF/9PPl89bP6Op6vfl7s3urrcr76WX35h3urL/Nwb/XlHLrwWNgWnrA9Fi4L14Xbwn3hxWuL1xavLV5bvHPxzsU7F+9cvHPxzsU7F+9cvHPxTrzt8Vi4LFwXbgv3hePJtPkozsABGjgTywM8K5vzueTT2Zf8eChg7UyYiyd8JszFZeG6cFu4LywL68KLty7eunjb4m2Lty3etnjb4m2Lty3etnjb4j2Tp/m2OpPn4rJwX/isI8628ITPJLm4LFwXbgv3hWVhXfj0qrMtPOEzSS4uC9eF28J9YVk4hiVY0wEaeEr9ED1j5OKycF24LdwXloV1YV/Z4wautTNGLp7wGSMXl4Xrwm3hvrAs7N7uO/eMkYtPr2/8M0a6r3uOjLCWIyOs5cgIazkywnzEZqCACg7QwBiHYT5iM7CA5zqe3BbuC8vCuvBY2BaecHksXBY+vdO5LdwXloV14QGfQXHcmbJ+BsXFuvBY2Bae8BkUx5yydn0B+OLz3xfnCZ8NfrH/+37v5fqI78Vt4b6wLKwLj4Vt4QmfgXDx4pXFK4tXFq8sXlm8snhl8cri1cWri1cX7xkIx4uP1s9AuFgW1oXHwrbwhM9MuLgsXBdevGPxjsU7Fu9YvGPxjsVri9cWry1eW7y2eG3x2uK1xWuL1xbvXLxz8c7Fe55a+E2wfp5aXCwL68JjYVt4Jst5anFxWbgufHrV+fR2Z1lYFx4L28ITPvPh4rJwXdifDj4cOyjgKR3OY2FbeMLn2cjFZeG6cFvYV9bvtskZMhfrwmNhW3jCZ8hcXBauC8fIDZMze/xGmJzZc/KZPReXhevCbeG+sCysC4+FF29fvLJ4ZfHK4pXFK4tXFq8sXlm8snjP7PG7j3Jmz/Bj8Myei+vCbeG+sCysC4+FbWEfSujot1AuLOAp9QPzDJ6L+8KysC48FraFJ3wGj9+PlDN4Lq4Lt4X7wrKwLjwWtoVP7/GDLGfwXFwWrgu3hfvCsrAuPBaOgUF2Ddc88BqueeIpnc514bZwX1gW1oXHwrawr6zfqdQzdS4uC9eF28J9YVlYFx4Lu/eYvtj0DJiL68JnfXHuC5/1fZucAXPxWPisP5wnfAbMxWXhunBbuC8sC+vCY+HF2xZvX7x98fbF2xdvX7x98fbF2xdvX7x98crilcV7JtLxHNT0TKSL+8KysC48FvaHzUcI6Rk2fvdVz7C5uC/sJY9vaZle02edPBa2hSd8TZ91clm4LtwW7gsv3jNX/Nawnrni93D1zJWLy8J14bZwX1gW5sr/+ibxxbbwhK97JSeXhevCLdmnQXw+7ujOY2FbeDofreAjB5PLwnXhtnBfWBbWhcfCtvDilcUri1fOOsP5/PePQ8mH/sX/r+ey+fr6sVT8AtJH/yXLwrrwWNgWnrAfS+UYc2Q+CDC5Lnx6q/Ppbc6n17fzOL3iPFiXYQsv6+jHT/F7hT7aL1kW1oXHwrbwhP34CS4L14VPr6/XPL2+XlMW1oXHwqfX133O5HPaxuCycF24LdwXloXP+sf29IF9Txbn82/V+fzb4SwL68IDro+Fzzrm3Bc+60znc38d2+qcYrEcs8baOcVisCx8HsPVeSxsC0/46kFf36sHT67Lv9MW7gvLwsr2OXvwYlt4wlLZDrJsB1m2gwh8HsP+bMDOY9ifB9h5DJ/sORlcFq4Lu8ufGdh5PPtzAjuP54tt4Qmfx/PFZeG6sNf3Zwx2Hs8Xy8K68FjYFp7J8zye/fnEPI/ni+vCbeG+sCysC4+FT9exH32AWnJZuC7cFu4Ly8K68FjYFl68dfHW09uc68Jt4b6wLKwLs09ntYXZpz7sLfn82+58LttxrM6zRy4uC9eFz2VT576wLKwLj4Vt4Qmfv1MXl4XrwotXFq8sXlm8snjP37hzffV0Dee2cGcdz9+1i3XhsfC5LuY84fN37eJzXXybn79rF7eFF+9YvGPxjsV7ZsLFy76zZd/Zsu9s2XdnJly8eG1xXVMQ+7JdUxCfXBduC3sdfy47z96/WBceC5/Hp/fj2fsHz8fZ+xeXhevCbeG+sCysC4+FbeHFWxZvWbxl8ZbFWxbv2e/HNy3m4+zr45nxfJy9fIw6mo+zly/uC8vCuvBY2BY+l1kOvnr55LJwXbixPOdv6MWysC48FraFJ9yXdTzz4eRz8u0Tj9Gq3Zf4nGb7RANnoo8kb74lfST5hRVsYAcFVHCABs7EgW1gG9gGtoHN3zQ5183fNOm+df2dkgtLrpC/U3JhAzt4LPrxYGWeUwNeOEDfUMNxJvo7JRdim9gmtonNB4pfyG6Z7JbJbpm5W86pAS8sYAO9gjka6BXmgf6eyIUFrOBR7Bj8Pc/p/i4UUMEBGjgT/T2RCwtYQWw+OvwYVD7P2fyOccrznM3veMYyz9n8LixgBRvYQQEVHKCB2Dq2jq1j69g6to6tY+vYOraOTbD56HDxvemjwy9soCZ6bx5PkeY5F9+FDeyggAoO0MCZ6L15oTekHyVnQ57YQQEVHKCBM/H8fsWJBfS1UEdf3uE4QAN9ef1Y94a8sIAVbGAHBVRwgBZ4Tqp3YY8mO+fMu9ArTMcBWjRZpSHPOfO8A8458y6sYAM7KKCCAzQwG7LSkOeUeOfyVhbdX9e4cIAGzkRvyAsLWMEGYmvYGraGrWFr2Dq2ju18m9NXqLPy58uaR5acc9udm1oKWMEGdlBABVEI21fYvsr2VfamsjeVvanszbP1fHnP1juy75y6zkPhnLruwgo2sIMCKjhAAzOCzqnrLsRm2AybYTNshs2wGTbDNrFNbDMD75y67sIOjsBz4jkPpnPiuQs7KKCCAzQwA++ceO7CAmbgnbPNXSigggM0MAPvnG3uwgJWsEf2nZPJecqdk8ldOBNbptE5mdyFFWxgBwVUcIAGZryeM8iJ/ed//sOf/vqv//LP//aXf/3bP/3b3//85z/943/k//F///SP/+0//vR//vnvf/7bv/3pH//273/96z/86f/557/+u/9L//f//PPf/L//7Z///vynz8P/z3/7n8//fhb8X3/5658P+s9/4K8fr//0ebJzHDX+58+znVKzxPN85oci5XUR/xyZl3hu+iwwxg9/X1//vT5iDZ5PXlgAbbcXQCUWwB6vFqBvFuB4POV/Px7lnQWYJTbibPJqAfT138tx8e5//3xq/NYCSKzB80r81QLYZgu23IXy3hY4vpxzHUalvFqCsjkU/YvL5054/tWrRdgdy93v5Z4L0Z+h+vpY3hyMzQfLepFnJupSo9+v0UYc0c9mX7Zn+bI5NsdkOZ7Zeon64JB4pvCPFWSzTx/9v2jLnypsDkt/meI8quabFbTnYfGor0vsNqZY7pDnU93XG3O+rvE8O6uxNZ9ZTo3+Y1LWx26nRsi0uRxao91fE+XQej7TfbkmdVNDdMRiyPNhYdbQHzfo8eDjdZ/MCIsiUl+W6LtDKw6M50nd0qvlfgXJyB76usLd1RivV2O3MUeP9ZAh/WWJTXBWyeh/ntmWlyXmp5uibQ7N6g81z4UoS373H2OvbfK7WsnUe1ngF9uysC3t1YZo7eOw2JVo/s791aXzdfI22R1YI5fjuXezxvOK88caujulsTyl0aWC3V6T/nhEZPXnb8HrNbHdb0ieFhRbT63qlwNjc3Q+fXlwPW9Llb5U+fEXsT8+36a9fLxNd+tSffjmuRjPWwXyel3arttG/pg875qwJOXHju2b+Htel2aNUZfw+sa6tJlnO7WvZ21f12VznFbNs66qKsu6/Lgkx93Zlz3nj3bPnnv+oCw1viyHbc+Y4iB7Xim11zV2y1F7/kKvZ39fa8jmOO0zl0Oez1Fe1tjvGX1k2z33rr7cM7I7WSh5hDyvXzc1dkeqzpJHWXu8rrE7UmuNRK3Pu0rv1eg9uv95W+l1gsguUXtsDlVOnZ498GOFsTubNS5R5usSm8P0ef5JBsnjdY3d4XF8vCUW5PhUycsqujlQpVrsFqlzOTx+TEPd5emouUlHt1clttujysjtYa93i+7O447xkPkrpa2/3qq7Q33kWdQTX7fLtnGf92tioz6ffujrhlHd/WAat1Se99ofL8Jdxx/689B9jOt1MbzG8k/rMv/Qn9yueYg8eb7+mRq7s9PG1fB69VW/XNiP+uk23S5FLxmFvT9eLsXulOz5Q5JrUkZ5eUo2ZHcdOWPXtrFc2j9PCW7X6C0v4Xr74Uj/UmN8flI37OMjbLtF89Ll+K16fZK7q1EbNTZ7xcqnN2ysfnrDxtqnN2z2W8KyS563K15vid0FVJv5S9vXH5b64wmy6e6EsOYx3pZflp9qbC/k8jfh2WqbGrvt0fLW7PPRlr6ssd2m2jM39Id1+cYRqrlNn8+p9GWN+fEROj8+Qucfe4SO/EF5Put63e9zc2TUx+CGSVtvFP+YXHNzhB7TJucNa7G3ahyvpsQG1fUS7msN+zyF5/xDU9hfIbr2ytD3jvFpeRH4qPayhl8ZfXjf/NE+vnH+6H/kYf58+DDz+q/VzcbQ7aVoXom29Tivj28U8Wkqr01qfVNkd5Rqy4d0T7Z1o3x9RrS7V5oPVmz5mW5fTiX39ykf3Kd86Kv7lLv7+L3lBnn+vOnrJxK/eM6Ud1zLDw8D5jeK1Mf4Lw+Sn4r0j58HlP2zpjsPBPYlbt0Gv78mY7Mm2/suea+i1U0kl93zppsJsnvcdPPZ27bEzYdv+6dvmSBt9wtVdo9qjjnI86dyTZAvj9/2RSyfno0fDrKfisjnx3rVj4/1bYl7x/rtNdkc6/tNqrlfbL65X46p3PJgXxbkpyK7x09FWh6ruvw4/PR4dXusznzK2+bYRGr7/Omovwb54RHSPn4+en9N3k3DmRfXzwdSutmk9hs26fx8k87PN6n90Zs0j9LnJrX3fvi7Tzd3Femb/bJ7CHVzLIG/ffrpvu2fB2r/PFD7bwjU7Rb9DSeXo8YpXR9jvj65lN2t/ZpXY9rbJpN3T6Dmg+cly9HxNZJ3JyAjU32u4yvk6yCm3Tld4yymr0+f7ct1kOz2LU851xOhLl9K7C73Zx6lxzzzry9fdo+gGq1fluvsal9KbG938kyvrk8ov1Wk2sz76csW+V6RkRn0w9PFn4tsT9mNrluD7Ovu1d0A0pHn28eHzZee+bKDd8+hni2T94TaepI6H28d78uDn6/Hu+5uzGuJDdJ/OBP6shhl+wyqC3dgl8Ej9ctdy7J9CNWr8LiDrfp1TKduD7TsmueN9f66xu7mlOTOfSwndfZle4zdY30edqw/D19LbJeisxS2WYrtsNCe11LPBzdEiH4ZWjp2Z3WPvAVyTEVDEftykI3d2WXhlL1sSsjulmE++V0GVH4tcbdZ7HWz7J5APa8a4jiXpsu9T/vOadCo/GjX8eYP/62RhMV2o/g6t1B739Qon5+O7R9D3Tod25a4dzp2e002p2P7LZojk35IsG/VEO5+ir4+Sbax6xXecHiU/lYNmfmSwr7Gdl1uDVYt8/Hx0bEtce/o2D2Iqj4V0vUAZznR/jJgteweRVnelJrrey8/Lcau7Wu+cSB1GRHwvFX2pcjuYdSdobf7rXFv/G+Z4+Ol2GyMPvOHuk9tm41xu4i9V0QeObJJHtvdsi2iuW8f65Cz7xXJ27hSHvJmkZK36aTM10Xq7olUmY8ctlqOd/mXpyfl3Qh5Ocy7PrZPTrkb/Lp1f/Fze2ewed09kbp7C2VfpGWyP6+zX9/Mqbs3n+pQxq6N1+90lM9/+Gv5+Id/X+Leax3l8x/+X2xRfh7s9Y/ltsbz2RoPYF+fFv6qxuPjGr1kMvdlvMO3ajAi51nudY3d06SbJzHbGjdPYn6xPYbmukz7uIY86pvbNG/UPZ8Hv96324c4yoDT0eumYXYLMvjpHvN1fNTxG3bu+IN3LsHedo3btu80T8bfrqPev7VRedrYbHOUte1N+ryTWzf7dvsMp80cNdEfr0+H9svR8jdqfZHo63Lsf+fyMXBv65PCr79zu5eibl7g1jY+/53bPcW5+Tu3LXHz9cXx+e/cfoveusDd17h3gVt3r0Tdbf39ctx7k7J/PAxlX+Lmnr29Jq+zY/dC1K1z5H3L9nwd6nlPub1uWdle7d8ZyFJ3z6LuDWT5xaoUBlztzrK3y3FvNMx+Qfwj4XE5VzcLIp9v049fzN+X+A2bQ5hwQUrfbY75Rx7pz+dGkT4ic3Mlt3sbqucEFrIEWH18+Z3Vj98w2S6FcCt6GTj/81Ls7qCUPNfvdT0vvV/ieN67zAojj/eKMG70yVreLMIZcllHoHxno+aAcbHdrp1/aInjIwjCRi2vV2X+jj0zf8eemb9hz2w7V/MZkMz1Yed37sFoybXRH9+U/1aRyfOsvjnB3T2Oyhtsy+Cz3r6xED0Hr6s83t0cbbQsMl6P2Kz2+e++ff67b3/wT7ZKLodq2W2OXQzJbHnzVKa8PNh3ryOp5sPK8dDNr+XuvaheORWq8/XInrp7lvS8iZzPCx7t9aWH2ccXt7aLEHswhcHxve+Xt6R/tXMejZ2znOp+4zAZLc/Zn8+lN4fJ9jnMzRu58zfMzjM/n55nfj4/z/x8/Okvtui9G7mzfn4j9xc1Hh/XuHkjd1vj3o3ctntDarlYlznHWzVu3i+8uxzbmwb7bcpbUuscKD8th/6G7aF/9Lrcu7F9t8buxvb+GLt1Y7ttH+LcvbG9XZB7N7Y9uT/dubsadw/20v7gA+TezfFWxm+4Ob5dkHs3x9vuFal75w9t9zTp7s3x/XLcuzn+q7PDvpwdvpyvYzud3c1TzG2Rm9f+23ND5uEsQ18fZFU/Podpu6dJ985h9iXuTax3e0025zD7s+3J6PPHZma88nl8mH1+pO8GCfnXN85VOWYKeWdz1JJ3MGpZrgx/2hzycXjsbtLfDo8mH2/SX9xHWRL5sYwR+s7NmOcfTorUl+HRH5/f0dkW+S13H+9ukf47tkj/HVvk4/uxvxgAVvJFrVLfHc9WHjy7qOV1ke0bo/xIPe9mjpe3H3yk+4fPgZs8Pv+J2T0RuvkTsy1x7yfm9pq8/on5xRa99Rx4X+Pec+C2naTv5pmyfH4p9Yt1ufUsucn8/Oj4fGbf+2vy+uRh91zq3njLfdvnSydjvYr6qe23kXzzzFI/f9206cevm+5L3Nux+vnrpvstevPMcnw+JO8Xy3HrfnIbHw+WartXo+6dje2X4l6J3ca4eY78ixr3zpF3D6PublD7DefI2+W4tUl/McVETtdlxTbT92/n/bn1ltd2rveb5y32+e39Zh/f3t+XuBdg9htu79vHpy37+ffvnbXY/PysZVfj9v29j3frbtj7vbei2udvRbX5W141uf9lhdc/bvPTN0223xMY+Qj6eQt6uV36dRb+3Qx9rfLQpq3HxjdKMP72h+kwfyzRHx9fmW83hs58CGYPebkx+uPjKST74+M5JPclbn5qQj7dJduPROQr5evMWj/NuriroEyKbq8rbGfGyFsLxxxMS415v0bP5xLPGvKyRt8NuC+z5nd+yvGRupdt8vEhvr2RppozJzwfYq3zLn75EsHuac+9jt+XuNfxuxn17m2Ovn2PinlSx5rBXxbi02N8W+HWMb69sXnzGN9/wOTmMV7L58f49usjNW/j/TDd9U9fH9nVECYkFnldY/+Vi5on9k/WzfdHdm9A3eyU+nEQ992Tot8QHF82x3y9ObafY+GEeJ1W46fPsdyuMT6vsTy+/9ZnYR6aZwsPff0plb59/8lGtp3Z5rsw27n0cjyDLSO7vlciJ24yGW+W6LkUyxvL75bQ9t4GrcJM9+v15zeL8LOgRd7ctTMnOno+t3i9X3b3zpvm1UpTm2/V6C1/YHrbHGI3PxvUp2327t1PIO1q3P2c09j0bf/0omm7FIM5uO2xSbHtC1CSnT9kfePwy+/+7uZ5a8Yvw3rb+sv1ym7X1rlMjLG+8vO1Rtk+jMyvFz15+c7W17XZbVWrOWeb/fCj/Y1ct7zueaK+rLH/pZOej2efSbD5pdu9BTW5RfBYbzSML18f2t4lZYsUsc1y7AaJ5C30WTYbdfthKR5Xr3fhf66xu39073tOffdNqJsfdNquy/NROdOL9d1RtpuDf3IRNefuNKZ9HgC7++h3A2D3oOZuAOy/CXU3ALb7pvFJpzbrewfrj0XmyyL7b8LxM1Pt9Zn/vgb3Kp8XAe/VaMoN+cfmu3LbQWJ5TmXvfRSut+z/50WivVVDSo5jlmKvP4HWt1PyaV6CPLG8V2Q05tJsy7CZbxYxySLT3izSmfC9t/ZmEcvnA2M9af7Wzuk5lEjWQfffqjFyi4g9yps18opKrG4Oku1jm/bgK+nPC7PNdt2Oea0MRn6ybo627SeaRBhhJfp4vL00vBb5XJq5KbOdksGWeVNt2LubmC+iPlnePWLWOa7GezV4MC9z+STqt755+cgjV0t5bzm05JWrll0Xzo/Pbraf3lTJmH3y8g7etz7gqZyZPNneraLcC9R1ZtvvVRmVNVo/DPbNKvlI5cmbwN5XsXyO+uRS3l2WZeta2WzdR/kd+STbr0k982l5Xj/n+2XuxdyvVupmzMlj+7zGcpr6J283sfyOtPzF/pbl2NO3jz2+Uq4m73bT5KDRqf3dKnzgV+eY71UZNb88eLC8W4WP0Y5qrw+83aXY7/nM7+ApjA0pb1YxhnWblcebVeayLHNzqrz/5DAfHh2bJ4XbGsZgMVtnN/9WDeHGkL6+Ctrf1Jn0T1vH3P/8zfKyPVfI4+T1dwT3JW49MNyXuPXE8BffcF4G/s/HqxkyZPdcapbBraWXz6X2JWrOKDNrtXeeSzXhhk5bx9F878vYfH60tFE2n4HfjXC697BvX+LWwz7ZvUv1Gx72/bg56vsblZ4b7c3OPT4BTRXZ3ElpHz+Hlc8HxEj7Y5/D/rg5Ns9hf7VruEheP+Xxra+n34qybYV743t2a/K8c7J8jHl3k2w7YuDWQJBtiWcaNj7HrP3NImM5n1mP9u8VyQdUTzZ95zg7vvyZ21Xa65//sZ3rWPPM6smzvFXleSs1T0TaY308Xd+rUep7NSRnHHzeIC5v1WgMHW2PH57Gfqmx+9W8N7hvbF8wLflAt/zwCfN2v0bJO+3PXOsva8jubaibubwtcS+Xt7e4b+XydmPUxusIP5wsf9kYun3MntetfVbdFNm9Ss30WMvlw9e7SPvFUBZjmebnm+vChIM/fuz6e0X4RoG8vVXzLQ956OP1sb5/ySMn02+7Gvbpz+W2wq2fy9163B0quK1xc6igjN8wVHD7dXnJyzGT+noGWBkfD2Xdl7gXQOPjoaz7jaHLEK6x2Rjj042x/ax7zTdvWquvP+suY/umyJ0x9GIff156X+Lm56V3XyW5XWN7sc7FWF0/5PHl+/Sye4I087bSXN6Nt+984f5mx+6LaB08FajLGyc/fWdyX4bp7J68/Lx8u0ylTK+bMpvDlUmT12lt2pcz3F8tCa8i6g/vIn5vhXrncUlfnwp8r4wsm1eWtwm/lpHtBHm/p0x98KLUY72X+fUCb1uEqZyf953lzSI1M7bWIZtdvRujxid16jP2X7fz/PxDzb+oQSvKMqvkT7/j2yI3Tyh+sST3zih0+wzqdj7tPziQh4lMe7lzdBf60nNAtvwwzW3/WmT39OnebAL6+HyeKv/U5evf4jtvbe5L3HoZ9/6ajM2a7LbovdkEtHw+T9UvluPWbAK6e3vq3svvWnZjSm7PTrtfkluvv283yM0ZBX5R49aMAlrs8426vbF6b0aB/XLcm1HgFycCy4iHvgy4/frTq7V+ej2wL3Hr4khr/0NL3Jyk6heblCHdz80rLzfp/PzF3O1L35LH2NDy+nMQ26tFBixZq/3Nq8V7++XzZ1W7cwfTnPfC1vsqP22Njx9kzI8fZPyOE6nfch61/W7T3TszuzSWvJFZ15G6X3eKbh9B3DwD6p9Po6b942nU9iXunQHdXpPNGdB2i948A9p9P+ruGdB+Oe6dAfWPp//R3StY3zgD6h9PALTdIHfPgPY17p0ByceTVKn8hi/67Zfj1ibdBvLIQb0m70V6DtNUez3Wxz7/rbft47Gcj/J5Z3V9FFPu1xj589bmDyOf7td4PljPz1Y/fhiD8eXQ2D2Zunc2uV+MPKvtZbsYn0/s9Isa9+6d7Ivc/Mn/xZLc/M3X3/Cbb9uTD2H4QxmvD7PdnEgMoaiq+l4NyREUVUd/fYyM8ukTCN1NtXfvCcS+xM0A2W7RZRDnQzdbY/sWy72523Vs35rOfdsePzwZ+roku9/am58H0u20fzdPP8bH0/vr7vnSN04/frFzbn0eqG3n1be8DFvPHb7OfKW2HUN16+tAun3R6eb5un38kdR9iXvn67fXZPMrs9+it74OtK1x8+tAv6rx+LjGva8D7Wvc+zqQzs8/mLKtcXNCxbvLsa2x36a3vg7kw3A/3h7jj16XW18Hul1j83WgXxxjt74ONLaPom5+HWi/IPe+DjS2T6Lu7dxtjZsH+93leP8Aufd1oLG9h3vz60D7Bbn3daCxmw3w3unD2H6C6uaF9n457t27+NXJ4Z2vA43yGz5AuS1y72by/tTw3j3HUcbH5zBj9wjo3jnMvsStc5j7a7I5h9mfbN+65zjq51/S25+w3zzS7fO7dPsat+7Sjaofh0cdvyE8tstxa5NuB7Teuku3r3DnLt1+VH9e+zxxnTDmG28GKG8X6Gzv1bB8E7uut+m+93YBJy+P+npdZHcH9+4rCtsiz/2Zz9RsvHy/cFtiZrvprOO9EjzZWz/no/f3ysgftzp+mC+qvlmjv1mjUqNtjrD+8eP8fYlbz3xH739oiZvva2y3p/6XL3x9b58s99bmm8mxLse7NfipP96VfrNGr3dq6MfPXPTjZy6/eKU4b6rPWt98KznnEH3iy1fwtq9o39oUvyhxa1tsX5xnLtQfTiO/9fJ9Ya7LzYvA+xr5olhdJyH7Xg36xObmfdX95AqdaRFMXs/T840qm0l2flWlU2W8nv5i7CYAvDmt4thNAHhz4qFfTDhRmcd4bqZV+8U24XrjuZPfnvxiXZb2dhWuam32N6dKGZW3k5+/4O3dKrpMcvL2hCu8w/bkWt+t0pcq8u60La2tVfTdKst9tmZvb5exVJmPN6v0ZTqbXt/d0/2xVnn7qGMOzNHbJlu2z6f68pJN3x0wvyrDe/HPhSmbMrt7qrdnY/rV0uSFyZM3c7V9Z6U+KDN4y36d8/TnMvr/x7ZZ7gqscyl8sFIflOmFuQN2E2SO+fj/YdvwcbQnd/ktK9Xfjc/Hg7EW63d7vzmP13wsVV4ffL+YxjQnQ37ifLOIFsY01/FmEclBLEPmu6sz8hHBsLcnmV1X5/0iTFSv491JZkeOxB2j9HeXJN/lfxaRd5dEmHdf+m/YO+V1JNjvmdjvF1PvFr1zpOxneG7MEi2vJ6/ZfzEn56uv6xjBr1+7scfHU1ftS9y6r2O7Z1q/ocTNj0Lttmdjmpc2Xn89yHbPom7NwrFdis7NpfV5+M9LoR9fHtruIdDdWfe331OpfOqwyst12ddYP4T5env03WtAdz8MtS1y79b2vsStW9u/KHHn1nb/+B5V//gW1fYDf7eWYV/hzjLsPhCdEwzLcq/gmI3wboHJ3M/yToHyqHwrRN8rUfg61zqf07dKKJ9wsPeWoi0T/s33lmKZzlH6eK+E8tR6faD3nRVhFtZ1dolvleD+XpO3VqSOPMF4PvN569gsqkxZPd5bkTG4mbB+leMbJZh9pMz6VomRjyfWScC/UWDmj/qUt7bDzKfu6/3N7xTI/ppDPlyF9woI96jkh1tU1m6XkLwtKtLfLJGPFJ7VyjslauE9gfX7A99prsJD2bKM9PlWCZ7618dbQVN51PQ8jX+rMyqDDX8ce/CdpciUeD4ye29zthyE/lyl8t5SMACiPep7B3hmlfT1wwXfOTrzLvkTx3slqnCAP94pUYYsM3iun6L+cua++0xVHTm7ch311bi8fW7n7/lcZ54q3/j1MD6Vvn6h6qcV2Y7ov/M2ju1mvL73Ns6+xL23cbaBYXxXqj42G2P/QQH2io6Xl7i/KtLWrxK8emnE9iOnGA8n682Lr6uze8epLJ/s+3Gzji9FNheHxuelrMjYFNkPgVheUGqb1dk9TC2Nq4FlyGR59G8U0byjo7pO8fytIpbDuH64xvy5yMfD636xHLpc69rr5djdN+98R6BbW27Y/fRi4G7EtNZltrclBfQ7m5UPOz7vmW/2zXYI+aPx7eDlKHk+cftSZDelX8lRsbMsH1T9ucjuXmiT5VtOc5bNpt0uS97hmVV2yzJ+Qxfv31XKp/+tLjO1/rwku3gUyy/vFZlTXpfZPXu6H0vbm++23DffJMrcDtvLIZ19fQP8S4Xd+0pcjMoPE8ZL+1JkN/RvHZ+63kv8WuQX383LpxG2/uz8tEF2j0z9tYg4wVqKyJcfwO17Tw/ONh+bEvYbkmA3VcHdJJiPx29Jgu0K3ey/uf+e1N3+83dfP+6/uZ0Aj/co2sudPLeTk/GRrec5+WbiqIf+0SvDwJDHcpX289psX2HonMUW26zN/B1ro9sf9LyvNGyzOttnTo+84Hve9dsVqb9hD5ffcLjuV6fkE9JWlxuoP6+O/IZdXPSP/vWbfK51/WDZ17Cf+4n98hXG/lhOhX8Kk+3Ufr0yOGZ5o2p+mZ+rPnY7J+/VPPfTckJtX4vsX/LIH/P1Xn9rXzbJ7pUqK7k2zyeI8/Ueru3z+4n7bVI5J2jLj9fP20R+Q+tsl6QXXqde7h79vCTbcwLOkx5r/+k3jlfa73muo6+P1/o7Enb7QlHpvPn/eH3HYrbyG8Kx1T96dWojHNfpQ35anf4bwrH9hgN2d0088vMHz9ue8527c11zuuM++thsD/v07tzczV127+7cvsTdybb2d8WW72O+/vrS7PXzW2vbIvdGsWyP9bsbZOzn1OYGsLx9c+7eT80viuRIAavl9ZLM3YR/Y+ap3pjr6x8/FdkNc5L49e3l9XPA/T0kLhxVls8x/HwPaXvLJS+Rnr9q491bLjf3zb7IzX2zGwl3e9+IfLxv9rd+lmNeZi/v3vq5uWH3Re5u2PkbNuzuG0o3N+z23k9hGsL1xsDXez9z90iLe6/rAf+dOyU3m2Zf5N7Nzqm/44x1X+TmWfy+yM2jTH9HtOrH0fqLO0d32/cXd45ubtjH7/jN2v3w3d6wo3/evrvrmjyd+OG7GF/vKuxmAOyMMe5tmZ3gpwTY3kvjnk/VXt69l3Z39+pv2L27B1u3d+/uwdZv2L28MzmXd/p+2r27Jy9ScooCKetctT/tXtsV4TirP9yhbN+5uXh3987fsXvH79i99nEs7u4KVkbg1XX82087eG4nrerZv4/1g59f9832Tund/i2/I57L74jn+TtOW6f8oTu4lRxU155XnZsdvJtd1fLyt5vJZgfLb+jg8jsCuvyGgH5eH5fP9/Bxlf35Lt5+W6Yxunp52vHlBvRzOXYzp+Sox/ULJs+nod+oITlHmujbNfKda1neZ/9mjZlvQDzab6hhb9bQ3B769vbQ3B769vbQXJfx9vZYa7y7PZhDb7y9PUZuj/H29hi5Lvb29lhrvLs9eF/I9N3lsHzJdn1f8Zs18sngfHt7rDXeXY6ZsTw3GfSLZ2DKWL11Qoz29UuMdTvXa76S2n6Y+OF7VXoeq00e9m4VpqFruk6g8r0qI2/GH/Ol/ufrZ4O7E/mbQ6B/UeTeKP9fPKW8+wvefsM11rPKxxdZzxq7k9+bbwz8osrNlwZ+UeXm20X7R6Z8zLSt3xH75sPbu8+i5bccKvZbDpXP72Ptn0Xnyd7zWXR5uWGfjwy2VwU5VLytX7398jD6WWR3S215KPbjD/rXIruZGJdPrLU3Sxhjke3dEo//8gzp/uP9PvMelvzwIZyftuiuCGedXdeRg+8XaS8HGtwf8aCbo0y2k5rwQkJv9np1ZPcu8aMzx+/cbJPdd6NKqSzKM1X67ymzGcWxHTD0YJaJzYCh/cilfF7xrPZ6eOhzfbZfkH/wdvA6f8dP5xayO+DyW+l9nQ6ttq81fku+yvz8p1h/w8t7v6hy8521X1S5+1O8HzTEtNCl6eZQ0e2TAj4E017fYlD5bokyHl9y6XfcwK2/4Qbuc21+yxGrv2HQwN3Xk/rr15Oeh8HuHRhbpjVcBg/2H18F2I/nunsLt/2OAYjtt1wf/GKM6c1dvHu6dfOkbzey7Pat0/Y7zqbbbzmbtt9y4fUbnm5tx/0x9WVrP3wk+BtF+oO74w+tmwbcDdv5PVXuzUHzixq3JqH5VY07s9D84kL05qvjv7oovvdL/IubFvfe3P5FkY+nSHiekOSb22WZ3u9LSp+fs3nZw/muxyyvPxPxrLGdnyzv99W+jiL88p2I/UQLOXNzWXrv53XZfTyQbyE9diV2n5iZfNfgyevsAF/eb9q92p8zosr6eYVvzDZU/qtXxr5RQPOiYr1L+J0Ctz52vitw61vnuwK3Jn3aFvhwzqd7w2u3l7z5xl3py7QG7cu8fdtpisry4db+VomxzMXc31sK02XKbX2rxMw7vWX+8G72/RLKdBc63lsR5dNe64dOv1PisbwdZ+8tRc2R7KWuQ9m/UaIx2ff6kcNvLUUO1ChV31sRfpRLK/rptni7hExWZP0qxXeWYrBH6ucl9K0SLadieaK9V0J5/D/aWyXWyOnvbYvGFP39h68UvVnivZ26vou3PFz6VglmRuuqb5ZgRX6YKPQbJfLipnR7b6f2yef3Ho83jwtmzKtv7VS+vPnDfeT7BTg0pb7eDqXsrlqfudeJi+Wc9xsTSPFC43hrNfK78Nrf2heSv4Syzkr2jQI54ZLM9l6BHJoz+2cF1nE539qIPAp4Kys1b1Wv87y8twRfd+N/f/7Pf/6Xv/z9n/76r//yz//2l3/92/99/t1/HqX+/pd//h9//fP1P//Xv//tX5Z/+m//7/+Jf/I//v6Xv/71L//7n/7P3//1X/78P//9738+Kh3/7E+P6z/+mx2zU9ho5b//w5/K838/7xqNf5jPi67n/27HP9fnxZI9T3OOf378wfOc3P5BtbXj//C/OJ4dPf9j/vf/PBb5/wM=",
      "brillig_names": [
        "is_registered_l1_unconstrained"
      ]
    },
    {
      "name": "is_registered_l2_unconstrained",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "aztec_token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "is_registered_l2_unconstrained"
      ]
    },
    {
      "name": "process_message",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext",
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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lUkyKGbiKjEKYi6uCw2sYAN9YgzgCxOYwQJic2yOzbE5Np+2c6auCxOYwQIKqKCBFWwgtoQtYUvYEraELWFL2BK2hC1hy9gytowtY8vYMraMLWPL2DK2gq1gK9gKtoKtYCvYCraCrWATbIJNsAk2wSbYBJtgE2yCTbEpNsWm2BSbYlNsik2xKTbDZtgMm2EzbIbNsBk2w2bYKraKrWKr2Cq2iq1iq9gqtoqtYWvYGraGjSwpZEkhSwpZUsiSQpYUsqSQJYUsKWRJIUsKWVLIkkKWFLKkkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZEt2UJe5dRDflQJ84piPONuYjzjYmJM42ZiTONqYkzjbmJM42JiXONmYlzjamJc425iXOZtNh02HTYdNh0xEju08CkKN9cmAFY2U00CfGyJaYazxG9oUZLKCAChpYwQb6xIatYWvYGrYY2RK7JEb2hQZWsIE+MabgPYLSpDypTJJJOqlX7A+Ocz3nDU+Bcb8lBxZQQAX7kvbnwrmec4if2ECfGOP0wm5rQXlSuDRQQAUNrGADfWKM0gsTmEFsGVvGlrFlbBlbjFLt+yBaIQcmMIMFFLDb+tv2OVohB1awgd0Wj4KjFXJgArstHgVHK+RAAcNmgQZWsIFh60Mumh5LPFKMuRgHCqhgDPw4ns6RH8fTOfTjcDnHfizvOfhjyc7RH+Jz+J9YQAEjZWLJzhnKT6xgA8MWmzqGfTy7iqbHEs+CoumxxKOeaHosLRYnhn2LFYphf2EFG+gTY9hfmMCwxTLEsL+wKzw2VIz1CyvYwK6IhzbR6TgwgRkscxSf3xE4UUEDK9hAH9jObwoExtCNxz7Rhjgwg10cD4OiDXGggrGaNbCCsZoe6BNj8F4YmRbLkDNYQAEVNLCCDfSJ5QCxFWwFW8FWsBVsBZtE3RwYFWJDxez1/W2uHK2FAw2sYCyvBfrEmNv+wgRmMGyx+WKO+wsVNLCCDfSJMd/9hQnMIDbDZtgMW8x+31sWczs/JnCiTzw/KHBiAjPYbfFIK1oLByroE2OS+xT7Iqa5vzAWMo6+mOr+QgPjqU7srJjw/kKfGL+48aAregQHhi12QPzoXhgLGYseP7vRsRE9ghIPpKJHcGC35djzMQ1+YPQIDkxgBgsooIJh08CwWWDY+hrHvInSW/VyTJwovSkvR+fgQAEVNLCCbWKM2Hj2FI2BAwVU0MAKtokxyOIxVMxxOLCBPjGGXm/ry9HhJ/HIKjr85PrGSgEFVNDACjbQJ54fmzgxgdgUm2JTbIpNsSk2xWbYDJthM2yGzbAZNsNm2AxbxVaxVWwVW8VWsVVsFVvFVrE1bA1bw9awNWwNW8PWsDVsDZtjc2yOzbE5Nsfm2BybY/NhK9H3NzCBGSyggAoaWMEGYkvYEraELWFL2BK2hC1hS9gStowtY8vYMraMLWPL2DK2jC1jK9gKtoKtYCvYCraCrWAr2Ao2wSbYBJtgE2yCTbAJNsEm2BSbYlNsik2xKTbFptgUm2IzbIbNsBk2w2bYDJthM2yGrWKr2Cq2iq1iq9gqtoqtYqvYGraGrWFr2Bq2hq1ha9gatobNsTk2x3ZGRQ2MYi2wgT4wnVFxYgIzWEABFTSwgg3ElrAlbAlbwpawJWwJW8KWsCVsGVvGlrFlbBlbxpaxZWwZW8ZWsBVsBVvBVrAVbAVbwVawFWyCTbAJNsEm2ASbYBNsgk2wKTbFptgUm2JTbIpNsSk2xWbYDJthM2yGzbAZNsNm2AxbxVaxVWwVW8VWsVVsFVvFVrE1bA1bw9awNWwNW8PWsDVsDZtjc2yOzbE5Nsfm2MiSRJYksiSTJZksyWRJJksyWZLJkkyWZLIkkyWZLMlkSSZLMlmSyZJMlmSyJJMlmSzJZEkmSzJZksmSaAeU+HZctAMOrGAv1m8Ml2gHlH7Du0Q7oPS3bEo0/kl/y6ZEY5/0G60lGvuk374s0dg3MIF9NTX+Wgz0CwVU0MAKNtAnxkDXWN4Y6BdmsNv6bcISLXxisTgxpC/sde38sz4xhvSFCcxgmRViSF+oIDbDFkP6Qp8Y4/jCUMSmjnF8oYAKGljBBvrEGMcXJhBbw9awNWwNW8PWsMU4ttgtMY4vTKCAUSGOyRibFodRjM3Acn7j7sQEZrCAAvbl7fdTS7QCDqxgt/W7rCVaAS+MsXlht/X7qSVaAQcWUEAFDaxgA31ijM0LsWVsGVvGlrFlbBlbDN5+e7dEK+CFMXgvjLotMIrFNovBe2IM0/6eQ4mWPel3hUu07A1UsC9Di40aw/TCvgwtFieG6YnxG9tCHKOlhS1Gy4UGVrAX81icGC0nxg/ghQnMYAF7XY/ljSFyYQOjbix6DJELE5jBAgqooE2MH6p+/7dEL9tABQ2sYANjyXrYRC/bwARmsIAChs0CDaxgA8PWj5LoWpP+vkGJrjXpd5tLdK0NVNDACjbQJ8YnIPtkaCW61gZmsHRMgQIqaB0lsIIN9InxWcgLE5jBAoYttlkJW2yHYhMlKsQmkQwWUMBYslhjaaBP1ANMYAYLKGBfshQbqv+SDaxgA31i//nSFJuv/3wNjGI5MP5arLz5xD7IBiYwgwUUUEEDK4itYmvYGraGrWFr2Bq2hq1ha9g86sax7lEhdqxHhdi+bmCvkGPz9QE50AdGQ9jABGawgAIqaGAFG4gtYUvYEraELWFL2BK2+EZrf7WjnF9pvdAnxjC9MIEZLKCACkbdfnCd32TtL3SU86us/a57Ob/LeqGAChpYwQb6RDnABGITbIJNsAk2wSbYYvD2pwQlmrwGJjCDBRRQQQMr2EBshs2wGTbDZtgMW4zu/lSjROOW9qcaJRq3BsbpeBwacZZ5oYIGVrCBsbx94ETj1sAEZrCAAipoYAUbiM2xOTbH5tgcm2OL0d2foZRoxtL+rk+JZiztz0VKNGMNFFBBAyvYQJ8Y4/jCBGJL2BK2hC3GcX94U6IZa2ADfWKM4wsTGDYLLKCAdWL8hF7fQk9gBqNCDhRQQQMr2MBY3v67GTPiDUxgBgsooIIGVrCB2BRbjOPz4+0xji8sYLdJLG+M4wu7TWKjxjiW2EMxjuNSOZq5LoxxfGHYQhzj+MKweWC3xciKli7VsPUT5IEVbKBPjN/uCxOYwQIKiK1iq9gqtoqtYWvYYkhrbJ0YvHEbIHqzVGM7xOC9MIGxkHFwxeC9UEAFDYy6fUtGh5b2HqISHVrap5Mo0aE1UEEDK9hAnxiD98IEdlv/MkyJHq2BAoatBBpYwQaGrW+o6NEamMCwWWABBVTQwAo20CfGQL8wgdgKtoKtYIuBHndGokdrYAN9Ygz0CxMYthpYQAEVNLCCDfSJMdAvTCA2xabYFJtiU2yKTbEZNsNm2AybYTNshs2wGTbDVrFVbBVbxVaxVWwVW8VWsVVsDVvD1rA1bA1bw9awNWwNW8Pm2BybY3Nsjs2xOTbH5th82qKfa2ACM1hAARU0sIINxJawJWwJW8KWsCVsCVvClrAlbBlbxpaxZWwZW8aWsWVsGVvGVrAVbAVbwVawnVnSAg2sYJt4RsWJ8dc80MD+13qDZYk+sYE+MUIhbghGn9jADBZQQAUNrGADfaJhM2yGzbAZNsNm2AybYTNsFVvFVrFVbBVbxVaxVWwVW8XWsDVsDVvD1rA1bA1bw9awNWyOzbE5Nsfm2BybY3Nsjs2nLdrLBiYwgwUUUEEDK9hAbAlbwpawJWwJW8KWsCVsCVvClrFlbBlbxpaxZWwZW8aWsWVsBVvBVrAVbAVbwVawFWwFW8Em2ASbYBNsgk2wCTbBJtgEG1niZImTJU6WOFniZImTJU6WOFniZImTJU6WOFniZImTJU6WOFniZImTJU6WOFniZImTJU6WOFniZImTJU6WOFniZImTJU6WOFniZImTJU6WOFniZImTJU6WOFniZImTJU6WOFniZImTJU6WOFniM0vkmFkix8wSOWaWyDGzRI6ZJXLMLJFjZokcM0vkmFkix4EtYUvYEraELWFL2BK2hC1hS9gytowtY8vYMraMLWPL2DK2jK1gK9gKtoKtYCvYCraC7cySEugTzyw5MWwamMEChq0GKtht/ZmaRIvbwAb6xMiSC7utP2mTaHEb2G0tljeypMWSRZZcGDYJrGADw2YdI0suTGDYWmABBVTQwAo20CdGllyYQGwVW8VWsVVsFVvFFqnRHx1KtK2px5aMfPDYfJEPF1awgX15PbZk5MOFCcxgAcMW2zfywWNxIh8urGADfWD0tQ1MYAYLKKCCBj5s1l+vkOhrs/6US6Kv7cKeD9bfiJDoa7P+qEiir21gAftf60+NJFrRLEXdPnit9/xLNJ0NrGADfWIfvAMTmMECCoitYCvYCraCTbAJNsEm2ASbYBNsgk2wCTbFptgUm2JTbIpNsSk2xabYDJthM2yGzbAZNsNm2AybYavYKraKrWKr2Cq2iq2GLY6+2kCf2A4wgRksoIAKGoitYWvYHJuHrQZmsIACKmhgm0PEfWB0mg1MYAYLKKCCBlawgdgStoQtYUvYEraELWFL2BK2hC1jy9iIipiZbiC2jC1jy9gytoytYCvYCraCrWAr2Aq2gq1gK9gEm2ATbIJNsAk2wSbYBJtgU2yKTbEpNsWm2BSbYlNsZ4D0H4l8BsiJCcxgAQXstv4oWaLFbWDYPLCBPjECpD8eluh2G5jBAgqooIEVbKBPbNgatoatYWvYGraGrWFr2Bo2x+bYHJtjc2yOzbE5Nsfm0xadcQMTmMECCqiggRVsILaELWFL2BK2hC1hS9gStoQtYcvYMraMLWPL2DK2jC1jy9gytoKtYCvYCraCrWAr2Aq2gq1gE2yCTbAJNsEm2ASbYBNsgk2xKTbFptgUm2JTbIpNsSk2w2bYDJthM2yGzbAZNsNm2MiSQpYUsqSQJYUsKWRJIUsKWVLIkkKWFLKkkCWFLClkSSFLCllSyJJClhSypJAlhSwpZEkhSwpZUsiSQpYUsqSQJYUsKWSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkiVKlihZomSJkiVK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",
      "brillig_names": [
        "process_message"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2550444873539515884": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3263449651635518104": {
            "error_kind": "string",
            "string": "Shield gateway address cannot be zero"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7069518359247663558": {
            "error_kind": "string",
            "string": "Function _claim_public can only be called internally"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8459146718181593566": {
            "error_kind": "string",
            "string": "L1 portal address cannot be zero"
          },
          "8606784891595333955": {
            "error_kind": "string",
            "string": "Token contract class cannot be zero"
          },
          "11430482739715627628": {
            "error_kind": "string",
            "string": "Function _log_claim can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14788743618517749904": {
            "error_kind": "string",
            "string": "Function _register_public can only be called internally"
          },
          "15520311074722577191": {
            "error_kind": "string",
            "string": "Function get_config_public can only be called statically"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBtJwAABAMnAgIEAScCAwQAHwoAAgADgGwuCIBsAAElAAAARSUAAAISKAIAAQSAbScCAgQAOw4AAgABKACAQwQABikAgEQE/////ygAgEUAAAEpAIBGAEfazXMoAIBHAgDZKACASAIAyigAgEkCAO0oAIBKAgASKQCASwRqCeZnKQCATAS7Z66FKQCATQQ8bvNyKQCATgSlT/U6KQCATwRRDlJ/KQCAUASbBWiMKQCAUQQfg9mrKQCAUgRb4M0ZLgAAAYBTKACAVAQACQEAAAGAVAABKAGAUwQAAQEAgFMAAoBULgCAVIBVLgSAS4BVAQCAVQACgFUuBIBMgFUBAIBVAAKAVS4EgE2AVQEAgFUAAoBVLgSAToBVAQCAVQACgFUuBIBPgFUBAIBVAAKAVS4EgFCAVQEAgFUAAoBVLgSAUYBVAQCAVQACgFUuBIBSgFUoAIBUBABAKACAVQQABCgAgFYEADgoAIBXBAAQKACAWAQADigAgFkEAAMoAIBaBAEAKACAWwEAACgAgFwCAAAoAIBdBAAAKACAXgAAACgAgF8BAAEoAIBgBAABKACAYQQAAigAgGIEAAUoAIBjAgAIKACAZAAAJSgAgGUEAGQoAIBmAACjKACAZwAArSgAgGgAALcoAIBpAADZKACAagAA3isAgGsAAAAAAAAAAAEAAAAAAAAAACYlAAAydikCAAIAiFImEwoqAQIDLQgBAicCBAQCAAgBBAEnAwIEAQAiAgIELQoEBS4MgEUABScCBAAGLQgBBScCBgQCAAgBBgEnAwUEAQAiBQIGLQoGBy0OBAcnAgcEACcCCQQDACoHCQgtCAEGAAgBCAEnAwYEAQAiBgIILQ4HCAAiCAIILQ4HCCcCCAQDACoGCAckAgADAAACsiMAAAfgLQgBBycCCAQEAAgBCAEnAwcEAQAiBwIIHzCAWYBgAAgtCAEIAAABAgEtDgcILQgBBwAAAQIBLgyAXQAHJwIKBAstCAALLQoIDC0KBw0ACAAKACUAADKfLQIAAC0KDAkBIgAJgGAACy0LCwocCgoJACwCAAsAAAAAAAAAAAAAAAAA//////////////////////////8OKgkLDCQCAAwAAANZJQAAMxYnAgsEDC0IAAwtCggNLQoHDgAIAAsAJQAAMp8tAgAALQoNCQEiAAmAYAAMLQsMCycCDAQNLQgADS0KCA4tCgcPAAgADAAlAAAyny0CAAAtCg4JASIACYBgAAgtCwgHHgIACAAtCAEJJwIMBAMACAEMAScDCQQBACIJAgw2DgAIAAwAASIACYBgAA0tCw0MASIACYBhAA4tCw4NHAoMCQAEKgkNDiQCAAwAAAQOJwIJBAA8BgkBLQgBCScCDAQDAAgBDAEnAwkEAQAiCQIMNg4ACAAMAgEiAAmAYAAMLQsMCAEiAAmAYQANLQsNDBwKCAkABCoJDA0kAgAIAAAEYCcCCQQAPAYJAS0IAQgnAgkEAgAIAQkBJwMIBAEAIggCCR8wgGCAXQAJASIACIBgAAwtCwwJHAoJDAQcCgwIACcCDAQPLQgADy4IgFsAEC4IgF4AES4IgGoAEgAIAAwAJQAAMygtAgAALQoQCS0IAQwnAg8EAwAIAQ8BJwMMBAEAIgwCDy0KDxAtDggQACIQAhAtDgkQJwIIAA0tCAEJJwIPBAIACAEPAScDCQQBACIJAg8tCg8QLQ4IECcCDwQQLQgAEC0KCREtCgwSAAgADwAlAAA4ny0CAAAtChEIJwIMBA8tCAAPLQoIEC4IgFkAES4IgFsAEgAIAAwAJQAAOP8tAgAALQoQCQoqDQkIJAIACAAABXElAAA6aQsiAA6AXgAIHgIACQEKKg4JDBIqCAwJJAIACQAABZUlAAA6ewsiAAqAXgAICyIACIBbAAkkAgAJAAAFsiUAADqNCyIAC4BeAAgLIgAIgFsACSQCAAkAAAXPJQAAOp8LIgAHgF4ACAsiAAiAWwAJJAIACQAABewlAAA6sScCCQQMLQgADC0KBQ0tCgIOAAgACQAlAAA6wy0CAAAtCg0IJwIMBA0tCAANLQoIDi4IgGEADy4IgFsAEAAIAAwAJQAAOw4tAgAALQoOCTQCAAkrAgAIAAAAAAAAAAADAAAAAAAAAAAnAg8EEC0IABAtCggRAAgADwAlAAA8eC0CAAAtChEJLQoSDC0KEw0tChQOLQgBCAAAAQIBLQ4JCC0IAQkAAAECAS0ODAktCAEMAAABAgEtDg0MLQgBDQAAAQIBLQ4ODScCDgQPLQgADy0KCBAtCgkRLQoMEi0KDRMtCgoUAAgADgAlAAA9Cy0CAAAnAg4EDy0IAA8tCggQLQoJES0KDBItCg0TLQoHFAAIAA4AJQAAPQstAgAAJwIOBA8tCAAPLQoIEC0KCREtCgwSLQoNEy0KCxQACAAOACUAAD0LLQIAACcCDwQQLQgAEC0KCBEtCgkSLQoMEy0KDRQACAAPACUAAD4vLQIAAC0KEQ4tCAEIJwIJBAUACAEJAScDCAQBACIIAgktCgkMLQ4KDAAiDAIMLQ4HDAAiDAIMLQ4LDAAiDAIMLQ4ODC4IgF0AAyMAAAekDSIAA4BVAAckAgAHAAAyRCMAAAe5HgIAAwA0AgADACIGAggtCwgHJwIJBAIAKggJAzsOAAcAAyMAAAfgKQIAAwAod4j/CioBAwctCwUDACIDAgMtDgMFLQsCAwAiAwIDLQ4DAi0LBQMAIgMCAy0OAwUkAgAHAAAIIiMAAAoYLQgBAwAAAQIBLgyAWwADLQgBBwAAAQIBLgyAXgAHLQgBCAAAAQIBLgyAaQAIJwIJBAotCAAKLQoDCy0KBwwtCggNAAgACQAlAAA+oy0CAAAeAgAJCQsiAAmARQAKJAIACgAACIwlAAA+yC0LAgkAIgkCCS0OCQItCwUJACIJAgktDgkFJwIKBAstCAALLQoFDC0KAg0ACAAKACUAADrDLQIAAC0KDAknAgsEDC0IAAwtCgkNLgiAYQAOLgiAWwAPAAgACwAlAAA7Di0CAAAtCg0KHgIACQAzKgAKAAkACyQCAAsAAAkOJQAAPtotCwMJLQsHAy0LCAcnAgoECy0IAAstCgkMLQoDDS0KBw4uCIBFAA8ACAAKACUAAD7sLQIAAC0KDAgBIgAIgGAABy0LBwMcCgMHACwCAAkAAAAAAAAAAAAAAAAA//////////////////////////8OKgcJCiQCAAoAAAmPJQAAMxYBIgAIgGEACS0LCQcBIgAIgFkACi0LCgknAgoEAycCDAQDACoKDAstCAEIAAgBCwEnAwgEAQAiCAILLQ4KCwAiCwILLQ4KCycCCwQDACoICwotCgoLLQ4DCwAiCwILLQ4HCwAiCwILLQ4JCwAiCAIJLQsJBycCCgQCACoJCgM7DgAHAAMjAAAKGCkCAAMA/9wXPAoqAQMHLQsGAwAiAwIDLQ4DBicCAwAFJAIABwAACkUjAAAOxS0IAQcnAggEAwAIAQgBJwMHBAEAIgcCCB8wgGGAYAAILQgBCAAAAQIBLQ4HCC0IAQcAAAECAS4MgF0ABycCCgQLLQgACy0KCAwtCgcNAAgACgAlAAA/qi0CAAAtCgwJASIACYBgAAstCwsKJwILBAwtCAAMLQoIDS0KBw4ACAALACUAAD+qLQIAAC0KDQkBIgAJgGAACC0LCAccCgcIACwCAAkAAAAAAAAAAAAAAAAA//////////////////////////8OKggJCyQCAAsAAAsbJQAAMxYtCAEIAAABAgEuDIBbAAgtCAEJAAABAgEuDIBeAAktCAELAAABAgEuDIBoAAsnAgwEDS0IAA0tCggOLQoJDy0KCxAACAAMACUAAD6jLQIAAB4CAAgBHgIACQAKKggJCyQCAAsAAAuHJQAAQCEtCAEIJwIJBAMACAEJAScDCAQBACIIAgktCgkLLQ4DCwAiCwILLQ4HCycCCwQMLQgADC0KCA0uCIBhAA4uCIBbAA8ACAALACUAAEAzLQIAAC0KDQkLIgAJgF4ACAsiAAiAWwALJAIACwAAC/glAABBnS0IAQgnAgsEAgAIAQsBJwMIBAEAIggCCy0KCwwtDgkMJwIMBA0tCAANLQoFDi0KCA8ACAAMACUAADrDLQIAAC0KDgsnAgwEDS0IAA0tCgsOLgiAYQAPLgiAWwAQAAgADAAlAAA7Di0CAAAtCg4INAIACC0IAQgnAgsEAgAIAQsBJwMIBAEAIggCCy0KCwwtDgoMLQsICwAiCwILLQ4LCCcCDAQNLQgADS0KCA4uCIBgAA8uCIBbABAACAAMACUAAEGvLQIAAC0KDgswCgAKAAkBIgAJgEUACDAKAAsACC0IAQgnAgkEAwAIAQkBJwMIBAEAIggCCS0KCQstDgQLACILAgstDgoLJwIJBAstCAALLQoIDC4IgGEADS4IgFsADgAIAAkAJQAAQDMtAgAALQoMBAsiAASAXgAICyIACIBbAAkkAgAJAAANRyUAAEGdLQgBCCcCCQQCAAgBCQEnAwgEAQAiCAIJLQoJCy0OBAsnAgsEDC0IAAwtCgUNLQoIDgAIAAsAJQAAOsMtAgAALQoNCScCCwQMLQgADC0KCQ0uCIBhAA4uCIBbAA8ACAALACUAADsOLQIAAC0KDQg0AgAILQgBCCcCCQQCAAgBCQEnAwgEAQAiCAIJLQoJCy0OBwstCwgJACIJAgktDgkIJwILBAwtCAAMLQoIDS4IgGAADi4IgFsADwAIAAsAJQAAQa8tAgAALQoNCTAKAAcABAEiAASARQAIMAoACQAIKQIABADTzTE4JwIJBAMnAgwEAwAqCQwLLQgBCAAIAQsBJwMIBAEAIggCCy0OCQsAIgsCCy0OCQsnAgsEAwAqCAsJLQoJCy0OBwsAIgsCCy0OCgsAIgsCCy0OBAsAIggCCS0LCQcnAgoEAgAqCQoENwsABAAHLQsGBAAiBAIELQ4EBgAiBgIILQsIBycCCQQCACoICQQ7DgAHAAQjAAAOxSkCAAQANgslIQoqAQQHJAIABwAADuAjAAATWi0IAQQnAgcEBQAIAQcBJwMEBAEAIgQCBx8wgFWAYAAHLQgBBwAAAQIBLQ4EBy0IAQQAAAECAS4MgF0ABCcCCQQKLQgACi0KBwstCgQMAAgACQAlAABC6S0CAAAtCgsIASIACIBgAAotCwoJHAoJCAAsAgAKAAAAAAAAAAAAAAAAAP//////////////////////////DioICgskAgALAAAPhyUAADMWJwIKBAstCAALLQoHDC0KBA0ACAAKACUAAELpLQIAAC0KDAgBIgAIgGAACy0LCwonAgsEDC0IAAwtCgcNLQoEDgAIAAsAJQAAQuktAgAALQoNCAEiAAiAYAAMLQsMCxwKCwwGHAoMCAAnAgwEDS0IAA0tCgcOLQoEDwAIAAwAJQAAQuktAgAALQoOCwEiAAuAYAAHLQsHBC0IAQcAAAECAS4MgFsABy0IAQsAAAECAS4MgF4ACy0IAQwAAAECAS4MgGcADCcCDQQOLQgADi0KBw8tCgsQLQoMEQAIAA0AJQAAPqMtAgAAHgIADQEeAgAOAAoqDQ4PJAIADwAAEIolAABDYC0IAQ0nAg4EAwAIAQ4BJwMNBAEAIg0CDi0KDg8tDgMPACIPAg8tDgkPJwIPBBAtCAAQLQoNES4IgGEAEi4IgFsAEwAIAA8AJQAAQDMtAgAALQoRDgsiAA6AXgANCyIADYBbAA8kAgAPAAAQ+yUAAEGdLQgBDScCDwQCAAgBDwEnAw0EAQAiDQIPLQoPEC0ODhAnAhAEES0IABEtCgUSLQoNEwAIABAAJQAAOsMtAgAALQoSDycCEAQRLQgAES0KDxIuCIBhABMuCIBbABQACAAQACUAADsOLQIAAC0KEg0eAgAPADMqAA0ADwAQJAIAEAAAEYMlAAA+2i8KAA4ADScCDwQCJwIRBAMAKg8REC0IAQ4ACAEQAScDDgQBACIOAhAtDg8QACIQAhAtDg8QJwIQBAMAKg4QDy0KDxAtDgoQACIQAhAtDggQLQsODwAiDwIPLQ4PDikCAA8ERRtfricCEgQTLQgAEy0KBxQtCgsVLQoMFi0KDRctCg8YLgiAYQAZLQoOGi4IgFsAGy4IgF0AHC4IgFsAHS4IgF0AHgAIABIAJQAAQ3ItAgAALQoUEC0KFRELIgAQgF0ADSQCAA0AABJXJwIOBAA8Bg4BHgIADQAnAg8EBCcCEgQDACoPEhAtCAEOAAgBEAEnAw4EAQAiDgIQLQ4PEAAiEAIQLQ4PECcCEAQDACoOEA8tCg8QLQ4JEAAiEAIQLQ4KEAAiEAIQLQ4IEAAiEAIQLQ4EEC0LDgQAIgQCBC0OBA4pAgAEBBxz7MknAgoEEi0IABItCgcTLQoLFC0KDBUtCg0WLQoEFy4IgFUAGC0KDhkuCIBbABouCIBdABsuCIBbABwuCIBdAB0ACAAKACUAAENyLQIAAC0KEwgtChQJCyIACIBdAAQkAgAEAAATPCcCBwQAPAYHAQAiBgIILQsIBycCCgQCACoICgQ7DgAHAAQjAAATWikCAAQAHHPsyQoqAQQHJAIABwAAE3UjAAAWHC0IAQQnAgcEBQAIAQcBJwMEBAEAIgQCBx8wgFWAYAAHLQgBBwAAAQIBLQ4EBy0IAQQAAAECAS4MgF0ABCcCCQQKLQgACi0KBwstCgQMAAgACQAlAABC6S0CAAAtCgsIASIACIBgAAotCwoJHAoJCAAsAgAKAAAAAAAAAAAAAAAAAP//////////////////////////DioICgskAgALAAAUHCUAADMWJwIKBAstCAALLQoHDC0KBA0ACAAKACUAAELpLQIAAC0KDAgBIgAIgGAACy0LCwonAgsEDC0IAAwtCgcNLQoEDgAIAAsAJQAAQuktAgAALQoNCAEiAAiAYAAMLQsMCxwKCwwGHAoMCAAnAgwEDS0IAA0tCgcOLQoEDwAIAAwAJQAAQuktAgAALQoOCwEiAAuAYAAHLQsHBC0IAQcAAAECAS4MgFsABy0IAQsAAAECAS4MgF4ACy0IAQwAAAECAS4MgGYADCcCDQQOLQgADi0KBw8tCgsQLQoMEQAIAA0AJQAAPqMtAgAAHgIABwEeAgALAAoqBwsMJAIADAAAFR8lAABEnCkCAAcAIxDODy0IAQsnAgwEBgAIAQwBJwMLBAEAIgsCDC0KDA0tDgkNACINAg0tDgoNACINAg0tDggNACINAg0tDgQNACINAg0tDgcNJwIHBAwtCAAMLQoLDQAIAAcAJQAARK4tAgAALQoNBCcCCQQFBiIJAgcnAgsEAwAqCQsKLQgBCAAIAQoBJwMIBAEAIggCCi0OCQoAIgoCCi0OCQonAgsEAwAqCAsKACIEAgsuAgALgAMuAgAKgAQuAgAJgAUlAABFjQAiCAIKLQsKCScCCwQCACoKCwQ3CwAEAAkAIgYCCS0LCQgnAgoEAgAqCQoEOw4ACAAEIwAAFhwpAgAEAKta3P4KKgEEBycCBAJ0JwIIAm8nAgkCdycCCgIgJwILAnMnAgwCZScCDQJyJwIOAnsnAg8CfSQCAAcAABZkIwAALAItCAEHJwIQBAcACAEQAScDBwQBACIHAhAfMIBDgGAAEC0IARAAAAECAS0OBxAtCAEHAAABAgEuDIBdAAcnAhIEEy0IABMtChAULQoHFQAIABIAJQAARdMtAgAALQoUEQEiABGAYAATLQsTEhwKEhEALAIAEwAAAAAAAAAAAAAAAAD//////////////////////////w4qERMUJAIAFAAAFwslAAAzFicCEwQULQgAFC0KEBUtCgcWAAgAEwAlAABF0y0CAAAtChURASIAEYBgABQtCxQTJwIUBBUtCAAVLQoQFi0KBxcACAAUACUAAEXTLQIAAC0KFhEBIgARgGAAFS0LFRQcChQRACwCABUAAAAAAAAAAAAAAAAA//////////////////////////8OKhEVFiQCABYAABelJQAAMxYnAhUEFi0IABYtChAXLQoHGAAIABUAJQAARdMtAgAALQoXEQEiABGAYAAWLQsWFRwKFRYGHAoWEQAnAhYEFy0IABctChAYLQoHGQAIABYAJQAARdMtAgAALQoYFQEiABWAYAAXLQsXFicCFwQYLQgAGC0KEBktCgcaAAgAFwAlAABF0y0CAAAtChkVASIAFYBgABAtCxAHLQgBEAAAAQIBLgyAWwAQLQgBFQAAAQIBLgyAXgAVLQgBFwAAAQIBLgyAZAAXJwIYBBktCAAZLQoQGi0KFRstChccAAgAGAAlAAA+oy0CAAAeAgAYAQoqExgZJAIAGQAA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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "register_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "aztec_token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "name",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          },
          {
            "name": "name_len",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "symbol",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          },
          {
            "name": "symbol_len",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "decimals",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13612974213305719737": {
            "error_kind": "string",
            "string": "Expected address did not match supplied token address"
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17288131482828810359": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18159344801564042747": {
            "error_kind": "string",
            "string": "Token already registered"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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798922+//eZFLvLh7m++vjq5kTs53q+9vjoZbsG9vqonF3m/ecPdcDfc66uT4W64G+5mvRvufrm3335zI3dykPPvM9x++82TvMjvnG+//eTrq5MbGW6De3118iBP8iIXmfV21tvfOd9++81BZr39nfPtt9+8yKy3ww24wZyD9QbrDdYbrDdYb7DeYL0BN+Em603Wm6w3WW+y3mS9yXqT9SbcAXew3sF6B+sdrHew3sF6B+sdrHfAnXAn3Al3wp2sd/J5nnyeJ5/nyXonn+fF53nxeV5wF9zFehfrXax3sd7FehfrLdZbrLfgFtyCW3ALLr7a+Grjq42vNr7a+Grjq42vNr7a+Grjq42v9uur+Ly+is/rq/i8vorP66u4/fabB3mSF7nIcBvcBrfBbXAb3Aa3wW1wG9z2999HcfvtNzdyJ//991HcfvvNgzzJcDvcznqD9QbrDdYbrDdYb7DeYL0BN+AG3ISbcBNuwk24CTfhJtyEm3AH3MGcB3MeQU4ycx7MeSxykeFOuJP1TtY7We9kvZP1TtY7We9kvRPugrvgLrgL7oK74C64C+6Cu+AW3IJbcAtuwS24Nd/51yIXme+j/Xnnvxu5k/k+2nA33M16N+vdrBdfNXzV8FXDVw1fNXzV8FXDVw1fNXzV8FXDVw1fNXzV8FXDVw1fNXzV8FXDV63B7XA73A63w33PV3H77TdP8iK/30e3335yfMiNDBdfNXzV8FXDVw1fNXzV8FXDVw1fNXzV8FXDVw1fNXzV8FXDVw1fNXzVBtwBd8AdcAfcAXfAHXDxVcNXDV81fNXwVcNXbbK/k/2d7O8sMvu72N/F/q5OhouvGr5q+Krhq4avGr5q+Krhq4avGr5q+Krhq1ZwC27BLbgb7oa74W64+Krhq4avGr5q+Krhq46vOr7q+Krjq46vOr7q+Krjq46vbr/92evbb7+5kTv59fPtt988yJMMF191fNXxVcdXHV91fHX77Tez3s56OV91zled81XnfNU5X3V81fFVx1cdX3V81fFVx1cdX3V81fFVx1cdX3V81fFVx1cdX3V81fFVx1cdX3V81fFVx1cdX91++/k8jEUuMp+r+Xrj9ttv7mQ+V/iqc77qnK8656vO+apzvuqcrzrnq875quOrjq86vur4quOrjq86vur4quOrjq86vur4quOrjq86vur4quOrjq86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kn570m9P+u1Jvz3ptyf99qTfnvTbk3570m9P+u1Jvz3ptyf99qTfnvTbk3570m9P+u1Jvz3ptyf99qTfnvTb81NwC27BLbgb7oa74W64G+6Gu+FuuBsuvqLfnvTbk3570m9P+u1Jvz3ptyf99qTfnvTbk3570m9P+u1Jvz3ptyf99qTfnvTbk3570m9P+u1Jvz3ptyf99mz4quGrhq8avmr4quGrhq8avqLfnvTbk3570m9P+u1Jvz3ptyf99mzvz6+yvT+/yvb+/Crb+/OrbO/Pr7K9P7/K9v78Ktv786uk357025N+e9JvT/rtSb896bcn/fak357025N+e9JvT/rtSb896bcn/fak354NXzV81fBVw1cNXzV81fBVw1f025N+e9JvT/rtSb896bcn/fak357025N+e9JvT/rtSb896bcn/fak357025N+e9JvT/rtSb896bcn/fak3570238yXHxFvz3ptyf99qTfnvTbk3570m9P+u1Jvz07vur4quOrjq86vur4quOrjq/otyf99qTfnvTbk3570m9P+u1Jvz3ptyf99qTfnvTb87ff/vXAb7/95Ebu5L+/f5S//faTB3mS4eIr+u1Jvz3ptyf99qTfnvTbk3570m9P+u1Jvz3ptyf99qTfnvTbk3570m9P+u3Z8VXHVx1fdXzV8VXHVx1fdXxFvz3ptyf99qTfnvTbk3570m9P+u1Jvz3ptyf99qTfnvTbk3570m9P+u1Jvz3ptyf99qTfnvTbk3570m9P+u1Jvz3ptyf99qTfnvTbk3570m9P+u1Jvz3ptyf99qTfnvTbk3570m9P+u1Jvz3pt2fgq8BXga8CXwW+CnwV+CrwFf32pN+e9NuTfnvSb0/67Um/PeP9884Z7593znj/foaM988PZrx/3jnj/fPOGe/fz5Dx/vnBpN+e9NuTfnvSb0/67Um/Pem3J/32pN+e9NuTfnvSb0/67Um/Pem3J/32pN+e9NuTfnvSb0/67Um/Pem3J/32pN+e9NuTfnvSb0/67Um/PQNfBb4KfBX4KvBV4KvAV4Gv6Lcn/fak357025N+e9JvT/rtSb896bcn/fak357025N+e9JvT/rtSb896bcn/fak357025N+e9JvT/rtSb896bcn/fak357025N+e9JvT/rtSb896bcn/fak357025N+e9JvT/rtSb89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F9wFd8FdcBfcBXfBLbgFt+AW3IJbcAtuwS24+KrwVeGrwleFrwpfFb4qfFX4qvBV4auNrza+2vhq46uNrza+2vhq46uNrza+2vhq46uNrza+2vhq46uNrza+2vhq46uNrza+2vhq46uNrza+2vhq46uNrza+2vhq46uNrza+2vhq46uNrza+2vhq46uNrza+2vhq46uNrza+2vhq46uNrza+2vhq46uNrza+2vhq46uNrza+2vhq46uNrza+2vhq46uNrza+2vhq46uNrza+2vhq46uNrza+2vhq46uNrza+2vhq46uNrza+2vhq46uNrza+2vhq46uNrza+2vhq46uNrza+2vhq46uNrza+2vhqv77an9dX+/P6an9eX+3P66v9ub7aT3643z/7v0+//Tcv8sOd+eSHO+c3H1/d/HDXc83x1c0Pdz2s46ubH271Jz/cGk9e5Idb6z/+/MP/+1/+/V/+y3/913/+f/7h//hfP//3//qf/+2f/se//Nt/u//3f/x///33n/zXf/+Xf/3Xf/m///N///d/+6d//j//57//83/+13/7p+8/+4fP/Z//9P0N+T/f35n+xz//8PPU/+nH3+PPj6y//z+efx715/u7/N9//v2C73+x+s/3Pz39/YXvV3x/DPDn+87/j//x3OJ/PV/380PwGr9f01r+aW1/L+jfC55f7PUn4vtL8fs12f6M9vs1P4811vcf59+vaPtPz+8vjfcm+ac/953vL60/0b+/tP7+0s+Nc/4+78+25/Ml9TuDn993+/Pz+093xX2PPz8/l/h9jp/fbPyTZ/nPV/8818/v/X2/fv9+fV/x8xR5v358/szP71d//7KPfv7v96v7D6nPZ9Xt87vsn19bf5fdPp8/7Yf+H+cr7mD2n7F/r6j6s88d+t875J+V7x3i5w71XPF3tGP+mfP3ip8F/mCeC/L3gp+X4ex/Z/+zEfP550z6++TPr83fr/k+yd/PRfuZezuDb+vvZPv4Gd78nez42cD5dyE/v+3+5+fD9Heybf783/Pc9fexfoYf71bcnWv7/UzMP/355PXP/24p//Ef//gf/z8=",
      "brillig_names": [
        "discover_new_messages",
        "debug_log_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "storage_read",
        "build_msg_block",
        "attach_len_to_msg_block",
        "debug_log_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "debug_log_oracle_wrapper",
        "build_msg_block",
        "get_l1_to_l2_membership_witness",
        "notify_created_nullifier_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "AAAAAAAEAAAAAAAAAAAAEgAAAAAAAAAQAAAAAAAAVgkAAAAA//////////8AEJzWY1yLy0tRo6Si\nqONzoSyUJLBec5Es+vMXEhwFJlQbh1Q5Fi1ACiumESR5+I8ceEEHA0VtWfhmLuL+z9O76QjUowaQ\nFAO99zn/7QYt0CLjh+1LwpeRQEENhR6n/zfXDr7RJW++/DLR1dYHli3hATjAkBX4YgHpY1etsYf3\nrH4MwbsI3tzCtoaYXVs/AgehYu0SBvj+Z4EJMZoPeAYDkAluhUZPcOGoKnh4wtsmSF0Km6NAArXA\ndLWR1FCO1vbFE0m7q8egakDyZsoHaljS8sdzN9RpEY8F+QED0gBxsKoY69g3hIJCCfCqYLwy1Irt\nfcVr/Dssjoy83NNNqVGiYgqVq3xWKc5U740sCeoHc50nvaWkNrCd6Gbu5Y4+ZSLUKhhoY3IBOXf0\nrza3wT+MXa3EJN6+8adaV0PStfqmd6IdqF70ZdI01JDRoOjHuT5acS42HWqWKEGVU0089z6mRgI8\nz70vAijfuGfHjR5cykkq+hfkbyJ0BaSXABddpvWYEabVvIpfVK1Cmo0sICvRD9kVavxZhNfishhT\njnOjarMEaHGye2msWK1jh5dtDtpyAx4+e0Dduaitynb2eIOYxQyl2hUkaLU5fCBsU6LXFaLqRuE9\nMkhPxp2IZ+GNVsAwHlDld7t4rv/zbCUtanIs8RcZ8GnLCJ9ddPwGRjlVT3QbLM+qen+xUvpf4Mjo\nj5M/4OV9x6yinB/lpvjDuDApTSCCqklonY0fGTACntjGxraWx+B4ukFDwQ4UE3mXIzi2EdvgmW6f\ntS0D4uc90G6MyFJGvaX6ptCGgQ+1adt2aDIF3wr8a0XOdNFGDNPMZm6MMHq+vThxsYMzDroti4dv\nmxmz7hM37OYMZEaDHOA0ls4ypkWhz4tfCGNY/9jEfYwFJnnwhPJ7oSVWC6jwqzoIu2mEI4Ktt7Eb\naGmvMSBwJ7AcGYGxgITUy2FQmcLaiTDNizYG1yn7sTEjczsQCxSmtSdZqCF8zlZiqBSnrrS63Hya\nqDEz/MhrnZxgZvNafsTACOLpGJwIPNFNc9mpgkmMTK3pGeF0KU4o4MmJbihIfHgWX1KT4Kb3A/UB\nDB6JxBOqsnBLjXveCtNSw+aanDrFRSWBhmOsSJQDAAWSKDf0/dLZYeady6L9lDSDZzMMfMJGBJnj\nJX6ATFDQ/cJ/vzcBovNos1KiUD/eb3vKeIH1eI8ml9ELV0QL0fPtRYigptnq0YgsQ0s9zWR+Z5Va\n0IxpxwJi9/WIw9BrFUwCpmLsmkn3l4Qc1smHzMl/N4aPx804IV+Ec4xNO0enz04WRXM2Jm+VZiwb\nRH0ow/hEnl8YOQYL0G/KL4P/aFgR0HBTNgVAqCrtEQN/BAVrCj5DkNEpkQleoY4TsCnPFu7/8J2a\nYwh9hYyWapiyAgDtv3VtpPhPH10yUQg/AGbgdNaZE0SEgCxP8jVvgEDo4ujibGQc4qITFFWfQIwv\n7it7cnd9jb6ZjmucS2t19awOQyocCKr++QjgNMZEe7XaiSd3ntVS2uS5ltNgz5anibIAZsO18Enw\nII3voJSc6vA0eEA2U9d2WJeRqwlHDtDoHOFw77Z68xYkxpnbiUbfLCQ43HZ3twLxkhhD9KP5Qq04\nLGN3wNUzLw+MSCdC59CkfKAx7JyVdTPcWatemcWuPKLYF+M5k1rBHtnPfVeGYUKhWhtTXhDMMqDH\n884mb8RT2+FyFvrQWiUvolSXLE1Oh000dm+alVIfyLVcMUwl4Dh0qbZ/fnm18QNu7Y2q90yLvr+K\n/nKPDsgbT0ItPeuk1y0Z+MqgWjxZLRXdSwaR6iblI/SK09JUjLqXKXO9YTFCvb8GoYxTUFgAHFmz\n8kjY+mZUBOIPXWYtVDizETqEP+v51FQcQkyzvBAoqtx1Nsj14OtC+xqxo1GsW0GdqFahvIm0lDIY\nUvfLAHYXaAmc4dFUb8HF2T8KO2o9Ml9fz2XeBm/nwG55ldcBazN1btkZIJ9Nb1xpPOISQctqyc8U\n7pzyCvnJ83Em6gMIU1PxSp2rBzzBk7mLR7GQkPwwLqaUFvfU+HMKjogaLESUKWtigfabefMtYKTg\npFbKL/hvYxhz/mw3BiBl7EAtm+c5KAbUenket2ewpJYNTV7J9tYNWNz+Y4AqqMsQoA6efOievCZP\n3GlpR5CVadLo3HzKsWxO4cFJtAqHGXu8IO1CrgTw2toWiVQkdyQBK/11f+E0D/PzBUjhc8VPLg0A\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAACGWg7lXbv3YKniYUjiFoPtrg5muqGTkGOmtwZGRgVkLojl3X0PE6jl91RKLS9CKarv+Xf\n/2r83Ef7y7hCNDwUzADENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04sAZaN5cMk\ngqp9HQoJ1xeOyTuteFj5bmTwtI0T/DBF7F3IrJuupLmeobqEaLN+EOCE3rvz8G891XJ5kBMevpRD\n0wjG1j0HkTruZrSFZmQJ4zJievrMBCtdWDUY"
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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TbEpNsWm2BSbYlNsik2xTWwT28Q2sU1sE9vENrFNbGc2+m52ZuOJBaxgAzt42M7d07PxQgUneNjqsf/6KLfAw1bVsYIN7OAABVRwgpbo2XghtoKtYCvYPBvrdBRQwQlaomfjhYfNJ7jzsW+BDTxsrTkOUEAFJ2iJ5/STvrznBJQnVrCBbvMlOyeiPFESzxkni6MXM8fjr/Xz3x5/rft281C4UMEJWqKHwoVH3e42D4ULG9hBt/kyeChceNiOmX6qD3QLtEQPhQsLWMHDNsSxgwMU0G2++jwULnSbL6SHwoUFrOBhExd7KFw4QAEVnOBhE18cD4ULC1hBt/lCeihcOEC3+d7noXDhTPSev9CL+a84J6X0ncBb+vq3x5LpsZD9nJHyxAJWsIHHkh3TO1Qf1RYooIITtERv6flwLGAFG3jYZnEcoICHbfqSeUtfaIne0rM7uu2cCNJt6tjADg5QQAUPm50KS/SWvrCAFWxgBwcooILYGraOrWPznjf/xd7zFwqo4AQt0RvSztkwH6ArfBMKiy4surDo3iLmK8pb5EIFJ2iJ3iIXFrCCDewgtoltYpvYJjbDZtj8CGnT0SuY47PC85Lc0QJ9vFdgASvYwA4OUEAFJ4itYCvYCraCrWAr2Aq2gq1gK9gqtoqtYqvYKraKrWKr2Cq2iq1ha9gatoatYWvYGraGrWFr2Dq2jq1j69g6to6tY+vYOraObWAb2Aa2gW1gG9gGtoFtYBvYBJtgE2yCTbAJNsEm2ASbYFNsik2xKTbFptgUm2JTbIptYpvYJraJbWKb2Ca2iW1im9gMm2EzbIbNsBk2w2bYyJJBlghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJ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",
      "brillig_names": [
        "sync_private_state"
      ]
    },
    {
      "name": "withdraw_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "withdrawNonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "burnNonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "2550444873539515884": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBqJwAABAMnAgcEBicCCAQAHwoABwAIgGQdAIBngGcGLgiAZAABLgiAZQACLgiAZgADLgiAZwAELgiAaAAFLgiAaQAGJQAAAGolAAAB8SgCAAEEgGonAgIEADsOAAIAASgAgEMAAAEpAIBEAEfazXMpAIBFBP////8oAIBGAgDZKACARwIAyigAgEgCAO0oAIBJAgASKACASgQABikAgEsEagnmZykAgEwEu2euhSkAgE0EPG7zcikAgE4EpU/1OikAgE8EUQ5SfykAgFAEmwVojCkAgFEEH4PZqykAgFIEW+DNGS4AAAGAUygAgFQEAAkBAAABgFQAASgBgFMEAAEBAIBTAAKAVC4AgFSAVS4EgEuAVQEAgFUAAoBVLgSATIBVAQCAVQACgFUuBIBNgFUBAIBVAAKAVS4EgE6AVQEAgFUAAoBVLgSAT4BVAQCAVQACgFUuBIBQgFUBAIBVAAKAVS4EgFGAVQEAgFUAAoBVLgSAUoBVKACAVAQAQCgAgFUEAAQoAIBWBAA4KACAVwQAECgAgFgEAA4oAIBZBAADKACAWgQBACgAgFsBAAAoAIBcAgAAKACAXQQAACgAgF4AAAAoAIBfAQABKACAYAQAASgAgGEEAAIoAIBiAgAIKACAYwQAZCYlAAAgmR4CAAcAHgIACAAzKgAHAAgACSQCAAkAAAIVJQAAIMIeAgAHAQoqAgcIJAIACAAACAYjAAACLB4CAAcBLQgBCCcCCQQCAAgBCQEnAwgEAQAiCAIJHzCAYIBdAAkBIgAIgGAACi0LCgkcCgkKBBwKCggALQgBCQAAAQIBJwIKAAItDgoJLQgBCicCCwQHAAgBCwEnAwoEAQAiCgILHzCASoBgAAsnAgsALC0IAQwnAg0ECAAIAQ0BJwMMBAEAIgwCDS0KDQ4tDgsOACIOAg4tDgsOACIOAg4tDgsOACIOAg4tDgsOACIOAg4tDgsOACIOAg4tDgsOACIOAg4tDgsOLQgBCwAAAQIBLQ4MCycCDAQHLgiAXQAFIwAAAxENIgAFgEoADSQCAA0AAAenIwAAAyYtCwsKKwIACwAAAAAAAAAABwAAAAAAAAAAJwIRBBItCAASLQoLEwAIABEAJQAAINQtAgAALQoTDS0KFA4tChUPLQoWEC0IAQsAAAECAS0ODQstCAENAAABAgEtDg4NLQgBDgAAAQIBLQ4PDi0IAQ8AAAECAS0OEA8tCwoQACIQAhAtDhAKLgiAXQAFIwAAA7YMKgUMECQCABAAAAddIwAAA8gnAgwEEC0IABAtCgsRLQoNEi0KDhMtCg8UAAgADAAlAAAhZy0CAAAtChEKLQsJCy0OCwktCAEJJwILBAQACAELAScDCQQBACIJAgstCgsMLQ4HDAAiDAIMLQ4IDAAiDAIMLQ4KDCcCBwAtLQgBCCcCCgQFAAgBCgEnAwgEAQAiCAIKLQoKCy0OBwsAIgsCCy0OBwsAIgsCCy0OBwsAIgsCCy0OBwstCAEHAAABAgEtDggHLgiAXQAFIwAABIUNIgAFgFkACCQCAAgAAAb7IwAABJotCwcIKwIABwAAAAAAAAAABAAAAAAAAAAAJwINBA4tCAAOLQoHDwAIAA0AJQAAINQtAgAALQoPCS0KEAotChELLQoSDC0IAQcAAAECAS0OCQctCAEJAAABAgEtDgoJLQgBCgAAAQIBLQ4LCi0IAQsAAAECAS0ODAstCwgMACIMAgwtDgwILgiAXQAFIwAABSoNIgAFgFUADCQCAAwAAAaxIwAABT8nAggEDC0IAAwtCgcNLQoJDi0KCg8tCgsQAAgACAAlAAAhZy0CAAAtCg0FKQIABwAnFrFmJwIJBAMnAgsEAwAqCQsKLQgBCAAIAQoBJwMIBAEAIggCCi0OCQoAIgoCCi0OCQonAgoEAwAqCAoJLQoJCi0OBwoAIgoCCi0OAgoAIgoCCi0OBQoAIggCCS0LCQcnAgoEAgAqCQoFOQOAgEWARYBDAAcABSACAAUhAgAHLQgBCQAiCQIMLQsMCycCDQQCACoMDQoiMgAHgF0ACi0KBwsnAg0EAwAqCw0MAAgBDAEnAwkEAQAiCQINLQ4LDQAiDQINLQ4LDS0KCwgGIggCCCQCAAUAAAZ2IwAABk0tCwkFACIFAgUtDgUJACIJAgotCwoHJwILBAIAKgoLBTwOBwUjAAAGdgsiAAiAYAAFJAIABQAABoslAAAh2wEiAAmAWQAHLQsHBQsiAAWARAAHJAIABwAABqwlAAAh7SMAAAggACIIAg0AKg0FDi0LDgwnAg0EDi0IAA4tCgcPLQoJEC0KChEtCgsSLQoMEwAIAA0AJQAAIf8tAgAAASIABYBgAAwtCgwFIwAABSoBIgAFgGAACAAiCQILACoLBQwtCwwKLQsHCw0iAAiAVQAMJAIADAAAByolAAAjIy4CAAuAAygAgAQEAAUlAAAjNS4IgAUADAAiDAINACoNCA4tDgoOLQ4MBy0KCAUjAAAEhQAiCgIRACoRBRItCxIQJwIRBBItCAASLQoLEy0KDRQtCg4VLQoPFi0KEBcACAARACUAACH/LQIAAAEiAAWAYAAQLQoQBSMAAAO2ASIABYBgAA0AIgoCDwAqDwUQLQsQDi0LCw8MKg0MECQCABAAAAfTJQAAIyMuAgAPgAMoAIAEBAAIJQAAIzUuCIAFABAAIhACEQAqEQ0SLQ4OEi0OEAstCg0FIwAAAxELIgAFgF4AByQCAAcAAAgbJQAAI8MjAAAIIC0IAQcnAggEAgAIAQgBJwMHBAEAIgcCCC0KCAkuDIBDAAknAggABi0IAQknAgoEAgAIAQoBJwMJBAEAIgkCCi0KCgstDggLJwIKBAstCAALLQoJDC0KBw0ACAAKACUAACPVLQIAAC0KDAgnAgoECy0IAAstCggMLgiAYQANLgiAWwAOAAgACgAlAAAkIC0CAAAtCgwHHgIACAAzKgAHAAgACiQCAAoAAAjPJQAAJZwtCAEHJwIIBAQACAEIAScDBwQBACIHAggtCggKLgyAXgAKACIKAgouDIBeAAoAIgoCCi4MgF4ACi0IAQgAAAECAS0OBwguCIBdAAUjAAAJHw0iAAWAWQAHJAIABwAAIEcjAAAJNC0LCAUBIgAFgGAACC0LCAccCgcFACwCAAgAAAAAAAAAAAAAAAAA//////////////////////////8OKgUICiQCAAoAAAmAJQAAJa4rAgAFAAAAAAAAAAACAAAAAAAAAAAnAg0EDi0IAA4tCgUPAAgADQAlAAAg1C0CAAAtCg8ILQoQCi0KEQstChIMLQgBBQAAAQIBLQ4IBS0IAQgAAAECAS0OCggtCAEKAAABAgEtDgsKLQgBCwAAAQIBLQ4MCycCDAAFJwINBA4tCAAOLQoFDy0KCBAtCgoRLQoLEi0KDBMACAANACUAACH/LQIAACcCDAQNLQgADS0KBQ4tCggPLQoKEC0KCxEtCgESAAgADAAlAAAh/y0CAAAnAg0EDi0IAA4tCgUPLQoIEC0KChEtCgsSAAgADQAlAAAhZy0CAAAtCg8MCyIADIBeAAULIgAFgFsACCQCAAgAAAqXJQAAJcAtCAEFJwIIBAIACAEIAScDBQQBACIFAggtCggKLQ4MCi0LCQgAIggCCC0OCAknAgoEDS0IAA0tCgkOLQoFDwAIAAoAJQAAI9UtAgAALQoOCCcCCQQNLQgADS0KCA4uCIBhAA8uCIBbABAACAAJACUAACQgLQIAAC0KDgUeAgAIADMqAAUACAAJJAIACQAACywlAAAlnC8KAAwABRwKBAgAKQIABADGEbDFJwIKBAQnAgwEAwAqCgwLLQgBCQAIAQsBJwMJBAEAIgkCCy0OCgsAIgsCCy0OCgsnAgsEAwAqCQsKLQoKCy0OBAsAIgsCCy0OAgsAIgsCCy0OCAsAIgsCCy0OBgsAIgkCCi0LCgYnAgsEAgAqCgsEOQOggEWARQAFAAYABCACAAQhAgAFLQgBCQAiCQIMLQsMCycCDQQCACoMDQoiMgAFgF0ACi0KBQsnAg0EAwAqCw0MAAgBDAEnAwkEAQAiCQINLQ4LDQAiDQINLQ4LDS0KCwYGIgYCBiQCAAQAAAxMIwAADCMtCwkEACIEAgQtDgQJACIJAgotCwoFJwILBAIAKgoLBDwOBQQjAAAMTAsiAAaAXQAFJAIABQAADGUnAgkEADwGCQEtCAEFAAABAgEtCAEGJwIJBGUACAEJAScDBgQBACIGAgktCgkKLgyARgAKACIKAgouDIBHAAoAIgoCCi4MgEgACgAiCgIKLgyASQAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKACIKAgouDIBcAAoAIgoCCi4MgFwACgAiCgIKLgyAXAAKLQ4GBScCCQEALQgBBicCCgQhAAgBCgEnAwYEAQAiBgIKJwILBCBDA6IAAYBaAAsACQAKJwIKAQAtCAEJJwILBCEACAELAScDCQQBACIJAgsnAgwEIEMDogADgFoADAAKAAsnAgsBAC0IAQonAgwEIQAIAQwBJwMKBAEAIgoCDCcCDQQgQwOiAAiAWgANAAsADCcCCwQgJwIMBCQnAg0ERC4IgF0ABCMAABF8DCoECw4kAgAOAAAfQSMAABGOLQsFBi0L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",
      "debug_symbols": "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",
      "brillig_names": [
        "withdraw_public"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "ContractInstanceDeployer"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "updated_class_ids",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "private_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "shielded_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minter",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "upgrade_authority",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "shield_gateway",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Portal"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "l1_tokens",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "l2_tokens",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "eth_token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "recipient",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "amount",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            },
            {
              "name": "message_leaf_index",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::Deposit"
        },
        {
          "fields": [
            {
              "name": "eth_token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "aztec_token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::Register"
        },
        {
          "fields": [
            {
              "name": "token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "from",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "to",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "amount",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::Withdraw"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::_claim_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::_claim_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::_log_claim_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::_log_claim_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "aztec_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::_register_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::_register_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::claim_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::claim_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::claim_shielded_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::claim_shielded_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "l1_portal",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "token_contract_class_id",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::contract_class_id::ContractClassId"
                    }
                  },
                  {
                    "name": "shield_gateway",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Portal::get_config_private_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "l1_portal",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "shield_gateway",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_contract_class_id",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::contract_class_id::ContractClassId"
                    }
                  }
                ],
                "kind": "struct",
                "path": "config::Config"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::get_config_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Portal::get_config_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "l1_portal",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "shield_gateway",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_contract_class_id",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::contract_class_id::ContractClassId"
                    }
                  }
                ],
                "kind": "struct",
                "path": "config::Config"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::get_config_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "aztec_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::get_l1_token_unconstrained_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::eth_address::EthAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::get_l1_token_unconstrained_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::get_l2_token_unconstrained_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::get_l2_token_unconstrained_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::is_registered_l1_unconstrained_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::is_registered_l1_unconstrained_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "aztec_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::is_registered_l2_unconstrained_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::is_registered_l2_unconstrained_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "aztec_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "name",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  },
                  {
                    "name": "name_len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "symbol",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  },
                  {
                    "name": "symbol_len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "decimals",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::register_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::register_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Portal::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::sync_private_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "withdrawNonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "burnNonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::withdraw_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::withdraw_public_abi"
        }
      ]
    }
  },
  "file_map": {
    "104": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        authwits::AUTHWIT_TYPES,\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_private_state = generate_sync_private_state();\n    let process_message = generate_process_message();\n    generate_authwit_exports();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_authwit_exports() {\n    let authwits = AUTHWIT_TYPES.values();\n    authwits.for_each(|(s): TypeDefinition| { s.add_attribute(\"abi(authwits)\"); });\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // TODO(#15012): Here we use PRIVATE_LOG_CIPHERTEXT_LEN for message ciphertext length. Fix message vs log naming.\n    quote {\n        #[$utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::do_process_message(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    },
    "105": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::{compute_fn_selector, size_in_fields};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "108": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_array, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_public, is_fn_view,\n    size_in_fields,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else if is_fn_public(f) {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    } else {\n        if is_void {\n            create_utility_void_stub(f)\n        } else {\n            create_utility_stub(f)\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n    let params_num_fields =\n        fn_parameters.fold(0, |acc, (_, typ)| acc + crate::macros::utils::size_in_fields(typ));\n\n    let serialized_args_index_name = quote { serialized_args_index };\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args = [0;2];\n    // let mut serialized_args_index = 0;\n    // let target_address_serialized = aztec::protocol_types::traits::Serialize::serialize(target_address)\n    // for i in 0..target_address_serialized.len() {\n    //    serialized_args[serialized_args_index] = target_address_serialized[i];\n    //    serialized_args_index += 1;\n    // }\n    // serialized_args[serialized_args_index] = fee_juice_limit_per_tx as Field\n    // serialized_args_index += 1;\n    // ```\n    let serialized_args_array_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_NAME = [0; $params_num_fields];\n            let mut $serialized_args_index_name: u32 = 0;\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append =\n                add_to_field_array(SERIALIZED_ARGS_NAME, serialized_args_index_name, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n"
    },
    "109": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "112": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "114": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ, _) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "115": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "117": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{private_notes::MAX_NOTE_PACKED_LEN, process_message::do_process_message},\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        do_process_message(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "118": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "119": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    prelude::AztecAddress,\n    utils::array,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__EVENT_COMMITMENT, hash::poseidon2_hash_with_separator_bounded_vec,\n    traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private_log` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "121": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "122": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::decode_message,\n    encryption::{aes128::AES128, log_encryption::LogEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    constants::PRIVATE_LOG_CIPHERTEXT_LEN,\n    debug_log::{debug_log, debug_log_format},\n};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn do_process_message<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message = AES128::decrypt_log(message_ciphertext, message_context.recipient);\n\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "123": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\npub global MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "124": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{\n        GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2,\n        PRIVATE_LOG_CIPHERTEXT_LEN,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "140": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "143": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/messaging.nr",
      "source": "use crate::{\n    hash::{compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness,\n};\n\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    merkle_tree::root::root_from_sibling_path,\n};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field,\n    leaf_index: Field,\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_l1_to_l2_message_hash(\n        portal_contract_address,\n        chain_id,\n        contract_address,\n        version,\n        content,\n        secret_hash,\n        leaf_index,\n    );\n\n    // We prove that `message_hash` is in the tree by showing the derivation of the tree root, using a merkle path we\n    // get from an oracle.\n    // Safety: The witness is only used as a \"magical value\" that makes the merkle proof below pass. Hence it's safe.\n    let (_leaf_index, sibling_path) =\n        unsafe { get_l1_to_l2_membership_witness(contract_address, message_hash, secret) };\n\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert_eq(root, l1_to_l2_root, \"Message not in state\");\n\n    compute_l1_to_l2_message_nullifier(message_hash, secret)\n}\n"
    },
    "153": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "156": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "160": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "161": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "162": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "163": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getTimestamp)]\nunconstrained fn get_timestamp_oracle() -> u64 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_timestamp() -> u64 {\n    get_timestamp_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "164": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "165": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "166": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, constants::L1_TO_L2_MSG_TREE_HEIGHT};\n\n/// Returns the leaf index and sibling path of an entry in the L1 to L2 messaging tree, which can then be used to prove\n/// its existence.\npub unconstrained fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field,\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\n}\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field,\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {}\n"
    },
    "169": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "170": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "171": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "173": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(fetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(validateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(bulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "175": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{\n    note_interface::NoteType,\n    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}\n\npub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<NOTE_PCKD_LEN>,\n{\n    // N + 3 because of the contract address, note nonce, and note_hash_counter that are stored out of the packed note.\n    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        MAX_NOTES,\n        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,\n    );\n\n    let mut notes = BoundedVec::<_, MAX_NOTES>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MAX_NOTES];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "178": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "180": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "182": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables, which is expected to never result in collisions or slots\n// being close to one another due to these being hashes. This mirrors the strategy adopted by Solidity mappings.\nimpl<K, T, Context> Storage<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "190": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    /// Initializes the value.\n    ///\n    /// # Panics\n    /// Panics if the value is already initialized.\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    /// Reads the value.\n    ///\n    /// # Panics\n    /// Panics if the value is not initialized.\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        assert(self.is_initialized(), \"Trying to read from uninitialized PublicImmutable\");\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n\n    /// Reads the value without checking if the value is initialized.\n    pub fn read_unsafe<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n\n    fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.nullifier_exists(nullifier, self.context.this_address())\n    }\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "205": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "208": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "209": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "211": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "212": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "214": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "216": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "221": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "228": {
      "path": "/home/vscode/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "246": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "289": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "290": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr",
      "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH,\n    traits::{Deserialize, Empty, Packable, Serialize, ToField},\n};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl Packable<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn pack(self) -> [Field; ETH_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn to_be_bytes(self) -> [u8; 20] {\n        let field_bytes: [u8; 32] = self.inner.to_be_bytes();\n        let mut bytes = [0; 20];\n        for i in 0..20 {\n            bytes[i] = field_bytes[i + 12];\n        }\n        bytes\n    }\n}\n"
    },
    "292": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "294": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "298": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/noir-protocol-circuits/crates/types/src/contract_class_id.nr",
      "source": "use crate::constants::GENERATOR_INDEX__CONTRACT_LEAF;\nuse crate::traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField};\n\npub struct ContractClassId {\n    pub inner: Field,\n}\n\nimpl Eq for ContractClassId {\n    fn eq(self, other: ContractClassId) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl ToField for ContractClassId {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for ContractClassId {\n    fn from_field(value: Field) -> Self {\n        Self { inner: value }\n    }\n}\n\nimpl Serialize<1> for ContractClassId {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<1> for ContractClassId {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] }\n    }\n}\n\nimpl Empty for ContractClassId {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n// Implement the Packable trait so ContractClassId can be stored in contract's storage.\nimpl Packable<1> for ContractClassId {\n    fn pack(self) -> [Field; 1] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; 1]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl ContractClassId {\n    pub fn compute(\n        artifact_hash: Field,\n        private_functions_root: Field,\n        public_bytecode_commitment: Field,\n    ) -> Self {\n        let hash = crate::hash::poseidon2_hash_with_separator(\n            [artifact_hash, private_functions_root, public_bytecode_commitment],\n            GENERATOR_INDEX__CONTRACT_LEAF,\n        ); // TODO(@spalladino): Update generator index\n        ContractClassId::from_field(hash)\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "304": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "306": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "307": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "317": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "321": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] != 0 };\n        consumed_counter = 1;\n    } else if typ.is_field() | typ.as_integer().is_some() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type, _) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type, _)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    let serialize_trait: TraitConstraint =\n        quote { Serialize<$serialized_len> }.as_trait_constraint();\n    quote {\n        impl $serialize_trait for $typ {\n            #[inline_always]\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "323": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "324": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "334": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] != 0,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] != 0,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] != 0,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] != 0,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "345": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "359": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    #[inline_always]\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// T = type of item in BoundedVec\n// M = max length of BoundedVec\n// O = field length of T\n// O * M + 1 = total serialized length of BoundedVec<T, M> (the +1 is for length of the BoundedVec)\nimpl<T, let M: u32, let O: u32> Deserialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Deserialize<O>,\n{\n    #[inline_always]\n    fn deserialize(fields: [Field; O * M + 1]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[O * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; O];\n            for j in 0..O {\n                nested_fields[j] = fields[i * O + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl<let N: u32> Deserialize<0> for () {\n    fn deserialize(_fields: [Field; 0]) -> Self {\n        ()\n    }\n}\n\nimpl<T, let M: u32, let O: u32> Serialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Serialize<O>,\n{\n    #[inline_always]\n    fn serialize(self) -> [Field; O * M + 1] {\n        let mut fields = [0; O * M + 1];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..O {\n                fields[i * O + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[O * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    #[inline_always]\n    fn deserialize(fields: [Field; N]) -> Self {\n        str::<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "364": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as u8 as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as u16 as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as u32 as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as u64 as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "365": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T, let N: u32> Serialize<N + 1> for Option<T>\nwhere\n    T: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T, let N: u32> Deserialize<N + 1> for Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    fn deserialize(fields: [Field; N + 1]) -> Self {\n        if fields[0] == 1 {\n            let mut value_serialized: [Field; N] = std::mem::zeroed();\n            for i in 0..N {\n                value_serialized[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_serialized))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "383": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_padded_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_padded_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_padded_array::{\n    assert_sorted_transformed_i_padded_array_capped_size,\n    assert_sorted_transformed_padded_array_capped_size, validate_padded_items,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_padded_arrays::assert_split_transformed_padded_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"
    },
    "384": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimised to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "386": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "392": {
      "path": "/home/vscode/nargo/github.com/noir-lang/sha256/v0.1.3/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "396": {
      "path": "/home/vscode/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "431": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        array_concat(note_completion_log, padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "52": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/portal/src/encoding/deposit.nr",
      "source": "use aztec::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    hash::sha256_to_field,\n    traits::{FromField, ToField},\n};\n\n// bytes4(keccak256(\"deposit(address,bytes32,uint256)\")) = 0xeb2243f8\nglobal DEPOSIT_SIGNATURE: [u8; 4] = [0xeb, 0x22, 0x43, 0xf8];\n\npub fn deposit_content_hash(\n    eth_token: EthAddress,\n    recipient: AztecAddress,\n    amount: Field,\n) -> Field {\n    let encoded = abi_encode_deposit(eth_token, recipient, amount);\n    let content_hash = sha256_to_field(encoded);\n    content_hash\n}\n\npub fn abi_encode_deposit(\n    eth_token: EthAddress,\n    recipient: AztecAddress,\n    amount: Field,\n) -> [u8; 100] {\n    // abi.encodeWithSignature(DEPOSIT_SIGNATURE, tokenAddr, recipient, amount)\n    // This encodes the following data:\n    // offset - data\n    // 0x00 - 4 bytes for the signature\n    // 0x04 - 32 bytes for the token address\n    // 0x24 - 32 bytes for the recipient\n    // 0x44 - 32 bytes for the amount\n    // Total: 100 bytes\n    let mut encoded = [0; 100];\n    for i in 0..4 {\n        encoded[i] = DEPOSIT_SIGNATURE[i];\n    }\n\n    let eth_token_bytes: [u8; 32] = eth_token.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = amount.to_be_bytes();\n\n    for i in 0..32 {\n        encoded[i + 0x4] = eth_token_bytes[i];\n        encoded[i + 0x24] = recipient_bytes[i];\n        encoded[i + 0x44] = amount_bytes[i];\n    }\n\n    encoded\n}\n\n// For testing purposes, enables printing the ABI-encoded data\npub unconstrained fn field_from_encoded_bytes(encoded: [u8; 100], offset: u32) -> Field {\n    let mut arr = [0; 31];\n    for i in 0..31 {\n        if offset + i >= 100 {\n            break;\n        }\n        arr[i] = encoded[offset + i];\n    }\n    aztec::protocol_types::utils::field::field_from_bytes(arr, true)\n}\n\n#[test]\nfn test_abi_encode_deposit() {\n    let eth_token = EthAddress::from_field(0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F);\n    let recipient = AztecAddress::from_field(\n        0x1e571fd19f8f3aab48fd795e1b39f72dd61f44735c88a7576721be8a5065f863,\n    );\n    let amount = 0x1234567890abcdef1234567890abcdef;\n    let encoded = abi_encode_deposit(eth_token, recipient, amount);\n\n    // abi.encodeWithSignature(\"deposit(address,bytes32,uint256)\", address(0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F), bytes32(hex\"1e571fd19f8f3aab48fd795e1b39f72dd61f44735c88a7576721be8a5065f863\"), 0x1234567890abcdef1234567890abcdef) =\n    // 0xeb2243f80000000000000000000000002458675deb5e0691da2d2ba8dcaf58cfd2c2651f1e571fd19f8f3aab48fd795e1b39f72dd61f44735c88a7576721be8a5065f863000000000000000000000000000000001234567890abcdef1234567890abcdef\n    let expected: [u8; 100] = [\n        0xeb, 0x22, 0x43, 0xf8, // Function selector - deposit(address,bytes32,uint256)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F\n        0x24, 0x58, 0x67, 0x5d, 0xeb, 0x5e, 0x06, 0x91, 0xda, 0x2d, 0x2b, 0xa8, 0xdc, 0xaf, 0x58,\n        0xcf, 0xd2, 0xc2, 0x65, 0x1f,\n        // Aztec Recipient Address\n        0x1e, 0x57, 0x1f, 0xd1, 0x9f, 0x8f, 0x3a, 0xab, 0x48, 0xfd, 0x79, 0x5e, 0x1b, 0x39, 0xf7,\n        0x2d, 0xd6, 0x1f, 0x44, 0x73, 0x5c, 0x88, 0xa7, 0x57, 0x67, 0x21, 0xbe, 0x8a, 0x50, 0x65,\n        0xf8, 0x63,\n        // Amount\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,\n        0xcd, 0xef,\n    ];\n\n    if encoded != expected {\n        std::println(f\"test_abi_encode_deposit: got: {encoded}\");\n        std::println(f\"test_abi_encode_deposit: expected: {expected}\");\n    }\n    assert_eq(encoded, expected);\n}\n\n#[test]\nfn test_deposit_content_hash() {\n    let content: [u8; 100] = [\n        0xeb, 0x22, 0x43, 0xf8, // Function selector - deposit(address,bytes32,uint256)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F\n        0x24, 0x58, 0x67, 0x5d, 0xeb, 0x5e, 0x06, 0x91, 0xda, 0x2d, 0x2b, 0xa8, 0xdc, 0xaf, 0x58,\n        0xcf, 0xd2, 0xc2, 0x65, 0x1f,\n        // Aztec Recipient Address\n        0x1e, 0x57, 0x1f, 0xd1, 0x9f, 0x8f, 0x3a, 0xab, 0x48, 0xfd, 0x79, 0x5e, 0x1b, 0x39, 0xf7,\n        0x2d, 0xd6, 0x1f, 0x44, 0x73, 0x5c, 0x88, 0xa7, 0x57, 0x67, 0x21, 0xbe, 0x8a, 0x50, 0x65,\n        0xf8, 0x63,\n        // Amount\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,\n        0xcd, 0xef,\n    ];\n\n    // sha256(content) = 0x5a05320993a46599dc6c5605c5f2bf139d6fb5f3709e23c5af2b530f1e883aa8\n    // sha256_to_field uses the first 31 bytes of the hash\n    let expected: Field = 0x5a05320993a46599dc6c5605c5f2bf139d6fb5f3709e23c5af2b530f1e883a;\n    let content_hash = sha256_to_field(content);\n    if content_hash != expected {\n        std::println(f\"test_deposit_content_hash: got: {content_hash}\");\n        std::println(f\"test_deposit_content_hash: expected: {expected}\");\n    }\n    assert_eq(content_hash, expected);\n}\n"
    },
    "54": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/portal/src/encoding/register.nr",
      "source": "use aztec::protocol_types::{address::EthAddress, hash::sha256_to_field, traits::ToField};\n\n// bytes4(keccak256(register(address,string,string,uint8))) = 0x611a7a19\ncomptime global REGISTER_SIGNATURE: [u8; 4] = [0x61, 0x1a, 0x7a, 0x19];\n\npub fn register_content_hash(\n    eth_token: EthAddress,\n    name: str<31>,\n    name_len: u8,\n    symbol: str<31>,\n    symbol_len: u8,\n    decimals: u8,\n) -> Field {\n    let encoded = abi_encode_register(eth_token, name, name_len, symbol, symbol_len, decimals);\n    let content_hash = sha256_to_field(encoded);\n\n    // Debug log the ABI-encoded data\n    // let field_array: [Field; 9] = aztec::utils::bytes::bytes_to_fields::<260, 9>(encoded);\n    // dep::aztec::oracle::debug_log::debug_log_format(\"ABI Encoded: {}\", field_array);\n    content_hash\n}\n\npub fn abi_encode_register(\n    eth_token: EthAddress,\n    name: str<31>,\n    name_len: u8,\n    symbol: str<31>,\n    symbol_len: u8,\n    decimals: u8,\n) -> [u8; 260] {\n    // abi.encodeWithSignature(REGISTER_SIGNATURE, tokenAddr, token.name(), token.symbol(), token.decimals())\n    // This encodes the following data:\n    // offset - data\n    // 0x00 - 4 bytes for the signature\n    // 0x04 - 32 bytes for the token address\n    // 0x24 - 32 bytes for the name offset\n    // 0x44 - 32 bytes for the symbol offset\n    // 0x64 - 32 bytes for the decimals\n    // 0x84 - 32 bytes for the name length\n    // 0xa4 - 32 bytes for the name // Limited to 31 bytes\n    // 0xc4 - 32 bytes for the symbol length\n    // 0xe4 - 32 bytes for the symbol // Limited to 31 bytes\n    // Total: 260 bytes\n    let mut encoded = [0; 260];\n\n    let eth_token_bytes: [u8; 32] = eth_token.to_field().to_be_bytes();\n    let decimals_bytes: [u8; 32] = decimals.to_field().to_be_bytes();\n\n    let name_len_bytes: [u8; 32] = name_len.to_field().to_be_bytes();\n    let symbol_len_bytes: [u8; 32] = symbol_len.to_field().to_be_bytes();\n\n    // Fixed offsets for name and symbol\n    // Offset for the name is 0x80 per the ABI encoding, but 0x84 in the raw data\n    let name_offset_bytes: [u8; 32] = 0x80.to_field().to_be_bytes();\n    // Offset for the symbol is 0xc0 per the ABI encoding, but 0xc4 in the raw data\n    let symbol_offset_bytes: [u8; 32] = 0xc0.to_field().to_be_bytes();\n\n    let name_bytes: [u8; 31] = name.as_bytes();\n    let symbol_bytes: [u8; 31] = symbol.as_bytes();\n\n    for i in 0..32 {\n        // First 4 bytes are the function signature\n        if i < 4 {\n            encoded[i] = REGISTER_SIGNATURE[i];\n        }\n\n        encoded[i + 0x4] = eth_token_bytes[i];\n        encoded[i + 0x24] = name_offset_bytes[i];\n        encoded[i + 0x44] = symbol_offset_bytes[i];\n        encoded[i + 0x64] = decimals_bytes[i];\n        encoded[i + 0x84] = name_len_bytes[i];\n        encoded[i + 0xc4] = symbol_len_bytes[i];\n\n        // Copy name & symbol\n        if (i as u8) < name_len {\n            encoded[i + 0xa4] = name_bytes[i];\n        }\n        if (i as u8) < symbol_len {\n            encoded[i + 0xe4] = symbol_bytes[i];\n        }\n    }\n\n    encoded\n}\n\nunconstrained fn pad_31<let N: u32>(s: str<N>) -> str<31> {\n    let mut padded = [0; 31];\n    let s = s.as_bytes();\n    for i in 0..31 {\n        if i < N {\n            padded[i] = s[i];\n        }\n    }\n    padded.as_str_unchecked()\n}\n\n#[test]\nunconstrained fn test_abi_encode_register() {\n    let eth_token = EthAddress::from_field(0xbbEda607223492F9dce036A21C459fE1dcab56c7);\n    let name = pad_31(\"Test Token\");\n    let symbol = pad_31(\"TT\");\n    let decimals = 18;\n    let encoded = abi_encode_register(eth_token, name, 10, symbol, 2, decimals);\n\n    // abi.encodeWithSignature(\"register(address,string,string,uint8)\", address(0xbbEda607223492F9dce036A21C459fE1dcab56c7), \"Test Token\", \"TT\", 18) =\n    // 0x611a7a19000000000000000000000000bbeda607223492f9dce036a21c459fe1dcab56c7000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000a5465737420546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000025454000000000000000000000000000000000000000000000000000000000000\n    let expected: [u8; 260] = [\n        0x61, 0x1a, 0x7a, 0x19, // Function selector - register(address,string,string,uint8)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0xbbEda607223492F9dce036A21C459fE1dcab56c7\n        0xbb, 0xed, 0xa6, 0x07, 0x22, 0x34, 0x92, 0xf9, 0xdc, 0xe0, 0x36, 0xa2, 0x1c, 0x45, 0x9f,\n        0xe1, 0xdc, 0xab, 0x56, 0xc7,\n        // Name Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x80,\n        // Symbol Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0xc0,\n        // Decimals: 18\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12,\n        // Name Length: 10\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x0a,\n        // Name: Test Token\n        0x54, 0x65, 0x73, 0x74, 0x20, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n        // Symbol Length: 2\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x02,\n        // Symbol: TT\n        0x54, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n\n    if encoded != expected {\n        std::println(f\"test_abi_encode_register: got: {encoded}\");\n        std::println(f\"test_abi_encode_register: expected: {expected}\");\n    }\n    assert_eq(encoded, expected);\n}\n\n#[test]\nunconstrained fn test_register_content_hash() {\n    let content: [u8; 260] = [\n        0x61, 0x1a, 0x7a, 0x19, // Function selector - register(address,string,string,uint8)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0xbbEda607223492F9dce036A21C459fE1dcab56c7\n        0xbb, 0xed, 0xa6, 0x07, 0x22, 0x34, 0x92, 0xf9, 0xdc, 0xe0, 0x36, 0xa2, 0x1c, 0x45, 0x9f,\n        0xe1, 0xdc, 0xab, 0x56, 0xc7,\n        // Name Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x80,\n        // Symbol Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0xc0,\n        // Decimals: 18\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12,\n        // Name Length: 10\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x0a,\n        // Name: Test Token\n        0x54, 0x65, 0x73, 0x74, 0x20, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n        // Symbol Length: 2\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x02,\n        // Symbol: TT\n        0x54, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    // sha256(content) = 0x0448b4e27885c9528619c3ccd291634a7aa4f66d562d479904429803f535d9f4\n    // sha256_to_field uses the first 31 bytes of the hash\n    let expected: Field = 0x0448b4e27885c9528619c3ccd291634a7aa4f66d562d479904429803f535d9;\n    let content_hash = sha256_to_field(content);\n    if content_hash != expected {\n        std::println(f\"test_register_content_hash: got: {content_hash}\");\n        std::println(f\"test_register_content_hash: expected: {expected}\");\n    }\n    assert_eq(content_hash, expected);\n}\n"
    },
    "55": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/portal/src/encoding/withdraw.nr",
      "source": "use aztec::protocol_types::{address::EthAddress, hash::sha256_to_field, traits::ToField};\n\n// bytes4(keccak256(\"withdraw(address,address,uint256)\")) = 0xd9caed12\nglobal WITHDRAW_SIGNATURE: [u8; 4] = [0xd9, 0xca, 0xed, 0x12];\n\npub fn withdraw_content_hash(eth_token: EthAddress, recipient: EthAddress, amount: Field) -> Field {\n    let encoded = abi_encode_withdraw(eth_token, recipient, amount);\n    let content_hash = sha256_to_field(encoded);\n    content_hash\n}\n\npub fn abi_encode_withdraw(\n    eth_token: EthAddress,\n    recipient: EthAddress,\n    amount: Field,\n) -> [u8; 100] {\n    // abi.encodeWithSignature(WITHDRAW_SIGNATURE, tokenAddr, recipient, amount)\n    // This encodes the following data:\n    // offset - data\n    // 0x00 - 4 bytes for the signature\n    // 0x04 - 32 bytes for the token address\n    // 0x24 - 32 bytes for the recipient\n    // 0x44 - 32 bytes for the amount\n    // Total: 100 bytes\n    let mut encoded = [0; 100];\n    for i in 0..4 {\n        encoded[i] = WITHDRAW_SIGNATURE[i];\n    }\n\n    let eth_token_bytes: [u8; 32] = eth_token.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = amount.to_be_bytes();\n\n    for i in 0..32 {\n        encoded[i + 0x4] = eth_token_bytes[i];\n        encoded[i + 0x24] = recipient_bytes[i];\n        encoded[i + 0x44] = amount_bytes[i];\n    }\n\n    encoded\n}\n\n#[test]\nfn test_abi_encode_withdraw() {\n    let eth_token = EthAddress::from_field(0xbbEda607223492F9dce036A21C459fE1dcab56c7);\n    let recipient = EthAddress::from_field(0x52b1D2CEBF3C80813f82dC4B5F56fCB4e04aC439);\n    let amount = 0x1234567890abcdef;\n    let encoded = abi_encode_withdraw(eth_token, recipient, amount);\n\n    // abi.encodeWithSignature(\"withdraw(address,address,uint256)\", address(0xbbEda607223492F9dce036A21C459fE1dcab56c7), address(0x52b1D2CEBF3C80813f82dC4B5F56fCB4e04aC439), 0x1234567890abcdef) =\n    // 0xd9caed12000000000000000000000000bbeda607223492f9dce036a21c459fe1dcab56c700000000000000000000000052b1d2cebf3c80813f82dc4b5f56fcb4e04ac4390000000000000000000000000000000000000000000000001234567890abcdef\n    let expected: [u8; 100] = [\n        0xd9, 0xca, 0xed, 0x12, // Function selector - withdraw(address,address,uint256)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0xbbEda607223492F9dce036A21C459fE1dcab56c7\n        0xbb, 0xed, 0xa6, 0x07, 0x22, 0x34, 0x92, 0xf9, 0xdc, 0xe0, 0x36, 0xa2, 0x1c, 0x45, 0x9f,\n        0xe1, 0xdc, 0xab, 0x56, 0xc7,\n        // Recipient Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0x52b1D2CEBF3C80813f82dC4B5F56fCB4e04aC439\n        0x52, 0xb1, 0xd2, 0xce, 0xbf, 0x3c, 0x80, 0x81, 0x3f, 0x82, 0xdc, 0x4b, 0x5f, 0x56, 0xfc,\n        0xb4, 0xe0, 0x4a, 0xc4, 0x39,\n        // Amount: 0x1234567890abcdef\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,\n        0xcd, 0xef,\n    ];\n\n    assert_eq(encoded, expected);\n}\n"
    },
    "56": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/portal/src/main.nr",
      "source": "mod constants;\nmod encoding;\nmod config;\n\nuse aztec::macros::aztec;\n\n#[aztec]\npub contract Portal {\n    use std::meta::derive;\n\n    use aztec::{\n        authwit::auth::assert_current_call_valid_authwit_public,\n        event::event_interface::{\n            emit_event_in_public_log,\n        },\n        hash::hash_args,\n        macros::{\n            events::event,\n            functions::{\n                initialization_utils::compute_initialization_hash, initializer, internal, private,\n                public, utility, view,\n            },\n            storage::storage,\n        },\n        protocol_types::{\n            address::{AztecAddress, EthAddress, PartialAddress},\n            contract_class_id::ContractClassId,\n            public_keys::PublicKeys,\n            traits::{FromField, Serialize, ToField},\n        },\n        state_vars::{Map, PublicImmutable},\n    };\n\n\n    use token::Token;\n\n    use crate::{\n        config::Config,\n        constants::PUBLIC_NOT_SECRET_SECRET,\n        encoding::{\n            deposit::deposit_content_hash, register::register_content_hash,\n            withdraw::withdraw_content_hash,\n        },\n    };\n\n    #[storage]\n    struct Storage<Context> {\n        config: PublicImmutable<Config, Context>,\n        l1_tokens: Map<EthAddress, PublicImmutable<AztecAddress, Context>, Context>,\n        l2_tokens: Map<AztecAddress, PublicImmutable<EthAddress, Context>, Context>,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Register {\n        eth_token: EthAddress,\n        aztec_token: AztecAddress,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Deposit {\n        eth_token: EthAddress,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Withdraw {\n        token: EthAddress,\n        from: AztecAddress,\n        to: EthAddress,\n        amount: u128,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(\n        l1_portal: EthAddress,\n        token_contract_class_id: ContractClassId,\n        shield_gateway: AztecAddress,\n    ) {\n        assert(!l1_portal.is_zero(), \"L1 portal address cannot be zero\");\n        assert(token_contract_class_id.to_field() != 0, \"Token contract class cannot be zero\");\n        assert(!shield_gateway.is_zero(), \"Shield gateway address cannot be zero\");\n\n        storage.config.initialize(Config { l1_portal, shield_gateway, token_contract_class_id });\n    }\n\n    #[private]\n    #[view]\n    fn get_config_private() -> Config {\n        storage.config.read()\n    }\n\n    #[public]\n    #[view]\n    fn get_config_public() -> Config {\n        storage.config.read()\n    }\n\n    #[private]\n    fn register_private(\n        eth_token: EthAddress,\n        aztec_token: AztecAddress,\n        name: str<31>,\n        name_len: u8,\n        symbol: str<31>,\n        symbol_len: u8,\n        decimals: u8,\n        message_leaf_index: Field,\n    ) {\n        aztec::oracle::debug_log::debug_log_format(\n            \"Registering L1 token {0} as L2 token {1}\",\n            [eth_token.to_field(), aztec_token.to_field()],\n        );\n\n        assert(storage.l1_tokens.at(eth_token).read().is_zero(), \"Token already registered\");\n\n        let config = storage.config.read();\n\n        // L1->L2 message content hash from token name, symbol, decimals\n        let content_hash =\n            register_content_hash(eth_token, name, name_len, symbol, symbol_len, decimals);\n        aztec::oracle::debug_log::debug_log_format(\"Register content hash: {0}\", [content_hash]);\n\n        // Ensure the supplied token address matches the expected address. This ensures its deployed with\n        // the correct code and initialization parameters.\n        let initializer = Token::interface().constructor_with_minter(name, symbol, decimals, context.this_address() /* minter */, AztecAddress::zero() /* not upgradable */);\n        let args_hash = hash_args(initializer.args);\n        aztec::oracle::debug_log::debug_log_format(\"Args hash: {0}\", [args_hash]);\n        let init_hash = compute_initialization_hash(initializer.selector, args_hash);\n        aztec::oracle::debug_log::debug_log_format(\"Init hash: {0}\", [init_hash]);\n        let partial_address = PartialAddress::compute(\n            config.token_contract_class_id,\n            0x9876543210, // salt, hardcoded\n            init_hash,\n            AztecAddress::from_field(0),\n        );\n\n        aztec::oracle::debug_log::debug_log_format(\"Computed partial address: {0}\", [partial_address.to_field()]);\n        let computed_address = AztecAddress::compute(PublicKeys::default(), partial_address);\n        aztec::oracle::debug_log::debug_log_format(\"Computed address: {0}\", [computed_address.to_field()]);\n\n        assert(\n            computed_address == aztec_token,\n            \"Expected address did not match supplied token address\",\n        );\n\n        // Set the shield gateway\n        Token::at(aztec_token)\n            .set_shield_gateway(config.shield_gateway)\n            .enqueue(&mut context);\n\n        // Consume the message\n        aztec::oracle::debug_log::debug_log_format(\n            \"Consuming message with leaf index {0} from portal {1}\",\n            [message_leaf_index, config.l1_portal.to_field()],\n        );\n\n        aztec::oracle::debug_log::debug_log_format(\"L1 Portal: {0}\", [config.l1_portal.to_field()]);\n\n        context.consume_l1_to_l2_message(\n            content_hash,\n            PUBLIC_NOT_SECRET_SECRET,\n            config.l1_portal,\n            message_leaf_index,\n        );\n\n        Portal::at(context.this_address())._register_public(aztec_token, eth_token).enqueue(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _register_public(aztec_token: AztecAddress, eth_token: EthAddress) {\n        // Initialize the token mappings\n        storage.l1_tokens.at(eth_token).initialize(aztec_token);\n        storage.l2_tokens.at(aztec_token).initialize(eth_token);\n        emit_event_in_public_log(\n            Register { eth_token, aztec_token },\n            &mut context,\n        );\n    }\n\n    #[private]\n    fn claim_public(\n        eth_token: EthAddress,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        let content_hash = deposit_content_hash(eth_token, recipient, amount.to_field());\n        aztec::oracle::debug_log::debug_log_format(\"Deposit content hash: {0}\", [content_hash]);\n\n        let config = storage.config.read();\n\n        // Consume the message\n        context.consume_l1_to_l2_message(\n            content_hash,\n            PUBLIC_NOT_SECRET_SECRET,\n            config.l1_portal,\n            message_leaf_index,\n        );\n\n        Portal::at(context.this_address())\n            ._claim_public(eth_token, recipient, amount, message_leaf_index)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _claim_public(\n        eth_token: EthAddress,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        Token::at(storage.l1_tokens.at(eth_token).read()).mint_to_public(recipient, amount).call(\n            &mut context,\n        );\n\n        Portal::at(context.this_address())\n            ._log_claim(eth_token, recipient, amount, message_leaf_index)\n            .call(&mut context);\n    }\n\n    #[private]\n    fn claim_shielded(\n        eth_token: EthAddress,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        let content_hash = deposit_content_hash(eth_token, recipient, amount.to_field());\n        aztec::oracle::debug_log::debug_log_format(\"Deposit content hash: {0}\", [content_hash]);\n\n        let config = storage.config.read();\n\n        // Consume the message\n        context.consume_l1_to_l2_message(\n            content_hash,\n            PUBLIC_NOT_SECRET_SECRET,\n            config.l1_portal,\n            message_leaf_index,\n        );\n\n        Token::at(storage.l1_tokens.at(eth_token).read()).mint_to_private(recipient, recipient, amount).call(\n            &mut context,\n        );\n\n        Portal::at(context.this_address())\n            ._log_claim(eth_token, recipient, amount, message_leaf_index)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _log_claim(\n        eth_token: EthAddress,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        emit_event_in_public_log(\n            Deposit { eth_token, recipient, amount, message_leaf_index },\n            &mut context,\n        );\n    }\n\n    #[public]\n    fn withdraw_public(\n        eth_token: EthAddress,\n        from: AztecAddress,\n        recipient: EthAddress,\n        amount: u128,\n        withdrawNonce: Field,\n        burnNonce: Field,\n    ) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(withdrawNonce == 0, \"Invalid nonce\");\n        }\n\n        let config = storage.config.read();\n\n        // Burn the tokens\n        Token::at(storage.l1_tokens.at(eth_token).read()).burn_public(from, amount, burnNonce).call(\n            &mut context,\n        );\n\n        // Message the L1 Portal\n        let content_hash = withdraw_content_hash(eth_token, recipient, amount.to_field());\n        context.message_portal(config.l1_portal, content_hash);\n\n        aztec::oracle::debug_log::debug_log_format(\"Withdraw L2ToL1 Message {0}\", [content_hash]);\n\n        emit_event_in_public_log(\n            Withdraw { token: eth_token, from, to: recipient, amount },\n            &mut context,\n        );\n    }\n\n    #[utility]\n    unconstrained fn is_registered_l1_unconstrained(eth_token: EthAddress) -> pub bool {\n        !storage.l1_tokens.at(eth_token).read().is_zero()\n    }\n\n    #[utility]\n    unconstrained fn is_registered_l2_unconstrained(aztec_token: AztecAddress) -> pub bool {\n        !storage.l2_tokens.at(aztec_token).read().is_zero()\n    }\n\n    #[utility]\n    unconstrained fn get_l2_token_unconstrained(eth_token: EthAddress) -> pub AztecAddress {\n        storage.l1_tokens.at(eth_token).read()\n    }\n\n    #[utility]\n    unconstrained fn get_l1_token_unconstrained(aztec_token: AztecAddress) -> pub EthAddress {\n        storage.l2_tokens.at(aztec_token).read()\n    }\n}\n"
    },
    "58": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/authwit/auth.nr",
      "source": "use crate::{\n    authwit::authwit_interface::AuthwitInterface,\n    context::{gas::GasOpts, PrivateContext, PublicContext},\n    hash::hash_args_array,\n    macros::authwits::authwit,\n};\nuse dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::ToField,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\npub global IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n#[authwit]\nstruct CallAuthwit {\n    msg_sender: AztecAddress,\n    selector: FunctionSelector,\n    args_hash: Field,\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let authwit = CallAuthwit {\n        msg_sender: context.msg_sender(),\n        selector: context.selector(),\n        args_hash: context.get_args_hash(),\n    };\n    let inner_hash = authwit.emit_as_offchain_effect_and_get_hash();\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "66": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "67": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{\n    gas::GasOpts, private_context::PrivateContext, public_context::PublicContext,\n    returns_hash::ReturnsHash,\n};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\nuse crate::test::helpers::cheatcodes;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateStaticCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<N>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateStaticCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateStaticVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateStaticVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PublicCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicStaticCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicStaticVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicStaticVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for UtilityCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T, let N: u32> UtilityCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\n// UtilityVoidCallInterface\n\npub struct UtilityVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for UtilityVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T, let N: u32> UtilityVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\npub trait TXEPublicCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field);\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicStaticVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\npub trait TXEPrivateCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field);\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n\n        let (_end_side_effect_counter, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns: T = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_end_side_effect_counter, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateStaticVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\npub trait TXEUtilityCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self) -> T;\n}\n\nimpl<let M: u32, T, let N: u32> TXEUtilityCallInterface<T, N> for UtilityCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self) -> T {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let returns_hash = crate::oracle::simulate_utility_function::simulate_utility_function(\n            self.get_contract_address(),\n            self.get_selector(),\n            args_hash,\n        );\n\n        let returns: T = ReturnsHash::new(returns_hash).get_preimage();\n        returns\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEUtilityCallInterface<T, N> for UtilityVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self) -> T {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let returns_hash = crate::oracle::simulate_utility_function::simulate_utility_function(\n            self.get_contract_address(),\n            self.get_selector(),\n            args_hash,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n        returns\n    }\n}\n"
    },
    "74": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        include_by_timestamp::IncludeByTimestamp,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: IncludeByTimestamp,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: IncludeByTimestamp::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp =\n            IncludeByTimestamp::min_with_u64(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: IncludeByTimestamp::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "75": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_U32_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> u128 {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> u128 {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "76": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n\n    pub fn get_preimage_and_assert_empty<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n        assert_eq(self.hash, 0);\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "77": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_timestamp, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let contract_address = get_contract_address();\n        let version = get_version();\n        let chain_id = get_chain_id();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "79": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/event/event_interface.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext},\n    event::event_selector::EventSelector,\n    messages::{\n        logs::{event::to_encrypted_private_event_message, utils::prefix_with_tag},\n        offchain_messages::emit_offchain_message,\n    },\n    utils::remove_constraints::{remove_constraints, remove_constraints_if},\n};\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator,\n    traits::{Serialize, ToField},\n    utils::arrays::array_concat,\n};\n\npub struct PrivateLogContentConstraintsEnum {\n    /// The contents of the log are entirely unconstrained, and could have any values.\n    ///\n    /// Only use in scenarios where the recipient not receiving the message is an acceptable outcome (e.g. because the\n    /// sender is somehow motivated to ensure the recipient learns of it).\n    pub NO_CONSTRAINTS: u8,\n    /// The contents of the log and its encryption are constrained. The tag (and therefore whether the recipient is\n    /// actually able to find the message) is not.\n    ///\n    /// Only use in scenarios where the recipient not receiving the message is an acceptable outcome (e.g. because the\n    /// sender is somehow motivated to ensure the recipient learns of it).\n    // TODO(#14565): This variant requires for tagging to also be constrained, as it is otherwise useless.\n    pub CONSTRAINED_ENCRYPTION: u8,\n}\n\npub global PrivateLogContent: PrivateLogContentConstraintsEnum = PrivateLogContentConstraintsEnum {\n    NO_CONSTRAINTS: 1,\n    CONSTRAINED_ENCRYPTION: 2,\n    // TODO: add constrained tagging and constrained handshaking\n};\n\n/// Emits an event in a private log, encrypting it such that only `recipient` will learn of its contents. The log will\n/// be tagged using a shared secret between `sender` and `recipient`, so that `recipient` can efficiently find the log.\n///\n/// The `constraints` value determines what parts of this computation will be constrained. See the documentation for\n/// each value in `PrivateLogContentConstraintsEnum` to learn more about the different variants.\npub fn emit_event_in_private_log<Event, let N: u32>(\n    event: Event,\n    context: &mut PrivateContext,\n    sender: AztecAddress,\n    recipient: AztecAddress,\n    constraints: u8,\n)\nwhere\n    Event: EventInterface + Serialize<N>,\n{\n    // This function relies on `constraints` being a constant in order to reduce circuit constraints when unconstrained\n    // usage is requested. If `constraints` were a runtime value then performance would suffer.\n    assert_constant(constraints);\n\n    let (ciphertext, randomness) = remove_constraints_if(\n        constraints == PrivateLogContent.NO_CONSTRAINTS,\n        || to_encrypted_private_event_message(event, recipient),\n    );\n    let log_content = prefix_with_tag(ciphertext, sender, recipient);\n\n    // We generate a cryptographic commitment to the event to ensure its authenticity during out-of-band delivery.\n    // The nullifier tree is chosen over the note hash tree for this purpose since it provides a simpler mechanism\n    // - nullifiers require no nonce, and events, being non-spendable, don't need the guarantee that a \"spending\"\n    // nullifier can be computed.\n    // TODO(#11571): with decryption happening in Noir we can now use the Packable trait instead.\n    let serialized_event_with_randomness = array_concat([randomness], event.serialize());\n    let event_commitment = poseidon2_hash_with_separator(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n    context.push_nullifier(event_commitment);\n\n    context.emit_private_log(log_content, log_content.len());\n}\n\n/// Emits an event as an offchain message. Similar to private log emission but uses offchain message mechanism instead.\n///\n/// Unlike private log emission, encryption here is always unconstrained. This design choice stems from the nature of\n/// offchain messages - they lack guaranteed delivery, unlike private logs. Without delivery guarantees, smart\n/// contracts cannot make assumptions about a message being delivered, making constrained encryption unnecessary.\n/// However, message integrity remains protected through a cryptographic commitment stored in the nullifier tree,\n/// preventing tampering even in the absence of guaranteed delivery. See the description of the\n/// `messages::offchain_message::emit_offchain_message` function for more details on when a guaranteed delivery is\n/// valuable. If guaranteed delivery is required, the `emit_event_in_private_log` function should be used instead.\npub fn emit_event_as_offchain_message<Event, let N: u32>(\n    event: Event,\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n)\nwhere\n    Event: EventInterface + Serialize<N>,\n{\n    // Safety: as explained above, this function places no constraints on the content of the message.\n    let (message_ciphertext, randomness) =\n        unsafe { remove_constraints(|| to_encrypted_private_event_message(event, recipient)) };\n\n    // We generate a cryptographic commitment to the event to ensure its authenticity during out-of-band delivery. Note\n    // that the commitment is made from the (constrained) event content, and not the (unconstrained) ciphertext.\n    // The nullifier tree is chosen over the note hash tree for this purpose since it provides a simpler mechanism\n    // - nullifiers require no nonce, and events, being non-spendable, don't need the guarantee that a \"spending\"\n    // nullifier can be computed.\n    // TODO(#11571): with decryption happening in Noir we can now use the Packable trait instead.\n    let serialized_event_with_randomness = array_concat([randomness], event.serialize());\n    let event_commitment = poseidon2_hash_with_separator(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n    context.push_nullifier(event_commitment);\n\n    emit_offchain_message(message_ciphertext, recipient);\n}\n\npub fn emit_event_in_public_log<Event, let N: u32>(event: Event, context: &mut PublicContext)\nwhere\n    Event: EventInterface + Serialize<N>,\n{\n    let mut log_content = [0; N + 1];\n\n    let serialized_event = event.serialize();\n    for i in 0..serialized_event.len() {\n        log_content[i] = serialized_event[i];\n    }\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    log_content[serialized_event.len()] = Event::get_event_type_id().to_field();\n\n    context.emit_public_log(log_content);\n}\n\npub trait EventInterface {\n    fn get_event_type_id() -> EventSelector;\n}\n"
    },
    "80": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    // TODO(#2707): Consider making this a u64 as we already cast this to that when encoding the message. This would decrease\n    // the likelihood of collisions without any extra cost.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "82": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n    // +1 to length to account for the separator\n    let nonzero_length = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, nonzero_length)\n    // NOTE: we use poseidon2_hash_subarray here because we want to hash the bytecode only up to\n    // its nonzero length. We do NOT want to include a `1` at the end to indicate \"variable length\",\n    // and we want to enforce that all trailing elements are zero.\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "94": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(self.global_variables.block_number, public_data_tree_index)\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "99": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v1.2.1/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    }
  }
}
