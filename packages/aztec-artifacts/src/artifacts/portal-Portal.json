{
  "transpiled": true,
  "noir_version": "1.0.0-beta.5+0000000000000000000000000000000000000000",
  "name": "Portal",
  "functions": [
    {
      "name": "_claim_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7069518359247663558": {
            "error_kind": "string",
            "string": "Function _claim_public can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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CqcuAIADgAUBAIAFAAKADi4EgAuADiMAAArsKACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uBIALgA4BAIAOAAKADi4EgAmADiMAAArsIwAAC0UoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4EgAuADwEAgA8AAoAPLgSADoAPIwAAC0UoAIANBAADAQCABYANgAwLAIADgAWADSQAgA0AAAupAQCACoAIgA8uAIAKgBAuAIAMgBELAIAQgA+AEiQAgBIAAAupLgGAEIAOLgSADoARAQCAEAACgBABAIARAAKAESMAAAt4AQCADIAIgAYmLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAADAEjAAAMcSQAgA0AAAwOIwAADCcuAIADgAUBAIAFAAKADi4EgAuADiMAAAxsKACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uBIALgA4BAIAOAAKADi4EgAmADiMAAAxsIwAADMUoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4EgAuADwEAgA8AAoAPLgSADoAPIwAADMUoAIANBAADAQCABYANgAwBAIAMgASADQMAgAgAAoAOAQCADYAOgA8BAIAKgA6AEA0AgBCACoAOJACADgAADSUuAYAQgBEuBIARgA8DAIAQAAKAEAMAgA8AAoAPIwAADPQuAIAMgAYmKgEAAQXFa8RaDhAAAjwEAgEmLgGAA4AGCwCABgACgAckAIAHAAANWSMAAA1kLgCAA4AFIwAADcsuAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAANty4BgAqACC4EgAiACwEAgAoAAoAKAQCACwACgAsjAAANhigBgAUEAAEDAIAGAAKABiMAAA3LJioBAAEFRafKcRlB5BU8BAIBJg==",
      "debug_symbols": "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",
      "brillig_names": [
        "_claim_public"
      ]
    },
    {
      "name": "_log_claim",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "11430482739715627628": {
            "error_kind": "string",
            "string": "Function _log_claim can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgUEBCcCBgQAHwoABQAGgEQdAIBGgEYGLgiARAABLgiARQACLgiARgADLgiARwAEJQAAAF4lAAAAXygCAAEEgEgnAgIEADsOAAIAASYlAAACOB4CAAYAHgIABwAzKgAGAAcACCcCBgEBJAIACAAAAIglAAACYR4CAAYBHgIABwAKKgYHCCQCAAgAAACkJQAAAnMcCgMGACkCAAMAIxDODy0IAQcnAggEBgAIAQgBJwMHBAEAIgcCCC0KCAktDgEJACIJAgktDgIJACIJAgktDgYJACIJAgktDgQJACIJAgktDgMJJwIBAAAtCAECJwIDBAYACAEDAScDAgQBACICAgMtCgMELQ4BBAAiBAIELQ4BBAAiBAIELQ4BBAAiBAIELQ4BBAAiBAIELQ4BBC0IAQEAAAECAS0OAgEnAgIEACcCAwQFJwIEBAEtCgIFIwAAAWQMKgUDAiQCAAIAAAHuIwAAAXYtCwECJwIFBAUGIgUCAScCBwQDACoFBwYtCAEEAAgBBgEnAwQEAQAiBAIGLQ4FBgAiBgIGLQ4FBicCBwQDACoEBwYAIgICBy4CAAeAAy4CAAaABC4CAAWABSUAAAKFACIEAgYtCwYFJwIHBAIAKgYHAjcLAAIABSYAIgcCBgAqBgUILQsIAi0LAQYuAgAGgAMoAIAEBAAGJQAAAssuCIAFAAgAIggCCQAqCQUKLQ4CCi0OCAEAKgUEAi0KAgUjAAABZCgAgAQEeAANAAAAgASAAyQAgAMAAAJgKgEAAQX3ofOvpa3UyjwEAgEmKgEAAQW+Hj//PqT2+jwEAgEmKgEAAQWeoTt9j/vabDwEAgEmAQCAA4AFgAcuAIADgAguAIAEgAkLAIAIgAeACiQAgAoAAALKLgGACIAGLgSABoAJAQCACAACgAgBAIAJAAKACSMAAAKZJi4BgAOABgsAgAYAAoAHJACABwAAAuYjAAAC8S4AgAOABSMAAANYLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAAA0QuAYAKgAguBIAIgAsBAIAKAAKACgEAgAsAAoALIwAAAxMoAYAFBAABAwCABgACgAYjAAADWCY=",
      "debug_symbols": "tZfdjuIwDIXfpddcxHZ+eZUVGjFMZ4RUFdSBlVYj3n3tNm7pSInYQXtDv7jk1Cd2Av1q3trX68fLsX8/fTbbX1/N63DsuuPHS3c67C/HU8/Rr8bIBxi+2A1fXbMNfAUegxGIDMCAlIFAwTPIJCsRmWUlEhkcKKQM3jZbJAGOoMwKMUNEhZAhaSTlCBpU8BkkwwmcQlZGtAr5EUikoIJWBSVn5ORRcp7AZfBGQSNBI2GOpAyRFGKG0cUIYQIyoJAfSmAUnEIWJCSFLEhOZvFiUhCDSYBvEZeJ5OkTaCRpJOWIlTWcIGQAjYBGEBR8BjIKLoPViNWI01lOdTwpyNORIZBCyCB1n0AjiX0RCaQJnLEKosP1cpKzeHfSmSOgyyCpTuAzSGdOoBGn33HjGt5um0a3w8tlaFvZDXf7g3fNeT+0/aXZ9teu2zS/9911/NLned+P18t+4Lvste3f+MqC78euFbptltmmPBWIkk4HYjuzBJi0EoGKiEFUDWPxTsKvJLAsYZMJWcIm8LNEsCsFKitEa2NWiNbbkkLVRkpqAyAVbbinbfj/a8PFuRqxXI1YkXBBbYAnKiWRygrJyYYZFRKLPWkDsGyj1twINGvwWe3LzV1pTd7+ukMYY9FKrTcdOC0qnxQliboVj4uVVVm/WXm+PeH5/ny8KtEWrVREInrSNPhHapZwbu2k0qL8A58V0NxVNa6PrFoOYS5qgsUE80qh0uOEaoIolhUqzQkhSbWmxQwJl94iEx/Ow0XV8PgzJ97pHvGBygqV3oxzDgmg1FZY6UwKRutBAZckyMHjGtFoFozhZxrJ6FpQgorGY4uBxeOiKhDMLFA8v6lS0BRQN2kKLv2oIJHmgsS7vwX/tpi4LCZ9K+qOh/vDcVi9VNxEbDjuX7s2D9+v/eHu7uXPWe/oS8l5OB3at+vQitLyZsIfv/hNY8M/hzv+MysjXnP+m7STtxUZ8qHPbykyhHGYNnyi7W6S2l8=",
      "brillig_names": [
        "_log_claim"
      ]
    },
    {
      "name": "_register_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "aztec_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14788743618517749904": {
            "error_kind": "string",
            "string": "Function _register_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tZvdbhQ7DMffZa97kQ8ntnkVhFCBBVWqCirtkY5Q3/3YSezsIk20ZwZu2t96J/+JEyf2ZNpfpy/nT6/fPj48ff3+8/Tu/a/Tp+eHx8eHbx8fv3++f3n4/iTWX6egP2Iqp3dwd4pZPqL+ls8xCEAWiAIlGlQBvbaqRS+uaiEBjAY8gOD0LhUFHsDZgDqkkA3MEs0ScUCKBnWA9rRDMdBbVIEaDMDAvkKzoFnILEQDOBlghxyiQR0Qg0ExUEEZlpyyAQ3IyaAOgGhQDKx5gQHNiwZusWtQW8nIZwoGbuEBbZwbYAdoXjQoBuNiiGBglpQNaEDzokEdAMHAmoNdXOziYnevZtFoSRIboNHSoRjwAMoGOIDtYh7NS4gGxUCaZwnRou40SGmARksHuThnAQ3sjAraSpvryDfQrnaQu0MS0LBpoAMO+pWGTQcewGbhYakBDGhATAY4QAO7Qx2gXQUW0BXXoQyo9lU1C5oF3cIDdAw70AAN7A7YAUM0qAM0sAEVwIAHaEh0wAEaEh3qALDmGtgNmhcNzFLtGo2EIpsMaiR0KAY8QL3ogAPYLuZxMYVg4BZtLtNN6kUHGqAh0aEO0AHvYBdnaw5mAWuugV2Kglpk4VPNBjS+0mipWYEGqBcdzMJm4WHhkAzqgBgNyoAUDPQWoEADcjYwC5gFzKKd71AH6B7eoQzQiOpgt9C5aNC8SAo4QCOqQ+0Qg07GoOLERjE7kVHzpZPbsl+nc1E1XwSdjEFuK9kJjZpPnYqTt0Bv0WanEbmNXKW51qkOis23TuBkKjEmJ2+RopPbNN5qbVSc2KjNWic00jU0yFtUV6nT5irNS25ERlSNdKsaJC1Qs3oKcjfU/rXsi7URGWnvO2XpC4VG0oKaTdPZoGpU3FbcVt2mfR7ERhpwg8hIZ2aQ3k2rjaQbwKA6qGXoQW6LbtP1M4iNNOoGkZFG3SC7W4bkpMqlFUfBqTixkW4Ig8gIk5OrUHRCI3Yb23WgGwNRIzRqvnUqTmykO/Ugb5G9hW7WncBtul2TRgQ03zqBExlpahxUjdBboKuQ28hVdO/jrKTxx9CIh61lceZWaIITGyW3JbfpbA0iI3AbuE13vUFopJE4qBqh29D7gn438h6QK7PfTTOq7GmCVafLsDrqhBm6FUMrs1NDLZmDDgVGdEzFUbcNQ5hIijqWWJqChgxqCBqiYyvPBxZHmtfyvIBbJ3XlUXeoIztGcExhYnHM09r7q4uIIE1Ex1Ica5g4m1VyxKlArb/tOYOqI4eJMJEMuTvU0ZtxjBOnNYWJMHGK5SbGDckRimMJE6tje3gayI7oc8Ho88YUJ5o1heaFPqMJqq4+nKXQpqVjShPRMbfnuNSwOmrdZggTybGkibNZnWJ1WnGK4RTDKUZTjGYzns3Ym7WcK/mxIRnm/lgKii1KYnsAbFHSsUXJQHTsI5kaVsceMB1tQSYIYeK0xmmN05qmNbku5GntK6AjOfbF0HE2K7NZWxfNTWirO+pjKXSHGjaHmm/QR7IhT2tzaGBTkIWTSoCJ0xrboFJDcuxh1NFvUXKayI7gc1GaFwO9D6VO65y3MuetzHkrOO9GXeHt7e5khxcfX57PZz27uDjNkDOOH/fP56eX07un18fHu9M/94+v7aKfP+6f2u+X+2f5VlbN+emL/BbBrw+PZ6W3u9k6bDeV2oCtuWT9VFxC1vCVSFyIyOI0jQDpQqJeSaRtCWDdA5uEzHd1CYQrhbytIE83NBQIKmwpLN3Q7NfdkFpy041y2I36d90o5LNB27NBC4mC5kasOW91grcVuGQYCixiB92Qin3TjVVwS/HvGkmKo+3gXoRmCWQrRJA2XVnFZtGF3ydVDm+2JNau1DRduZrW31w5Hp7xeHzePisEm64sRGSTteEoGOZolHLtCa+2vmohKk8bF72o171IK1/0qKRJpItOyBHptcIizBHBNh05JppTkvh6QNMiQmXftlm9mNQUf1NYBGiSKtEckXplWwMWU5LMkcsQ/18KbNFZY9nnRyLrhBypp30aGH1SceHJMrbA+yHPbnU7thYachpqc4Kpzk1YdsPrnLiITznfSD4e6SKlyZa8Z6Ul2FppeRGfiYrtoDI/271YarCec3cNLrStsYgveTi0fqBsyZtFxmIHxepRLge+m8kgL3ZQqYA5e2aTKnRTZDkcbEEqp0Vx15DmiLYBZnnq2tZYBCkljw4Z3M10AIsAo0CeHGVP3pRY1Qp6TuFDWiHvGVI5ObN+5BzK5nBAXhUtXvZI/XKxF4ffNOB4RoByNCNAPZ4R9NXHsYywVLgpIyz9uDEjLDVuzAjr6Mrsi61uR1dJhxdbyYcXW4E/sNjW/fBnLYppTxkpbzHR81LFrbxU8HgFWOhoBVj4+Hqv4eh6r/H4eq/p6HpfKty03pd+3Ljelxo3rvdlbN1YAVY8XgFW+rsV4OVK47i10jAcrwCXGjdWgJgOV4CYD1eACH+gAlwPx20V4Erj1goQ8XBSQjqclJD/QFJaDseNFSDF4xUgpeMZgfLRjEBwPCNQOZoRlgo3ZYSlHzdmhKXGjRlhHV23VYAcDi82jocXG6c/sNjW/ThcAZKnNnmlsnkGyIvoih5d8u5udoGuBVbHoeiDeZEZZeVcK6ySvGfGinlbYbV9ksWmvN/dnIqVAAYX2JxLeXW5OO7HZEe6LG/u95wKX75DqtsrfSURPblLhqV9EvOUXd7j75LIHlOC+3pRUpi1I+6TqLP8JN7nSHAJyYz7JADmy8Vdjty68656UasPZ8V9jiB6wYacdknwHE5OuyQQLDgR6h4BhuIv5XaNw3x/xGlfD3x9yT5x0IXfBT7Ix/vPD89X/xHwplLPD/efHs/j49fXp88X3778+8O+sf8o+PH8/fP5y+vzWZXmvxXIj/eQ8Q4Kfbg76Z9OvM/ySJJz+xj1W3nOhxo/vGln/gM=",
      "brillig_names": [
        "_register_public"
      ]
    },
    {
      "name": "claim_public",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17288131482828810359": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "build_msg_block",
        "attach_len_to_msg_block",
        "debug_log_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "get_l1_to_l2_membership_witness",
        "notify_created_nullifier_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_to_radix",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "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\n0wjG1j0HkTruZrSFZmQJ4zJievrMBCtdWDUY"
    },
    {
      "name": "claim_shielded",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17288131482828810359": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "vL3dkvS8cp15L/vYBwTyB5m+lYkJh8ajmVDEDskhy3Oi0L1PMUnkyrdbhUZX1ecTv4+3+luLBJmLLAAE/v1v//c//l//6//9b//0z//Pv/zPv/3X/+Pf//Z//es//f3v//T//re//8t//4d/+6d/+efH//rvfzvO/6d1/tt/bf/l8a/c/+r977j/tftfv/6l4/633f/2+1+6/7316NajW49uPbr16NbjW49vPb71+NbjW49vPb71+NbjW49vPbn15NaTW09uPbn15NaTW09uPbn15NbTW09vPb319NbTW09vPb319NbTW09vvXHrjVtv3Hrj1hu33rj1xq03br1x641bz249u/Xs1rNbz249u/XsodfPf8f9r93/+vWvH/e/7f73oSfnvw+9cf7L979y/6v3v+P+1+5/Pf7tx3H/2+5/+/0v3f+ex9dPkAk6YUywCX5DOya0CX0CTZjKbSq3qdymcpvKbSr3qdyncp/KfSr3qdyncp/KfSr3qdynMk1lmspRO3ICTeAJMkEnjAk2wW+IGgpoE6YyT2WeyjyVeSrzVOapzFNZprJMZZnKMpVlKstUlqksU1mmskxlnco6lXUq61TWqaxTWaeyTmWdyjqVx1QeU3lM5TGVx1QeU3lM5TGVx1QeU9mmsk1lm8o2lW0q21S2qWxT2aayTWWfyj6Vz7prdgJN4AkyQSeMCTbBL6Cz/i5oE/oEmsATZMKZEv2EMcEm+A1nDV7QJvQJNIEnyISp3KZym8ptKp812OWENqFPoAk8QSbohDHBJvgNNJVpKtNUpql81mD3E2SCThgTbILfcNbgBW1Cn0ATpjJPZZ7KPJV5KvNUlqksU1mmskxlmcoylWUqy1SWqSxTWaeyTmWdyjqVdSrrVNaprFNZp7JO5TGVx1QeU3lM5TGVx1QeU3lM5TGVx1S2qWxT2aayTWWbyjaVbSrbVLapbFPZp7JPZZ/KPpV9KvtU9qnsU9mnst/KfBwT2oQ+gSbwBJmgE8YEmzCV21RuU7lN5TaV21RuU7lN5TaV21RuU7lP5T6V+1TuU7lP5T6V+1TuU7lP5T6VaSrTVKapTFN51iDPGuRZg3zWILUTbILfcNbgBW1Cn0ATeIJM0AlTmacyT2WZyjKVZSrLVJapLFNZprJMZZnKMpV1KutU1qmsU1mnsk5lnco6lXUq61QeU3lM5TGVx1QeU3lM5TGVx1QeU3lMZZvKNpVtKttUtqlsU9mmsk1lm8o2lX0q+1T2qexT2aeyT2Wfyj6VfSr7rSzHMaFN6BNoAk+QCTphTLAJU7lN5TaV21RuU7lN5TaV21RuU7lN5TaV+1TuU7lP5T6V+1TuU7lP5T6V+1TuU5mmMk1lmso0lWkq01SmqTxrUGYNyqxBmTUoswZl1qDMGpRZgzJrUGYNyqxBmTUoswZl1qDMGpRZgzJrUGYNyqxBmTUoswZl1qDMGpRZgzJrUGYNyqxBiRqUE2SCThgTbILfEDUY0Cb0CTRhKo+pPKbymMpnDXI/wW84a/CCNqFPoAk8QSbohDFhKttU9qnsU9mnsk9ln8o+lX0q+1T2qey3sp41yHxCm9An0ASeIBN0wphgE/yGNpXbVG5TuU3lswZZTpAJOmFMsAl+w1mDF7QJfQJNmMp9Kvep3KfyWYNsJ/gNZw1e8FCW44Q+gSbwBJmgE8YEm+A3nDV4wVTmqcxTmafyWYNCJ+iEMcEm+A1nDV7QJvQJNIEnTGWZyjKVZSqfNSjn1Tlr8II2oU+gCTxBJuiEMcEmTOUxlcdUHlN5TOUxlcdUHlN5TOUxlcdUtqlsU9mmsk1lm8o2lW0q21S2qWxT2aeyT2Wfyj6VfSr7VPap7FPZp7LfyuM4JrQJfQJN4AkyQSeMCTZhKrep3KZym8ptKrep3KZym8ptKrep3KZyn8p9Kvep3Kdyn8p9Kvep3Kdyn8p9KtNUpqlMU5mmMk1lmso0lWkq01SmqcxTmacyT2WeyjyVeSrzVOapzFOZp7JMZZnKUYN6Ak3gCTJBJ4wJNsFviBoMaBOmsk5lnco6lXUq61TWqaxTeUzlMZXHVB5TeUzlMZXHVB5TeUzlMZVtKttUtqlsU9mmsk1lm8o2lW0q21T2qexT2aeyT2Wfyj6VfSr7VPap7LeyHceENqFPoAk8QSbohDHBJkzlNpXbVG5TuU3lNpXbVG5TuU3lNpXbVO5TuU/lPpX7VO5TuU/lPpX7VO5TuU9lmso0lWkq01SmqUxTmaYyTWWayjSVeSrzVOapzFOZpzJPZZ7KPJV5KvNUlqksU3nWoM0atFmDNmvQZg3arEGbNWizBm3WoM0atFmDNmvQZg3arEGbNWizBm3WoM0atFmDNmvQZg3arEGbNWizBm3WoM0atFmDNmvQZg3arEGbNWizBm3WoM0atFmDNmvQZg3arEGbNWizBm3WoM0atFmDNmvQZg3arEGbNWizBn3WoM8a9FmDPmvQZw36rEGfNeizBn3WoM8a9FmDPmvQZw36rEGfNeizBn3WoEcN+gk2wW+IGgxoE/oEmsATZIJOmMp9KvepTFP5rEE9TugTaAJPkAk6YUywCX7DWYMXTGWeyjyVeSrzVOapzFOZpzJPZZnKMpVlKstUlqksU1mmskxlmcoylXUq61TWqaxTWaeyTmWdyjqVdSrrVB5TeUzlMZXHVB5TeUzlMZXHVB5TeUxlm8o2lW0q21S2qWxT2aayTWWbyjaVzxpUPqFN6BNoAk+QCTphTLAJfkE7jiOpJZ3iI4iSOEmSNGkkWZJPOsvxppaUHi09Wnq09Gjp0dKjpUdLj54ePT16evT06OnR06OnR0+Pnh49PSg9KD0oPSg9KD0oPSg9KD0oPSg9OD04PTg9OD04PTg9OD04PTg9OD0kPSQ9JD0kPSQ9JD0kPSQ9JD0kPTQ9ND00PTQ9ND00PTQ9ND00PTQ9RnqM9BjpMdJjpMdIj5EeIz1Geoz0sPSw9LD0sPSw9LD0sPSw9LD0sPTw9PD08PTw9PD08PTw9PD08PTw6dGOI6kl9SRK4iRJ0qSRZEnpkXXess5b1nnLOm9Z5y3rvGWdt6zzlnXess5b1nnLOm9Z5y3rvGWdt6zzlnXess5b1nnLOm9Z5y3rvGWdt6zzlnXess5b1nnLOm9Z5y3rvGWdt6zzlnXess5b1nnLOm9Z5y3rvGWdt6zzlnXess5b1nnLOm9Z5y3rvGWdt6zzlnXess5b1nnLOm9Z5y3rvGWdt6zzlnXess5b1nnLOm9Z5y3rvGWdt6zzlnXess5b1nnLOm9Z5y3rvGWdt6zzlnXess5b1nnLOm9Z5y3rvGWdt6zzlnXess5b1nnLOm9Z5y3rvGWdt6zzlnXess571nnPOu9Z5z3rvGed96zznnXes8571nnPOu9Z5z3rvGed96zznnXes8571nnPOu9Z5z3rvGed96zznnXes8571nnPOu9Z5z3rvGed96zznnXes8571nnPOu9Z5z3rvGed96zznnXes8571nnPOu9Z5z3rvGed96zznnXes8571nnPOu9Z5z3rvGed96zznnXes8571nnPOu9Z5z3rvGed96zznnXes8571nnPOo8pQ+MIGkmW5JPOOr+pJfUkSuIkSUqPkR4jPUZ6nHU+elBL6kmUxEmSpEkjyZJ8kqeHp4enh6eHp4enh6eHp4enh0+PmFR0U0vqSZTESZKkSSPJktKjpUdLj5YeLT1aerT0aOnR0qOlR0uPnh49PXp69PTo6dHTo6dHT4+eHj09KD0oPSg9KD0oPSg9KD0oPSg9KD04PTg9OD04PTg9OD04PTg9OD04PSQ9JD0kPSQ9JD0kPSQ9JD0kPSQ9ND00PTQ9ND00PTQ9ND00PTQ9ND1GekSdU1BPoiROkiRNGkmW5JOizi9KD0sPSw9LD0sPSw9LD0sPSw9PD08PTw9PD08PTw9PD08PTw+fHjFx6aaW1JMoiZMkSZNGkiWlR0uPlh4tPVp6tPRo6dHSo6VHS4+WHj09enr09Ojp0dOjp0dPj54ePT16elB6UHpQelB6UHpQelB6UHpQelB6cHpwenB6cHpwenB6RJ2PoJFkSQ8PO59RMdXpppbUkyiJkyRJk0aSJaWHpoemh6aHpoemh6aHpoemh6aHpsdIj5EeIz1Geoz0GOkx0mOkx0iPkR6WHpYelh6WHpYelh6WHpYelh6WHp4enh6eHp4enh6eHp4enh6eHj49YnLUTS2pJ1ESJ0mSJo0kS0qPlh4tPVp6tPRo6dHSo6VHS4+WHi09enr09Ojp0dOjp0dPj54ePT16evT0oPSg9KD0oPSg9KD0oPSg9KD0oPTg9OD04PTg9OD04PTg9OD04PTIOpesc8k6l6xzyTqXrHPJOpesc8k6l6xzyTqXrHPJOpesc8k6l6xzyTqXrHPJOpesc8k6l6xzyTqXrHPJOpesc8k6l6xzyTqXrHPJOpesc8k6l6xzyTqXrHPJOpesc8k6l6xzyTqXrHPJOpesc8k6l6xzyTqXrHPJOpesc8k616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOtesc80616xzzTrXrHPNOh9Z5yPrfGSdj6zzkXU+ss5H1vnIOh9Z5yPrfGSdj6zzkXU+ss5H1vnIOh9Z5yPrfGSdj6zzkXU+ss5H1vnIOh9Z5yPrfGSdj6zzkXU+ss5H1vnIOh9Z5yPrfGSdj6zzkXU+ss5H1vnIOh9Z5yPrPKaDGQVREidJkiaNJEvySVHnF7Wk9JD0kPSQ9Ig656CRZEk+Ker8opbUkyiJkyQpPTQ9ND00PUZ6jPQY6THSY6THSI+RHiM9RnqM9LD0sPSw9LD0sPSw9LD0sPSw9LD08PTw9PD08PTw9PD08PTw9PD08OkRE8luakk9iZI4SZI0aSRZUnq09Gjp0dKjpUdLj5YeLT2iziXIknxS1PlFLaknURInSZImpUdPj54elB6UHpQelB6UHpQelB6UHpQelB6cHpwenB6cHpwenB6cHpwenB6cHpIekh6SHpIekh6SHpIekh6SHpIemh6aHpoemh6aHpoemh6aHjo9YqrPCDj/Aw06/48W5JPiJC9qST2JkjhJkjRpJKWHpIemh6aHpoemh6aHpoemh6aHpoemx0iPkR4jPUZ6jPQY6THSY6THSI+RHpYelh6WHpYelh6WHpYelh6WHpYenh6eHp4enh6eHp4enh6eHp4efnv0mAx00+nhQT2JkjhJkjRpJFnSw8OPWITg4eEU1JJ6EiVxkiRp0kiyJJ/U06OnR0+Pnh5nmDkHSZImjSRL8klnmLkGtaSeREmcJEmaNJIsySdxenAqnxHmI2gknf9tXLezfi866/emltSTHirtiAsSiwfcKEAFDqABPTEWErixndgCO5CA4RatH0sKHNGYsajAEecXywrcaEBPjMUFbmzA0I17LRYUuFETYzGAey0LBQ6gAT0xlgW4sQE7kIAMhJvDzeHmcPN0i1k6ExuwAwnIQAEqcAANCLcGtwa3BrcGtwa3BrcGtwa3BrcGtw63DrcOtw63DrcOtw63DrcOtw43ghvBjeBGcCO4EdwIbgQ3ghvBjeHGcGO4MdwYbgw3hltUYeNABQ5gHIMGemJU4Y0N2IEEZKAAFTiAcFO4RRXGOhfXOjo3diABGShABQ6gAT3R4BYLf7QR2IEEZKAAFXi69RZoQE+Mmr+xATuQgAwUoALh5nDzdIsZOxNDtwcyUIAKHEADeuK1QM+FDdiBcGtwa3BrcGtwa3BrcOtw63DrcOtw63DrcOtw63DrcOtwI7gR3AhuBDeCG8GN4EZwI7gR3BhuDDeGG8ON4cZwY7gx3BhuDDeBm8BN4CZwE7gJ3ARuAjeBm8BN4aZwU7gp3BRuCjeFm8JN4aZwG3AbcBtwG3AbcBtwG3AbcBtwG3AzuBncDG4GN4Obwc3gZnAzuBncHG4ON4ebw83h5nBzuDncHG6ebteiQjc2YAcSkIECVOAAGhBuyBJClhCyhJAldGUJBQpQgQNoQE+8Xg88sAMJyEABKnAADeiJ1+vBhXAjuBHcCG4EN4IbwY3gRnBjuDHcGG4MN4Ybw43hxnBjuDHcBG4CN4GbwE3gJnATuAncBG4CN4Wbwk3hpnBTuCncFG4KN4Wbwm3AbcBtwG3AbcBtwG3AbcBtwG3AzeBmcDO4GdwMbgY3g5vBzeBmcHO4Odwcbg43h5vDzeHmcHO4ebrxcQAbsAMJyEABKnAADQi3BrcGtwa3BrcGtwa3BrcGtwa3BrcON2QJI0sYWcLXy4gGClCBEVcj0ICeeL2MXNiAHRjhGG7Xy8iFAgw3CxxAA55u5yIoPSYgTWzA040okICnG3GgABV4ulGcZmTJjZ4YWUJxDJElN3YgARkowNCN04x84CPwVOA49MiHGxkowPN4OU4o8uFGA3pi5MONcbwS2IEEDLc4zciHGxUYbtffGtATIx9ubMAOjHOLmyDy4UYBKnAADeiJkQ83NmC4RVNHPtzIQAEqcAAN6BNjQtLEBuzAcONABgpQgQNoQE+MfLgx3DywAwnIQAEqcAAN6ImRDzfCrcOtw63DrcOtw63DrcOtw43gRnAjuBHcCG4EN4IbwY3gRnBjuDHcGG4MN4Ybw43hxnBjuDHcBG4CN4GbwE3gJnATuAncBG4CN4Wbwk3hpnBTuCncFG4KN4Wbwm3AbcBtwG3AbcBtwG3AbcBtwG3AzeBmcDO4GdwMbgY3g5vBzeBmcHO4Odwcbg43h5vDzeHmcHO4ebrpcQAbsAMJyEABKnAADQi3BjdkiSJLFFmiyBJFliiyRJEliixRZIkiSxRZosgSRZYoskSRJYosUWSJIksUWaLIEkWW6LWK8RF4up3rOnW9VjK+UIAKHEADeuK1qvGFDdiBcGO4MdwYbgw3htu1zvEZ/HqtdHxhA3YgARkYuucDW68VjWMp4mtN4wtDwQIJyEABKnAADeiJ1yrHcQGudY4v7MDTTeOyRD7cKEAFnm56vu/EFKhHv21gA3YgAUM32iGSQOOMIwk0miSSQON4Iwk0jiySYIRxJMGNDdiBp9uII4skuFGACjzdRlzYKP8RizdH+Q8NDIsRGBYeeFpYD2SgABU4gAb0xCj/c1JNj2lRE2neJTEdaqIAFTiABvTEqPkbG7AD4dbhFjVv0SRR8zcOYJzQ9beeGDV/YwN2IAEZKEAFDiDcCG5R8zFoGzOlJoabBRIw3OJqRnXHCG9MjZroiVHdN5663gI7kIAMjJy8/jMFDqABPfF6U7iwATuQgHrNg+gxLerRzx9oQE+Mkr+xAeMk4jaLkr+RgQJU4AAa0BMjCGK0OSZJTezAcItDjyCI0eCYKNVimDdmSk0cQAN6YgTBjfGDNYiTJEmTRpLdFJOVeoz1xmyliR1IQAYKUIEDaEBP7HDrcOtw63DrcOtw63DrcOtw63AjuBHcCG4EN4IbwY3gRnAjuBHcGG4MN4Ybw43hxnBjuDHcGG4MN4GbwE3gJnATuAncBG4CN4GbwE3hpnBTuCncFG4KN4Wbwk3hpnAbcBtwG3AbcBtwG3AbcBtwG3AbcDO4GdwMbgY3g5vBzeBmcDO4Gdwcbg43h5vDzeHmcHO4Odwcbp5usWbXxAbsQAIyUIAKHEADwg1Z4sgSR5Y4ssSRJY4scWSJI0scWeLIEkeWOLLEkSWOLHFkiSNLHFniyBJHljiyxJEljixxZIkjSxxZ4sgSR5Y4ssSRJY4scWSJI0scWeLIEkeWOLLEkSWOLHFkiSNLHFniyBJHljiyxJEljixxZIkjSxxZ4sgSR5Y4ssSRJY4scWSJI0scWeLIEkeWOLLEkSWOLHFkiSNLHFniyBJHljiyxJEljixxZIkjSxxZ4sgSR5Y4ssSRJY4scWSJI0scWeLIEkeWOLLEkSWOLHFkiSNLHFnimSV0ZJbQkVlCR2YJHZkldGSW0JFZQkdmCR2ZJXRkltBxwK3BrcGtwa3BrcGtwa3BrcGtwa3BrcOtw63DrcOtw63DrcOtw63DrcON4EZwI7gR3AhuBDeCG8GN4EZwY7gx3BhuDDeGG8ON4cZwY7gx3ARuAjeBm8BN4CZwE7gJ3ARuAjeFm8JN4aZwU7gp3BRuCjeFm8JtwG3AbcBtwG3AbcBtwG3AbcBtwM3gZnAzuBncDG4GN4Obwc3gZnBzuDncHG4ON4ebw83h5nBzuCFLGrKkIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrKkIUvaVdJ04lXSFzZgWHAgARkoQAUOYHR7BfmkuUEaXRsTntOuqV31fCEBw8oCBXhatTiFqOcbDegTY1LkxAbsQAIyUIAKHEADwi3q+ey+oJgqObEDCchAAUYPW9BIsiSfFD2HF7WkUKTAOFIOjCO9dl7zxKjOGxswjnQEEpCBAlRguMUxRHXe6IlRnf0IbMAOPN2uDeOiOm883XqcUFTnjQN4ul1/6pOiNi9qST2JkkIxmihq7d54Lv5rDWzADiRgHGmcYNTajQocQAOebtfmdkdSSzqt4qjimX0RJ0mSJo2kMPFAT4zavpGA539P0fhRrzeeCtG08QQOigfwRedRUrRe1OuNBDwPlOJYol5vDKtr874BNGB4nW0a0xEf91NguFlgNEoLJCADBajAATSgJ0a9nvvZ0LXz4Tnhg669D885BHTtdcjXLoOhGwcZT9obDeiJ8aS9sQE7MMTiNKNUbzSgJ0ap3tiAHRj/WTRU1NyFUXM3NmD8Zx54tuQ52Ec0d3Eimts4Ec19nIjmRk5EcycnormVE9Hcy4lobuZENHdzIprbORFJekh6SHpIekh6SHpoemh6aHpoemh6aHpoemh6XOV24dkg0R65myG2M8R+htjQEDsaYktD7GmITQ2xqyG2NcS+htjYEDsbYmtD7G2IzQ2xuyG2N8T+htjgEDscYotD7HF47WR4DpnStZfhjQ14Cp0Dk3TtaHgOjtK1p+E5GknXHobnYCNdOxSeA4h07VGo8bfxZLtRgOfJnes40rVX4Y0G9MSonxsbsAMJGG4SKEAFnm4jzi1KacThRCndeOqO+Nt46t3IQAEq/rMBNKAnMtwYblGBNxJQgHrtFEbXLoYXWZJPisK7qCWFuAYSkIEjMR51I9owHnUjrnk86m4kIAMFqMABNGA0Rtw18ay7sQFPN4t7KcrvRgaebhZ3WFTgjQNoQE+MKryxATuQgAyEm8HN4GZwM7g53BxuUZEW912U5I0MDN245lGV59gtxcy4iXE4GhiHMwIH0IChcLZ6zIGbGPnQAyNcTje59vgMi2uXzwsH0ICROnEM126fFzZgBxKQgQIM3Tjea7fdwGu/3QtDNw792nP3QgIyUIAKHEBLvPbS9UAFDqABPfHaVffCs8bOb1Pp2lHwRgIyUIAKPKs5fnlduwve6Imxw+CN4RbXLfYUjN9j166C8cPq2lfwxgE0oCfGHp83NmCcRVzj2OnzRgaGW1y32O/zxgEMt2id2PXzwtj388YG7EACMlCA8cSONrt2AT3bQa89PimQgAwUYLxDcKAnXrt7XtiAHUhABgowjkwCB9CAnnjt+HlhWGggAUPsvO312rrTAsPYA0/j+H0Uk60mjmsTRIq5Vjf5pLOWbmpJPYmSOEmSwqQFDqABPTEePjc2YAcSkIGhG9cz3unid0XMsYqX7JhidRMlcZIkaVIoxvFHVd3oiVFVNzZgB0Yzh1jUT/y4i5Wkboz6iWOO8rmoJ1ESJ0lStGlc2aicGw3oiVE5NzZgqMYNEdUQP9RiqSi+/u9+U0yPuuls0BHUkyiJkyRJk8KkBxrQE6NgbjzP8/xEgGLa08QBPA9Tg3xSbMN5UUvqSZR0nnj8gowJTxMVOIAG9MTYGvfGBuxAAsKN4BZ1F79MY8LTRAOGWzR6bJd7Y7h54Ol2zg+imPBE8WszJjxNFODpFrUY06Amnm5xs8c0KLpaJ7YtC9nYt+yinkRJnCRJoRhXOx5r100Tj7XrD+KxdiMDzyONX03j2jD3wgE0oCde2+TGCV7b4sadcW2MGyd4bY17oQE9MQrwxgbsQAIyMNyi4aIMbxzAcIvmjDK8MMrwxgYMt2izeIDdyMCzeePUYs+yi0bSw+pqg9i27KRr78CLWlJPoqQwsUABKnAkxjPuxjhMD2TgqRC/3mJ+1MQBtGv3MsoNAyl3DKTcMpByz0DKTQMpdw2k3DaQct9Ayo0DKXcOpNw6kHLvQMrNAyl3D6TcPpBy/0DKDQQpdxCk3EKQcg9Byk0EKXcRpJgIRec0WYqJUBMJeDaZUqAAFRhNJoEGPO8jjfaPR+SNDdiBBAy3uEDRO3Lj6TbiqsSDc8SRRfWOuDOih+TCeJzeeLrFD96YCDWRgHxtEUfXroMXadJIsiSfFNUcP1RjWhPFz+KY1kTxszKmNU00oCdGNcfvw5jWNLEDCcjAh9t1h84l1MnmcmwUM5LiR1NMSLpJk85jsmi92E7+Rp8Y05EmNmAHEpCBAlTgABoQbg1u8SIavxdjOtJEAjJQgAq0uw1iCtJFsQjbRaFPgR1IQAYKUIFxNhJoQE+Mp2z8So0JSBPpvkg+V0knn6ukU0w5iq6HmHF0kyWFeGA8VG9swA4kIAPjVCxQgQN4ttoR5JPm8qrkc3lV8rm8KvlcXpV8Lq9KPpdXJZ/Lq5LP5VXJJT0kPTQ9ND00PTQ9ND00PTQ9ND00PTQ94o33nG5NMbNoYgeebebX3zJQgAocQAN6YpTzjQ3YgXAzuMXD2aMG4uF84wAa0BPj4XxjA3YgAcMtiiR+Xd6owLMZ436MRcwu8ov4WsTsopbUk0LxwjhSDowjlROjyG9swA6MIx2BDBSgAgcw3DzQE+PX5o0N2IEEZKAAz18AZ+8DxzwhPnsfOOYJ8RHHG7vdXxj73d/YgB1IQAYKUIEDCDeCG8ON4cZwY7gx3BhuDDeGG8ON4SZwE7gJ3ARuAjeBm8BN4CZwE7gp3BRuCjeFm8JN4aZwU7gp3BRuA24DbgNuA24DbgNuA24DbgNuA24GN4Obwc3gZnAzuBncDG4WbhroiR5uUSLegB1IwNPt7GHimCc0UYEDaECfGPOEJjbg6XZOBeCYJzQxLHqgAgfQgGFxxkpMDprYgB1IM3faFSAXClCBA2hAT7wC5MIG5Ouli6/dDy/SpIeoXn9nST4pQqJd2IAdSEAGCvB0iiaMvdEusqRoqvOOiNk/ExuwXxuHcW6DyLkNIuc2iJzbIHJug8i5DSK3uT0a5zaInNsgcm6DyLkNIuc2iJzbIHJug8i5DSLnNoic2yByboPIuQ0i5zaInNsgcszz4bMfkWOez0QFxu11/a0BPTGy4MYG7EACMlCA4WaBA2jAh9uIOyV2UbqoJfUkSuKkUDyfTDFhiHv8r1HZPS5/VPaNBGTgeaQ9KiUq+8YBNKBPjBlDfPYMcswYmtiBdO06xX3uicZ97onGfe6Jxn3uicZ97onGfe6Jxn3uicZ97onGfe6Jxr2lR0uPlh4tPVp6tPRo6dHTo6dH9LSdvZ0cK6nx2cnIMXVoogAVOIAG9MSo9hsbsAPhRnAjuBHc4pXg7PPkmFA00ROj4G9swA48dc/Bfr6WRIsrdy0yEHT+RxTXO57sNxKQgQJU4AAa8DxECot4st/YgOEWzR9P9hsZKMBw08DQPasuJg1NbMAODN1ohajbs/ORY+YQczRI1C3H8UbdchxZ1C2HcTzDL4xn+I0NGCMKcWTxDL+RgQIMt7is8eCWOJx4cEscTpS3xM0Z5S1xOFHeEicU5X0jAwWowAE0YLidxxATjCb2eY/ErKKJDDwt4lEXs4omDmB0b19/64nx4L6xATuQgAwUoAIHEG4Nbld3Ogc2YLhRIAHDrQeGrgQa0BOjoG8MXQ3sQAIyUGZY01XQFw6gAT2RD2ADdmC0zghU4AAaMM4irnG8zd/YgB1IdycWXzOUbhSgAgfQgJ54dcJdGK3jgQwUoAIH0IDnWcTDMFYrm9iAHUjAGMmJWyPqOGI/piXxiJsg6vjGDgyFuHeijm+MAaI4oajjGwfwPN4RVz5K+sIo6RsbsAMJyMBwi0sYJX3jABrQJ8Y8ponRYe+BPNuBr2GuCxUYuhZoQE+MOr7xPIuzd4VjztNEAp5uZ4ccx5yniQo83aLrIOY8TfTEqOMRhx51fPbfccx54rOfjWPOE5+daxxzniYKMHSjHaKOL4w6vrEBQzfOLSo27pKY3TRxAC0xyvTGGF64kIECjAGKOLdrItOFBvTEay7ThQ3YgQRkYDRqtFk8hG/0xHgI33ievMfFiofwjQRkYIzJRevESNeNA2hAT4yOtxsbsAMJGCOL0VBjAM+z8Lg9o3gvjOK9sQHjLOI/i+K9kYECVOAAxjhmtGR0sV0YXWw3NmAHEpCBAlTgHAvmWAiM/cIG7EACxllwoAAVOIBxFkegJ0b3240N2IEEZKAA41pIoCdGmd7YgHEWGkhABgpQgQNoQE+M4o1+v5hyNbEDCRhuFihABQ7gnOjAMRHrxuhsv7EBO5CADBSgAkP3vM9icS+OXsZY3GtiB8ZwdbT6NV4dN8E1YH2hAgfQgJ6oB7ABY2w8bpgY9IqupGsiVvzuiylXEl1JsTTXRAIyMBSi1YcCB9CAnmgHsAF7HsM1l+RCBgpQgQOIs7imkwT6AYyziCvvcRbR6jFifaMCB/A8i+jZikW4LoxFuCaeZxGdXDE9ayIBGShABQ5guPVAT2wHMNwosAMJyEABKnAAw40DPTEGum8MNwnsQAIyUIAKHMBw00BPjCHvG8PNAmMKQLRvjHpHb0bMC5Mop5gXNlGBAxiTDeIsYuw7fu7H1DCJ2oy5YRM7kIDhFofD4eaBMbEhjowH0ICeGPNTop8oJohN7EACzjlvrNe3ARcqcAAN6InXBwIXNmAHxuyMaMkY6b5xAA0YZxEteT7RJzZgBxKQgQJU4EiMJIjHYswpm9iBoRuX0BgoQAWORA/duNxR89F7EFPIJgpQgQNo95xj1mtS8okxtWxiA3YgARkoQAVG+55XPtbYmtiAHRhnYYFxhTzQE6NibzwVorcj5pNNJOB5xtEHEnPHJPpAYu6YRB9IzB272iHmjk1swA4kIANDVwIN6IlRhTe2ewI+j+ujgAsJyEABKnAADeiJ14dv0TpCQAae9wNff6vAOIvrDwzoifGMjZ6cmEE2sQPP1onfATGDbKIAFTiAp5tE60QVXhhVeGMDdiABGSjA0I0rFN8DREbFXDGJHqKYKzZRgXFkcfeZAePIoh2i3m5swJi2FBZRhTcyUIAKHEADxuyl86a9Jozd2IAdSEAGyjzj2BVQogMotgW8MarwxgYMXQokIAMFeN6T8Zi5ltq60YCeGB/33NiAHUjAaB0OHEADeuI1gSz+s2sG2YUdSMCzAtr1nwlQgQNoQE+MjxZubIkS/ezRfNKBBGSgABU4gAb0RD2AcFO4abjFZVEGClCBA2iJI3SjoUYHEpCBAlRg6HqgAT0xBoRuPN2u2zOGhG4k4EjdmPp1oyf6AcShOw7dKd2cgQJU4EhjN6BPjGlYHroxDWviANqJGugnnlkSc7ImNmAH0okWyEABKjB0z+ONlZ78OrLYLO5GBir+9jzIeMmJ2VYTPTE2iruxATuQgGFBgQJUYLhxoAE9MbaWixeimHE1sQMJiBMSASpwAA3oiXoAGxDNp2i+qIvLOOriRk88H0kTG7ADCchAASoQbgNuA24GN4Obwc3gZnAzuBncopyuS3jNpLzQE6OcbmzADiQgAwWoQLg53Hy6SUyzmtiAHUhABgpQgQNoQLg1uDW4Nbg1uDW4Nbg1uDW4Nbg1uHW4dbh1uHW4dbh1uHW4dbh1uHW4EdwIbgQ3ghvBjeBGcCO4EdwIbgw3hhvDjeHGcGO4MdwYbgw3hpvATeAmcBO4CdwEbgI3gZvATeCmcFO4KdwUbgo3hZvCTeGmcFO4DbgNuA24DbgNuA24DbgNuA24DbgZ3AxuBjeDm8HN4GZwM7gZ3AxuDjeHm8PN4eZwc7g53BxuDjdkSUOWNGRJQ5Y0ZElDljRkSUOWNGRJQ5Y0ZElDljRkSUOWNGRJQ5Y0ZElDljRkSUOWNGRJQ5Y0ZElDljRkSUOWNGRJQ5Y0ZElDljRkSUOWNGRJQ5Y0ZElDljRkSUOWNGRJQ5Y0ZElDljRkSUOWNGRJQ5Y0ZElDljRkSUOWNGRJQ5Y0ZElDljRkSUOWNGRJQ5Y0ZElDljRkSUOWNGRJQ5Y0ZElDljRkSUOWNGRJQ5Y0ZElDljRkSUOWNGRJu7KEAsNNAxU4gAb0xCtLLmzADiQgA+FmcDO4GdwMbg43h5vD7cqSEchAASpwAA0Ybo93ZelXllzYgKfb+bWeXPPAzi4kuSaC3ShABQ6gAT0xsuTGBuxAuDW4Nbg1uDW4Nbg1uHW4dbh1uHW4dbh1uHW4dbh1uHW4EdwIbgQ3ghvBjeBGcCO4EdwIbgw3hhvDjeHGcGO4MdwYbgw3hpvATeAmcBO4CdwEbgI3gZvATeCmcFO4KdwUbgo3hZvCTeGmcFO4DbgNuA24DbgNuA24DbgNuA24DbgZ3AxuBjeDm8HN4GZwM7gZ3AxuDjeHm8PN4eZwc7g53BxuDjdPt5h0NrEBO5CADBSgAgfQgHBDlhCyhJAlhCwhZAkhSwhZQsgSQpYQsoSQJYQsIWQJIUsIWULIEkKWELKEkCWELCFkCSFLCFlCyBJClhCyhJAlhCwhZAkhSwhZQsgSQpYQsoSQJYQsIWQJIUsIWULIEkKWELKEkCWELCFkCSFLCFlCyBJClhCyhJAlhCwhZAkhSwhZQsgSQpYQsoSQJYQsIWQJIUsIWULIEkKWELKEkCWELCFkCSFLCFlCyBJClhCyhJAlhCwhZAkhSwhZQsgSQpYQsoSQJYQsIWQJIUsIWULIEkKWELKEkSWMLGFkCSNLGFnCV5ZIoAIH0ICeeGXJheFmgR1IwNPtHMeRmAM3UYEDaEBPjCy5sQE7kIBw63DrcOtw63DrcCO4EdwIbgQ3ghvBjeBGcCO4EdwYbgw3hhvDjeHGcGO4MdwYbgw3gZvATeAmcBO4CdwEbgI3gZvATeGmcFO4KdwUbgo3hZvCTeGmcBtwG3AbcBtwG3AbcBtwG3AbcBtwM7gZ3AxuBjeDm8HN4GZwM7gZ3BxuDjeHm8PN4eZwc7g53Bxunm4xJW9iA3YgARkoQAUOoAHh1uDW4Nbg1uCGLBFkiSBLBFkiyBJBlgiyRJAlgiwRZIkgSwRZIsgSQZYIskSQJYIsEWSJIEsEWSLIEkGWCLJEkCWCLBFkiSBLBFkiyBJBlgiyRJAlgiwRZIkgSwRZIsgSQZYIskSQJYIsEWSJIEsEWSLIEkGWCLJEkCWCLBFkiSBLBFkiyBJBlgiyRJAlgiyRK0s8sAMJyEABKnAADeiJV5ZcCDeDm8HN4GZwiyw5h/UlJgBONKAnRpbc2IAdSEAGChBuDrfrveRCn6jXe8mFDdiBBGSgABU4gAaEW4Nbg1uDW4Nbg1uDW4Nbg1uDW4Nbh1uHW4dbh1uHW4dbh1uHW4dbhxvBjeBGcCO4EdwIbgQ3ghvBjeDGcGO4MdwYbgw3hhvDjeHGcGO4CdwEbgI3gZvATeAmcBO4CdwEbgo3hZvCTeGmcFO4KdwUbgo3hduA24DbgNuA24DbgNuA24DbgNuAm8HN4GZwM7gZ3AxuBjeDm8HN4OZwc7g53BxuDjeHm8PN4YYsUWTJQJYMZMlAlgxkyUCWDGTJQJYMZMlAlgxkyUCWDGTJQJYMZMlAlgxkyUCWDGTJQJaMa5DlTPBxDadYYAcSkIECVOAAGtATr+GUC+HGcGO4MdwYbgw3hhvDjeEmcBO4CdwEbgI3gZvATeAmcBO4KdwUbgo3hZvCTeGmcFO4KdwUbgNuA24DbgNuA24DbgNuA24DbgNuBjeDm8HN4GZwM7gZ3AxuBjeDm8PN4eZwc7g53BxuDjeHm8PN082OA9iAHRgvIz0wXkYkUIAKHEADemKU9I0N2IEEhFuDW4Nbg1uU9Pmhq8SMxhvj9eDGBuxAAoYbBQpQEynHnYwasAMJyEABhlg0akTFjQaMQ4+/jai4sQFPt/NzUokl8SYyUIAKHEADemJExY0NCDeBW0TFiPshouKc0CzXTMkbB9CAnhhRcWMDdiABGQg3hZvCTeGmcBtwG3AbcBtwG3AbcBtwi6gYcbEiKm70xIiKGxuwAwnIQAEqEG4GN4Obw83h5nBzuDncHG4ON4ebw83TLRbjm9iAHUhABgpQgeHmgQb0xIiKGxuwAwnIQAFqYhT6+UWwxBzOiQLMnl7HWIdjrMMx1uEY63CMdTjGOhxjHY6xDsdYh2OswzHW4RjrcIx1OMY6HGMdjrEOx1iHY6zDMdbhGOtwjHU4xjocYx2OsQ7HWEdM/RznwogSUz8nMlCAChxAA3piJMGNDZh9CtckT4tjiJK+MEr6xgbsQAIyUIAKHEC4DbgZ3AxuBjeDm8HN4GZwM7hFxZ5f3sg1h/NGAjJQgAocQAP6jXrN4bwx3CzwVDi/0dVrXuaNBvTEqMIbG7ADCchAAcKtwa3BrcGtw63DrcOtw63DrcOtw63DLer4/CJYr3mZF0Yd39iAHUhABgpQgQMIN4Ibw43hxnBjuDHcGG4MN4Ybw43hJnATuAncBG4CN4GbwE3gFnXscUdFHV8YdXxjA3YgARkoQAUOYLjFTRvlf2GU/40N2M91NuNyn+U/kYECVOAAGtATz/Kf2IBwM7gZ3AxuBjeDm8HN4OZwc7g53BxusbbuEZclFte9UYEDaECfGPMyJzZgBxKQgQJU4AAaEG4Nbg1uDW4Nbg1uDW4Nbg1uDW4Nbh1uHW4dbh1uPdw0UIAKHEADeiIdwAbsQAKGrp94JoG1OIYzCSYSkIECVOAAGtATY/XcG+EmcBO4CdwEbgI3gZvATeCmcFO4KdxiKd0W7RBr6d4oQAUOoAE9cRzABuxAuA24DbgNuA24DbgNuBncDG4GN4Obwc3gZnAzuBncDG4ON4ebwy2S4PxQW2NW5UQBKnAADegTY1blxAbswHDzQAYKUIGn2/nNlcasyomeGElwYwN2IAEZKEAFwq3BrcGtw63DrcOtw63DrcOtw63DrcMtkuD8tExjVuXEBuxAAjJQgAocQAPCjeHGcGO4MdwYbgw3hhvDjeHGcBO4CdwEbgI3gZvATeAmcBO4RZb0uOUiS25swA4kIAMFqMABtMRIjR43baTGjQRkoAAVeOqeH6dpzJ+ceJ7FOZtbY/7kxNPt/NhLY/7kxNPtnO6tMX9y4ul2fo6nMX9yYrjFLRepcWO4RfNFatwYbnGakRo3EjDcLFCA4Rbndq3DfeHpxnFukRqBMX/Szp50jfmTE0+3cy62xvzJiafb+XNSY/7kxNPt/MhfY/7kxHCTQE+M1DgXL9SYPzkx3CyQgAwUoAIH0ICeeK3Vf2EDwq3DrcOtw63DrcOtw63DjeBGcCO4EdwIbgQ3ghvBjeBGcGO48Rzv1mv+5I0EZKAAFRi6gZEEErdGJIHE1YwkuFGAChxAA3piJMGNDdiBcFO4KdwUbgo3hZvCbcBtwG3AbcBtwC3yQeJOjXy4cSRGEtwYCnH/Rs3fKEAFDqABPTFq/sYG7MDTTaM2o+ZvFKACB9CAPjHmOU5swA4kIAMFqMABNCDcGtwa3BrcGtwa3KLmz0ELjXmOEwfQgJ4YNX9jA3YgARkItw63DrcOtw43ghvBjeBGcCO4EdwIbgQ3ghvBjeHGcGO4MdwYbvGmcI6AaMxznDiABvTEeFO4sQE7kIAMDLcRqMBws8Bw88A5o0aveY43NmAHEpCBAlTgABoQbgNukQ/jwg4kIAMFqMABNKAnRmrcGG5xWeL94UYCMlCAmhj5cC7qqTF3cSIBGShABcbxxmWJfAiMOYZ2duxrzDGc6IlRx+fSmRpzDCd2IAEZKEAFDqABPbHDrcOtw63DrcOtw63DrcOtw63DjeBGcIs6PlcI1ZhjOJGBAlTgABrQE6OOb2xAuDHcGG4MN4Ybw43hxnATuAncBG4CN4GbwE3gJnATuAncFG4Kt3jORy92zDGcyEABKnAADeiJ8Zy/sQHDzQNPt+hBjjmGEwWowAE0oCdGHd/YgB0IN4Obwc3gZnAzuBncHG4ON4ebw83hFjUfPb0xx3DiABrQJ8Ycw4kN2IEEZKAAFTiABoRbg1uDW4Nbg1uDW4Nbg1uDW4Nbg1uHW4dbh1uHW4dbZEn0Ysccw4kDaEBPjCy5sQE7kIAMnLOmNOYNWnSJx7zBiR1IQAYKUIEDaEBPFLgJ3ARuAjeBm8BN4CZwE7gJ3BRukQ/nAqsa8wY9usRj3uBEBgpQgQNoQE8882FiA8JtwG3AbcBtwG3AbcBtwM3gZnAzuBncLNziPjMBKnAADeiJfgAbsAMJCDeHm8PN4eZw83SLeYMTG7ADCchAASpwAA0Itwa3BrcGtwa3Fm4aKEAFDqABPTHWj7qxATuQgKfbuWiqxta5ExU4gAb0xDMfJjZgBxIQbgQ3ghvBjeBGcGO4MdwYbgw3hhvDLZadOld21ZiwONGAnhjLTt3YgB1IQAYKEG4CN4GbwE3hpnBTuCncFG4KN4Wbwk3hpnAbcBtwG3AbcBtwG3CLLDlXs9OYsDjRgJ4YWXJjA3YgARkowHCLEonUuDBS48bQHYEdGLoWyEABhq4HDqABfWJMTZzYgB1IQAYKUIEDaEC4Nbg1uDW4Nbg1uDW4Nbg1uDW4Nbhdq84dgQ3YgQRkoABjKk9ghMK5HLHG1MSJHRhiPZCBAlTgABrQEyMUbmzADoRblP+5eKHGJEQ/Fz/WmIQ40ROj/G9swA4k4OMsro5Gu7oUL1TgABrQE68uxQtbYtx95x4GGrPdJjbgeTjRhxez3SYyUIAKHEADemLcfTc2INwa3Brc4o6KTr5rxcJzeVS9lim8/9c4HAuMw/HAATSgJ8YddWMDduB5OOdCqHotaXijAE+36CS5VjeM3qRrdcPo6rlWNzxXCNVrdcPr0OOOuhEndC1eGMbX4oUXGtATr8ULL2zADiQgAwV4ukVlXYsXxnv1tXjhjZ4YT5EbT7cY67gWL7yRgAwUoAIH0BLjeRGjJTGZzWOIJGaweYyLxAw2j8GQmME20RPjcXAjAUMh2jdeF28MhbhhIuKjYz8mnXmUSEw6m2jAuHce7TCOq3AubMAOjFu5BzJQ8AcKHEAD+t0OIyaoTWzADpT7jEdMRYvTHDEVbaIlXjeMBHYgAeOGuf5WgAqM29MCDeiJMUvxiLOIWYo3MlCAChxAA3ritZPfhQ0It2szv2jqaze/CwWowAE0oCfGxOMbG7AD4eZw83S7Fn87t4AY1+Jv5w+bcS3+dqMAFTiAcWTnZbmWeTtfsce1zNuNBGSgABU4gKE7Aj0xpibe2IAdSEAGhpsFKnAADeiJMTXxxgbswLDwQAEqcAAN6IkxH/HGBuxAAsKN4RZjgOeGE+Na2+1GA3pizEe8sQE7EBdLcLEEF0twsaK7/9ycYlxLt7W4o6K7/0YCMvAUa3HLRXf/jQNoQE+M7v4bG7ADCchAuA24DbgNuA24Gdyijlvc61HHN8q512jc9mfFThxAA3riWbETG7ADCchAuHm4xd3nA2hAnxjTiSY2YAcSkIECVOAAGhBuDW4Nbi10PfBUOCf6j5gipGcP/YgpQjee1T2xATuQgAwUoAIHEG4dbgQ3ghvBjeBGcCO4EdwIbgQ3ghvDjcNNAjuQgAoMhbPeYtrPxAbsQAIyUIAKHEADhltcrNhq1+N4Y6/dGzuQgAwUoAIH0ICeOOA24DbgNuA24DbgNuA24DbgNuBmcDO4WbhFqxsBGShABQ6gAT0xav7GBoSbw83h5nBzuDncHG6ebjEZaGIDdiABGShABQ6gAeHW4Nbg1sJNAwnIQAEqcAAN6ImRDzc2YFiMQAYKMCwscAAN6IkRCjc2YAcSkIEChFuU/7mH17jWSjv38BrXXJ8bO5CADBSgAjNIY620iZ54RcWFDdiBBOTE6/kWlzDeSFu0b7yR3jiABvT5Enkt9nVjA3YgARkoQAUOoAHT7Vrs68YG7EACyjy3a4Wvs6dsXGt5XRjf2MQJXWt53diBBIwXDAsUoAKjoTzQgJ7Y4dbh1uHW4RYvsjcKUIEDaEBPJLjRZfEf/+VvD9t//1u8/Ml5u8a7302cJEmaNJIsySfF3jcXtaT00PTQ9ND00PTQ9ND00PSIHW/OuoqXPj2LIt75bpIkTTor5vwFFu9wev74iXniN3GSTIp8Pm+d65XsIk6SpPDgk0aSJflN17vY+Tvpeuk6X6Gvd66LJEmTRlKoPO7SmHB9U/xvj9a43o/O3wLX69FFnHQqny/317vRRSPJknxShN35Xn+96pxv7debzkUjyZJ8UrzlxFHFS85FPYmSOEmSNGkk2aTIsfON/HrjuYiSOCmO+WzxeIM5K/56gbmoJ1ESJ0mSJsX5nlch3lwu8knxhnLmx/WCctb29X5y9g5fryfRLiPbb2T7jWy/ke0XbyatP6qzn9UZr0U9fmJN6BNoAk+QCafZ2fMbXgE2wW8Io7NLOF6AAuK/ejRcvNCcE+rjdSbAb4hXmYA2oU+gCXE8j8aJGgnQCaH8aK0okAC/IT6C0nPadnwDdVNPoiROkiRNGkmnxTnhO7590nM6d3z6dFP8t2eFRkVdNJIsySdFlZ3dT9HFcBMnSZImjSRL8knxonFOEY+uhZt6EiVxUiifbRU1GBT1dnZpRT+Bnj2n0U1wkyRp0kiyJJ8ULw4XtaTzqM6O2HhC6NkHGk+ImyRJk0aSJfmkqMuLQo/v5NezHzXyXs+Owsh7PXsEI+9vakk9KVRsPgMukqRQ9vkMuMiSfFIUxEUtqSedHmcf6/WsuEiSTg+Jp8tIsiSfFOVzUUvqSeHR53PmIkkKD5rPmYssyW+6njMXtaSeFB48nz0XSVJ45LPnHLC4fuufow3XU+gcVrh+6V/UknrS6XEONFy//c9xhvhmSM9hhusJdtFIsqTwOI8g3vXPiadXV4Dmk+4iSuKkOA+ZT7qLRpIl+X2vXT0AF7WknkRJnCRJmjQmRTWe02Kvp99FPYmSok/kmE+/izRpJFmST4oKvaglRY/O8XhqUDw1Qn4+EcZ8IgSMCTbBb4gCCGgT+gSaMJVtKttUtqlsU9mmsk9ln8pXh1e/nxoBPEEm6IRQPp+JHG+s52tgNOP5Fhjn3yb0CTSBJ8gEnRCvmPHQnRAvmI8LGXvlBbQJfUK8wMrjYOQ8mPhvB9//7Qnx3wa0CX1CHBU//luNE4kjOaVG/n8tXlYnnOIW0XBCv0/ZzqYwKOj9B8Me/7vHUY35Ih2vGzdZ0nyRjteNm1pST6IkTpKk9LD0sPSw9PD08PTw9PD0iA0gz5f6q4/jfG2/ujgu8puuDo6L4hWznRSvjv2kkWRJPul6faaTRpIl+aQInyOuXUvqSZQUr7Fxf8yX9atf4SKfFEFzUUsKlUfA0fXSHDRfkOl6GfaTRpIlzZf165f+RS2pJ1FSvICebSXzZZOuF+SgltSTKGm+rMenPDdp0kiypPnjJL7iuakl9aR4QT5b/HpBDhpJlhTHfLa4zZf16KG4SZNGkiX5JD+S4nzPqxBJdBElhd55PeJOPF/q6XpjPVvSZ/tF98NNLaknUVIc81m154Pz369QOrumIpQCdMKYYBOikMb5H18/2OM/jt/v/eNxOOh2HnQaxNMkdrjW2Il6wphgE+Ig4iAjo0P+XF8l5APGBJvgN0RiBpwHbjMxbSZmAE+QCTphTAjluIA3xG7CAW1Cn0ATeIJMCOV5njbP0+Z5nsu3xP7dAW1Cn0ATeIJM0BuieyPAJkzlMZXHVB5TOfbxjd55niAT4gY6rgf8BTbBb7jC/rge8A84r5a8cIUVt53+x+N/+Pu//Pd/+Ld/+pd//m//9q//+I/n/23+D//zb//1//j3v/2Pf/jXf/znf/vbf/3n//X3v/+Xv/1///D3/xV/9D//xz/8c/z7b//wr4//6+Ow/vGf/+/Hvw/B/+ef/v6PJ/3Hf8F/fTz/Tx9PmHb/148HgabAYzx6V+LR/a0pEcU2JXhbop1PhEvi8Yr5VIKeSzx+N/kt8fhp1IuE/SHBzyX4HDUKBWGBgLbtY4hP6a9jMLKnx6DPJSRGKq+DUKOUUNlWGDwvx7ko5jMFW9wTcj43QuEx1NWeKfhzhfhENARslHuK/Q+Btrov2/kT/TqGx8/p1OD+p0RbSBju7KcC64ZsaEh71gxteUOMeS0ev0vp6Q3RFnflo9XyxpbRnx4Gr4rcPJuCjueHoavDGJyH0cqpuP6pMZ5rxHtLSDx6tIrC/pk8smbeFnQe/dMzWdycj76qnlfl0a1QzqX/Wer9eL89enu7PVbn8uiAmDfp4+gPfn4utCq286fiXWxW4tf/bNW+usdiUtSlMXq5TX9xLmSW58K8uC6L+7RrPo0eHdGI8UfvzZ8aY/U46pZ3mVSNL8exCFGikXfq4/X4ucbqODpLPhbt+XHQ4j49t4CeKXYc/lRjfWX0wF02at19uTLnciDPa9czkHu5Mt80VndqDLbed1nz5xqrO7UfMw0fnWLjNQ2mfESyPb9TaXGnKs+CUcVRkP357kaL+8NRL0dpjG8Si9v0XLopM0iO5xqr2+OcgTYP5JyF9VSFFzeq4k1UvZXL8uX9bZGn1nlmsj1Gq55JLNuj5wPmXKrm+Zksn/qad8fJ/LxVV7f6yJN54PNyWRbuI4XmTfYYDJH+VIVXj/5Hb32ez+OV5ngS7jz+0scDH/lq3Pjx+H1+Lv6XPnI5RjXu49BF8cvq5ZTGPJDHCHC5uv7nO7L0d9t0eRTcMk6Zj6dHsXwlIy0POn36Snb+JHiqoXhBHVTv9WNbgylbgx89ds81xvsvdWJ/6UsuH/mDmmvl/+JXw6PYobG4KtpWuZ63aHlJfvQ6/6mwuEMtf9Yb+XMFWj3i5mm4P1dYtoQceX+atuctIasXIMv7gkqeP34+/Kmhq+NoeUUeIxQvaXDPTo7HPd6fa9j797i+naLLFqX8cf0Y06anZzLa8kUO6UXPW2N5dxhe073za7UWX9bcGvb8V/7gd2ttyLu1NvQvrTX3eRD8uKzPW2LV+zQ6nmp/1Mmf9+dY9T81wovgoS9p+KGz1vxwf6ph7f1as/5XPk+4ZS8U96Yv3eOMHzw8Fl1Iy/60A/1p5aJ86chadRN3ygilYU+7iW0sXzWOfNXw57fGUsM0j8O8va3hR39R46DUaM9Lxdu7seH93dhYKmhWyVGa4qvEsini6/27Kepvg69NIW/3vS8l9u7xtUSHROme+JXE1hCA+7KDQ/HL4EWJ7EV7SOhLEpK9m1306RVpxzI/8y3h3N/hJY1zM40NjfWpbA2qtGP5iJ/XxNgXwyry/sjMeH9o5rA3x2bWR3E4+qxLpX0bIFo8T8zmJfHWnzfGapDp0R2SvZqPrrRyMnTYizfH86Gm1VhT7PEVEmM8bY4fUmNrvKvJ+zG8FOGj56+cw3whsnzOY0hZ6wvLl+Hc9ZG0TMFH9wIvjsTffcK21WDT5pv5+lTQPdLaolGXx7H3oF4fiOLqDqfFgfD7bSpvt+lS4hPNYVkxj4GEVXPYm7W/PIxHAOW7T5PFnU7L93PPcTOqj8lfSFD+6iIq/e9fJfrqTs+jePzceSqx2xp98XK+FhnZ8XRuxbloUln9Gs7+iQfa0/aQD4zc0/tD90uJHM/Q8tbwOwnFkJktJFatIS1HEaR25fmvmhS9V1L7q7+K8OI+bV56Fb37a3eq9fl2e+5Q9/wmY16OEWft1xb5kh8sb4/vrI5C8LuHbXEUK4kcvBNbnMiyQd3nc0FJ2mulf66qnff6q/lxrvifIrqIZHn7532Tt3/fryU+8KBUTPA7V+BdNMey+j27TNq5/+YrNTdi5fT7cbt6P5XlgKgKgv35T9u1Bn4D2eKnrSznmORsCOrPuxt+0jje1uCWPwm5H69pEN4/uD3XWA04lZ/65+6UL2nsdjlsHsdSY92mlNeW5Xmfg44PtMf4q89llAFNe1ujxvLv7rGev3ClPW+PsXryow+6DV70PCwPZKAPpf6O+nYg/P7FXWns3uybx/H6DYLuC1qF4WrsqR2OiS610+BXF8Y6Y3Tg+Z1qq1l7+dOB++L+WI49IQzbI1vRLyXtF8dBR/5Wt0VzrB+5hN8fLk/fDY3XIr2I6Csimz8MfzqZveNY/YqxMVv1XHLo+fuDrXpQD8xirFPuvvVvLX9P5YCHmrz4kwxvuraYCvD2eIe9PVZhbw9V2PsjFasO2N0kXXbibo5UvD/I8H7X/KpHfK9rPt473++a3/4W5mmY99Xo0V7v3Ae+K1p+A2L5aOv+R//vlzn+q9GjvQ6+tcRWB19fDf1s5viyMfIl7vEb9Fg0xtv9+r293a+/ltj8af1+x9z7/XL6gW45fb9Xri9FdnvlfPVII7xV4zB+84mSZk/Wg8tw8bdPYVYym+W6lNgr19VXTnvluhp22usEX35ptXWLLxW2bvHlF2Obt/j6q7PNW3z1WdHuLb78ZKzngEDvvc4ct30N4Zy/KfJcY/1pUty+17n0+gXL9w/g2tuVspTYq5TVJx+bD7b95tBFcCy/ocPrsFL9do1e1Bjva5R+kl99y3do9k0e+vz7t778wslGeZNcfMy3+sAJ7xzG7UUJmSFkMl6U4DyKMlz0qoTSaw3ahfBzSfqrIngsaJMXL62jYHxxXZaD1pq/Vs4vWV7SePyGxecri1ts81vPRxfp4urufre60tj9Bncs6lbe/dW0PIqBOfV2LFJMFr8UnPJR6Y9OuWcvc335dRPh6yaqC2SMLxqrk/EyY66OKH7VWD33W/mC7tHVaU/PRpc/nbLfycrj9le5bvmj5YH6VGP9pJOco9H+mFH5/Um3eGo7vo88akfDl9/3y2+BW8v7bPVZYl8N91iOOteJ3N8bdfWpFPquj8MWGqsuqL2PcPvqI6XNr3CX59KOnNbQDl41yKo33zV7wN1XrzH+fgCM4/0AWH7stBkAy3Gn/QBYXRvKp91jjKG/drP+KeJPRdYf8ufyCI/fO8/f/Nca2ayPt3t7TYNyUnWvSz180xirN7t8p7LXvuR/jPXmFzpczuQ3Go/OzhwPbPb8u/Vuy1/KOWh07gD8msi5v0KOkZQZZ78UyRWdzlXwXxThHM4bTPSiiOXwwKgvzb+6OJwjPlJnN/xKY2CNqz96xH+lkb+oxPrqJlmuTHBgEZ7HD7NFu/qqP6Rj1PfBurjbVh9BPcb8MCIvehwvHw0WfngcjS9kVtnIJhi6tWGvNjGWsXmwvHrH1K8Cxmsajnl5XgYaf7VQyZF3rrb22nFoy1+u2lZV6G+/3Sx/cqoQ1qqTIvKrVVceXcT4hPpa2PYVFUVf4Lkx9Ysqo+OMBuurKjke0s4ddV9UsRxGbedGuK8eS2lda4vWXQ1V7ecTrT6XOvMJi8DVQYVfy+zF3E8ntRlztPx0ig2rSvGyiX+Q2UzLH663lHtPX7738tu4piavVpOXxRFc+VUVrMp07qX6msq5Cd1UebC8qoIVhM4txJ6qrNZV+szaTAOjMDakvahi+S724Ha8qOLlWHzxqrxeJ2pgSbRFN8haw7HWVP0o/jcaxuhuk+e/gtadOo7nSK8zEr8vNPf2xypria0Bw7XE1ojhDwtvIa+bl/d1/XJZVj1cWP3B29NxqbVEz487/PGD+ZVxKZKGhchk8WN9raKe7UGjLX7y09uzWNYSW4N9RO/PYtlvjv5yo+Ld4qGiL6qMHNF5sCxyiN8eh11L7F0a/mvHYf9sjsU47E+XxorKYvk+fzfKlgp703uWi+ZRdgo9ePWIWR3I3kSQpcQjDTFuMJRfFBnlfWaIvyiSA1QPNn3lPmOGBkt/vv6vLF+hP7KkYXd0pdae8q9LGu5q1PGY32gIuoWlVt4vNB7H37O3vbbHV433vw5frml45OxTblwv7i/WRWxYM6758VSDVgv5bebyUmIvl/XtCfzLxuhYxqrXLxq+NcZqFT5zDLPXzzO+iay+idqZI7g+DPSqsau/eC4YNZSj88siPUXYXhbJjsbjxfU7t9cAtXcfl0uFrcflcqR+c6rgei3TvamCMd/j+RDq5mzYVdXiWcnWn0+2pvH2ZGuytydbryU2J1uvWqN3fNqlr83lZ8oVHfiP78O+LXS9+m4vB8e19Mc8nrp/SNjqY6gD3di93mH6Z7Ut15zca9Efbo15f9mx+E5+qRH7010aY/TXNDx7EB8PiPaSxuM3/nxN9qPLU43VWOP2wpX93RBcKmyF4PIDxs0QXC/AuRmC/oFPAlZflj5emvLT4z6eLzsZH20+/8WAPuqhTz/uWmtgfYtepwl90eDVl1WbH6otNTY/VPvhXPINqB/Unx/H6rf+1pe2fCzX7vWG6+LlEff1Q7P1kWx9a7tskB5r/10N8ojklxq1N2xt0Up8fGtUe79Rl30fe58vr49jq0mXMbb1hexaYesDWXr7GblcfJzzC0KqH7j+agFzz7Et/mPu2K8WMIdGf3EB8+1F0N/uE9O3+8SW0xM3n2/rxdz3nm/cP7AQ1ViuNvCB9dyxAtQfHwX8SgNLnjw6f56vss+r+cl7Pza4j3d/bKwlNl+Nly2aQ8Bd/HmLMi2/W9tcM4mWT+qUcH2+zD7Tcr+TrSWTftDYWjJpqbG5ZNJPGsfbGntLJq019pZM4vX0rq1VZHg9vWvvlXLzONYayzbdWjKJub/fHpsab5zL1pJJ2xqLJZN+uMe2lkzi1f5Ru0smrQ9kb8kkXo3abF9cf/9m3zyO12+QvSWTWJZfauwtmbQ+kL0lk3g9VrL1m2P1kdX2b44f9qHa+M3x0xN3a8kkFl+L7CxVtBTZG3H58WS2jmM1eNQNO380ff77hVe/o3aXTFq+9m/9Hlwr7PweXI4vbB3DWmHrGJZvljkz4YH+Hy8N1A4qOxwer2koBozV6TUNywkw3Q95SeMx8JTPuKM/bw9aVdvuqPNS5HFP5G9bG0+njC0lPLuR1Pt4TQK/sF2eDtVu3x384h3WoUHPG5TH26uorCW2xr7Z2l8qsTl8vmxP/U/n3/zumuCLu+GvJkc5jlc1sBXKA1/V4L6jwW8/UfjtJ8oPMzyzL8p7f3GSaM54e+DTGVH97eUIf5DYa4vVNc1Pj/sfi639ai50vow+ehnGixrYlN3Gq8eBhRhsPN8u+4e57oxZ6nVm9y9nzFeVxTdPP6kwVMbzrxHkaMvn285X7rJa1G/zO7Af5v93LCvji69cf2gTx7cIfrz8LUI9FnpZBT9czPnFL1dGJ0yMfPTovqqi5ZuTl79/oQNje9T7qypcVOTVr2iIqoq+qlK6UshebpdRVPzVneO5fF3E/dUrzUdVefmuw5IEg2mRLW057YpyzuaDFzfMTzKYpsy0+E5J1vODdz+O++lo8kfFgxefzv7mpN6QyU7JczL5ook7/e9oG8dJ8cGfOKk3ZDj3k2q8Wq9AlksEfqptsDTzg1k+clL8anweB2b+H8erHyk7ProZdWDul6tK5PS7B/qLIppv7UP7eFFEcvB3iL96OiN7gYe9vOZHPZ3XRbBumI5X1/zANq5jNH71SHKa+ENEXj0SwTJowh+4Om0RCcvtqn6xKsVyJZScK7W8U9YL7mCiAPHzr1XWC5jmrNHe6+eqXxYfldUHmntdQ2uJrX4dYftLJTbX6F21J+GrGxrPF3OVVX/K1kcRy6NgdC7VIc/vR0Hv/zxcrRu4uwjacnncjqXn61zgXy2xW7clsIXGavnlzXV6lyJ73dJria1u6R8kdrqll+tAb/VRrRV2uqja+9t2vN1NtlpqNDuntH41JMeuABaAlTodWvquwCgvC+XG1j/Xw5PlTELDamfHixI5X1/KIsdfJVanceA0/PkxLGd5HQ3ToOsyyePr10LLPamwHpeWH79fRVaXFBVeR+Bluy221ydcLU6crzpWHyHbx+D5g6XmQ/t6OcZffBb5HZvVD/K/HsXmDFd6TcGQEfaiQu5zdNAL10JzLpbVYVneb8ZcTcTqZ4m/EMjfRn/cTV8EZPWVFOWkRRrl/X0cL0mUUeGvEqubOmvba0rtt0NZaVPHK0fQR9lw5XkrjOVSvVlVR+nlfij/qeHLH7s907a9KJH3VF2Q4bvEquepMeZMlYfXdxF+8135WI5RYXypjq8rbb8E5COY69SLx8/U3QLXnICmdYF/2n/oPN6FclGox2/LVyTGkR9HjIPHaxLteFsif16Pw15qi0F4JyJ67SgwUDGoroL2osSg1yTyI7VH376/JMHZ1TzqpnC/kbD8xmPYeE2Cc5bm4Lrs2S8k8GL26BV77Yrg69ZRP874VVtgPV57rVL/OJFXJfLD51E3WviNxMiFqMYov6p/JZHri426XtKvJPLjjgfK21ekP787tS2/HzLFyi/2YpNiZ5NX743WKL9leHB/6TiaPnon8jeMvBY9sZQqRPxFEcWY0OO3tr0mMhin88fau78S8bIi5fFiw1ori6H2/uKRlIa1/rxhdbU/Set4h3vw6AuZ5exoPcpSqO14VUawx+RDpr18UpjX0sfiQaG07qLHKnu8bOIfZN4PhXMRVdx4Y7x64+Wikg/WF+vIccc8xmTkRREstHUOAb4kMhpWhRvttffEx3+Y7xQP9vaqSJlicyweH/z+RCrl9ydSLU+mY3/UB+trLdK1LHT7arN2LKT2eLvgF0VGPZIXbzXCkPnjxwC9KCJFRF9sWOIq8uJNT8jZx2Px1TaxKvLiJeZyszG9eInx0/nLXKNf3Sdepj3x86ujyy3NmXqZ27O4U36S4TIpRxfP5fWqVbvPnp+ORstMo8WPt9+c1BsyVuavLH6Bqbb/DW3DR5mU0+QjJ/W6DPZeP+f2LJpY5X9H23A5KdGPnJS8GJxHWVbmaC8G54FF9h8iLz0H9hYzeH/dtFVvpeev3Ufqlfb0P7tMdawWUjkYq2vVvsJvIqt+V8zTkz9mz+ovjuQxmjBvM29l5aLvR7KYOjKwv5nVzeseDfRFZLUOZc+RXOm1Tb6dzkqE8gI/UF4V2W3Y5dIdDW1S5ll/a5P1fKl8ixt1OfzvIqtvmvNHB7ci0b5KrGZvNHzc2MtP99+J4Luc3uvo8K9ERkZRH+XjgK8iq03wjuwSoVZfm77e8rZ6PSDsxvXg2h36TWa1xpUQ1kWpGyOx/uZYCB8YEPuiiv34wB3rn7hj/f071j9xxy5FOr7HpaO/KLJ5x65ve8qVbx5V1F4twM3TWYdjfpwgdVveXyYs1un94+fP/nQVydFPeS0GxLEFl7wi0I6OLVv1NYmGxehbmRjwK4kcG2rNXjsKQs9s3Z3wNxKCbVKldCf9SgLvzfVD/l+dCDbDof7aiRD6P0leOpEPPKIe3falw/21ExkDHxF5f0nC0Zx1efFfSIz8LLnuxfYLAc/5Hi4vtYPnB7D1u8bfCGR91R7b107hNQH0kPa6e/jX5df68tm+s5DcWM0W3fvttZZ4+9dXYy/bzz1dBSpWW3jeFrk6MtepVP4LCcEizbqQWG09fmD9t3Y83Vd+rD6OsnwUe+uLw1i9gGKCQ+cyt+3rSkO712Q8vSbLG7xuYlLXSvxyWWm5FAOmEY3+bKWiddzlk9S5PT2Kdejmk9T/WObw64nw27W62hVqs1ZJ/spa7Q2fQNT9+r43hi1H744yevf0i5CfRKjuqfhs4cgY5n56OpbzeKh2X307ndU4lWCXCz3KG0o72r6IouD0j+8xfiUysmPw8YZBC5HV0v1bs/d/aJGcKvE4Dl4cx2o135EpxnWpjK/LXo/1yn4YqNLaL/DlW4Ll6TySrHzEuLrAy1V6cvWl8olp+/JkkNWPG831NmT8MWX5q8gqUbGbCtUV2r+JbF7fUffA/dYgqw+hHh38uSxf3X3wa//GWH0J1cp4GZfH9jeN1QToljPJqdXujS992GO1uh/hhyPVX33UvzbJeL/PdayWX9vtc123CTesVGrPv/qI3dqfHgmGGKTOW23bj2/GZwI8Wn/l8c3aINEX7yGrxf02H9+r7aU2H99Lic01m394bJa1tJ9vLjd0fODZq29vUbl8fO82yPIVQA58f1h/O3y9P5YLlDtGcuvuLN8KdymCV/9+9JUIvd/hO1ajULsdvmPIux2+YzXestvhuxbZ7CFdi2z2/+w+Nu2wF9/x6ruV6UJkvaCkY5HxtniVWI1BDUx1xi9d+sVrVR+Y6Xws3iJsuT1KWXajfuPIX8p39QmUZEe81JVCfyWBMcr6hvhNYhWI2Mb8McDPi4siq/pHLwYtjmO1Dyo+9OhMixz6xMDT+MTA03h/4Gl8YuBpfGLgaXxi4Gl5j2AxNhd5fo/4arDnyJd3afXzy1/dq1gSqy6Y8/1AVjdrw0KbdW3Jr7eIHR+4We34wM1qx9s3qx0fuFnXIps361pk+2ZdBbxiTH6M53dJLIr5/FdvmeAjtBBZ7juVjwk+/uhl7vtHQpgx9ejIWJxOO95P6Piw4u2bvvUP3PSr/Vs2b/rVppXbN/1SZPemX4ps3vTru6TlR2DU6koB3+4S2+xA++O95jf3Kwaq/thK5tuR9OMDId0/cb/2T9yv/f37tX/ifu2fuF/7B+7XdTccEWYblD6nL91w1pfb6eW2s/W3kfi+hKCDVF+VyIVHpS5p/CuJnDj/x15lL0rU7tXfSNRu/ONFCcOKSPyaxMjZBvU7xVcl6molv5LA/rvHiydieRT26olYbn1Zv2N9VUJevKje/rO5E7+TwFrs/OLdid2MXfVtifHiRW0HPuk99HmD/tDzjwVUjvol4peef1uNU9HIF9Rz36T/eD58sEqNzYnSP4jsTZReDmRsP6vlEz+o5P0fVPKJH1TygYnSa5HtZ/WqXxZ7xFOd7Pl1aMc+c4HtExfY377AenzgAi9Fdl/G9PirLzDny9hj7K49v8CrsabHL5CB8Ux5NnZny8+mylBTXYfiyxpdttrTd2ulsbXCzkpjPyhsrDS2HAllz7EuOepWLl9ac6w08FLIWn/OvaxBzzR+MTT8fLjcxnJ5dMwAqh9afDuZ1USVg7FJoS8aZHWLHp5l2x4dmfoRFX/esMu5DIdtzWVY/TT1/AiN6m54XydV2GplvccpYAZ7/fTy6xuNLZfvylyun12244vEJ14A3v9Syj7xpZR94kMNs4+8ACzvEUyqOOraJF/vkdVgFeV6YlzmzX1TsN8qNLH9M+Ejv1DgJosz+cRIlX1ipMreH6myT4xU2SdGquwjI1Xb8zPp+fxMW41VNSvbBpWpWd9mvK2+L8RHPdT8WBzIBwZW/RNjVf6JsSp/f6zKPzFW5Z8Yq/Ljr75dHz+tKDvL7fl0NV+OVW12lvthn7hL/AN3yWqsavMuWY1Ubd8lS5Hdu2Qp8pm7JMdliBbfJCxF+CA8xGVxqzX9i0X21t5fS2ytvf+DxM7a++velc3vcX/o59mc5bHug9v7HvcHkfe/x80FmqTOR/LtZfQfnQj4kvWo87P0FxJY7fCwpq9IoN/8weVF8RcSnntdPFjbSxLYGu+PCS+/kXAqEvKCRMM+5Q/uz47Cl2v4bZ7KUmRv/u86Rzf2x1kJbG1tE2v2/4USb7dD65JXtJcS68f+534dqy31+mHxqxL6kgThYz0q36b8SgLrQtbloX8jIViOVPi1tiB8PVk/wHxZ4rWLWr+NqT83fiOBb9ZZ9UUJnEj5DvRXElIWHn3tojJWs5PjePG+wCex/aWLygMTcl5qTNya0p+3g696GbspdiYvowP7K2JKvmn9sSrEL84i547WfuzfCGTXkSi/JJCLBdc1mH8lkNNEnN8TqJNEftWI6Px+KSo1O2iV/M0j4BfrGhOA2cvcssN3Jbrkinpd6wdiXyRcl1+IYAuyukjsl00DXZfzOssCVGUp4W8aq+kIMkrEDHr+AaDrchNRbKWo5duM8zfNHyJj/ThXPM79RZGyhhXXnuZXj4TK6/83EV3v4ozVDnnRJj9cn5xz8uD6MPt6fVajRb3lVgW9Dq1+bxX9xPXRDzTtUmT7Iq/apOfvxEef1/M2WUVB2Z1R64jC1yhYDTlxywp8jCjgOMb+aiZE2MKX/vyU/+uBrAZIsQtpq5uxn8uK/CmyGlE8DrxRH0fzZ+fjtrxfJfsBH1yWLvpNq5Rl0h+N3F4J+0G5ZdegsiiJfOmtWo067e6O5KsvpN7dHenRs1eWUKKnJ7IacWJ8jFD2b/+ywouvhpsaJpk/WuV4rvH+bqbu7+9mujyO0XMp/9FrubyqUd4rf6fhuEXbixoNG+rU9Qh+pYHffg9cXJfl/YFOnl7erb7cH+043l/Evx3H+6v4r49k8xb5hcjze+Qnka2b5AeRvbvkB5FP3CZlV4K6f9/328Q/cJushpr2bxP/xG3in7hN/BO3iX/iNvG/+DbBomStTvj49rRpO/0ntQ/n243W1lO+y1DA819YD5XV7ZoidSXHr4uet6OvO/OxeoXLqyrSsEinvKwysmWbLTZpeKisVkDvOd/T6673b6iM41UVdLD4ap+tH1SwmYHzYuuXh8pqAoocii7lY4yXzym7Un86p/XHeNnb0RZbQf6gIrl57SNq/VWVkWfUbdm+q5Gk/atE9JmrtDya7TtvrbJ7rZcq2xW5rbKuyNW19pzL9Ri449WxLJLX3cpGvbwKX14Og/4xx7XTqzqHYcDpsPGh46HjZZ3drQ5/p/Ny+5wjkqnTTV+8eQjfZZK8rmL5mHt00rz64OZjYEoT8asqLXuuuf66+q4i62WE8SNt1M/x/hOd1dpTBz60OBc+11d1flFXv9BZ1sNvdF4/r/16WOvs18NvjsdfvX+sTAexY6zu5tVXWI8fgdhLsbO1l3XEoKPHGzrY5u49HUwd+mN9uN+2c9kyzGj5cvELneVjdK3Treg0ef14+DPHw0WHdbyaqpiBy+sXnuVokY2O30ND+8s6hgEjM+XP6Ax6QwetbMv0Ge/3+rZjvN/t+9MZeblvfPkDeNkt0PAzun5J8r1bYLUFCn5FW112Xe0XGoZ1Qutg2i81cneC9upxxNqO17m8fBz4dfe6huX6M6+fS9nuof7g/aVG/gYq8/x+qZHV97rGOaaHH0D26pGUvqeFyHIMKwfBHqPix7MxrMePokX57q2ruzqK0bAKZXkX/3YUy27FlrPcuG4x076MCbZj2cGpmM1SVyrpx29UOuV7S68De79U6bkQfK+fkv4nKsvPWvHh1CFLldVGgptfkTxUlt8b7nxGck5MXrQKPuR+vIXTSmX1yNnckOj65fG8z2pnD5wf2gQThxe7Xf3QJptftJyfNS/7j7c2JnqoLKcr7G2+9cOxbO5w9EMFcTbu4z1Snt/7bfUtFxbbeZwQDuXLBxTXQPzzjNz7lOuh8oFvua4XoTersH3iQ6yz+2D1wra3RdoPx7J99zf+xN3f5O1EWGrsV9DyfHYraHnvP3o3sPN3Wc78+82/EnEsLOdlpsw3kdWPwuF4Da0jfu2rxvKubflx2J9fZf5OhTDNjV9XaUXFXlaRMuWufeJYxuutm7+c+h8fj7x+LL5s3WPvx4K+qGH4bOKoD49vInR8IrJXW2jtRjb1T0T2coBt+8VptZPWbkzSR140lq2y+zrZaHykVewDrbKnMeTVa7z9WF627PZjmfsnHstM77fsSmP/fluez2cey97ysexl2sm3J+pqucKRY1dD685c305n9ctj70Ok9YFgaQ+rqwx9P5CVRh6HlZVSf6fhZRS4DjZ8E1mtVSgtxxqk6WJuUlt9gb7/2Fh9Jrb72BD5xGNjtb7mfqQsj2U7Ulbf1O9HympQaTdSlgNT25GyPJ/PREp53VlGynLZE8mJil2Fn4usVi1sHZsFdFp0ObfVuoVO+cvFH4P9z5NJl1+GG74Mrx+3fe0/WH9VhrU6/1j/6FciTbCYfF3U+nci+Ni+t8WRrD7legzz4BOd1ems99rKRUuas70m0tGL3o++OpJF0m59BvLTceR3af3QxbVZfTz1ieNo+QDrra71MX4n0j4gknfrGyL1ydMX94gtv1lC2JO3F0WwDuIfvSBviMirIh0f4jO/LII1KsU/cDqviwycjtn7InK8KlIXBqgru38T8bdreH0cZf7qqnJWY2G7WbJMecE32atMc/pAyi/XINxNeX8/XdfHsZnyyy23PnAcuyn/g0j7gMhmym+vU7lI+X7091N+LbKZ8r8QkVdF9lL+J5GtlN8/nddF9lJ+W2SV8muRzZTv7e10/eE49lK+N/prU35gOn/tBPp+HPKB4luK7Bbfvoi8KrJZfD+I7BXf9um8LrJZfLsiy+JbiuwW32qnq83iWx/HZvF1fbv4lr/Ge84Sejz4Fpe32/u/xnv399/TliK772md3s/W9XHsvad1or/2ODbf034SaR8Q2XtPW4vsvqctN67ffVQsRXYfFfsi8qrI5qPiB5G9R8X26bwusvmo2BVZPiqWIruPCn77t9YPx7H5qGB/P0vs/V/jXT7Q57oU2U55eT9d5QN9rl3krz2O3ZSXD/S5/iCymfLygT7Xrh/oc12L7Ka8fqDP9QeRzZTXD/S57p/O6yKbKa8f6HNdi+ymvL6frvqBPtc+2l+b8ru/xpebcu0W33pnr83i2xeRV0U2i+8Hkb3i2z6d10U2i29XZFl8S5Hd4lvty7V506+PY7P47O1egfXUBcX+JEOez3+I1TbfnrrQV9ty7U5d6MuduTanLvTVgNbu1IW1yObUhR9E9qYu9OX3ILudJZ8Y1OqfGNTq7w9q9U8MavX3B7X6Jwa1+icGtfonBrX6Jwa16BODWvSJQS36xKAWfWJQiz4xqEWfGNSiTwxq0ScGtegTg1r0/qAWfWJQi94f1Poh5fc6S2g5SLCZ8kuR3ZSn9na6/nAceylPzf/a49hM+Z9E2gdE9lJ+LbKb8qsBre2UX4rspvy+iLwqspnyP4jspfz26bwuspnyuyLLlF+K7Kb8+8NaPxzHZsqT/LUpv9lZQuvvtjaLbymyW3z7IvKqyGbx/SCyV3zbp/O6yGbx7Yosi28pslt8/PaUgR+OY7P4Vt9sbRbf8tf45tQFkg98SECfGNSiTwxq0fuDWvSJQS16f1CLPjGoRZ8Y1KJPDGrRJwa16BODWvSJQS36xKAWfWJQiz4xqEWfGNSiTwxq0ScGtegTg1r0/qAWfWJQi94f1Poh5Td/jY8P9LkuRbZT/v3PtH44js2UH+OvPY7dlB8f6HP9QWQz5ccn+lztE32u9ok+V/tEn6t9os/VPtHnap/oc7VP9LnaJ/pc7RN9ru9/pvXDcWymvNNfm/K7v8b9Ax8SrEV2i88/8CHBDyKbxecf+JBg/3ReF9ksPv/AhwRrkc3i4+PtKQM/HMde8cXOJn/l1IUxsAELLdZXW4pYrnzavfVXRbADqLcXj4SOXP6bjrLu6VeR9dKPkssn9z93dx6/UdG80/qf+yP/SsWx7JwvFnJdLSOm2GxSF0vk8nJMq48D6+DXVZS/7AH6kFncsZobLVt9zaL+VWO5ADJ28DzG092aHyKLjqzdFcx5Nay1u4L58kh295vbF1nsN/eDyN5+c2uRzf3m1iJ7+839cJ+0ukNGe36frL7V2r5PVvt/bd8nqyPZvk+2RVb3yVpk8z5ZiuzeJ0uRz9wnI++TftDz+2S1ouD2fbIa2tq+T1ZHsn2fbIus7pO1yOZ9shTZvU+WIh+5T7AL2jkn/Pl9slrDb/s+WS0nuH2frI5k+z7ZFlndJ2uRzftkKbJ7nyxFPnOf5HTTc3bO8/tk9aN4+z5ZDV5s3yerI9m+T7ZFVvfJWmTzPlmK7N4nS5GP3Cecv1Ued6Us7pNPvMfKJ95j5RPvsfKJ91j5xHusfOI9Vv7y99ih+WHAsMX7yVLEchOBRy/54mbT5S+vzb2TWVe37N7eybzc9ml31+O1yu6ux7wa6Nre73WtsruHLY/P7GH7wzlt7j67VtndfXZfZbX77PJab+96vFbZ3fV4rbK76zHb8Yk7xtpn7pjl0WxXwVpl975bqmzfd9sqr993u7se8/Kzru1dj9l+2OVuc3fWtc7+rse/OZ7VLq8/6GzvhvornZfbZ3+X1+XNs73r8Vpld9fjpcr2rsdrld1dj9mXy3Bv73rMy6289nc9Xuv8oq5+obOsh9/ovH5e+/Ww1tmvh98cj796/+zveizrLY62dz3+QWd71+OfdHZ3Pf5JZ3fX4x/aeXvX49/oLB+ja53tXY9/Oh7+zPFs73q8TtXdXY9l/Rtxe9fjH3S2dz3+jc6gN3Q2dz2W1fZSu30t0vv7fS0/nNH2rsfrH/S7ux5LXwxbbO56vNTY3PX4B42tXY9/OJetXY/XGnu7Hq/PZW/X46XG5q7HP2hs7Xq81tjb9Xipsb3r8fpI9nY9Xs9haC3312m9H6tZDMvlPnIqRKt743xTEVp2MG7twyS0+oW6uQ/T8kA292Faa+ztw7TU2N2HSVbja9v7MAmvBh1392ESltVPwK19mGT19dj2PkzCy4fF5j5M62PZ3YdJeN1zu7cPk8j7ezAvNbb3YVqfz+4+TOtMIXTyE41Xk4nwW+2PCazfkmm539ZBmNzfn4+Wy2rrr+2tj0XGJwpxNZazW4jinyjE5ec524W4PJbtQtRP7LEo+v4ei0uN/ULU/pFCXM5GPzBXmQ7HOX2dLSmr13Px/LZFvPSGfxdZ/8Zs+KlQHu/6m0PRw+frirayrti3Q1luGXCF4B0KMp42y2ro3fJFcFjJla+zWWUsP9XBkCrXEWL1ryrr5efmyZRapm8xOT7ykjA+8JIwPvKSMD7ykjA+8pIwPvKSYB94SbCPvCSMT7wkrO99tvIFhC7u/dWqiTqyL+TRaVQ+iGxf735bvSQQNuyuvbmPK/dSHpSO7m95sBpee1TNFOE/v/8bX1VWa7BSdr52lrKh+vErlZ5f7XRezPhv4ss7jvBTV5Yq7RPptPqGYTedlqvi7e61Lb5cMGlzr21ZfbuzmwjLNsk5gtzk1TbZTkn/xJa2sh5J2004/8R2tOsKEsp2EX25Djkv0UNQnqvosXqzbeiP0OdfRunqc7PtX0F6yAdqWVefnG3Wsi6/9OqZtr1OrPilyu7dr8cn3hG0vf+OsNTYrqD1+exW0PKuvVZMnl0AbXHbrhdeyHvf9fkHfbr6JTUcfem1I6591Vi+2eIbul5mYf5WhfJd5fFgfv1Yioq9rCJQGe0TxzJeb90c/un9j1x5+Vh82bqbIx76okbZy/yosf9NpH8kbPsHwraPD/ys024feHHS1T5QuzHZP/GisW6V3ddJpf6JVqH3O792NYa8eo13f7qvW3b7sbxcrG77sbwcDNptWfvE/bY8n888lr3lY9n9+T4Duv7GaWvIUFcDZLtDhssD2RwyXGvsDRkuNXaHDHW5YdjukKGullfcf2ywv//YWC7Ksv3YWK6wuB0p6wVidiNltcbifqQIvx8pK439SFmez2cipbzuLCNlJdIlv5XqjzN/LrIaj9re/0RXY2O7+5+oLm7b3f1PdDWStLv/yVpkc/+TH0T29j9RXXXVbq64qqrLn4Rba/EtRXbX4lN9eyHbH45jby0+XQ2JfeI4Ntfi+0mkfUBkby2+tcjmWnw6PrAc2FpkczmwX4jIqyJ7y4H9JLK1HNj+6bwusrcc2LbIajmwtcjmcmD6/g5iPxzH3nJgavp+lixTfm/FVV1+/bSb8svu992U9/fTdX0cmynv/a89jt2U/0GkfUBkM+XXo5ybKe8f2IJhLbKb8vsi8qrIZsr7B7Zg2D+d10U2U35XZJny/oEtGMb7iy3+cBx7KT8O+2tTfnPF1dE+sKj9WmSz+H4hIq+K7BXfTyJbxbd/Oq+L7BXftsiq+NYiu8X3/gZiPxzHZvH19n7xrX6Nb+5/Mjq9/2t8LLdj2nxPW4rsvqeN/na2/nAce+9po9tfexyb72k/ibQPiOy9p61FNt/TBn1gX/G1yO6jYl9EXhXZfFTQB/YV3z+d10U2HxW7IstHBX1gX/HBb//W+uE4Nh8VzO9nCb3/a3zwB/pclyLbKf/+5mE/HMdmysvx1x7HbsrzB/pcfxDZTHn+QJ/rkA/0ua5FdlNePtDn+oPIZsrLB/pc90/ndZHNlJcP9LmuRXZTXt9PV/lAn+tQ/WtTfvfX+PIrr93iW4rsFt++iLwqsll8P4jsFd/26bwusll8uyLL4luK7Bbf+xuI/XAcm8U33u4VWE9dUM9n8JDn8x/Gcg3F3akLY7Uf0+7UhWH0/tSFsRrQ2p26sBbZnLrwg8je1IVh4wOdJZ8Y1BqfGNQa7w9qjU8Mao33B7XGJwa1xicGtcYnBrXGJwa1xicGtcYnBrXGJwa1xicGtcYnBrXGJwa1xicGtcYnBrXGJwa17P1BrfGJQS17f1Drh5Tf6yyx5SDBZsovRXZT3trb6frDceylvDX+a49jM+V/EmkfENlL+bXIZsrbakBrN+XXIpsp/wsReVVkL+V/EtlK+f3TeV1kL+W3RVYpvxbZTfn3h7V+OI7NlKfjr035zc4Sow/s1LwW2S2+fRF5VWSz+OgDOzXvn87rIpvFtyuyLD76wE7NscLSm8VHH9ip2ZjeLz5+f+qC8Qc+JLBPDGrZJwa17P1BLfvEoJa9P6hlnxjUsk8MatknBrXsE4Na9olBLfvEoJZ9YlDLPjGoZZ8Y1LJPDGrZJwa17BODWvaJQS17f1DLPjGoZe8Pav2Q8pu/xvUDfa5Lke2Uf/8zrR+OYzPlR/9rj2M35fUDfa4/iGymvH6gz9XGB/pc1yK7KT8+0Of6g8hmyo8P9Lnun87rIpspPz7Q57oW2U359z/T+uE4NlPe7K9N+d1f4/6BDwnWIrvF5x/4kOAHkc3i8w98SLB/Oq+LbBaff+BDgrXIbvH521MGfjiOveKL3WL+yqkLIxu1191Lf7d0g1mujeatvyqSy3w8RF48EjpyDyM6yrqn/m1B2eXSj7kHTBfHtfnl0o+ad1pXPl5VcSw754uFXFeL2w7H4rZlX6evi9v6arxCczkYLRtMteM3GtJzhQ8RspXKciGK3POEWplso/pVZHmf5KFQK8+crxsL+GpU61xOO7eWkjEWWx/5arG43nLHrN7KtsrU2leV5V4wuftR6yUOfqlCiv3E68ZD31VWZ9S1LAr4/Ix279qy59u3u7YvRIh63itUfi59u1dWn2tR7qLEVN4JpP/qQDJmicsC098PZPVFgZLmJVYp2zF9XUB/LTOG5LNnjOcL6O+fUt0k8PsprbrXPDcVLU/0Idt3iefe6HaURYO+3yXLNetGPr9as4MW57KUMcH+lFYuzzeZ1fgWaS4RSqO159FEyw2ZR3nPGbRYS8yXgwaav64fv/jHIg6IPhFN6w/AdqNp91iorGz2n6gsdyzJfpgHLtulfeYBQvaJBwj5R66Sf6R9/SPX2t5/DP1Y144F6B6H/byuV59ybT9Glofi2DauuS8eJOuBL0xYbj6OxRNgtVzh9k4sPx2N5TvueU66kFmtC4vtOVvtwpNj92Hy+BE1b93HA63syXf4f/zH//n4//7Df/+nf/1vf/+X//4P//ZP//LP//P8Lxufi6U+7o4mE3TCOOFxwM0m+A39iN0UH9Am9Fht+AE0gWOnwwecyue7UD+Vz9fWPibYBL+BjgltQp9AE3iCTJjKNJVpKtNU5qnMU5mnMk9lnso8lXkq81TmqcxTWaayTGWZyjKVZSrLVJapLFNZprJMZQ3lRxtqm9AnhPKj1JQnyASdMCbY/K/8hjGVR7v/ZvQJU3lM5TGVx1QeU3lM5TGVbSrbPGabx2xT2aayTWWbyjaVzSb4DX5MmMfsU9lpAk+QCTphKvtU9qncjiOpJfUkSuIkSZoG7RhJljTbpbUjKT1aerT0aOnR0qNp0kiypDyPnh69JfUkSuKk9Ojp0dOjp0dPD8q2ojwPyvOgPA9KD5KkbCvKtqJsK0oPTg9OD04PTg/OtuI8D87z4DwPTg/O6yHZVpJtJdlWkh6SHpIekh6SHpJtJXkemueheR5Zwk3zemi2lWZbabZV1nHT9ND0GOmRtdyymFtWc8tyblnPbaTHyOuRJd2yplsWdbP0sPTIum5Z2C0ru2Vpt6ztlsXdsrqbp4fn9cgCb1nhLUu8eXp4emSVtyzzlnXes8571nnPOu9Z5/2YHv2QJE0aSZaUHi09ss571nnPOu9Z5z3rvGed96zz3tKjzevRs8571nnPOu89PXp6ZJ33rPOedd6zznvWec8671nnndKDKCnbKuu8Z513Sg9Kj6zznnXes8571nnPOu9Z5z3rvHN6cF6PrPOedd6zzrukh6RH1nnPOu9Z5z3rvGed96zznnXe80Hd80nds8571nnPOu/5tO75uO5Z5z3rvGed96zznnXes8571nkf6THyemSd96zznnXeR3pYemSd96zznnXes8571nnPOu9Z593Sw/J6ZJ33rPOedd49PTw9ss571nnPOu9Z5z3rnLLOKeucjulBByVxkiRp0sj/1pLSI+ucss4p65yyzinrnLLOqaVHG0mWNNuKss6pp0dPj6xzyjqnrHPKOqesc8o6p6xzovSglpRtlXVOWedE6UHpkXVOWeeUdU5Z55R1TlnnlHVOnB6c1yPrnLLOKeucOD0kPbLOKeucss4p65yyzinrnLLOSdJD8npknVPWOWWdU76TU76UU9Y5ZZ1T1jllnVPWOWWdU9Y5jfQYeT2yzinrnLLOKd/QaaRH1jllnVPWOWWdU9Y5ZZ1T1jlZelhej6xzyjqnrHPK93Xy9Mg6p6xzyjqnrHPKOqesc8o652N68NGSehIlcZLkf6tJI8mS0iPrnLPOOeucs865pUeTJE0aSZaUHj09ss4565yzzjnrnLPOOeucs865p0ef14OzzjnrnLPOOd/bmdIj65yzzjnrnLPOOeucs84565w5PTivR9Y5Z51z1jnneztzemSdc9Y5Z51z1jlnnXPWOWeds6SH5PXIOuesc84653xv56xzzuc55/Ocs84539tZ0yN/gHPWOWedc9Y55/OczzpvMWmPz0J/IJ0oQAUOoAE98Sz3iQ3YgQSEm8HN4GZwM7gZ3BxuDjeHm8PN4eZwc7g53Bxunm5yHMAG7EACMlCAChzAyy36dzyxHcDLTU/sQAIyUIAKhQGEW/P8234A4dbh1uHW4dbh1uHW4dbh1nFuhHMjuBHcCG4EN4IbKXAADYhzY7hxA3YgARkIN4Ybw43hxnATtKTg3ATnJjg3gZsIEC0paElBSwrcFG4KN4Wbwk3RkopzU5yb4twUborrNtCSAy050JIDbgNuA24DbgNuAy05cG6GczOcm8HNcN0MLWloSUNLGtwMbgY3h5vDzdGSjnNznJvj3BxujuvmaEnPltTjAKabHh1IQAYKUIEDaMA8N0WWaGvADiQgA+HW4Nbg1uCGLFFkiSJLFFmiyBLtcOsCVOAAGhBuBDdkiSJLFFmiyBJFliiyRJElSnAjXDdkiSJLFFmiDDeGG7JEkSWKLFFkiSJLFFmiyBIVuAmuG7JEkSWKLFGBm8ANWaLIEkWWKLJEkSWKLFFkiSrcFNcNWaLIEkWW6IDbgBuyRJEliixRZIkiSxRZosgSNbgZrhuyRJEliixRg5vBDVmiyBJFliiyRJEliixRZIk63BzXDVmiyBJFlqin2zgOYAN2IAEZKEAFDmC6DbyXDGTJQJYMZMnAe8nAe8lAlgxkyUCWDGTJQJYMZMlAlowOt05ABgpQgXDrcEOWDGTJQJYMZMlAlgxkyUCWDIIbDSBaElkykCWD4cZwQ5YMZMlAlgxkyUCWDGTJQJYMgZvguiFLBrJkIEuGwE3ghiwZyJKBLBnIkoEsGciSgSwZCjfFdUOWDGTJQJYMhduAG7JkIEsGsmQgSwayZCBLBrJkDLgNXDdkyUCWDGTJMLgZ3JAlA1kykCUDWTKQJQNZMpAlw+HmuG7IkoEsGciS4XBzuCFLDFliyBJDlhiyxJAlhiyxI93sGEADZksassTwG8fwG8eQJYYsMWSJIUsMWWLIEkOWWIdbb8AOJCAD4dbhhiwxZIkhSwxZYsgSQ5YYssQIbiRAtCSyxJAlht84xnBDlhiyxJAlhiwxZIkhSwxZYgw3xnVDlhiyxJAlht84JnBDlhiyxJAlhiwxZIkhSwxZYgo3xXVDlhiyxJAlht84pnBDlhiyxJAlhiwxZIkhSwxZYgNuA9cNWWLIEkOWGH7jmMENWWLIEkOWGLLEkCWGLDFkiTncHNcNWWLIEkOWGH7jmMMNWWLIEkOWOLLEkSWOLHFkiR/p5ocAFTiABoQbssTxXuJ4L3FkieM3jje4ob/EkSWOLHFkieO9xO8ssRPDrbUTCchAASpwAA3oiVeWXNiAcCO4EdwIbgQ3ghvBjeDGcGO4MdwYbgw3hhvDjeHGcGO4CdwEbgI3gZvATeB2Zck5Mc6vLLnQgJcbn1N0DmADdiABORWuLLkQbleWXH9rQLgNuA24DbgNuA24DbgNuA2c28C5DbgZ3AxuBjeD25UlFwpQgTg3g9uVJYFXllzYgB0IN4ebw83h5nBztKTnuT3q6yjcCqfhg6kwF5bCWngUHStcfFvxbcW39cJUmAtL4eLbRmEr7OB+FC6+vfj24tuLby++XQuX8+3lfHs5Xyq+1AqXdqbSzlTamYovFV8qvlR8qfhyaWcu58vlfLmcLxdfLteXSztzaWcu7czFV4qvFF8pvlJ8pbSzlPOVcr5SzleKr5Trq6WdtbSzlnbW4qvFV4uvFl8tvlraWcv5jnK+o5zvKL6jXN9R2nmUdh6lnUfxHcV3FF8rvlZ8rbSzlfO1cr5WzteKr5Xra6WdrbSzl3b24uvF14uvF18vvl7a2cv5ejnfklftgG87WuFemApzYSk6WngUtsLFt+RVK3nVSl61kletFd8mhbXwKGyFi28vviWvWsmrVvKqlbxqJa9ayatW8qr14ttxfVvJq1byqpW8alR8qfiWvGolr1rJq1byqpW8aiWvWsmrxsWXy/UtedVKXrWSV42LLxffklet5FUredVKXrWSV63kVSt51aT4Srm+Ja9ayatW8qpp8dXiW/KqlbxqJa9ayatW8qqVvGolr9oovqNc35JXreRVK3nVRvEdxbfkVSt51UpetZJXreRVK3nVSl41K75Wrm/Jq1byqpW8alZ8vfiWvGolr1rJq1byqpW8aiWvWsmr5sXXcX17yate8qqXvOoHfPvBhaWwFh6FrTDOt5e86iWveiu+jQpzYSmshYtvK74lr3rJq17yqpe86iWvesmrXvKq9+LbR2ErXNq55FWn4kvFt+RVL3nVS171kle95FUvedVLXnUuvlyub8mrXvKql7zqXHy5+Ja86iWvesmrXvKql7zqJa96yasuxVfK9S151Ute9ZJXXYqvFt+SV73kVS951Ute9ZJXveRVL3nVtfhqub4lr3rJq17yqo/iO4pvyate8qqXvOolr3rJq17yqpe86lZ8rVzfkle95FUvedWt+FrxLXnVS171kle95FUvedVLXvWSV92Lr5frW/Kql7yikldUfg/S0QtTYS4shbXwKGyFcb7Uim9rhXthKsyFi28rviWvqOQVlbyikldU8opKXlHJK+rFt0thLTwKW+HiS8W35BWVvKKSV1TyikpeUckrKnlFVHypXN+SV1TyikpeUfk9SFx8S15RySsqeUUlr6jkFZW8opJXJMVXyvUteUUlr6jkFZXfg1Tyisr7FZX3Kyp5ReX3IGnx1eJb8opKXlHJKyrvV3TnlZ585VXvwa1wL0yFubAU1sKjsBV2sBVfK75WfK34WvG14mvF98qrc5mDRldenUtDNbry6uIrr84vhxtdeXVzL39Dhbn8jRTW8jejsOEYHL585dXN8OUrr26m8jdcWMrfaOFR/sYKex4Dt+J75dXNxffKq5uL75VXNxffK69uLr6tnO+VV9cx9OLbe+Hi27lw8e1auPheeXVz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Ky55xSWvmIsvl+tb8opLXnHJK+biK8W35BWXvOKSV1zyiktecckrLnnF5f2Ky/sVl7zikldc8orL+xWX9ysuecUlr7jkFZe84pJXXPKKS17xKL6jXN+SV1zyikte8Si+o/iWvOKSV1zyiktecckrLnnFJa/Yiq+V61vyiktecckr9uLrxbfkFZe84pJXXPKKS15xySsueSUHfOVohXthKsyFpeho4VHYChffkldS8kpKXknJK2nFt0lhLTwKW+Hi24tvySspeSUlr6TklZS8kpJXUvJKevHtuL5S8kpKXknJK6HiS8W35JWUvJKSV1LySkpeSckrKXklXHy5XN+SV1LySkpeCRdfLr4lr6TklZS8kpJXUvJKSl5JySuR4ivl+pa8kpJXUvJKyu9BKb8HpeSVlLySkldS8kpKXknJKyl5JaP4jnJ9S15JySspeSXl96CM4lvySkpeSckrKXklJa+k5JWUvBIrvlaub8krKXklJa+k/B4UL74lr6TklZS8kpJXUvJKSl5JySvx4uu4vlrySkteackrLb8H9eDCUlgLj8JWGOerJa+05JW24tuoMBeWwlq4+LbiW/JKS15pySsteaUlr7TklZa80l58+yhshUs7l7zS8ntQqfiWvNKSV1rySkteackrLXmlJa+Uiy+X61vySkteackrLb8HlYtvySsteaUlr7TklZa80pJXWvJKpfhKub4lr7TklZa80vJ7UEteaXm/0vJ+pSWvtPweVC2+pf9KS15pySsteaXl/UrvvJLgy9eCqTAXlsJaeBS2wg6+8+riVrj4WvG14mvF14qvFV8rvlZ8vfh68fXi68XXi68XXy++Xny9+Dp8x3EUboV7YSrMhaVw+MY45jW/fbIVDt9z3mm/5rdPboV7YSrM0Lny6ubie+XV/fdWuPj24tuLby++vfj24tuLby++vZxvL+fbiy8VXyq+VHyp+F55dbMU1sLlfKn4Xnl18ZVXN7fCvXDx5eLLxZeLLxdfLu3M5XylnK+U85Xie+XVzaWdpbSzlHaW4ivFV4qvFl8tvlraWcv5ajlfLeerxVfL9dXSzlraeZR2HsV3FN9RfEfxHcV3lHYe5XxHOd9RzteKr5Xra6WdrbSzlXa24mvF14qvFV8rvl7a2cv5ejlfL+frxdfL9fXSzl7a2Us7O3yv+e2TW+FemApzYSmshUdh+NqB62vtKNwK98LFtxXfVnxb8S15ZSWvrOSVlbyyklfWi2+nwlxYCmvh4tuLb8krK3llJa+s5JWVvLKSV1byyqj40ihc2rnklZW8Mi6+XHxLXlnJKyt5ZSWvrOSVlbyyklcmxVfK9S15ZSWvrOSVSfGV4lvyykpeWckrK3llJa+s5JWVvDItvlqub8krK3llJa9Mi+8oviWvrOSVlbyykldW8spKXlnJKxvFd5TrW/LKSl5ZySuz4mvFt+SVlbyykldW8spKXlnJKyt5ZV58vVzfkldW8spKXpkXXy++Ja+85JWXvPKSV17yykteeckrL+9XXt6vvOSVl7zyklde3q+8vF95ySsveeUlr7zklZe88pJXXvLKe/HtrXAvTIW5cPHtxbfklZe88pJXXvLKS155ySsveeVUfEkKl3YueeUlr5yKLxffklde8spLXnnJKy955SWvvOSVc/Hlcn1LXnnJKy955VJ8pfiWvPKSV17yykteeckrL3nlJa9ci6+W61vyykteeckr1+KrxbfklZe88pJXXvLKS155ySsveeWj+I5yfUteeckrL3nlVnyt+Ja88pJXXvLKS155ySsveeUlr9yLr5frW/LKS155ySv34uvFt+SVl7xy5BUdyCs6kFd0IK/oQF7RcaQvHYcU1sKjsBUuvq34tuLbim8rvsgrOpBXdCCv6EBe0dGKb3Mw8ooO5BUdyCs6evHtxbcX3158e/FFXtHRy/lSOV8q50vFl6hwaWcq7Uylnan4UvGl4svFl4svl3bmcr5czpfL+XLx5XJ9ubQzl3aW0s5SfKX4SvGV4ivFV0o7SzlfKecr5Xy1+Gq5vlraWUs7a2lnLb5afLX4avHV4jtKO49yvqOc7yjnO4rvKNd3lHYepZ1HaedRfK34WvG14mvF10o7WzlfK+dr5Xyt+Fq5vl7a2Us7e2lnL75efL34evH14uulnUtetZJXreRVO+DbDirMhaWwFh5Fx8r/jvNteL+iVvKqteLbim8rviWvWsmrVvKq4f2K2p1XdPKdVxrcCvfCVJgLS2EtPApbYQdT8aXiS8WXii8VXyq+VHyp+FLxpeLLxZeLLxdfLr5cfLn4cvHl4svFl4uvFF8pvlJ8pfjeeWXBUlgLX74ebIUdfOfVxa1wh86dVxcX3zuvrr/XwsVXi68W31F8R/EdxXcU31F8RznfUc53FN9RfEfxteJrxffOq4upMBcu52vF986ri62wg++8urj4evH14uvF14uvl3b2cr5eztdxvv2Ab7/z6uJemApzYSk6WngUtsLFtx2FW+FemAoX3yaFtfAobIWLby++vfj24tuLb+fC5Xx7Od9ezrcX347re89vv7m0M5V2puJLxZeKLxVfKr5U2pnK+XI5Xy7ny8WXy/Xl0s5c2plLO3Px5eLLxVeKrxRfKe0s5XylnK+U8y15dc9vv7m0s5R21tLOJa/u+e03F18tviWvesmrXvKql7zqJa/u+e2X7yjXt+RVL3nVS17d89tvneJb8qqXvOolr3rJq17yqpe86iWv7vntl6+V61vyqpe86iWv7vntl44X35JXveRVL3nVS171kle95FUveXXPb798HdeXSl5RySsqeXXPbw+de377zVJYC4/CVhjnSyWvqOTVPb/98m1UmAtLYS1cfFvxLXlFJa+o5BWVvKKSV1Tyikpe3fPbL98+Clvh0s4lr+757ZcOFd+SV1TyikpeUckrKnlFJa+o5NU9v/3y5XJ9S15RySsqeXXPb791im/JKyp5RSWvqOQVlbyikldU8orK+xWV9ysqeUUlr6jkFZX3KyrvV1TyikpeUckrKnlFJa+o5BWVvLrnt1++Wq5vySsqeUUlr+757ZfOKL4lr6jkFZW8opJXVPKKSl5Ryat7fvvla+X6lryikldU8uqe337rFN+SV1TyikpeUckrKnlFJa+o5NU9v/3y9XJ9///C7mZHkiU5rPC7zLoX5T/hZq5XIQYESY2EAQYcYkQKEIT77sp0t+z8dtoQp6uj4oR7ZJ7KqGvsoVeDXk16VfPt5zw131484Ak/8IIDTvi73ppvv97W4A4PeMJ4G156NenVpFeTXk16NenVpFc13369/YEXHHDCeAdeejXp1aRXk15NejXp1aRXNd9+vYP7S68mvZr0qubb73kmXno16dWkV5NeTXo16dWkVzXffr0P95deTXo16dXkeXDyPDjp1aRXk15NejXp1aRXk17VfPv1Lu4vvZr0atKryfNgzbcX46VXk15NejXp1aRXk17VfPv1JveXXk16NenV5Hmw5tuL8dKrSa8mvZr0atKrSa9qvv16N/eXXk16NenV5Hmw5tuLG9zhAU/4gRcc8Ndb8+2X6dVDrx569fA8WPPtxXjp1UOvHnr10KuHXj30qubbr7cPeMIPvGC8HS+9eujVQ68eevXQq4dePfSq5tuvdwTMPtOrh149PA/WfHsxXnr10KuHXj306qFXD72q+fbrfbi/9OqhVw+9engefOjVw+erh89XD716eB6s+fZivPTqoVcPvXr4fFXz7bMdPt73v0U8ar798u1VcYM7POAJP/CCA8YbeBNv4k28iTfxJt7Em3gTb+LdeDfejXfj3Xg33o13491499db8+3FDb7edXjAE77eOLzggBPeX769uue5vSrGe3tVx08Yb8Pb8Da8DW/H2/F2vJ31dtbb8Xa8HW/H2/HeXhU3uMOsd+C9vSpecMAJ4514J96Jd+Kd7PNkvZP1TtY78d5eXX7Y54d9ftjnB++D98H74H3wPuzzw3oX612sd+Fd3N/FPi/2ebHPC+/Cu/AG3sAb7HOw3mC9wXoDb3B/g30O9jnZ58SbeBNv4k28yT4n603Wm6x3493c380+b/Z5s88b78a78W68++ut+fbiBnd4wF9vzbcXLzjghPE2vA1vw0uvgl4FvQp6FfSq5tuvt33vb9CroFdBr2q+/Z6n46VXQa+CXgW9CnoV9CroVc23X+8YMPtMr4Je1Xx7nQcvvQp6FfQq6FXQq6BXQa9qvv16J/eXXgW9CnpV8+33PA9eehX0KuhV0KugV0Gvgl7VfPv1Lu4vvQp6FfSq5tvrPHjpVdCroFdBr4JeBb0KelXz7dcb3F96FfQq6FXNt9/zJF56FfQq6FXQq6BXQa+CXtV8+/Um95deBb0KelXz7fc8Gy+9CnoV9CroVdCrpFdJr5LPV8nnq6RXSa+SXiWfr5LPV0mvkl4lvUp6lfQq6VXSq5pvv94WcMLffU56VfPt9zwdL71KepX0KulV0qukV0mvar79ekeD2Wd6lfSq5tvrPHjpVdKrpFdJr5JeJb1KelXz7dc7ub/0KulV0quab7/nefDSq6RXSa+SXiW9SnqV9Krm26/34f7Sq6RXSa9qvv2eZ+GlV0mvkl4lvUp6lfQq6VXNt19vcH/pVdKrpFc1317nwUuvkl4lvUp6lfQq6VXSq5pvv97k/tKrpFdJr2q+/Z5n46VXSa+SXiW9SnqV9CrpVc23H2/Ntxd3eMATfjjPggNOGC+92vRq06tNr2q+/XrbAy844ITxdrz0atOrTa82vdr0atOrTa9qvv16+/f+bnq16dWmV5vnwZpvL8ZLrza92vRq06tNrza9qvn2653cX3q16dWmV5vnwZpvL8ZLrza92vRq06tNrza9qvn26324v/Rq06tNrzbPgzXfXoyXXm16tenVplebXm16VfPt1xvcX3q16dWmV5vnwZpvL8ZLrza92vRq06tNrza9qvn2603uL73a9GrTq83zYM23F+OlV5tebXq16dWmV5te1Xz79e7f93f+fHs1f769mj/fXs2f7/Pg/Pn2av58P1/Nn+/nq/nz7dX8+T4Pzppvv9zwfns1f769mj8N7/fz1az59ve/Kztrvv3978rOmm8vTnh/+faquMEdHvCEHxhvx9vxdrwD78A78A68A+/AO/AOvAPvwDvxTrwT78Q78U68E+/EO/FOvLdX73/Ld9Z8e3GHr/c5POEHXnDAyXn2lxfe26t7/O1VMd6Fd+FdeBfehXfhDbzBeoP1Bt7AG3gDb+C9vSreX769Kma9iff2qnjCD7xgvIk38W68G+9mnzfr3ax3s96N9/aqmH3e332u+fbir7fm24sHPOEHXnDACX/XW/Pt19sa3OEBTxhvw9vwNrwNb/+BWW9nvZ31drz9gRcccMJ4B96Bd+AdeAf7PFjvYL2D9Q68g/s72efJPk/2eeKdeCfeiXfinezzZL0P631YL72q+fZi9vlhnx/2mV7VfHsx3oWXXjV61ehVo1eNXtV8+/Uu7i+9avSq0auab7/nCbz0qtGrRq8avWr0qtGrRq9qvv16k/tLrxq9avSq5tvrPHjpVaNXjV41etXoVaNXjV7VfPv1bu4vvWr0qtGrmm8/56n59uIGd3jAE37gBQf89dZ8+2V61elVp1c1337P0/DSq06vOr3q9KrTq06vOr2q+fbr7QOe8AMvGG/HS686ver0qtOrTq86ver0qubbr3cEzD7Tq06var79nmfipVedXnV61elVp1edXnV61fl81fl81elVp1edXnU+X3U+X3V61elVp1edXnV61elVp1c13369i/tLrzq96vSq5tvveQIvver0qtOrTq86ver0qtOrmm+/3uD+0qtOrzq9qvn2e57ES686ver0qtOrTq86ver0qubbr3dzf+lVp1edXtV8e50HL70a9GrQq0GvBr0a9GrQq5pvP96aby9O+LvPg17VfPs9T8NLrwa9GvRq0KtBrwa9GvSq5tuvtze4wwOeMN6Ol14NejXo1aBX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d1zv+zVw59s/fLzP5Q4PeMIPvOCAE95fPr36MN4H74P3wfvgffA+eB+8D96Fd+FdeBfehXfhXXgX3oV34Q28gTfwBt7AG3gDb+ANvIE38SbexJt4E2/iTbyJN/Em3o134914N96Nd+PdeDfejXf/9q473/7hBnd4wBN+4AUHnDDehrfhbXgb3oa34W14G96Gt+HteDvejrfj7Xg73o634+14O96Bd+AdeAfegXfgHXgH3oF34J14J96Jd+KdeCfeiXfinXgn3gfvg/fB++B98D54H7wP3gfvg3fhXXgX3oV34V14F96Fd+FdeANv4A28gTfwBt7AG3gDb+BNvIk38SbexJt4E2/iTbyJd+PdeDfejXfj3Xg33o1346VXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVaNXjV41etXoVate5Ztvr97/f5rrzrd/uMMDPt41Dz/w8a44fLzvZ6V159s/vL98e/V+blp3vv3DxxvnnLdXxRM+3jhrub0qPt58Die8v3x7lec6b6+KjzfPtd1e7XM9t1fFx7vPPtxeFR/vPtdwe1W8v3x7tc+e314Vv72v3+geHvCEn8Pn2k6vPvz2vn67ezjhtzfez2vrzrd/uMHH+35GW3e+/cPH289enV69fvt6eMEBH28/15P7y6dXr9++Hm5wh493nHt6evXh451nb0+vPhzw8c5znadXl+98e7z/d2fWnW+P9//uzLrz7R8+3qcdnvDxvn8/sO58+4cDPt7zPrrz7cWnV7HONZxefbjDx3veI3e+/cPHe94Xd779w8f7nsVad779w/vLp1ev31IebvDxntf8nW//8IQf+HjzrOX06sPHe94Xd749znvhzrd/uMHHe94Xd779w8d73gt3vv3DCz7e87648+0ffnvzvBfufPuHG9wPn+s8vfrw25vnfXHn21+/RTy84Dh89uH06sPH2841nF59uMHHe95Td779w8d73gt3vv3DCz7eca7t9OrDxzvOtZ1effh4Zz/c4QEf7zyv1dOrDx/vfV+cXuV9L5xefXh/+fQq7/vi9OrDx3vfC6dXH57w8d73xenVh4/3vhdOrz68v3x6lfd9cXr14eO974vTqzw/L+58+4ePN85enV59+HjPz4g73/7h/eXTq7zvqdOrDx/v+Rlx59s/POHjve+R06sPH+99X5xeffjt3e/f9a073/7hBvfD/fCA5+F5+Dn8HF6H1+GA83Ac3l9uP3CDrzcPD3jC17sPH2+7Xz/e83Pkzre/fvt0eH/59Gqfny93vv3Dx3t+ptz59tdvjQ5P+IEXfLzn9X/n2z+8v3x69eHjPT8v7nz767dAhwd8vM/PH7/+9L//5R9//Zd//dtf/tef/tv/ff3xf/zXv//bf/717/9ef/zP//Mfn7/513/89W9/++v//Of/+Mff/+0v//2//vGXf/7b3//t/Xd/+qn/80/r/XJ7fcyIP//60+sq/un13xt/fr3+Q2O+/jzef349AP96/Qfh+f779ze8/4WZX+9/Kub9hfMdr8em1xEr/vzHOcU97+u18+u1h3WW1yfCX69PZ59zvN4wv14v/M8ZXq/pX6/X7/v7++f7X+/l87X7/c/Pr/Xz+7uf51e/fzzfvdrrj+P93eP93e/j32v4ffzev15PAe+/n++/P197Xc/8fYbZfs3z/c/n+19fedrn+1+/q3/O4tbvb2/7Vz9njN9fem1T3+8v5fdL8dqC95f2Z1Xz9dqac9WqXl19Xfn+vbOvF/xs/XtV6/XHPLv687mwV3dfl/r5hteNOMrWvle2fvV2vta/i/35NZ7ztd8b9Pq8M/vvBb5Wu87ffzfotYPr+VzKqyp5Rc//5wTfLervu/LnP/74489//D8=",
      "brillig_names": [
        "discover_new_messages",
        "build_msg_block",
        "attach_len_to_msg_block",
        "debug_log_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "get_l1_to_l2_membership_witness",
        "notify_created_nullifier_oracle_wrapper",
        "storage_read",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_to_radix",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "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\n0wjG1j0HkTruZrSFZmQJ4zJievrMBCtdWDUY"
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "l1_portal",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "token_contract_class",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "shield_gateway_beacon",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "8459146718181593566": {
            "error_kind": "string",
            "string": "L1 portal address cannot be zero"
          },
          "8606784891595333955": {
            "error_kind": "string",
            "string": "Token contract class cannot be zero"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBNJwAABAMnAgQEAycCBQQAHwoABAAFgEouCIBKAAEuCIBLAAIuCIBMAAMlAAAAUSUAAACDKAIAAQSATScCAgQAOw4AAgABKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgAAACgAgEcBAAEoAIBIBAABKACASQQABCYlAAAIZx4CAAUALQgBBicCBwQDAAgBBwEnAwYEAQAiBgIHNg4ABQAHAAEiAAaASAAILQsIBycCCAQCACoGCAotCwoJHAoHBgAEKgYJCiQCAAcAAADhJwIGBAA8BgYBLQgBBicCBwQDAAgBBwEnAwYEAQAiBgIHNg4ABQAHAgEiAAaASAAHLQsHBQAqBggJLQsJBxwKBQYABCoGBwgkAgAFAAABMCcCBgQAPAYGAS0IAQUnAgYEAgAIAQYBJwMFBAEAIgUCBh8wgEiARQAGASIABYBIAActCwcGHAoGBwQcCgcFAC0IAQYAAAECAScCBwACLQ4HBi0IAQknAgsEBAAIAQsBJwMJBAEAIgkCCx8wgEOASAALLQsJCwAiCwILLQ4LCScCCwAsLQgBDCcCDQQFAAgBDQEnAwwEAQAiDAINLQoNDi0OCw4AIg4CDi0OCw4AIg4CDi0OCw4AIg4CDi0OCw4tCAELAAABAgEtDgwLLgiARQAEIwAAAf0NIgAEgEMADCQCAAwAAAgFIwAAAhItCwsJKwIACwAAAAAAAAAABAAAAAAAAAAAJwIQBBEtCAARLQoLEgAIABAAJQAACJAtAgAALQoSDC0KEw0tChQOLQoVDy0IAQsAAAECAS0ODAstCAEMAAABAgEtDg0MLQgBDQAAAQIBLQ4ODS0IAQ4AAAECAS0ODw4tCwkPACIPAg8tDg8JLgiARQAEIwAAAqINIgAEgEkADyQCAA8AAAe7IwAAArcnAgkEDy0IAA8tCgsQLQoMES0KDRItCg4TAAgACQAlAAAJIy0CAAAtChAELQsGCS0OCQYrAgAGAAAAAAAAAAADAAAAAAAAAAAnAg4EDy0IAA8tCgYQAAgADgAlAAAIkC0CAAAtChAJLQoRCy0KEgwtChMNLQgBBgAAAQIBLQ4JBi0IAQkAAAECAS0OCwktCAELAAABAgEtDgwLLQgBDAAAAQIBLQ4NDCcCDQANJwIOBA8tCAAPLQoGEC0KCREtCgsSLQoMEy0KDRQACAAOACUAAAmXLQIAACcCDQQOLQgADi0KBg8tCgkQLQoLES0KDBItCgUTAAgADQAlAAAJly0CAAAnAgUEDS0IAA0tCgYOLQoJDy0KCxAtCgwRLQoEEgAIAAUAJQAACZctAgAAJwIFBA0tCAANLQoGDi0KCQ8tCgsQLQoMEQAIAAUAJQAACSMtAgAALQoOBAoqCAQFJAIABQAABCElAAAKwAsiAAqARgAEHgIABQEKKgoFBhIqBAYFJAIABQAABEUlAAAK0gsiAAGARgAECyIABIBEAAUkAgAFAAAEYiUAAArkCyIAAoBGAAQLIgAEgEQABSQCAAUAAAR/JQAACvYcCgEEACwCAAUAAAAAAAAAAAAAAAAA//////////////////////////8OKgQFBiQCAAYAAAS7JQAACwgpAgAEADuaygEvCgAEAAULIgAFgEYABiQCAAYAAATfJQAACxooAgAFAN6tMAoABQAEKwIABAAAAAAAAAAAAQAAAAAAAAAAJwILBAwtCAAMLQoEDQAIAAsAJQAACJAtAgAALQoNBi0KDggtCg8JLQoQCi0IAQsAAAECAS0OBgstCAEGAAABAgEtDggGLQgBCAAAAQIBLQ4JCC0IAQkAAAECAS0OCgknAgoEDC0IAAwtCgsNLQoGDi0KCA8tCgkQLQoBEQAIAAoAJQAACZctAgAAJwIMBA0tCAANLQoLDi0KBg8tCggQLQoJEQAIAAwAJQAACSMtAgAALQoOCicCBgABMAoAAQAGMAoACgAHKQIAAQA7msoFLwoAAQAGCyIABoBGAAckAgAHAAAF6yUAAAsaMAoABQABJwIJBAotCAAKLQoECwAIAAkAJQAACJAtAgAALQoLAS0KDAYtCg0HLQoOCC0IAQkAAAECAS0OAQktCAEBAAABAgEtDgYBLQgBBgAAAQIBLQ4HBi0IAQcAAAECAS0OCAcnAggECi0IAAotCgkLLQoBDC0KBg0tCgcOLQoCDwAIAAgAJQAACZctAgAAJwIKBAstCAALLQoJDC0KAQ0tCgYOLQoHDwAIAAoAJQAACSMtAgAALQoMCCcCAQAFMAoAAgABJwIBAAYwCgAIAAEpAgABADuaygcvCgABAAILIgACgEYABiQCAAYAAAbgJQAACxowCgAFAAEnAgcECC0IAAgtCgQJAAgABwAlAAAIkC0CAAAtCgkBLQoKAi0KCwUtCgwGLQgBBAAAAQIBLQ4BBC0IAQEAAAECAS0OAgEtCAECAAABAgEtDgUCLQgBBQAAAQIBLQ4GBScCBgQHLQgABy0KBAgtCgEJLQoCCi0KBQstCgMMAAgABgAlAAAJly0CAAAnAgcECC0IAAgtCgQJLQoBCi0KAgstCgUMAAgABwAlAAAJIy0CAAAtCgkGJwIBAAcwCgADAAEnAgEACDAKAAYAAR4CAAEANAIAASYAIgkCEAAqEAQRLQsRDycCEAQRLQgAES0KCxItCgwTLQoNFC0KDhUtCg8WAAgAEAAlAAAJly0CAAABIgAEgEgADy0KDwQjAAACogEiAASASAAMACIJAg4AKg4EDy0LDw0tCwsODSIADIBJAA8kAgAPAAAINCUAAAssLgIADoADKACABAQABSUAAAs+LgiABQAPACIPAhAAKhAMES0ODREtDg8LLQoMBCMAAAH9KACABAR4AA0AAACABIADJACAAwAACI8qAQABBfeh86+lrdTKPAQCASYlAAAIZy0IAQInAgMEBAAIAQMBJwMCBAEAIgICAy0KAwQuDIBGAAQAIgQCBC4MgEYABAAiBAIELgyARgAELQgBAycCBAQFAAgBBAEnAwMEAQAiAwIELQoEBS4MgEYABQAiBQIFLgyARgAFACIFAgUuDIBGAAUAIgUCBS0OAQUtCgIBLQoDAi4IgEUAAy4IgEQABCYlAAAIZy0LBAULIgAFgEQABiQCAAYAAAlFJwIHBAA8BgcBJwIFBAYtCAAGLQoBBy0KAggtCgMJLQoECgAIAAUAJQAAC8wtAgAALQsBBS0LAgYtCwMHLQ4FAS0OBgItDgcDLgyARwAEASIABoBIAAItCwIBJiUAAAhnLQsEBgsiAAaARAAHJAIABwAACbknAggEADwGCAEtCwMGCyIABoBDAAckAgAHAAAKTCMAAAnSLQsDBi0LAQctCwIILQsECQ0iAAaAQwAKJAIACgAACfclAAALLC4CAAeAAygAgAQEAAQlAAALPi4IgAUACgAiCgILACoLBgwtDgUMASIABoBIAAUOKgYFByQCAAcAAAo3JQAADNotDgoBLQ4IAi0OBQMtDgkEIwAACr8nAgYEBy0IAActCgEILQoCCS0KAwotCgQLAAgABgAlAAALzC0CAAAtCwEGLQsCBy0LBAguAgAGgAMoAIAEBAAEJQAACz4uCIAFAAkAIgkCCgEiAAqARQALLQ4FCy0OCQEtDgcCLgyASAADLQ4IBCMAAAq/JioBAAEF9IABplnTJ0I8BAIBJioBAAEFHwBQEkAkIu48BAIBJioBAAEFdWTtHyggEd48BAIBJioBAAEFd3FxQhm9IUM8BAIBJioBAAEFWgLkG7UeqZ88BAIBJioBAAEFHwotJ9yCh6I8BAIBJioBAAEFxWvEWg4QAAI8BAIBJi4BgAOABgsAgAYAAoAHJACABwAAC1kjAAALZC4AgAOABSMAAAvLLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAAC7cuAYAKgAguBIAIgAsBAIAKAAKACgEAgAsAAoALIwAAC4YoAYAFBAABAwCABgACgAYjAAALyyYlAAAIZy4IgEUABSMAAAvcDSIABYBDAAYkAgAGAAAMRyMAAAvxLQsCBS0LBQYAIgYCBi0OBgUtCAEGJwIHBAUACAEHAScDBgQBACIFAgcnAggEBAAiBgIJPw8ABwAJLQsBBS0LAwctCwQILQ4FAS0OBgItDgcDLQ4IBCYtCwMGDCoFBgckAgAHAAAMXSMAAAzJLQsCBgAiBgIIACoIBQktCwkHLQsBCAAiCAIKACoKBQstCwsJACoHCQotCwMHLQsECS4CAAaAAygAgAQEAAUlAAALPi4IgAUACwAiCwIMACoMBQ0tDgoNLQ4IAS0OCwItDgcDLQ4JBCMAAAzJASIABYBIAAYtCgYFIwAAC9wqAQABBUWnynEZQeQVPAQCASY=",
      "debug_symbols": "tZvZbtxKDobfxde+qL2KeZUgCJzEOTBgOIFPMsAgyLsPyeIiO1CN3OrcuL9mi79qYbEWyb9uvtx/+vnPx4enr9/+vXn3/tfNp+eHx8eHfz4+fvt89+Ph2xNaf90E+hNzu3lXbm9iiTfvOn3W+VmDfMr3Jt+bfO/p5t3AzxHks8gnzE+Q7zD4M4Usn/g9BoTYBFJUQOmYCUAgFwW1FLUUtVTSwRqkVhSGQM8KXWAkBbI0BKgTcggKpAMEQyBmBbUktSS1UDsmrEWmEk7An1JCqFmBLHj33JJCF+hq6aSDDZypYSdUAVALiKWEoEDKWIwSk0IXoObNiaAJ5KBQBYpailqqWmpRGAItK3QBKvwEvcXQmw4VpLhgABGsgSzYg5XLUwjoJwySSkHHQFE3QX+izmWgzp2gFurcCU0A1B3UHeTiFpJCF4hRQe7eUlAoCuqes4K6F3UvcvfGbQgERQEEulqoKwtGS6eunFAUhgD16YQmkPTipO5ZLVndM7lHhJIUyB2jpVPHMVDHTdCfKOomVAFQC7XhhDFhhKQg7iMGhaIAAjRkJsjdR1b3rO5F3UtVUPeq7lXvToOoDIIu0NXC1SHg6jAUhSEAejHIxRCiglpiUKgKIMDVYZC7Q1b3rBdnvbgUBbVUda9SHtDqQNO7d717V/euFw+9eOjdtTrA1cHQioHrM6kagRIlNaGulMwjmUo2WzYVqlgNRFSzSTUZoV5NRDRZ1EpEdamdiWw0MwTqHKGhBFiqSveIVHohUKKSTkp4t0Z3ixT5QkOJIn1SRZWWmZoS3UNoCKWgvyZKA43KkmiUCdGvdF+ekSbRsBLCUnX2pYE+iadL9qVUKNSUwH6lQSUEQjwBCQ0lygFCqpJTMDKPZB6UoYS6UolGplJNpZpKtbI0U2mm0q0sNM46tUHmWk6qRqBELS7UhUqIRupRaLwJuY0WFNSXhWopNJQohwg1JcoiQuZRTKWarZoKjb3BqyCq5SSaX4TIl8tCcTqJ+g0Cr5OSEpVeCEsP5FtpRAEwNSWKWKFiBErFbLSAmERjS8hUmqk082jmQaUX6krDyjJMBUwFTAW0LC1kI1VpMRnxCo4q3OYabmJ1BEOKRsVuWNytuBtFpOLGymKRkFd6gsOQwlKxGY7g6G7DxcCtYGI9sFhl7Ia8EBQchhSXkVawsXM1BekWkcUoQQhyhSZSB2JaYqTyJnbr0bE6giHXQtCtNMIUu+II0bE6mtuI2XEYUnJVtJKN7GLZxbKLleLoYtXFqpessVhkbIY0SygWx2HI63dBdwN34+U8I4TgyGKJEQxn5Sd2Qw5lwerobtnFsluLi3F3p0Y4Kz9xGLbsyNsYahKe5SMtiBHZSgkEuLsF3crdnSvjEEyBg1awGVJaUiyO7pbcjRYzgtmt2cUq35g2ToG7MHfGZtjdyvErCIa885oIdkEMsgdAakrUP0JDiVfik0Apmy3bdTwIaBWOs3h0bIbRrdGtya1zN8qY3Zr92pIc/W6zgYCxG7bk6Nbu1u7WER3dCn7t7HHCHLIjGM5uZuQxSevCxPvRWNg698yMc9c8EQx550yrOcRhyKNPsBny6BMsjuZWQnZ0a0yOJlZScCyO7pbdLbsb90WNhDx7TOQMW/iCWU22cqtP5MlBsDqCIY+zkuiYgRu18IkDj52JPHYEm2EOjn5t8QtoWYqLEsZuOAs5EQx5GE2c5Z24sfK1NDwrhz0jb3AFOQMIVkdza3ycIegK3L6l8dFKdKyOYMhhL9gNm7s1F+tu7S7WXWy4GI8A2u6lNvuCkDfLitWQh7RgM+QwErS+6Dk5WrfwVpkxz5xHu5jM+xlcoRFyhQSrIU9bgkVCDnEYzgpNdCu4FcwaQ3Z0ayyObp3RN7EZ5uDobtndeK7iukXOXJUOnuKs0ETQCkWukKBbuUKCrFAJOUcJmnXm39oYmyHHpKDdIqXgaK2e5pifOAxLdnRr9Ws5y01srtv8bjPL5d+/b2/0ZPTjj+f7ezoY3RyV4gHq97vn+6cfN++efj4+3t785+7xJ1/07/e7J/78cfeMv2Lj3j99wU8U/PrweE/0+9a9w74r7g6ptdgdOzC6BG5/X4jEhUiFphq4Ot9ItBcSaV+iQOgiUWAj0csLhbyvgMvAIQoD0+6ewqoajeYuqcZIu9Wo+xKY5aNIYERkl+Dedom2KMUIWUuBp0+7EodL0XYlDrcF7LYF7Ev0pvXAYz4TKOlwEXqyhui97xYhLjRwrGlY5VzCfkssQjPhbkRbEwf/vsbhcuSLemTbHKPsN0f9i10ySvDY3B/ose9r4MpEC1FLSLvjdCyKEaonrYDJZ1dkVY5SvBx1XCZBz3RUAvYk0qJFG2hs4QG8CaR8PCxG8y4ZcT/35lWXWOqsePLmxehv0KhgzYlLvN22WEUn2CAZocTdmSi1K4TGqiB4aKH5E58sLAoy/q4Gzs3atwmPCkxjvJzec1i1abNZMUQfbXgA/FJjEWIVV7DatWkTYng0e1wDN3weYvVCjd5MYzMn/aERVt0SvT1q3W+PVZz2ApZGNxH2h8YiTnPVJi2b1Q4uSV8q9NW0BDbJ45HGZRopu0ZJl2n0qL2CC9uwq7FOHiNY8kjhkrXbiMnT4P7sWBYTffbYwA3KQiOfjy/aQZ+Nr1LPxldp5+NrqZGG1gQPitJlGgfjaxkcoBMLnp3m/WXLQgJApxXcWO5PszWen2YXEngmajNCKGO/GKvBFnyw4bHA3mCriwgdNWpr4BblkvGafJzg4W7Yr8giMqBqYADES1oTO7V4IfY7NSwzaPYM6lM0Dv2jCjnYOMubzdobFEqwEVIy7Cm0VUtEWwxH3O9tGvPl1NoW6bN2WwDCZsM4jjeELf+wRnW3Gou4TOC9AZs1fXxdjdXsPmyI9bEJilex3dpqm5Usgbe2O8JaX3YIeI9sN/GvRZbNYecy+UXSet0cCw06iVMNfLyzq9FXi65kO2hs3N2jmR5X8+qwjIPPgXYl0qpJ8Wzag3yzC39Dk+Zk5ch5E6R/NEdZ7VFy8S3KZnYOrzSusAbtp9eg/Qpr0KXGwTVCv8IadN2zduKFaXi/Z0c8HegjnQ70ka8Q6Ms5xbeeBdJeMh71fDIe7XQyHv10Mh7jCsl43RzHkvFK42gyhvMxCudjFK4Ro8vmOJiMoZ5PxtDOJ2PoZ5MxjPPJeKlxMBkvNQ4m43XPHkvGMaTTkR5DPh3qMZS/nI+rnX2l7SO2V/k4hnY+IcfQT2dkfIZ8OiXjUekVcvL/aZJjSXkpcjQrx3iFYI1XCNZ4jWBdN8nBzBxjO5+a4+oZzdHcHFcPnI4l5xjhfHZeixxMz2uRowdq6w4+mKBXx75HYz6V8zG/et5zjQQdM7+IJy9SYBvvPvGJafVIsatIC/sHUnH11OjgqxQxwfmXKVZVaVEnipb3X6aIqyc+pScbeH1zuva6GHmRWKFlOyZcTDbLRxzZXsnABybxwkctx4bu+gGYPzrPm5Pbtz1EsyfO+Ph9/2FeWD0PBCvFfvpYCdhxfIv1EgFc9tl4De0yiWjrGJwPx2USzbPGuKwU2Z9MZLisFDVZRepmjLxJotnLPnXAZRUJ4NnvsorkYtN9rhdV5OjUtipF8/cpWr+sIr37mzqQLpIAb05IF0n0Ym+WlHaJABSdWLebhbcI2DwE6bIS2PiCXk9W4bXAB/x69/nh+cX/pv8mqeeHu0+P9/L168+nz5tff/z3u/6i/9v+/fnb5/svP5/vScn/wR3/vK943lhH/XB7Q2+dvi+4jikJ6GukX2u9rbV/+E2F+R8=",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "get_l1_portal",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_l1_portal"
      ]
    },
    {
      "name": "get_l1_token",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "aztec_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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kRb1IivyolE0i1bSkecXlWOVY5VjlWOVY5VjlWOVY6UjJhVdJEWtSIt6kRV50SiaReWQckg5pBxSDimHlEPKIeWQckg5WjlaOVo5WjlaOVo5WjlaOVo5Wjm0HFoOLYeWQ8uh5dByaDm0HFqOXo5ejl6OXo5ejl6OXo5ejl6OXg4rh5XDymHlsHJYOawcVg4rh5XDy+Hl8HJ4ObwcXg4vh5fDy+HlGOUY5Yg81yAt6kVW5EWjaBatpMjzk6SoHLMcsxyzHLMcsxyzHLMcqxyrHKscqxyrHKscqxyrHKscKx0xcekiKWpFWtSLrMiLRtEsKoeUQ8oh5ZBySDmkHFIOKYeUQ8rRytHK0crRytHK0crRytHK0crRyqHl0HJoObQcWg4th5ZDy6Hl0HL0cvRy9HL0cvRy9HL0ckSej6BZtJKOPF+3IClqRVrUi6zIi0bRLFpJXg4vh5fDy+Hl8HJ4ObwcXg4vxyjHKMcoxyjHKMcoxyjHKMcoxyjHLMcsxyzHLMcsxyzHLMcsxyzHLMcqxyrHKscqxyrHKscqxyrHKsdKR0yOukiKWpEW9SIr8qJRNIvKIeWQckg5pBxSDimHlEPKIeWQcrRytHK0crRytHK0crRytHK0crRyaDm0HFoOLYeWQ8uh5dByaDm0HL0cvRy9HL0cvRy9HL0cvRy9HL0cledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnk+Ks9H5fmoPB+V56Py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",
      "brillig_names": [
        "get_l1_token"
      ]
    },
    {
      "name": "get_l2_token",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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WpEW9SIr8qJRNItW0pHnF5VjlWOVY5VjlWOVY5VjlWOlIyYVXSRFrUiLepEVedEomkXlkHJIOaQcUg4ph5RDyiHlkHJIOVo5WjlaOVo5WjlaOVo5WjlaOVo5tBxaDi2HlkPLoeXQcmg5tBxajl6OXo5ejl6OXo5ejl6OXo5ejl4OK4eVw8ph5bByWDmsHFYOK4eVw8vh5fByeDm8HF4OL4eXw8vh5RjlGOWIPNcgLepFVuRFo2gWraTI85OkqByzHLMcsxyzHLMcsxyzHKscqxyrHKscqxyrHKscqxyrHCsdMXHpIilqRVrUi6zIi0bRLCqHlEPKIeWQckg5pBxSDimHlEPK0crRytHK0crRytHK0crRytHK0cqh5dByaDm0HFoOLYeWQ8uh5dBy9HL0cvRy9HL0cvRy9HJEno+gWbSSjjxftyApakVa1IusyItG0SxaSV4OL4eXw8vh5fByeDm8HF4OL8coxyjHKMcoxyjHKMcoxyjHKMcoxyzHLMcsxyzHLMcsxyzHLMcsxyzHKscqxyrHKscqxyrHKscqxyrHSkdMjrpIilqRFvUiK/KiUTSLyiHlkHJIOaQcUg4ph5RDyiHlkHK0crRytHK0crRytHK0crRytHK0cmg5tBxaDi2HlkPLoeXQcmg5tBy9HL0cvRy9HL0cvRy9HL0cvRy9HJXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V5155PirPR+X5qDwfleej8nxUno/K81F5PirPR+X5qDwfleej8nxUno/K81F5PirPR+X5qDwfleej8nxUno/K81F5PirPR+X5qDwfleej8nxUno/K81F5PirPR+X5qDwfleej8nxUno/K81F5PirPR+X5qDyP+WBLg3qRFXnRKJpFKyny/CQpakXlsHJYOawckec9aBatpMjzk6SoFWlRL7IiLyqHl8PLMcoxyjHKMcoxyjHKMcoxyjHKMcoxyzHLMcsxyzHLMcsxyzHLMcsxy7HKscqxyrHKscqxyrHKscqxyrHSERPJLpKiVqRFvciKvGgUzaJySDmkHFIOKYeUQ8oh5ZByRJ5b0EqKPD9JilqRFvUiK/KiUVSOVg4th5ZDy6Hl0HJoObQcWg4th5ajl6OXo5ejl6OXo5ejl6OXo5ejl8PKYeWwclg5rBxWDiuHlcPKYeXwcng5vBxeDi+Hl8PL4eXwcng6Yh7P9Un5YfOgI/IM6kVW5EWjaBatpDj6k6SoFZXDy+Hl8HJ4ObwcXo5RjlGOUY5RjlGOUY5RjlGOUY5RjlmOWY5ZjlmOWY5ZjlmOWY5ZjlmOVY5VjlWOVY5VjlWOVY5VjlWOdTlazPK5SIpakRb1Iis6HCtoFM2ilRRV6iQpakVadHfI7RZoB2qggwOc4Co8alWigA1UsIPYGraGrWGLZTtuPZZJuIECNlDBDobNAx0c4ARXYSzmcaGADVSwg9g6iljR4zYOPFfwiKt+ruFxooIdNPA4dIlg52oeJ05wFZ5repwoYAMV7KCB2BybY3NsA9vANrANbAPbwDawDWwD27nyR1y+c+2PEwVsoIIdNNDBAU4Q28K2sC1sC9vCtrAtbAvbwhYrhMiR4DE1KFHABirYQQMdHOAED1uTA48ykShgAw9brKAQE4Xug56BBjo4wAmuwigV2gMF1MyLczGfY9GBdi7nc6GDA5zgodCIEPXhQgEbqGAHDXQwbHHyUR8uXIVRH/ot8LD1uGZRH7oGKthBAx0chbHUT/dAAVthpHSPixopfaGCHTTQwQFOcBVGSl+IbWAb2Aa2gW1gG9gGtoFtYpvYJraJbWKb2Ca2iW1im9gWtoVtYVvYFraFbWFb2Ba2VbZz2Z8LBWyggh000MEBThCbYBNsgk2wCTbBJtgEm2ATbA1bw9awRRaaBDZQweMYTAMNdHCAE1yFkYUXCthABbF1bJGFx2epLSb3JE5wFUZuXihgAxXsoIHY4jZ+fI3bYp5P4iqM2/iFAjYwbDOwgwY6OMAJrsLI+QsFbCC2gW1gG9giuy0aQWT3hQI2UMEOGujgACeIbWFb2Ba2hW1hW9gWtoVtYVtli7k/iQI2UMEOGujgACeITbAJNsEm2ASbYBNsgk2wCbaGrWFr2Bq2hq1ha9gatoatYVNsik2xKTbFptgUm2JTbIqtY+vYOraOrWPr2Dq2jq1j69gMm2EzbIbNsBk2w2bYDJthc2yOzbE5Nsfm2BybY3Nsjm1gG9gGtoFtYBvYBraBbWCjlii1RKklSi1RaolSS5RaotQSpZYotUSpJTGrSI51AVpMK0psoIIdNDAUHjjBldjPAnKigA1UsIMGOjjACWITbIJNsAk2wSbYBJtgE2yCrWFr2Bq2hq1ha9gatoatYWvYFJtiU2yKTbEpNsWm2BSbYuvYOraOrWPr2Dq2jq1j69g6NsNm2AybYTNshs2wGTbDZtgcm2NzbI7NsTk2x+bYHJtjG9gGtoFtYBvYBraBbWAb2Aa2iW1im9gmtoltYpvYJraJbWJb2Ba2hW1hW9gWtoWNWtKpJZ1aEhOX5FhIpMXMpcQGRrnqgR000MEBTvCwediillwoYNgsUMEOhm0GOjjAw3Z8YtliLtOFUUuGBArYwMM24jSjllxo4GEbcQxRSy6c4CqMWnKhgBE3TjPqwzGRvsWUpft7beAqjPpwoYDH8c44oagPF3bQQAfD1gInuAqjPsw4zagPFzYwbOef7aCBDg5wgodtRiOI+nChgA1UsIMGOjjAsMWljvpwYtSHCwVsoIIdNNDBAWKL+jCjGUV9uFDABirYQQMdDFs0mKgPF67CqA8XCthABTtooIPYFrZVtpjwlChgAxXsoIEODnCC2ASbYBNsgk2wCTbBJtgEm2Br2Bq2hq1ha9gatoatYWvYGjbFptgUm2JTbIpNsSk2xabYOraOrWPr2Dq2jq1j69g6to7NsBk2w2bYDJthM2yGzbAZNsfm2BybY3Nsjs2xOTbH5tgGtoFtYBvYBraBbWAb2Aa2gW1im9gmtoltYpvYJjZqiVNLnFri1BKnlji1xKklTi1xaolTS5xa4tQSp5YMasmglgxqyaCWDGrJoJYMasmgloyzlozAw3ZMCmoxvSpRwAYq2EEDHRzgBLE1bA1bw9awNWxRS5YEOjjACa7CqCUXRlwNjAgtcIARwQJXYdSHCwVsoIIdNDBs8QNEfbhwgmGLnyXqw4UCNjBsMzDirsABTnAVxhrot7gOsQr6Lc441kGPgeCYUXXvFw/sB8aRxWroMYAUk6oSBzjBdWAcWayLfqGADTxsMfIaU6qaxOHEwugShxNLo0sPPBQxUBnTqu5d5AfGAukXCthABTto4GFrcQyxXPqFq1pJ5PyFAjaQFhU5f6GBDg5wgmWLCVaJxwnFsv0xxSpRweOE2vlnDXRwgBNcheeuBicK2EAFsQm2c4cDDxxg2CxwFZ47HfTAiDsCO2iggxF3Bk5wFZ77HJwY7wHx1+JJ4UIFO2iggwOc4CqM6VVxlrHVQQy8xvyqRAMdHOBxEnoLXIWx8cGFAjZQwQ4aeNhUAgc4wbDFzxaFIEaHY8JVi2HemHGVqGAHDXQwfoqDIuNPkqJWpEU9KdIvxnpjVa7ECa7C2LPgQgEbqGAHDcS2sC1sq2yxXleigA1UsIMGOjjACWITbIJNsAk2wSbYBJtgE2yCrWFr2Bq2hq1ha9gatoatYWvYFJtiU2yKTbEpNsWm2BSbYuvYOraOrWPr2Dq2jq1j69g6NsNm2AybYTNshs2wGTbDZtgcm2NzbI7NsTk2x+bYHJtjG9gGtoFtYBvYBraBbWAb2Aa2iW1im9gmtoltYqOWLGrJopYsasmilixqyaKWLGrJopYsasmilixqyaKWrKoleqtaoreqJXqrWqK3qiV6q1qit6oleqtaoreqJXqrWqK3GzbBJtgEm2ATbIJNsAk2wSbYGraGrWFr2Bq2hq1ha9gatoZNsSk2xabYFJtiU2yKTbEpto6tY+vYOraOrWPr2Dq2jq1jM2yGzbAZNsNm2AybYTNshs2xOTbH5tgcm2NzbI7NsTm2gW1gG9gGtoFtYBvYBraBbWCb2Ca2iW1im9gmtoltYpvYJraFbWFb2Ba2hW1hW9gWtoWNWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCWNWtKoJY1a0qgljVrSqCWNWtKoJY1a0qgljVrSqCWNWtKoJY1a0qgljVrSqCWNWtKoJY1a0qgljVrSqCWNWtKoJY1a0qgljVrSqCWNWtKoJY1a0qgljVrSqCWNWtKoJY1a0qgljVrSqCWNWtKoJecmiccUaj23SbxwgIfimFit52aJJ0ZKXyhgAxU8TsiCrMiLQqWBE1yFkc89/mzk84WhilOIfL6wgwY6OMAJrsLI5wsFxDaxTWwTW+TzMflWzx0WL5zgKox8vlDAwxaxcrNFrd0WtbZb1NpvUWvDRT33V7Rb4PGXj0m+eu6oeOx5o+eeihc6OMDjSI/JrRoTHy+M7LxQwAaGzQI7aGDYRuAAJxi24wrExMfEw+ZxQpGdFyrYr20az60XT/KiUTSLVlJkoMclilzz898eR3rM19CYxpg4wVUYueZxgpFrFzZQwQ5a7e7oRaPoONS4qrHrYlBsu3iSFLUiLQqJBxro4CqMfPW4+JGvFx4XNE4u9lg8yYviisRPE/l64SqMfB1xTSNfLzxUIy5v5OuFHTwOdoQi8nXE2US+jrgoka8jGnnk64mRrxcK2EAFO2hg2OLQI19ntKrI1xmHHpk54yDPzIyDPFPzxA4a6OAAZ2I/Nz7tgQp20EAHBzgLI+eOuRQacwUTHRxg/DUPPK7kMdinPXd3057bu2nP/d205wZv2nOHN+25xZv23ONNe27ypj13edOe27xp13JoObQcWg4th5ZDy6Hl0HJoOXo5ejl6OXo54iF5zsBZO6Ku2hL1ViRFrUiLepEVedEoKkftd9prw9NeO5722vK0156nvTY97bXraa9tT3vte9pr49NeO5/22vq0196nMXOvHUOmGjP3Egd4tJAVjSVybcUVi1xb0W4iq1a0m8iUFXFj79Jb/NnYvfRCAY+Tu0WDjT1ML+yggQ4OcIIrMebd6TFcqTHvLrGBh+0YS9SYYafHbuQaM+wSj7hy/tlVGPuZXihgq78Wu5pe2EEDsQm22N/0wlUYW5te2M6d9vTcWfGkXmRFXjSKIrgGrsLY5vRCBePw4hrGZsISEWI74QtXYWwpfKGADVSwg3ExPNDBAYZtBK7CyL8Lw7YCG6hgBw10cIATXIWRiRdic2yOzbE5Nsfm2CIjW7S7SMkTIycvPOK2+M1j3+EWLSz2GT4x9hVu8WPFzsItfqzYW/jCDkaEuOqxw/CF8QgUhxP5dwz3acw/03gKivlniQp2MJ4DNNDBAU5wFUb2XChgxO2BBjoYcS1wgqsw9gK+UMAGKtgLY39f9cAGKthBAx2MIxuBE1yFkSIXCtjAsM3ADhroYNiO383Ph79bYDz9xU94Pv6dqGAHDXRwgPGgGb9xJMOJkQwXhi1+t0iGCxUMW1ydSIYLHRzgBFdhJMOFAoYtrlmkSLwZxSwvjbebmOV1YezBfaGAx5HF60/M50p0cIATXIVxD7tQwOPI4lUp5nMldtBAB0MR1yxuXIExXUvjBSqmYGm8KsVkKz1mlGtMttJ4P4rJVol6biKqMdfqIivyolE0i1ZS7CV6khSFZAYq2EEDHRzgBFfhudP9iRF3BR4R4jUu5lidZ3+k1kUr6Uisi6SoFR0R4zUuZlclGujgAGdhZFW8/cWCVBovd7EiVeJxoz3/+yiaRSsp9u49SYqOaxrvfTGDKrGDBjo4CiNH4p0tZkVpvKjFklPnJT1uHRd50XFBzz83i1ZS7Nd7khS1opDETxRpdKGBszBSY8RvGKlxoYLHYcaxx+68J3nRKJpF66KY8KTxBhkTnhIbqGAHDXRwgBNchYJNsEXexZtpTHhK7GDYLNDBsMVZxG3smB+kMeFJ420zJjwlCnjY4sUzpkElHrZ4B41pUBpvkOd2hregUTSLVlJsp3aSFEXEHngcabwaxqQmjffBmNR0YdzWLjyONN6aYqpTooIdNDDixgmer1NxDOf7VJzg+UJ1YgcNdHCAE1yF53vViWGLC3e+WZ2oYNjicp4vVyc6OMCwxTU7X7ACzzesE4/LG3809jI8SYvuqqgx53aGJ3nRKJpFKynucfFGFrsaJjZQQQfjMKMRxt3swogQv2ek7IUK9nPTP61NDLV2MdTaxlBrH0OtjQy1djLU2spQay9Drc0MtXYz1NrOUGs/Q60NDbV2NNTa0lBrT0OtTQ21djXU2tZQa19DrY0NtXY21JgIpcc0WY2JUImrMLpEjtWZNCZCJTbweDmLN8yYCJV4vJ4d02Q1JkIlDnCCqzA6R25xZNE7cmHYRmDY4siig+S2Ag10MPpI4iDPTpITV2FsRhp/NHYjPakVaVEvsqKIeOTXOje/j9O26GTRQAU7aGB05sRpx/30wgmuwrilXni3xU0l5i9FEVy5fKOei6DFn4tF0E5qRXFMcfVii/sLDXRwgBNchfMGCthAbBPbxDaxzbDFlZ0TXIXrBgrYwJ7XIBdt1JWLNmpMQOrxuhkTkBLXhT0mICUK2MDjbI730R4TkBINjMcjDRzgOn+kfstdFfotd1XoMeXouKn0mHF0US+K4D3QwQFOcBVGyl4Yp2KBDVTwuGpxfrlMa7/lMq39lsu09lsu09pvuUxrv+Uyrf2Wy7T2Wy7T2m+5TGu/aTm0HFoOLYeWQ8vRy9HL0cvRy9HL0cvR45p54AAnGNcsLrXdQAEbqGAHDXRwgBPE5tjOR+QZ2EAFO2iggwOc4CocYVuBAjbwuIzRHmNtxJOsyItG0UyK1Ne43pHkR89Kj3lCXSMtIskvHOAEjyPVaK6R5BcK2EAFwxa/4zLQwQFOcCXGPKFEAcM2A8O2Ag/b8SrTY55QooMDnOAqPNI/UcAGKohNsAk2wSbYBFvD1rA1bA1bw9awNWwNW8PWsCk2xabYFJtiU2yKTbEpNsXWsXVsHVvH1rF1bB1bx9axdWyGzbAZNsNm2AybYTNshs2wOTbH5tgcW1SGowuqxzyhxLD1wAFOcBVGZTh6mHrME0psoIIdNNDBAYYtcigeGE6MUtEjneIp4UIFOxjd+7dABwc4wZV1R84CcqKADVSwgwY6OBLPXRRvQVLUiu5Bj7Hafu6ieJIVxfGfYQY4wVUYReJCAQ/TSVrUi+JStUAHBzjP7fZ6bafYazvFXtsp9tpOsdd2ir22U+y1nWKv7RR7bafYazvFXtsp9tpOsdd2ir22U+y1nWKv7RR7bafYazvFXtsp9qbl0HJELTj6EXvM80lsYIwdxQ8RteBCAx0c4ARXYdSCCwUMmwUq2MG7bUZLiV3XThpFs2glxa5rJ0VED4wjjdOOzD76uHrMGEpchZHZFx5H6hEsMvtCBTto4GHzaGGR2RdOcJ17tfVzD8WTpKgVaVEvsiIvGkWzqByrHKscqxyrHKscqxyrHKsc8UjgJx6X7ehk7DF1KFHABirYQQMdHOAEsQk2wSbY4pHgeFHvMaEo0UAHBzgL4+Z/LGnSY2pQvBXE1KCLjr8URSzmBiWuwrizXyhgAxXs4HGIUZ5iJlHiAMPWAldhZPOFAoZNAyNuHHrk7YUDnGDEjasQeRsFI2YO9REXJPI2sizmDvUZRxZ5G20kJg8lOjjAwxZvcjGl6MK4h18oYNjiZ40bd7zixfSiPuNwIr2P/sEeE4z6isOJ9F5xQpHeJ0Z6XyhgAxXs4GFbcQyR3hfOaiNxtz4xXu8vDEUcb9y4L1QwFOefNdDBAU5wFcaN+0IBG6ggtoUtutNvcc2iP/3Co0P9Fr9x9KgHxnpn/Ziv0WPakR19Vj2mHSUa6GDE1cAJrsIjoRMli3WsbJaoYAcNdHCAszCGqY4ZHz1mJiUq2ME4Cwt0cIATjK6WOM1zhtKJAjZQwQ4a6GBcnSMLY1ZSooANVLCDcRZx8t3BAU5wFVrEnYERIX7uI49NohEceZw4wSPC0a/XY2pS4nG85wkdeZyo4HG8Er/8kdKJDg5wgqtw3MCwxU84GqhgBw10cFwd3T1mLF3XIYa5LuTqzIgbjWB20EAH4yzi+s4JrsIVZxGXegnYwMMWPWox5ynRwLDFoUcet/gBIo+jny3mPFl0rsWcp0QBI24PNNDBAUbc49xidtPZSmJ2U6KCHXRwXcM6PZYHSxSwXYM9PSYyJXbQQAcHOMFVGMPJF8ZF9cAOGuhgnPwInOAqjDS9UK5RsX7OcbpQwQ4a6OAAJ7gKY/zL40KZgnEWM9BABwcYZ3H+tVUYyXuhgA1UsF8Dtf2czXShgwOc4CqM8a8LBWyggsdZ6IkDnOAqjOSNV9CYBJXYQAX7NSrez0lQFzo4wAmuwhgeu1DA47eIrrpY8ivRwQHGWUQWRpoGxpJfiQI2UMEOGhi2HjjACa7CuAkf0516TLlKbKCCOdGhnxOxLnRwgBNchZHzFwrYwJgssgLjLDxwgBOMsziueizuZcd0px6TthIbqGAHDXRwgDEJ5mgwMT3LoivpnIgV730x5cqiKymW5kpchXYDI0Jc9bjdXqhgBw10cICzjiHGsU+McewLBWyggpzFOZ3kRAfjLOKXj9ttj6set9sLG6hgnEX8LHG7vdDBOIsZOMFVGHl8oYANVDBs0WDiJnyhgzFNKE4obsIXrsK4CV8oYAMVPGzRzRSTthIdDFu0ksjuC1diLMKVKGADFQybBhroYNgsMGwjMGzH1Yl5YRbpFPPCEhuoYMy6kcCYdhPHEPfuyM1zbtiFE1yFMT0s3sXP+WHxUh0TxCyKY0wQS+yggXFuPXCAE1yFmnPeemx8mNhABTtooIMDnIWR8/FWd84du1DBDsZZxJWMB+8LBzjBVRj14UIBG6jgETduizGnLHGCMVsrfsK4o18oYAMVjLjxc0fOR+9BTCFLFLCBCsaU4hMNdHCAE1yFMV3lQgEbeFzf6KuINbYSBzjBOItoiJGx0a9xTia70MGIEK0vMvbClRhzxyz6QGLumEUfSMwds+gDiblj53WIuWOJA5xgXd+YO5YYcVtgBw10MOaK98AJrsK4x14oYAMV7KCB8/rgq5/LYp0Yn6ReeLSHGX827rEXxlmcf6CDBsZZxEWNe+yFEzyuTrwHxAyyRAEbqOBhW3F1IgsvdHCAE1yFkYUXChhx4xeK71ujRsVcMYseopgrltjA48iisyjmiiXGkcV1iHy7cIBxZKdiFUYWXihgAxXsYNii0cad98IBTnAVxp33QqkzjntsdADNyMILHRxgzCaMFJmrcN1AAdv1BWU/l9q6sIMGOjjACa7Ec/JY9Gids8cu7KCBMSPy/GsDnOAqPD9pjb92ftJ6YgMV7KCBDo7CmIsZt/yY6JW4CmM65oUCNlDBDhroIDbFpmE72vo50etCARuoYAcjrgVOcBXaDRSwgRF3BXbQQAdjut8tcIKr0LXiegcNdJBDdw7dV9nGDRSwgVrimLR5oRXOaJNxoaaCHTTQwQFOcBWemXWigNhW2HpgBw10cIATXBdazPtKFLCBCnbQCmPS5dGJajGJy49eS4tZXIkGOjjAOLJxYItjmIENVLCDBjo4wIi7AlfhORP6RAEbqGAHD9vRR2oxeStxgBNchZF6FwrYwENx9LJaTN1KdHCAE1yFkYUXCthABbEZtsjCoyPXYu5W4gRXod9AARvIj+X8WM6P5fxYkYVHp6/F1CyXaFGRhRcq2ME49GhyMXn6wgFOcBXOGyhgAxXsILaJbWKb2Ca2hS3yWKKtRx4HxoyoeRQmixlRiQ08RnXt/LPHsO7xMmgxIyrRwQEew8fH26LFjKgL2w0UMOKuwCPCUdosZjklrkKV+rNHtszjzdJialNiBw10cIATDMXRCGJqU6KAYeuBCnYwbC3QwQFOkBOyGyhgAxXsoIEOcvmMyxd5cYojLy7soIEODnCCqzAS50IBsQ1sA9vANrANbAPbwDaxTWyROOdPGIlzYQcNdHCAE1yFkTgXCohtYVvYFraFbWFb2FbZ2u0GCthABTtooIMDnCA2wSbYBJtgE2yCTbAJNsEm2Bq2hq1ha9gatoatYWvYGraGTbEpNsWm2BSbYlNsik2xKbaOrWPr2Dq2jq1j69g6to6tYzNshs2wGTbDZtgMm2EzbIbNsTk2x+bYHJtjc2yOzbE5toFtYBvYBraBbWAb2Aa2gW1gm9gmNmpJo5Y0akmjljRqSaOWNGpJo5Y0akmjljRqSaOWNGpJo5Y0akmjljRqSaOWKLVEqSVKLVFqiVJLlFqi1BKllii1RKklSi1RaolSS5RaotQSpZYotUSpJUotUWqJUkuUWqLUEqWWKLVEqSVKLVFqiVJLlFqi1BKllii1RKklSi1RaolSS5RaotQSpZYotUSpJUotUWqJUkuUWqLUEqWWKLVEqSVKLVFqiVJLlFqi1BKllii1RKklSi1RaolSS5RaotQSpZYotUSpJUotUWqJUkv0rCXHo5qetcQDBWyggh000MEBTnAVTmwT28Q2sU1sE9vENrGdtWQErsKzlpwoYAMVDNsKNNDBw3b00FvM0fIRly9qSWDM0UoUsIEKdtBABwc4QWyCTbAJNsEm2ASbYBNsgk2wNWwNW8PWsDVsDVvD1rA1bA2bYlNsik2xKTbFptgUm2JTbB1bx9axdWwdW8fWsXVsHVvHZtgMm2EzbIbNsBk2w2bYDJtjc2yOzbE5Nsfm2BybY3NsA9vANrANbAPbwDawDWwD28A2sU1sE9vENrFNbBPbxDaxTWwL28K2sC1sC9vCtrAtbNSSTi0xaolRS4xaYtQSo5YYtcSoJUYtMWqJUUuMWmLUEqOWGLXEqCVGLTFqiVFLjFpi1BKjlhi1xKglRi0xaolRS4xaYtQSo5YYtcSoJUYtMWqJUUuMWmLUEqOWGLXEqCVGLTFqiVFLjFpi1BKjlhi1xKglRi0xaolRS4xaYtQSo5YYtcSoJUYtMWqJUUuMWmLUEqOWGLXEqCVGLTFqiVFLjFpi1BKjlhi1xKglRi0xaolRS4xaYtQSo5YYtcSoJUYtMWqJUUuMWmLUEqOWGLXEqCVGLTFqiVFLjFpi1BKjlhi1xKglRi0xaolRS4xaYtQSP2uJBQrYQAU7aGDYZuAAJ3jYjrFxi8lsiQI2UMEOGujgACeIrWFr2Bq2hq1ha9gatoatYWvYFJtiU2yKTbEpNsWm2BSbYuvYOraOrWPr2Dq2jq1j69g6NsNm2AybYTNshs2wGTbDZtgcm2NzbI7NsTk2x+bYHJtjG9gGtoFtYBvYBraBbWAb2Aa2iW1im9gmtoltYpvYJraJbWJb2Ba2hW1hW9gWtoVtYVvYVtli6lyigA1UsIMGOjjACWKjlgxqyaCWDGrJoJYMasmglgxqyaCWDGrJoJYMasmglgxqyaCWDGrJoJYMasmglgxqyaCWDGrJoJYMasmglgxqyaCWDGrJoJYMasmglgxqyaCWDGrJoJYMasmglgxqyaCWDGrJoJYMasmglgxqyaCWDGrJoJYMasmglgxqyaCWDGrJoJYMasmglgxqyThryQoc4ARX4VlLThSwgQp20EBsA9vANrBNbFFLjk/sLKbkJSrYQQMdHOAEV2HUkguxLWznc8mJHTTQwQFOcCXO87nkRAEbqGAHDXRwgBPEJtgEm2ATbIJNsAk2wSbYBFvD1rA1bA1bw9awNWwNW8PWsCk2xabYFJtiU2yKTbEpNsXWsXVsHVvH1rF1bB1bx9axdWyGzbAZNsNm2AybYTNshs2wOTbH5tgcm2NzbI7NsTk2xzawDWwD28A2sA1sA9vANrANbBPbxDaxTWwT28Q2sU1sE9vEtrAtbAsbtWRSSya1ZFJLJrVkUksmtWRRSxa1ZFFLFrVkUUsWtWRRSxa1ZFFLFrVkUUsWtWRRSxa1ZJ3jLSsw+pVnoIMDnOAqPEdWThSwgQp2EJtiU2yKTbF1bB1bx9axdWwdW8fWsXVsHZthM2yGzbAZNsNm2AybYTNsjs2xOTbH5tgcm2NzbI7NsQ1sA9vANrANbAPbwDawDWwD28Q2sU1sE9vENrFNbBPbxDaxLWwL28K2sC1sC9vCFtl9TPe2c8rjMVnbzimPB/o55fFCARuoYAcNdHCAE8Qm2ARbZPcxS9zPSZMXdtBABwcYNg1chfGkcGEOQfk5U/JCBwc4wVUYpeKYO+7nTMkLGxiHfv7ZDhroxxpBt8ABTnAVHqUiUcAGKthBA7F1bD1sLTBs40C7gQI2UMEOGujgACeIzbE5Nsfm2BybY3Nsjs2xObaBbYQtfqzRQAU7aKCDA5zgKpw3ENvENrFNbBPbxDaxTWwT28K2sC1sC9vCtrAtbAvbwrbKJrcbGLYV2EAFO2iggwOc4CqUG3j82WOCsMd0zsRVWMMeLjXs4VLDHi417OFSwx4uNezhUsMeLjXs4VLDHi417OGi2BSbYlNsik2xKTbFptgUW8fWsXVsHVvH1rFFJTjmNnvMAk2c4CqMSnChgA1UsIMGZveCx3zPIXEMkdIXdtBABwc4wVUYKX2hgNgGtoFtYBvYBraBbWCb2Ca2yNhj6rLHdM7EAU5wFUbGXihgAxXsYNiO1DtXnzvWq/Bz+bkLG6hgBw10cIATXIWCTbAJNsEm2ASbYBNsgk2wNWwNWyxFdyzL4edadBd20EAHBzjBVRhL0l0oIDbFptgUm2JTbIpNsXVsHVvH1rF1bB1bx9axdWwdm2EzbJHHx8ofHlM0EztooIMDnOAqjDv6hQKGLRptpP+FHTTwsGn83JH+F05wFUb6XyhgAxXsoIHYBraBbWCb2Ca2iW1im9gmtoltYov6oPGzRH04MerDhQI2UMEOGujgALGtssUUzUQBG6hgBw10cIATxCbYBJtgE2yCTbAJNsEWteRYM8NjiuaFUUsuFLCBCnbQQAdHYVSNYx1gjwmWo8cxRCW4cIATXIVRCS4UsIEKdhBbx9axdWwdm2EzbIbNsBk2w2bYohL0uA5RCS5chVEJLhSwgQp20EAHsTk2xzawDWwD28A2sA1sA9vANrANbBPbxDaxTWwT28Q2sUUlOBYM8ZhgmbgKoxJcKGADFeyggQ6GLRptVIILV2JMsEw8bMc3Vx4TLBMV7KCBDg5wgqswKsGF2ASbYBNsgk2wCTbBJtgatoatYYtKcHxa5jHBMtFABwc4wVUY9eFCARuITbEpNsWm2BSbYuvYOraOrWPr2Dq2jq1j69g6NsNm2Axb1JLjwzuPCZaJBjo4wAmuwqglFwrYwIgbjTaqxoUDnOAqjKpx4RH3+DjNYypl4nEWx2xuj6mUiYft+NjLYypl4mE7pnt7TKVMPGzH53geUykTwxZNLqrGhWGLyxdV48KwxWlG1bhwgGGbgaswqkZ0WMVUysTDNuLcompceNhGnFtUjQsP24hzi6px4WGL18mYSnliTKUcx5okHlMpE8NmgQqGzQMNDNsMHOAEV2FUjQsFbKCCHTQQm2ATbIKtYWvYGraGrWFr2Bq2hq1ha9gUm2JTbIpNsWkOffs5lfLCAU5wFfYbGHFPPI73WP7FY3rkmPFrRiW4cBVGJbhQwAYq2EEDHcRm2AybY3Nsjs2xOTbH5tgcm2OL+jCjpUZ9uFDADkaEaL+R8xeuwsj5CwVsoIIdNNDBw3bMEfCY8pi4CiPnLxSwgQp20EAHsS1sq2wx5TFRwAYq2EEDHRzgBMN21J2Y8pgoYAMV7KCBDg5wgtgatoatYWvYGraGrWFr2Bq2hk2xKTbFptgUm2JTbIpNscWTQoyAxJTHRAEbqGAHDXRwgBMM23F3iimPiWGbgWFbgTm5xs8pjxca6OAAJ7gK/QYK2EBsju2oD/N2ooMDnOAqPOpDooANVLCDYYufZTg4wAmuwlhP/8KI4IEODnCCqzBWy78wjjd+llgvPzCmG87o2I/phokKHmdxrDbhMd0w0cEBTnAVxvIOFwrYQAWxCTbBJtgEm2Br2Bq2hq1ha9gathY2CxzgBFeh3kABG6hgBw3EptgUm2Lr2Dq2jq1j69g6to6tY+vYOjbDZtgMm2EzbIYtVoWIXuyYbpg4wVUYO11cKGADFeyggWFbgYctepBjumHiKow8vlDABirYQQMdxDawDWwT28Q2sU1sE9vENrFNbBPbuUFGXPVzh4wTBWyggh000MEBTrBsMd0wUcAGKthBAx0c4ASxCTbBJtgEm2ATbIJNsAm2qCXRix3TDRMFbKCCHTTQwQHOwppC6DGFcEaXeEwhTHRwgBNchVEfLhSwgQpi69g6to6tY+vYDJthM2yGzbBFfTiWFfeYQjijSzymECZOcBVGfbhQwAYq2EEDsTk2x+bYBraBbWAb2Aa2gW1gG9iiPkTXdUwhvDDqw4UCNlDBDhro4ACxTWwL28K2sC1sC9vCtrAtbAvbKltMIUwUsIEKdtBABwcYNg9chefemicK2EAFO2iggwM8bMcS2R574l4Y9eFCARuoYAcNdHCA2Bo2xabYFJtiU2yKTbEpNsWm2KKWHKt7e0xYTGyggh000MEBTnAVGjbDZtgMm2EzbIbNsBk2w+bYHJtjc2yOzbE5Nsfm2Bxb1JJjaXOPCYuJDVSwgwY6OMAJrsKoJTFiE1MTEzsYcUeggxF3Bk5wFUbViFGCmJqY2EAFO2iggwOc4LpwxNTERAEbqGAHDXRwgBPEJtgEm2ATbOcCdLdAAx0c4ARX4TlN6cQIJoEGOhjBWuAEV2EUhQsFbKCCHTTQQWyR/sfqpyMmIc5jYfIRkxATFeyggQ4OcF4djeOchHji2aV4ooANVLCDVhitb8bxRuu70MDjcI4+vBGz3RInuBJjtluigA1UsIMGOjjAsp1LGh6dfONcvPBYJXqcKxZe/zYOZx4Yt5mjy3acKxZe2EAFO2igg8fhHLvFjHN1wwtXYbSoo5NknAsdHr1J41zo8OjqGedCh8d60ONc6PA89GhRF3JC5zqGIT7XMTyxgQp20EAHBzjBVRh3kciscx3DEWcRd5ELFezgYRtxmnEXuXCAE1yFcRe5UMAGRty4ZnFnGHHN4nYwohHE7WDEzx23gwsV7OAojBI/4vrG4+KFESEaTJT4EZckynakSEw6S2xgtJ24DmfinGigg9GU49zOxDlx5R9oZ+KcKGADNa9DTFBLNNDBlWccU9HO04ypaImt8GxRFqhgB6NFnX/WwQFGi5qBq/BcGTPwXNk1/mx8uSDnv3VwgBM8uipvcQzx5cKFAjZQwQ4a6OAAJ4htYpvYJraJ7VzZNc7tXNl1Ba7Ccw3XOKFzDdcTG6jgcejHHl7jXD7uQgePQ2/RHuLDhAtX4rl8XAQ7l4+7sIEKdtBABwc4wVUo2ARFfEtw9K2Mc8W3CwVsoIIdNNDBAU4QW0wxPt6Px7ni24UNVLCDBjo4wAmuwo6tY+vYOraOrWOLL5BaXLP41ujYSmucq7gdezaNcxW3CztooIMDnOAqjO7+CwXE5tgcm2NzbI7NsTm2gW1gG9gGtoEtMlbj14yMvXAURm5eGBEssIMGOjjACa7CSNMLBWxg2OLHijTtcbyRphc6OMAJrsRzZbYLBWyggh000MEBThCbYBNsgk2wCTbBFt8PHW9J41yZ7cIJrsLI+QsFbKCCHTQQW8PWsDVsik2xKTbFptgUm2JTbIpNsXVsHVvH1rF1bB1bfIt4vE6Oc2W2Cye4CuNbxAsFbKCCHTQwFB44wVUYReF4jx3ncmwXNlDBDhro4AAnuAoHtkj/4/14nAuvxSviufDahQ4OcIKrMIrChVVIz4XXLlSwgwY6OMAo0Ou///uffvvL3/71j//489/++s//+Puf/vTbH/6r/sV//PaH//Vfv/37H//+p7/+47c//PU///KXf/rt//njX/4z/tB//Psf/xr//Mcf/37/r/d7+J/++n/u/7wH/L9//sufDvrvf+Jv357/1fsr0vGLxV+/vyPdrELIbf0QRJ4HibkREeI+oFABhv/w99vzvx/bfMbfN+Mc7m8Mrx7APHbmOw/A1rMD6M//fj+mEMffv7ewtw7gmLdyHsCazw7An//9eOqLv+/N3zmAdezAGgHu3YvPDmBuDmBmI7r3wzw9gF1Dut+z8hDub5YizxvSJsr9sVauIPcnxocrIfJyjPtTp1eMNR5i9NdjyC1/0Ptj5XoeQzdXxEa2KnFtDzHmjzF2DXNWZvSH1HR5/ShmJZfcB6meH8WmdVosj3Yexn14q2K4vR5iVJk5lsJ5GmLTRFvswRwhmg15GmJt0tTyPO6vsVyK/mMDbbsGKlVq2pEdGaO3H0NsUrVNmvjTAL+4lsK1nM8uRNu2ilFV/z5u8LRVtE3blNin/Yxhoz09jL5L97nqWujt+WH47jBGr8OQh1NZH+4/Y1d+5/9UftfrZ3IvOtku9Dj6p2eyaZ0i8a3WeSr3fqKHc2k/Jrzevn49VL58PXbncu9CykZ6P/qHx4KfzkV32TZaZdt8KMPrx6uquzYWX9ifMUZ7aKafOBeds86l983vsmmn9z6q/HHvfVQU83sP3I8xxu621Ga1MnuM8eE4NmX03gNRLfX+9vk8xu44Wre6Pc7nx9E37bSvOg67D/08jbH/ZfxGKxuPeffhl+ltl7urKnJ7+GV+irFrqTxA3Y9jPY+xa6ntltWwtTbei9G1bpJ9Pm+pffcw2jNh3DmKexfJjxE27WORL7eHi/FTiN0DqUxq0MNbwU8xds3j3s2fbUyOjvWnUWzTUJ1n0mMGApf0xxpku9eD1uv94N5t/SzE9nq0usEcX64+P5PtXd+rdRzcn1/VXVMfdTJ3fJ4u28S9V6F6W7j3XbanUWx365cYEL1umPdxpifF3cbvenu495QZbz79eeLa+l1vuT36Kq7j8E3y++7pVEceSLu/0j0cyY8Pyd6+ek23R9Glyum9d+zpUWwfydQfbnT+9JHsGI56GsN5QB362NZvL8e49yXm1bj3D/rzGOPrD3U+f9eH3H6rN+v+mPmfeGu4JzsxNr/KkF1dryb68JB8H/H6McKmhc56vZ+6nkfQ3S0uT2Ot5xG2V8Ju1T6ny/MrYbsHoOp4upfUh4ds+TFPhu+OQ+oXsXl7K8a9Q33RxtvzGPPrbXx8uYpur6jWy7X44yvYhzOZsn2Qo3rp86uxbR2Tx/TV+nu5trQe09d8/pY/+1dzbdpXc23675pra+VB3Aednnc0zF3/02jc1X7Ikw+9rLsOKFEeBG/+Vox188y1dVvraYwlX8+11X7P+8l90C9/2PuYnr/VxjsvPPfBn9t7/ZvjRofaw6/ysWdx12HctIro/QnqaYfxGtuHjVs9bKznjWMbY3odx1zy5Rjr1t6McdOKIc+TRW7y1coht/bV0rEP4ZUqt4er8THG9mosoZg/viD8dDXs673w2xivtfTb9oJmhHvnLfcl+3gUuzu9dF7bHgbc2hgfgqzdqWQMeyyC8+UTWdW61uMN9uOJyK6MKm3j/ub3MEDzYchL2m6cqPoFH5qX6ocBgd0gzxj15jceK0dbH4arZPs82rhFEuLjiJfYrr+2etKOzqw3g7R652r6mHCfCjLqobY93hZ+DrK9S05GOLpvft7dIykpd+/ef3wI+/ADb4edVOrZQx/HIz9kzKvt/eGV+mN7b21bx7gzTH96GLIde+pWvYP94VbZbh+D7Po5xef/NDLwYcRb2u5Rf1XW3Dudx/MYm0eHIVmTx+PMAf94KmM3xptHYY83yk+FqN4S07EJsTuRGyeynofQ7TPQqucXfaiG9xfdD0F2OXerun6/hzz0HY+PQXav97LqwaFvQuiu/znPxdWfh9jfbBs324f+/M/dsF8bN9+OPPV6Nr13pr0bo0ae7jH8vRhWQ4LN/PkDjG5f8OvV+liU/K0Yx3LyL8Xwr09G6NtOqJo21dfT2Qj7EC9NaJDtiNFrMxqk21enNGyP4rYY6X14MP0pxqYKxndF5w1O2uZizO28iHqCuQ9APZyM3ua7rePpDA3ZDTvF4mXXI93z6/GL2vHKPBGx9g1vLrsg/daqd/Cxpv8cZPd46kzJ8scX/Y+TobZHIlUK793yfXMk/uXXUhtffi3dnwrDCiK7izq+/G67PxDn1x1Lnx+If/1V37/+qu/td74cszLmPgC/uxz21eTfHca9AlVvgdimpft2nsea/9MT3WdCaPVWqj6MW38MsXYtvY7i3k34NMSrV6NturT2QUYN2Bx71z0PMrZjo9Wvf8f57GR2IV7tvJXRv9p7uw9R8wD84bnhcyGcqSZzE2LbfVKvYGKPQ2DrU5eUUR97HOf9KchuAH49jMattt5rqbPVu9yy+byR7Qag+qqG+tgrtT7Uj/nlMfztURivP31ujmIXoia92NycyPaCruX1JmfyXuofi9NWW3+3fhzLaVcQ35Tk3SjUizfK7QDSazfKbYhvuFE68+OPxSmfX461zf5VAw1y7Ef3Ts6NUX3a95K8KexrO8/UjcL+/O12H4O3oLl5M93FUGYRatv0Ovwixu3LMbrUS2Fvt/diKM8fXZ7GiKN94W3/2IHtrRgv9jq8ehzbXof9Na0PlbSbPD+O/g3Xo//e5zIeJgLNL8d4LMufa2Ot3nBNNtdjd+dn5Pb+uLPpe9geyKAX5fE96uOB7EYsXv1xRb7e2F88jvcbCN0XOnfHsevivy1GGh87DT71w8SKjjmm/vx7G9n10NerQ2/P20fbff8kFMPjA7uH7nX5xHHord7V5+Zy7G+5yvvHsqdzZncfQR1B2kMQfyfIiy+GvzqZ145j9xYTS9yczw96ez7Zoe1Go+43jxqNepyq/lP/1vZ9qqYI+LQ3X8l40p2bF0P/+rjH/PqQxfz6iMX88oBF0/b1aqrtG6rpV8catkPQr/XQt12/+Gs99G336dEneuhf/pZ08wnl+mIfXfuGT3O34+CzbnBt/dAL/DFG+2o33z7ES918rfevVvP9xahHufub6OZz0v7l3v3Wv9y7vw/x2gv29qPWl7rnthFe6p3bfpz7Yufc/gPf1/rm2vbTpxf75tpXZ5ztP/D16s+688Ow8U/fTu3Gn15M122I19LV5lfTdTdf5LWu8O13yi818W2El5r49nvrF5v4/pvtF5u496838e0H162GBVprj99dzddjWK+vH35Yz2V9IlPuz/019a49fv/5U6bsPnl6MVO2IV7LlHH78o3t9cvhzwvH/gt0nohdH7/81jdjjK/HeOgt+dSX8DevHsqbb74e3321JHM8PErqJshu1kk9c8wub4aombfTxpshOisgzS+HcH3vgt5vwbwwWXs3CLcFF3vzp10kzNr8LrsVCtTrdeX4DvStGPf3WD7+3DSxF1dKuHeUPv91X171YRfj1RUsxvO8bfOrb03boxh8kTZvz6tY233/tLRuleveNff8YW77ysO3wfq4ztT4EGN3r1wPM+cexxU/xtjd9+Xh+/N7h+d8djbbqzprEk+bD7fbT9X1WS8td/TNL7O701nN1JAfZlb+vLzAprkvVhe4PfY0fHi/38+LFGaYbz7q192gz6yx58ePoH66qLftvH3mQ9/mJsauE+q1JSz0prv73EtrWGzPRW41uUFufXdBttP2a+q/rLV5jLn5lwuA3saXC4DuPoV6sQDodvTp5QKw/W207nb3kYb2XmP9Mch6GmS/DE4tLnQfe37+5L+PUZe16W5ZoF0MrcnV7XGhpJ9ibJ/s6plqvrcOzn3Et75v7Q9n8pkYJsonJvP5qi+66zI9tsisV2WV94Icq4PXSMnDvLNPBqlVEY+FkN8M0mtQ71jM980gswYIxuND86d+nF7jPvY4x+FTMQbrRP7QJf6pGPVGZbNtGsm2r+5+G6ol7O4FeHNddx2P0hj7vbNvWlvbjZiaMS5vfru9fTQsm9QeP4/6Kcy+k2c+fPg2x3z3ErMI3J3t3Rbz+G3AeC/GYnbeehhu/NQyX7dquS7y3nG41Juryy4L15efbrarjR27eucPc2yI/daBHF3ELEByz8Q3ozh9gceOsG9GGY0zGt3fjVLjIXJsWvlmlFkDqXLsNfnusTxc3SnPr67uHg0+UZ92n00d9YkPjB8HFT4d5sUy94uTerXMbT+h6pM1Gfv+Es/vqJa/+L3toe35222vvpETn/ZuNq2HpYWW93ejsKbhsc/ce1FGk6oPd7Z3o7D+3rG/zdMou6G571nZkA+x72zyZpRZz2J3ltubUdbDsazNo/J+lcXBgqKbbpB9jMVKjY8LynwmRuw2mB1DuumO2VWWxX2kPc5L/Hn44sufrOxDvDZg6F/+ZOUXy1ZSr2U9PK9/GKjbjUst1k5a8nRcah+i1Sce6/7C/M64lJqwjKdtXtb3UbwWDhAd8jyKji/PYtmHeGmwT8fXZ7G8fjna2xeVZ4t7FH8zyqgRnTvbZuBxzK//NF8eh9X5+47D/ng5XN7+aeZDlM3it+urpWwb4bXpPdslZ7U6he68ucXo3A/pvDIRZBfiXg0ZNxje3wwyHp5nxsNWMp8LUgNUd57+TjvrnRjd2vPV8327fNG3LAjcWNNJH3vKPy4I/GqMx/GYz8QwuoXtMfM+EeN+/K162x+vx8cYm7etF2fmbVcEvtXs0y798cf9xKrCwoqr92eIpzF0rS/X5W2Il+pyv315Gv/2YjQWgWyP3zV8uBh9N8DV52KY/fEjjZ+C7L6MemWO4P4w6FXr63Eppk+dC6OGdmv97SCtgvT5dpDqaLy9ufr1yytoz6/eLrcRXrpdblfxfnGq4H4l8NemCnb5hqmC24VXuVf22Z5Ptu7y5cnWXb482Xof4sXJ1rur0RofePl7c/m71roO/YevxD5e0bad0FovyQ/9Mfe77g8h1vabObqx22ML8x+zbbti82tXdLtU8q0WCZ23zdfy2xi2WB9rtPdirOpBvN8g5K0Y93f8fExet2ZPY2ynLL267HP7ahHcRnipCG6Xnn6xCO6Xr36xCOo3fBKwW43h/tBUHyC38XzJ5q67hHvoox7+9POufQxWuWiP04R+irHdBe2lT9W2MV78VO0X51JPQO2mT7/q7ts5ky99bxvN6PnPwmqnd364xX380mx/JC99cbu9IE1qcc52L8lvXdQmbAwlD+Xjp4tqX7+o29Hr1z5i3h/HS5d0W8Ze+k52H+GVz2S3O4i8do/cbt3R6wtCffzG9VPbf6wa2+o/zB371PYfxGhvbv/x8hYiX+4TG1/uE9tuY/Li/W2/FcqL9zf7huWo5naB82/YDYV1oH74KOBTMVj45N7583yPmu765ZeN3eDPiy8b2xAvPhpvr2gNATdbbXM1ti+jr62ctP2CedFfuvz5JjV9t7zfiwsn/SLGSwsnbWO8uHDSr2LcvhzjtYWT9jFeWzip73ZCenEtmW2MVx8pXzyObYz9NX1p4aQ+1jdcj/V7n8tLCye9HGOzcNIv2thLCyf17e5SLy6ctD+Q1xZO6rsOi1d/3F2MVxv7i8fxfgN5beGkvrZfary2cNL+QF5bOKmv9uV3jt1HVi+/c2yP47XXuF/ccV9aOKkv3wd5ZcGibZDXRlx+eTKvHcfutj3ZNUv8+fuL3bYL07y2cNL2sf+l98F9hFfeB7fjCy8dwz7CS8ewfbKsmQl3XP/91kDt0If9gW/vxXAGjH3pezEm+witm70V4z7wVPe4W3t+PXSXba+OOm+D3NtEvdvO8XTK2DbEqm4kX228F4I37GVPh2pfbh39zRbWiKHPL6jJl1dR2Yd4aezbZP6uIV4cPt9eT/8f59987jfhi7ux3q0cD8fxbgy2RLnjuzF6eyWGffmOYl++o/xihmf1Ra3W3pwkWjPe7vh0RpR/eVHCX4R45Vrs5zHXp8fth8XWPjUXuh5G770M480Yg7Y13j0OFmKYjxsRfJw+uJ/r3pml/jiz+5Mz5h+jbL55+lWUTpRhmyhze3975St3069/B/aL+f+NZWXW5ivXX1yTxbcI6/b2twiPx6JvR+HFZa7+5pcroykTI+89uu9G8YdvTt7+/kVvjO1pa+9G6Q9R7N2vaFQfo/i7UR66UnS+fV3GQ5R1ezNKf/i6qLd3f+l+e4zydqtjSYLRdVNbdrtPSdeas3nnTYP5VRimKXfdfae0/YLk5Y/jfnU0xv61uvl09jMn9YUw1Sl5TCbfXGK//f9xbRYn1W/9O07qC2F67SolfbdegW2XCPyua8PyzHfu9i0n1d8tn7cbM/9vt3c/Ul58dDMeB+Y+uapETb+743oziD9sKtvGm0GsBn+HrXdPZ1Qv8Jhvr/nxeDrvB2HdMB/vrvnxsBXzkP7ukdQ08XsQe/dIjGXQrH/DryObkrDdtOr1VSn2K6HUXKltS9kvuMNEAe3Pv1bZL2Bas0Zbe/xc9cPiozb1y11D2xCv9etM+11DvLhG7+56Kl/d6Lhtrud2sZEXPorYHkWnc+lxyPOno9gNab36eribePrqImjb5XEbS88/zgX+1BK7jxsTPL8ebTeC8/I6vbsgr3VL70O81C39ixCvdEtv14F+rY9KvtpFtV1u/aVj2Ed45Rh2m1TVd/r20FfQ7jXw1QCLpXjsnQByayzd6O+FED5KlYfvlj4VouYBisz3jkLrUsjjKmWfCWEsl2gPS1B+KoSzwszjGrafOREWxdD23oko/Xtqb51IG/WAcR/zeatt3keYWUFovHciY9CZ8LhI4idCLC7n42eGnwgxanjicU2mTwRYdVN/3GL0MwGqI/yxf/MzASq/1rAvnsJ7Ae5jwjWIuB6Xtlo/Lr3pbbdh9K3zYc+UTZDN3dzoIrAfOu78E0dy7y2un0QePpr4+Uh2206ztOp8XDf3foE+BNlNYWo1wmHt8Zr8dDq7IFrTZO9o7wZ59cJursn9QnBNHrp4f7omu7X/xqgv8cfjSjw/B9lNRjA2fH+edL7bSaoJ8yrabb0ZhCHB++tWezPI1+v5/b5UXz/Iw0z7n5q8bj9IYSHQOz+MDP4cZvswreN/epi+DxB85liUsQ3ta5PF2zGsV1ts/44W27/eYvt3tNhtkMZUIL21N4O82GL3zV5r0v09i+TdBHzxdPbFscZF7HFHgE9WWJYI6LfntX77SFUzzh5X8/9pOY3dKusvfdjhtvu69qUPO/YhXvuwYzt0sR6Wg3w6K9t3neqvbfS3D2F8NO2bELsVfV7bLDC2w3p6GC9tFui7Paqa8lVsf5gC+HHm76u/yXj6m2wb+OOiQo/fLn34WfdTo2oJjPvj1bOZw/vXjnqjfdwQ5eNR7F9+6o12/fDZ0ccT6V/O1e0KPK/l6jcs4rN7fRC6JB/Xz/z5Yuy+8zuW5uWV9PnkvV8E0cc1Tp99yOW7Parug+T1LHUTfX46Y7vrcw1I+O2hp0A+bDKzDeIknP/QP/qpIKPWyL6/6esmyJcnnf3iitiN4+ib49jN1h9Vxfrj1LWPn6H7bncnccZa/fFh2W6vn869kj0MKu5+4P13Q9nSHoZ85cOdYbeQn7ERkY3Hmd0fby/bjyhZ3UgfV0z4KciLv+94XJP6pwuyHSuate6LPq4G+tND//ZLKj4Fl/5w2/4pxm7ESWoKkcrjM//4UEnmdrZ7deDqY++rflxzbo5v6IjYDju92hGxvSZd+HLwYTX2n67JbujJbvXqYLfHvYRevn13r9tNH9LeuX13F0K0zXPI+vI31L6+/A31PsSLa/D94rb58G3788UeY7j/y/feXZAXJ/CP29cvyPYRwG6MBz6+O3xoH2O3lt/92bKux+NqSR8Tdx+ER/92a7sg+vVekLFbzu/VXpCx27DqtV6Qsduu6tVekH2QF7sN9kFe7QV58bY5b/PNZ7zHZ6vpmyBz+4HX4qN/ef4oMWTTH1O3mUHydv3EY1WrPpBjitLTMxnbNf3GwzS4x3Uj+4f0ld239tU7ZY9f7n0qBB33j0+IP4XYFUS2Fejt8an5px9l229PL4ZujmP3earWzLXWdVOH2u0b6tBuVb+X69BuiOjFOrQbqnq5Dm2DvFqHtkFerEPbNsLHEcvseRvZTbmwWz28mzyukPOptjof9nj0zYHsGqvw4dvjt14/NRH9jsaq39FY9euNVb+jsep3NFb9lsa6XSuDgaoxNq1kO071OOptm7q4+9Cq3+o20W8/9DK314/k/tLNzpdzczq7UaqXK/RulOrlRr8bHXq50e8+7Hux0e+3rX2x0f9i+8zXGv02yKuNfttKpDZ9uf/UY9NK5osdaD8813ymvTJQ9cPSTj8did2+oUjbd7RX+472al9vr/Yd7dW+o73aN7TXfTecslOYPvQ5feiGG7bd8rWWgX58N7L1egijg9TfDVEfAtrjJ8afClHbT/2wduCbIR67Vz8T4rEb//ZmCDapXP29EKNm/Y3H/YjfDPG4nc+nQrAe9u3NE2GLtPnuicxainY+rvn1Zgh780dd8j/NYfxcCNZG6G+2TlYXX+5fDjHe/FHlZmzM7s8v6C96/p0xxMcPsz/0/I/dOJWOekA91jHbDB/sqsarswf3QV6cPbgbyHj5Xj2/44Vqfv2Fan7HC9U2yIuzB/dBXr5X7/pl2bNBH2dAfRzaGd/zA8/v+IHXl3/gdfuGH3gb5NWHsXX7vX/gXg9j97E7ef4D78aa7m8gg/FMezZ2N7ZbajwMNY3HB7IPT4Xbpbce1rbW9yJMHoTmmxFqtPv29Bi2I6F91ViX3R6XVvqwJvVuwb/OQ2H3x9e5t2PosxifGBp+Plw+d8NUwgKX8jj7+KeT2W6M2lk0dG0uyHbXl8V+kfeOTP+WKOv5hd3OZbjNl+Yy7F5NV32ZoY+rU36cVBGPs08PRNhzXB6/9f7wMDJlu+1k1eXHlXPkw2468g0PAFO+/AAw5RseAPZBXrw/7IO8fH/YthEmVdwed3v+2EZ2g1Van8/3h3lzP0WYn40gNl8/k36rLwW72OZMvmOkan7HSNX8+kjV/I6RqvkdI1XzO0aqXp+fqc/nZ87dWJXMh2W8HqZm/TTjbffRDR/X6g/7Tv50IN8wsDq/Y6xqfsdY1fz6WNX8jrGq+R1jVVN/7+Z6f7XS6iyfz6erze1Y1Yud5VPnd7SS9Q2tZDdW9WIr2Y1UvdxKtkFebSXbIN/TSmpcRnXzTcI2SL8pN3HbNLXdtlTfEuS1tTD2IV5aC+MXIV5ZC2Pfu/LiR2q/6Od58SO1fR/cix+p7YN8+SM1qx3p7HE+0mqvBrh3IrCixO1xfpZ/IgQr0t2m+Dsh6De/88OD4idCrFp75s4ub4VgqcofJrx8JsTD/hS3h28AXg8h7Btw5/bsKKa3r5/KNshr83/3dfSF9ap2AV5aamq6/64hvnwdpBk71z6kWLu9/rlfm9Ud0x4X+Hg3hL8Vgg2vRR++TflUCGcg+mEC5GdCmLALXX/vWihfTz5+gPl2iPd+1MdvYx5fNz4TgrVjuvubITiRh+9APxWiniGlz/d+1L7Yg+Z2e7Nd8Else+tHZfupHzpOXw9A07T2/DrMXS9jm+w7Nx9GBz6s5bY7iHrS+mF1pk+cRc0dfezH/kyA6jqyh+33PhNg1qPR0vcC1DSR1b8W4HGSyKcuIp3fb5VKrw5a1/XFI/j4M/7v+//947/++e///Je//esf//Hnv/31P+5/77+PUH//8x//5S9/uv7v//3Pv/7rw3/9x//77/lf/uXvf/7LX/78b//873//27/+6f/859//dEQ6/ttvt+t//te43d+Pxm3J//6n3+T4/0eKD5N2//96/P92fwUe9+fx478ff6Gvezfg/X/s+BfxN5r5/U/Y/N//fRzy/wc=",
      "brillig_names": [
        "get_l2_token"
      ]
    },
    {
      "name": "is_registered_l1",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "is_registered_l1"
      ]
    },
    {
      "name": "is_registered_l2",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "aztec_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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kRZZkRf1olE0i1bSkecXlWOVY5VjlWOVY5VjlWOVY6UjJhVdJEWtSIusyIt60SiaReWQckg5pBxSDimHlEPKIeWQckg5WjlaOVo5WjlaOVo5WjlaOVo5Wjm0HFoOLYeWQ8uh5dByaDm0HFoOK4eVw8ph5bByWDmsHFYOK4eVw8vh5fByeDm8HF4OL4eXw8vh5ejl6OXo5ejl6OXo5ejl6OXo5ejlGOUY5Yg81yAtsiIv6kWjaBatpMjzk6SoHLMcsxyzHLMcsxyzHLMcqxyrHKscqxyrHKscqxyrHKscKx0xcekiKWpFWmRFXtSLRtEsKoeUQ8oh5ZBySDmkHFIOKYeUQ8rRytHK0crRytHK0crRytHK0crRyqHl0HJoObQcWg4th5ZDy6Hl0HJYOawcVg4rh5XDymHliDwfQbNoJR15vm5BUtSKtMiKvKgXjaJZtJJ6OXo5ejl6OXo5ejl6OXo5ejl6OUY5RjlGOUY5RjlGOUY5RjlGOUY5ZjlmOWY5ZjlmOWY5ZjlmOWY5ZjlWOVY5VjlWOVY5VjlWOVY5VjlWOmJy1EVS1Iq0yIq8qBeNollUDimHlEPKIeWQckg5pBxSDimHlKOVo5WjlaOVo5WjlaOVo5WjlaOVQ8uh5dByaDm0HFoOLYeWQ8uh5bByWDmsHFYOK4eVw8ph5bByWDkqz73y3CvPvfLcK8+98twrz73y3CvPvfLcK8+98twrz73y3CvPvfLcK8+98twrz73y3CvPvfLcK8+98twrz73y3CvPvfLcK8+98twrz73y3CvPvfLcK8+98twrz73y3CvPvfLcK8+98twrz73y3CvPvfLcK8+98twrz73yvFee98rzXnneK8975XmvPO+V573yvFee98rzXnneK8975XmvPO+V573yvFee98rzXnneK8975XmvPO+V573yvFee98rzXnneK8975XmvPO+V573yvFee98rzXnneK8975XmvPO+V573yvFee98rzXnneK8975XmvPO+V573yvFee98rzXnneK8975XmvPO+V573yvFee98rzXnneK8975XmvPO+V573yvFee98rzXnneK8975XmvPO+V573yvFee98rzXnneK8975XmvPO+V573yvFee98rzXnneK8975XmvPO+V573yvFee98rzXnneK8975XmvPO+V573yvFee98rzXnneK89H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",
      "brillig_names": [
        "is_registered_l2"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7069518359247663558": {
            "error_kind": "string",
            "string": "Function _claim_public can only be called internally"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8459146718181593566": {
            "error_kind": "string",
            "string": "L1 portal address cannot be zero"
          },
          "8606784891595333955": {
            "error_kind": "string",
            "string": "Token contract class cannot be zero"
          },
          "11430482739715627628": {
            "error_kind": "string",
            "string": "Function _log_claim can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14788743618517749904": {
            "error_kind": "string",
            "string": "Function _register_public can only be called internally"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AhwCVCcCHQIxJwIeAk0nAh8CMC0IASAnAiEEHAAIASEBJwMgBAEAIiACIS0KISItDhYiACIiAiItDhIiACIiAiItDgQiACIiAiItDhciACIiAiItDhgiACIiAiItDgsiACIiAiItDhQiACIiAiItDgciACIiAiItDggiACIiAiItDhoiACIiAiItDhsiACIiAiItDhwiACIiAiItDgYiACIiAiItDhoiACIiAiItDh0iACIiAiItDggiACIiAiItDh4iACIiAiItDgoiACIiAiItDgkiACIiAiItDgkiACIiAiItDhQiACIiAiItDhMiACIiAiItDgoiACIiAiItDggiACIiAiItDgwiACIiAiItDh8iACIiAiItDg0iJwITBAEnAhYEAwAqExYULQgBEgAIARQBJwMSBAEAIhICFC0OExQAIhQCFC0OExQnAhQEAwAqEhQTLQoTFC0OAxQAIiACAwAiEgIWLQsWFCcCFwQCACoWFxM+LwADABMAFAAbKQIAAwA4lsJWJwITBBotCAAaLQoDGwAIABMAJQAAPmItAgAALQobEhwKEgMALQgBEicCEwQGAAgBEwEnAxIEAQAiEgITLQoTFC0ODxQAIhQCFC0OERQAIhQCFC0OEBQAIhQCFC0OGRQAIhQCFC0OAxQnAgMEFi0IABYtCgUXLQoOGC0KFRktChIaAAgAAwAlAABExi0CAAAAIgICDi0LDgUnAg8EAgAqDg8DOw4ABQADIwAAKOInAgICbicCAwJsJwIFAmMnAg4CVScCDwJrLQgBECcCEQQcAAgBEQEnAxAEAQAiEAIRLQoREi0ODhIAIhICEi0OAhIAIhICEi0ODxIAIhICEi0OAhIAIhICEi0OBhIAIhICEi0OBxIAIhICEi0OAhIAIhICEi0OCBIAIhICEi0OCRIAIhICEi0OChIAIhICEi0OAxIAIhICEi0OChIAIhICEi0OBRIAIhICEi0OBBIAIhICEi0OBhIAIhICEi0OCxIAIhICEi0OCBIAIhICEi0ODBIAIhICEi0OCRIAIhICEi0OChIAIhICEi0OAxIAIhICEi0OChIAIhICEi0OBRIAIhICEi0OBBIAIhICEi0OBhIAIhICEi0OCxIAIhICEi0ODRILIIBbgF8AAiQCAAIAACqBJwIDBB4tCAEEJwIFBB4ACAEFAS0KBAUqAwAF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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "register_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "aztec_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "name",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          },
          {
            "name": "name_len",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "symbol",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          },
          {
            "name": "symbol_len",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "decimals",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "8998099065237381256": {
            "error_kind": "string",
            "string": "Expected address did not match supplized token address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17288131482828810359": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18159344801564042747": {
            "error_kind": "string",
            "string": "Token already registered"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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rxb7V4v9q8X+1WL/arF/tdi/WuxfLfavFvtXi/2rxf7VYv9qsX+12L9a7F8t9q8W+1eL/avF/tVi/2qxf7XYv1rsXy14teDVglcLXi14teDVglcLXi14teDVglcLXi14teDVglcLXi14teDVglcLXi14teDVglcLXi14teDVglcLXi14teDVglcLXi14teDVglcLXi14teDVglcLXpFvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtPxpfeEW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRb6/+/f+bqP79/5uo/v3/m6j3/PZH//1dozi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vfr374MV378PVnz/Pljx/ftgxffvgxXfvw9WfP8+WPH9+2BxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfvuPxhdecX77j8YXXgW8CngV8CrgVcCrgFcBrzi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vTi/vRJeJbxKeJXwKuFVwquEVwmvOL+93vPb16+GV5zfXpzfXpzfXpzfXpzfXpzfXpzfXpzfXpzfXpzfXpzfXpzfXpzfXpzfXpzfXpzfXpzfXpzfXpzfXpzf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",
      "brillig_names": [
        "discover_new_messages",
        "debug_log_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "attach_len_to_msg_block",
        "debug_log_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "storage_read",
        "debug_log_oracle_wrapper",
        "storage_read",
        "debug_log_oracle_wrapper",
        "build_msg_block",
        "get_l1_to_l2_membership_witness",
        "notify_created_nullifier_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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\n0wjG1j0HkTruZrSFZmQJ4zJievrMBCtdWDUY"
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "sync_private_state"
      ]
    },
    {
      "name": "withdraw_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "withdrawNonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "burnNonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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BicCCARlAAgBCAEnAwYEAQAiBgIILQoICS4MgEYACQAiCQIJLgyARwAJACIJAgkuDIBIAAkAIgkCCS4MgEkACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACS0OBgUnAggBAC0IAQYnAgkEIQAIAQkBJwMGBAEAIgYCCScCCgQgQwOiAAGAWQAKAAgACScCCQEALQgBCCcCCgQhAAgBCgEnAwgEAQAiCAIKJwILBCBDA6IAA4BZAAsACQAKJwIKAQAtCAEJJwILBCEACAELAScDCQQBACIJAgsnAgwEIEMDogAHgFkADAAKAAsnAgoEICcCCwQkJwIMBEQuCIBcAAQjAAAPlwwqBAoNJAIADQAAHZ0jAAAPqS0LBQYtCwYFACIFAgUtDgUGLgmAUgAFACIFAgUuBgAFgFItCwYFACIFAgUtDgUGJwIJBAstCAALLQoGDC4IgGEADS4IgFwADgAIAAkAJQAAIfYtAgAALQoMBS0KDQgtCwUJACIJAgktDgkFLgmAUgAJACIJAgkuBgAJgFItCAEJJwILBAkACAELAScDCQQBACIFAgsBIIBSAAIADAAiCQINQD8ADQAMAAsnAgwEDS0IAA0tCgYOLgiAYQAPLgiAUwAQAAgADAAlAAAh9i0CAAAtCg4FLQoPCy0LBQYAIgYCBi0OBgUHIgALgFQABg0iAAaAVgAMJAIADAAAEKslAAAhMgAiBQINACoNBg4tCw4MJwIOBAQGKgsODwQqDw4QAioLEA0DKIBUAA0ADg8iAA2AVAAPJAIADwAAEOolAAAktBwKDhACHAoQDwQcCg8OAgUogGAADgAPJwIRAgAKKhEOECQCABAAABEtBioPDhMLIgATgGAAEiQCABIAABEtJQAAJMYaKgwPECcCDAIEDCoODBEnAg4CICQCABEAABFZIwAAEU4uCIBcAAQjAAAReRgqEA8IDCoPDhAkAgAQAAARcCUAACTYLQoIBCMAABF5AyiAWAANAA8PIgANgFgAECQCABAAABGWJQAAJLQcCg8QAhwKEA0EHAoNDwIMKg8MDSQCAA0AABHCIwAAEbcuCIBcAAgjAAASGwUogGAADwANJwIRAgAKKhEPECQCABAAABH2BioNDxMLIgATgGAAEiQCABIAABH2JQAAJMYnAg8EgBgqDw0QDCoNDg8kAgAPAAASEiUAACTYLQoQCCMAABIbACoECBAOKgQQESQCABEAABIyJQAAJOouAgAFgAMoAIAEBAARJQAAIUQuCIAFAAQAIgQCCAAqCAYRLQ4QEQ0iAAuAVQAFJAIABQAAErMjAAASbS0LBAUAIgUCBS0OBQQtCAEFJwIGBAkACAEGAScDBQQBACIEAgYAIgkCCAAiBQILQD8ACwAIAAYtCgUNLgiAXAAPIwAAEtoBIgALgF8ABQ4qCwUGJAIABgAAEs0lAAAk6i0KCQ0tCgUPIwAAEtotCw0FACIFAgUtDgUNLQsEBQAiBQIFLQ4FBC0IAQUAAAECAS0OBAUtCAEGAAABAgEtDg8GJwIJBAQGKg8JCwQqCwkQAioPEAgLIgAIgFwACSQCAAkAABROIwAAEzcHIgAPgFQACwMogFQACAAQDyIACIBUABEkAgARAAATXCUAACS0DSIAC4BWAAgkAgAIAAATcSUAACEyACIEAhEAKhELEi0LEggcChASAhwKEhEEHAoREgIFKIBgABIAEScCFAIACioUEhMkAgATAAATwgYqERIWCyIAFoBgABUkAgAVAAATwiUAACTGGioIERMMKhIMCCQCAAgAABPkIwAAE9kuCIBcAAkjAAAUBBgqExEIDCoRDgwkAgAMAAAT+yUAACTYLQoICSMAABQELgIABIADKACABAQAESUAACFELgiABQAIACIIAgwAKgwLES0OCREtDggFACoPEAQOKg8ECCQCAAgAABRFJQAAJOotDgQGIwAAFE4tCwYIByIACIBUAAYtCgYEIwAAFGMNIgAEgFcABiQCAAYAAB1HIwAAFHgnAgYCAy0IAQgnAgkECQAIAQkBJwMIBAEAIggCCS0KCQsuDIBbAAsAIgsCCy4MgFsACwAiCwILLgyAWwALACILAgsuDIBbAAsAIgsCCy4MgFsACwAiCwILLgyAWwALACILAgstDgYLACILAgstDg4LJwIGBAInAgkECC4IgFwABCMAABT9DCoEBgskAgALAAAbpyMAABUPLQsFBi0IAQUAAAECAS0IAQgnAgsEIQAIAQsBJwMIBAEAIggCCycCDAQgACoMCwwtCgsPDCoPDBAWChAQJAIAEAAAFWMuDIBbAA8AIg8CDyMAABVCLQgBCwAAAQIBLQ4ICy0LDQgAIggCCC0OCA0tCAEIJwIMBAkACAEMAScDCAQBACIGAgwAIg0CDwAiCAIQQD8AEAAPAAwtDggFLgiAXAAEIwAAFbYMKgQJBiQCAAYAABqyIwAAFcgtCwsFLQgBBgAAAQIBLgyAQwAGLQgBCAAAAQIBLgyAXQAILQgBCQAAAQIBLgyAXQAJJwILBA8nAgwEHigCAA0AAQAuCIBcAAQjAAAWFQwqBAsPJAIADwAAGgQjAAAWJy0LCQoBIgAFgFYADC0LDAscCgsFAC0LBgsEKgULBgAqCgYFLQ4FCS0LCAYEKgYLCAAqBQgGLwiAQwAFHAoFCAAsAgAJAAAAAAAAAAAAAAAAAP//////////////////////////DioICQokAgAKAAAWniUAACT8OAoABQAGJwIFAnInAggCaScCCQJXJwIKAnQnAgsCaCcCDAJkJwINAmEnAg8CdycCEAJMJwIRAjInAhICVCcCEwJvJwIUAjEnAhUCTScCFgJlJwIXAnMnAhgCZycCGQJ7JwIaAjAnAhsCfS0IARwnAh0EHAAIAR0BJwMcBAEAIhwCHS0KHR4tDgkeACIeAh4tDggeACIeAh4tDgoeACIeAh4tDgseACIeAh4tDgweACIeAh4tDgUeACIeAh4tDg0eACIeAh4tDg8eACIeAh4tDg4eACIeAh4tDhAeACIeAh4tDhEeACIeAh4tDhIeACIeAh4tDhMeACIeAh4tDhAeACIeAh4tDhQeACIeAh4tDg4eACIeAh4tDhUeACIeAh4tDhYeACIeAh4tDhceACIeAh4tDhceACIeAh4tDg0eACIeAh4tDhgeACIeAh4tDhYeACIeAh4tDg4eACIeAh4tDhkeACIeAh4tDhoeACIeAh4tDhseJwIIBAEnAgoEAwAqCAoJLQgBBQAIAQkBJwMFBAEAIgUCCS0OCAkAIgkCCS0OCAknAgkEAwAqBQkILQoICS0OBgkAIhwCBgAiBQIKLQsKCScCCwQCACoKCwg+LwAGAAgACQAbKQIABQA4lsJWLQgBBicCCAQGAAgBCAEnAwYEAQAiBgIILQoICS0OAQkAIgkCCS0OAgkAIgkCCS0OAwkAIgkCCS0OBwkAIgkCCS0OBQktCAEBJwICBAYACAECAScDAQQBACIBAgItCgIDLgyAXQADACIDAgMuDIBdAAMAIgMCAy4MgF0AAwAiAwIDLgyAXQADACIDAgMuDIBdAAMtCAECAAABAgEtDgECJwIBBAUuCIBcAAQjAAAZLQwqBAEDJAIAAwAAGbcjAAAZPy0LAgMnAgUEBQYiBQICJwIHBAMAKgUHBi0IAQQACAEGAScDBAQBACIEAgYtDgUGACIGAgYtDgUGJwIHBAMAKgQHBgAiAwIHLgIAB4ADLgIABoAELgIABYAFJQAAJQ4AIgQCBi0LBgUnAgcEAgAqBgcDNwsAAwAFJgAiBgIFACoFBActCwcDLQsCBS4CAAWAAygAgAQEAAYlAAAhRC4IgAUABwAiBwIIACoIBAktDgMJLQ4HAgEiAASAXwADLQoDBCMAABktLQsJDwIqDAQQDCoQChEkAgARAAAaHyUAACEyACIFAhIAKhIQEy0LExEcChEQAC0LBhEEKhAREgAqDxIQLQ4QCQQqEQ0PLQ4PBi0LCBADKIBXAAQAEQ8iAASAVwASJAIAEgAAGm4lAAAktAwqEQoSJAIAEgAAGoAlAAAhMgAiBQITACoTERQtCxQSHAoSEQAEKhEPEgAqEBIPLQ4PCAEiAASAXwAPLQoPBCMAABYVLQsFCAAiCAINACoNBA8tCw8MHAoMCAAnAg0BAC0IAQwnAg8EBQAIAQ8BJwMMBAEAIgwCDycCEAQEQwOiAAiAWQAQAA0ADwUogFQABAAILgiAXAAGIwAAGwsNIgAGgFQADSQCAA0AABsxIwAAGyABIgAEgF8ABi0KBgQjAAAVtgAqCAYNDioIDQ8kAgAPAAAbSCUAACTqACIMAhAAKhAGES0LEQ8tCwsQDCoNChEkAgARAAAbbCUAACEyLgIAEIADKACABAQAISUAACFELgiABQARACIRAhIAKhINEy0ODxMtDhELASIABoBfAA0tCg0GIwAAGwsFIgAEgFQACwEogFcABAAMDCoLCQ8kAgAPAAAbySUAACEyACIIAhAAKhALES0LEQ8BIgALgF8AEA4qCxARJAIAEQAAG/ElAAAk6gwqEAkRJAIAEQAAHAMlAAAhMgAiCAISACoSEBMtCxMRACoLBhAOKgsQEiQCABIAABwoJQAAJOoMKhAJEiQCABIAABw6JQAAITIAIggCEwAqExAULQsUEgEiAAuAWAAQDioLEBMkAgATAAAcYiUAACTqDCoQCQskAgALAAAcdCUAACEyACIIAhMAKhMQFC0LFAscCg8QBBkiABCAYAAPHAoREAQAKg8QEQ4qDxETJAIAEwAAHKslAAAk6hkiABGAYAAPHAoSEAQAKg8QEQ4qDxESJAIAEgAAHM8lAAAk6hkiABGAYAAPHAoLEAQAKg8QCw4qDwsRJAIAEQAAHPMlAAAk6i0LBQ8NIgAMgFYAECQCABAAAB0MJQAAITIuAgAPgAMoAIAEBAARJQAAIUQuCIAFABAAIhACEQAqEQwSLQ4LEi0OEAUBIgAEgF8ACy0KCwQjAAAU/S0LBQYNIgAEgFYACCQCAAgAAB1gJQAAITIuAgAGgAMoAIAEBAARJQAAIUQuCIAFAAgAIggCCQAqCQQLLgyAXAALLQ4IBQEiAASAXwAGLQoGBCMAABRjASIABIBUAA0AIgYCDwAqDwQQLQsQDi0LBQ8NIgANgGEAECQCABAAAB3MJQAAITIuAgAPgAMoAIAEBABlJQAAIUQuCIAFABAAIhACEQAqEQ0SLQ4OEgAqBAsNACIIAg8AKg8EES0LEQ4NIgANgGEADyQCAA8AAB4aJQAAITIuAgAQgAMoAIAEBABlJQAAIUQuCIAFAA8AIg8CEQAqEQ0SLQ4OEgAqBAwNACIJAhAAKhAEES0LEQ4NIgANgGEAECQCABAAAB5oJQAAITIuAgAPgAMoAIAEBABlJQAAIUQuCIAFABAAIhACEQAqEQ0SLQ4OEi0OEAUBIgAEgF8ADS0KDQQjAAAPlygAgAQEeAANAAAAgASAAyQAgAMAAB7LKgEAAQX3ofOvpa3UyjwEAgEmKgEAAQW+Hj//PqT2+jwEAgEmJQAAHqMtCAECJwIDBAQACAEDAScDAgQBACICAgMtCgMELgyAXQAEACIEAgQuDIBdAAQAIgQCBC4MgF0ABC0IAQMnAgQEBQAIAQQBJwMDBAEAIgMCBC0KBAUuDIBdAAUAIgUCBS4MgF0ABQAiBQIFLgyAXQAFACIFAgUtDgEFLgiAWgAELQoCAS0KAwIuCIBcAAMmJQAAHqMtCwQFCyIABYBaAAYkAgAGAAAfkycCBwQAPAYHAScCBQQGLQgABi0KAQctCgIILQoDCS0KBAoACAAFACUAACVULQIAAC0LAQUtCwIGLQsDBy0OBQEtDgYCLQ4HAy4MgF4ABAEiAAaAXwACLQsCASYqAQABBQ0KLvL2wvvvPAQCASYqAQABBUSNqimioUC3PAQCASYlAAAeoy0LBAYLIgAGgFoAByQCAAcAACArJwIIBAA8BggBLQsDBgsiAAaAWAAHJAIABwAAIL4jAAAgRC0LAwYtCwEHLQsCCC0LBAkNIgAGgFgACiQCAAoAACBpJQAAITIuAgAHgAMoAIAEBAAEJQAAIUQuCIAFAAoAIgoCCwAqCwYMLQ4FDAEiAAaAXwAFDioGBQckAgAHAAAgqSUAACTqLQ4KAS0OCAItDgUDLQ4JBCMAACExJwIGBActCAAHLQoBCC0KAgktCgMKLQoECwAIAAYAJQAAJVQtAgAALQsBBi0LAgctCwQILgIABoADKACABAQABCUAACFELgiABQAJACIJAgoBIgAKgFwACy0OBQstDgkBLQ4HAi4MgF8AAy0OCAQjAAAhMSYqAQABBcVrxFoOEAACPAQCASYuAYADgAYLAIAGAAKAByQAgAcAACFfIwAAIWouAIADgAUjAAAh0S4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAACG9LgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAACGMKAGABQQAAQMAgAYAAoAGIwAAIdEmKgEAAQUP9JL8tuSCADwEAgEmKgEAAQUC3G4ngHYSnTwEAgEmJQAAHqMtCAEFJwIGBBEACAEGAScDBQQBACIFAgYnAgcEEAAqBwYHLQoGCAwqCAcJFgoJCSQCAAkAACJCLgyAXAAIACIIAggjAAAiIS0IAQYAAAECAS0OBQYMKgIDBSQCAAUAACLBIwAAImEBIgADgFMABw4qAwcIJAIACAAAInslAAAk6gwqAgcIJAIACAAAIpgjAAAijS4IgFMABSMAACK4AioCAwcOKgMCCCQCAAgAACKvJQAAJLQtCgcFIwAAIrgtCgUEIwAAIswuCIBcAAQjAAAizAciAASAVAACLQgBBQAAAQIBLQ4CBScCCAQEBioECAkEKgkICgIqBAoHCyIAB4BcAAgkAgAIAAAjLSMAACMKASIAAoBfAAcOKgIHCCQCAAgAACMkJQAAJOotDgcFIwAAIy0tCwUHLgiAXAACIwAAIzwMKgIHBSQCAAUAACNXIwAAI04tCwYBLQoEAiYtCAEIAAABAgEuDIBcAAgFIgACgFQACQciAAmAVAALCioLAgokAgAKAAAjiCUAACTGLgiAXAAFIwAAI5MNIgAFgFQACiQCAAoAACQAIwAAI6gtCwgFLQsGCA0iAAKAVgAJJAIACQAAI8UlAAAhMi4CAAiAAygAgAQEABElAAAhRC4IgAUACQAiCQIKACoKAgstDgULLQ4JBgEiAAKAXwAFLQoFAiMAACM8ACoJBQsOKgkLDCQCAAwAACQXJQAAJOoMKgsEDCQCAAwAACQ0IwAAJCkuCIBbAAojAAAkdwAqAwsMDioDDA0kAgANAAAkSyUAACTqDSIADIBhAAskAgALAAAkYCUAACEyACIBAg0AKg0MDi0LDgstCgsKIwAAJHctCwgLGSIAC4BgAAwcCgoLBAAqDAsKDioMCg0kAgANAAAknyUAACTqLQ4KCAEiAAWAXwAKLQoKBSMAACOTKgEAAQUohpKwR9z9QzwEAgEmKgEAAQVkYYioxs+UyzwEAgEmKgEAAQXJb5M7E53pFjwEAgEmKgEAAQVFp8pxGUHkFTwEAgEmKgEAAQVaAuQbtR6pnzwEAgEmAQCAA4AFgAcuAIADgAguAIAEgAkLAIAIgAeACiQAgAoAACVTLgGACIAGLgSABoAJAQCACAACgAgBAIAJAAKACSMAACUiJiUAAB6jLgiAXAAFIwAAJWQNIgAFgFgABiQCAAYAACXPIwAAJXktCwIFLQsFBgAiBgIGLQ4GBS0IAQYnAgcEBQAIAQcBJwMGBAEAIgUCBycCCAQEACIGAgk/DwAHAAktCwEFLQsDBy0LBAgtDgUBLQ4GAi0OBwMtDggEJi0LAwYMKgUGByQCAAcAACXlIwAAJlEtCwIGACIGAggAKggFCS0LCQctCwEIACIIAgoAKgoFCy0LCwkAKgcJCi0LAwctCwQJLgIABoADKACABAQABSUAACFELgiABQALACILAgwAKgwFDS0OCg0tDggBLQ4LAi0OBwMtDgkEIwAAJlEBIgAFgF8ABi0KBgUjAAAlZA==",
      "debug_symbols": "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",
      "brillig_names": [
        "withdraw_public"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Beacon"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "target",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "overrides",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "minter",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "shield_gateway_beacon",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "shielded_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Portal"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "l1_portal",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "l1_tokens",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "l2_tokens",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token_contract_class_id",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "shield_gateway_beacon",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "eth_token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "recipient",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "amount",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            },
            {
              "name": "message_leaf_index",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::Deposit"
        },
        {
          "fields": [
            {
              "name": "eth_token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "aztec_token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::Register"
        },
        {
          "fields": [
            {
              "name": "token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "from",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "to",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "amount",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::Withdraw"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::_claim_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::_claim_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::_log_claim_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::_log_claim_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "aztec_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::_register_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::_register_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::claim_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::claim_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::claim_shielded_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::claim_shielded_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "l1_portal",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "token_contract_class",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "shield_gateway_beacon",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Portal::get_l1_portal_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::get_l1_portal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "aztec_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::get_l1_token_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::get_l1_token_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::get_l2_token_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::get_l2_token_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::is_registered_l1_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::is_registered_l1_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "aztec_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::is_registered_l2_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::is_registered_l2_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "aztec_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "name",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  },
                  {
                    "name": "name_len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "symbol",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  },
                  {
                    "name": "symbol_len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "decimals",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::register_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::register_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Portal::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::sync_private_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "withdrawNonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "burnNonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::withdraw_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::withdraw_public_abi"
        }
      ]
    }
  },
  "file_map": {
    "101": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_private_state = generate_sync_private_state();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n"
    },
    "102": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "103": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/macros/events.nr",
      "source": "use super::utils::{compute_event_selector, get_trait_impl_method};\n\ncomptime fn generate_event_interface(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let event_type_id = compute_event_selector(s);\n\n    let from_field = get_trait_impl_method(\n        quote { crate::protocol_types::abis::event_selector::EventSelector }.as_type(),\n        quote { crate::protocol_types::traits::FromField },\n        quote { from_field },\n    );\n\n    quote {\n        impl aztec::event::event_interface::EventInterface for $name {\n            fn get_event_type_id() -> aztec::protocol_types::abis::event_selector::EventSelector {\n                $from_field($event_type_id)\n            }\n        }\n    }\n}\n\npub comptime fn event(s: TypeDefinition) -> Quoted {\n    let event_interface = generate_event_interface(s);\n    s.add_attribute(\"abi(events)\");\n    quote {\n        $event_interface\n    }\n}\n"
    },
    "105": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_public, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else if is_fn_public(f) {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    } else {\n        if is_void {\n            create_utility_void_stub(f)\n        } else {\n            create_utility_stub(f)\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n"
    },
    "106": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "109": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "111": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "112": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "113": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_utility(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"utility\")\n}\n\npub(crate) comptime fn is_fn_contract_library_method(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"contract_library_method\")\n}\n\npub(crate) comptime fn is_fn_test(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"test\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_tuple().is_some() {\n        let tuple_len = typ.as_tuple().unwrap().len();\n        let mut tuple_quotes: [Quoted] = [];\n        for i in 0..tuple_len {\n            let element_quote = quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name.$i)); };\n            tuple_quotes = tuple_quotes.push_back(element_quote);\n        }\n        tuple_quotes.join(quote {})\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Type does not implement trait\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n"
    },
    "114": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "115": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "116": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "118": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::fetch_tagged_logs},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "119": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "121": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "132": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/messaging.nr",
      "source": "use crate::{\n    hash::{compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness,\n};\n\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    merkle_tree::root::root_from_sibling_path,\n};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field,\n    leaf_index: Field,\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_l1_to_l2_message_hash(\n        portal_contract_address,\n        chain_id,\n        contract_address,\n        version,\n        content,\n        secret_hash,\n        leaf_index,\n    );\n\n    // We prove that `message_hash` is in the tree by showing the derivation of the tree root, using a merkle path we\n    // get from an oracle.\n    // Safety: The witness is only used as a \"magical value\" that makes the merkle proof below pass. Hence it's safe.\n    let (_leaf_index, sibling_path) =\n        unsafe { get_l1_to_l2_membership_witness(contract_address, message_hash, secret) };\n\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert_eq(root, l1_to_l2_root, \"Message not in state\");\n\n    compute_l1_to_l2_message_nullifier(message_hash, secret)\n}\n"
    },
    "142": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "145": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "148": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "149": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "150": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "151": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "152": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "153": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "154": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, constants::L1_TO_L2_MSG_TREE_HEIGHT};\n\n/// Returns the leaf index and sibling path of an entry in the L1 to L2 messaging tree, which can then be used to prove\n/// its existence.\npub unconstrained fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field,\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\n}\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field,\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {}\n"
    },
    "157": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "158": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "159": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "160": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, length, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "161": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(fetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    // The log fields length is PUBLIC_LOG_SIZE_IN_FIELDS. + 1 because the contract address is prepended to the content.\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_SIZE_IN_FIELDS + 1>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "163": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{\n    note_interface::NoteType,\n    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}\n\npub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<NOTE_PCKD_LEN>,\n{\n    // N + 3 because of the contract address, nonce, and note_hash_counter that are stored out of the packed note.\n    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        MAX_NOTES,\n        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,\n    );\n\n    let mut notes = BoundedVec::<_, MAX_NOTES>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MAX_NOTES];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "165": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "167": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "169": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables, which is expected to never result in collisions or slots\n// being close to one another due to these being hashes. This mirrors the strategy adopted by Solidity mappings.\nimpl<K, T, Context> Storage<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "177": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "191": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/unencrypted_logs/unencrypted_event_emission.nr",
      "source": "use crate::{context::PublicContext, event::event_interface::EventInterface};\nuse protocol_types::traits::{Serialize, ToField};\n\nfn emit<Event, let N: u32>(context: &mut PublicContext, event: Event)\nwhere\n    Event: EventInterface + Serialize<N>,\n{\n    let selector = Event::get_event_type_id();\n\n    let serialized_event = event.serialize();\n    let mut emitted_log = [0; N + 1];\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    for i in 0..serialized_event.len() {\n        emitted_log[i] = serialized_event[i];\n    }\n\n    emitted_log[serialized_event.len()] = selector.to_field();\n\n    context.emit_public_log(emitted_log);\n}\n\npub fn encode_event<Event, let N: u32>(\n    context: &mut PublicContext,\n) -> fn[(&mut PublicContext,)](Event) -> ()\nwhere\n    Event: EventInterface + Serialize<N>,\n{\n    |e: Event| { emit(context, e); }\n}\n"
    },
    "192": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "195": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "196": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "198": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "199": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "201": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "203": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "207": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "214": {
      "path": "/home/vscode/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "231": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "233": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "276": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "277": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr",
      "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH,\n    traits::{Deserialize, Empty, Packable, Serialize, ToField},\n};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl Packable<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn pack(self) -> [Field; ETH_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn to_be_bytes(self) -> [u8; 20] {\n        let field_bytes: [u8; 32] = self.inner.to_be_bytes();\n        let mut bytes = [0; 20];\n        for i in 0..20 {\n            bytes[i] = field_bytes[i + 12];\n        }\n        bytes\n    }\n}\n"
    },
    "279": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "281": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "285": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/noir-protocol-circuits/crates/types/src/contract_class_id.nr",
      "source": "use crate::constants::GENERATOR_INDEX__CONTRACT_LEAF;\nuse crate::traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField};\n\npub struct ContractClassId {\n    pub inner: Field,\n}\n\nimpl Eq for ContractClassId {\n    fn eq(self, other: ContractClassId) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl ToField for ContractClassId {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for ContractClassId {\n    fn from_field(value: Field) -> Self {\n        Self { inner: value }\n    }\n}\n\nimpl Serialize<1> for ContractClassId {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<1> for ContractClassId {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] }\n    }\n}\n\nimpl Empty for ContractClassId {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n// Implement the Packable trait so ContractClassId can be stored in contract's storage.\nimpl Packable<1> for ContractClassId {\n    fn pack(self) -> [Field; 1] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; 1]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl ContractClassId {\n    pub fn compute(\n        artifact_hash: Field,\n        private_functions_root: Field,\n        public_bytecode_commitment: Field,\n    ) -> Self {\n        let hash = crate::hash::poseidon2_hash_with_separator(\n            [artifact_hash, private_functions_root, public_bytecode_commitment],\n            GENERATOR_INDEX__CONTRACT_LEAF,\n        ); // TODO(@spalladino): Update generator index\n        ContractClassId::from_field(hash)\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "291": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "293": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "294": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "304": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "308": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "310": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "311": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "321": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "332": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "346": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    #[inline_always]\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// T = type of item in BoundedVec\n// M = max length of BoundedVec\n// O = field length of T\n// O * M + 1 = total serialized length of BoundedVec<T, M> (the +1 is for length of the BoundedVec)\nimpl<T, let M: u32, let O: u32> Deserialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Deserialize<O>,\n{\n    #[inline_always]\n    fn deserialize(fields: [Field; O * M + 1]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        let len = fields[0] as u32;\n        let mut index = 1;\n\n        for _ in 0..len {\n            let mut nested_fields = [0; O];\n            for j in 0..O {\n                nested_fields[j] = fields[index];\n                index += 1;\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\nimpl<T, let M: u32, let O: u32> Serialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Serialize<O>,\n{\n    #[inline_always]\n    fn serialize(self) -> [Field; O * M + 1] {\n        let mut fields = [0; O * M + 1];\n\n        let len = self.len();\n        fields[0] = len as Field;\n\n        let mut index: u32 = 1;\n\n        for i in 0..len {\n            let item = self.get_unchecked(i);\n            let serialized_item = item.serialize();\n\n            for j in 0..O {\n                fields[index] = serialized_item[j];\n                index += 1;\n            }\n        }\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    #[inline_always]\n    fn deserialize(fields: [Field; N]) -> Self {\n        str::<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "350": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "351": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "367": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"
    },
    "368": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "370": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "376": {
      "path": "/home/vscode/nargo/github.com/noir-lang/sha256/v0.1.3/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "380": {
      "path": "/home/vscode/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "397": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        },\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "51": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/portal/src/encoding/deposit.nr",
      "source": "use aztec::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    hash::sha256_to_field,\n    traits::{FromField, ToField},\n};\n\n// bytes4(keccak256(\"deposit(address,bytes32,uint256)\")) = 0xeb2243f8\nglobal DEPOSIT_SIGNATURE: [u8; 4] = [0xeb, 0x22, 0x43, 0xf8];\n\npub fn deposit_content_hash(\n    eth_token: EthAddress,\n    recipient: AztecAddress,\n    amount: Field,\n) -> Field {\n    let encoded = abi_encode_deposit(eth_token, recipient, amount);\n    let content_hash = sha256_to_field(encoded);\n    content_hash\n}\n\npub fn abi_encode_deposit(\n    eth_token: EthAddress,\n    recipient: AztecAddress,\n    amount: Field,\n) -> [u8; 100] {\n    // abi.encodeWithSignature(DEPOSIT_SIGNATURE, tokenAddr, recipient, amount)\n    // This encodes the following data:\n    // offset - data\n    // 0x00 - 4 bytes for the signature\n    // 0x04 - 32 bytes for the token address\n    // 0x24 - 32 bytes for the recipient\n    // 0x44 - 32 bytes for the amount\n    // Total: 100 bytes\n    let mut encoded = [0; 100];\n    for i in 0..4 {\n        encoded[i] = DEPOSIT_SIGNATURE[i];\n    }\n\n    let eth_token_bytes: [u8; 32] = eth_token.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = amount.to_be_bytes();\n\n    for i in 0..32 {\n        encoded[i + 0x4] = eth_token_bytes[i];\n        encoded[i + 0x24] = recipient_bytes[i];\n        encoded[i + 0x44] = amount_bytes[i];\n    }\n\n    encoded\n}\n\n// For testing purposes, enables printing the ABI-encoded data\npub unconstrained fn field_from_encoded_bytes(encoded: [u8; 100], offset: u32) -> Field {\n    let mut arr = [0; 31];\n    for i in 0..31 {\n        if offset + i >= 100 {\n            break;\n        }\n        arr[i] = encoded[offset + i];\n    }\n    aztec::protocol_types::utils::field::field_from_bytes(arr, true)\n}\n\n#[test]\nfn test_abi_encode_deposit() {\n    let eth_token = EthAddress::from_field(0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F);\n    let recipient = AztecAddress::from_field(\n        0x1e571fd19f8f3aab48fd795e1b39f72dd61f44735c88a7576721be8a5065f863,\n    );\n    let amount = 0x1234567890abcdef1234567890abcdef;\n    let encoded = abi_encode_deposit(eth_token, recipient, amount);\n\n    // abi.encodeWithSignature(\"deposit(address,bytes32,uint256)\", address(0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F), bytes32(hex\"1e571fd19f8f3aab48fd795e1b39f72dd61f44735c88a7576721be8a5065f863\"), 0x1234567890abcdef1234567890abcdef) =\n    // 0xeb2243f80000000000000000000000002458675deb5e0691da2d2ba8dcaf58cfd2c2651f1e571fd19f8f3aab48fd795e1b39f72dd61f44735c88a7576721be8a5065f863000000000000000000000000000000001234567890abcdef1234567890abcdef\n    let expected: [u8; 100] = [\n        0xeb, 0x22, 0x43, 0xf8, // Function selector - deposit(address,bytes32,uint256)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F\n        0x24, 0x58, 0x67, 0x5d, 0xeb, 0x5e, 0x06, 0x91, 0xda, 0x2d, 0x2b, 0xa8, 0xdc, 0xaf, 0x58,\n        0xcf, 0xd2, 0xc2, 0x65, 0x1f,\n        // Aztec Recipient Address\n        0x1e, 0x57, 0x1f, 0xd1, 0x9f, 0x8f, 0x3a, 0xab, 0x48, 0xfd, 0x79, 0x5e, 0x1b, 0x39, 0xf7,\n        0x2d, 0xd6, 0x1f, 0x44, 0x73, 0x5c, 0x88, 0xa7, 0x57, 0x67, 0x21, 0xbe, 0x8a, 0x50, 0x65,\n        0xf8, 0x63,\n        // Amount\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,\n        0xcd, 0xef,\n    ];\n\n    if encoded != expected {\n        std::println(f\"test_abi_encode_deposit: got: {encoded}\");\n        std::println(f\"test_abi_encode_deposit: expected: {expected}\");\n    }\n    assert_eq(encoded, expected);\n}\n\n#[test]\nfn test_deposit_content_hash() {\n    let content: [u8; 100] = [\n        0xeb, 0x22, 0x43, 0xf8, // Function selector - deposit(address,bytes32,uint256)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F\n        0x24, 0x58, 0x67, 0x5d, 0xeb, 0x5e, 0x06, 0x91, 0xda, 0x2d, 0x2b, 0xa8, 0xdc, 0xaf, 0x58,\n        0xcf, 0xd2, 0xc2, 0x65, 0x1f,\n        // Aztec Recipient Address\n        0x1e, 0x57, 0x1f, 0xd1, 0x9f, 0x8f, 0x3a, 0xab, 0x48, 0xfd, 0x79, 0x5e, 0x1b, 0x39, 0xf7,\n        0x2d, 0xd6, 0x1f, 0x44, 0x73, 0x5c, 0x88, 0xa7, 0x57, 0x67, 0x21, 0xbe, 0x8a, 0x50, 0x65,\n        0xf8, 0x63,\n        // Amount\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,\n        0xcd, 0xef,\n    ];\n\n    // sha256(content) = 0x5a05320993a46599dc6c5605c5f2bf139d6fb5f3709e23c5af2b530f1e883aa8\n    // sha256_to_field uses the first 31 bytes of the hash\n    let expected: Field = 0x5a05320993a46599dc6c5605c5f2bf139d6fb5f3709e23c5af2b530f1e883a;\n    let content_hash = sha256_to_field(content);\n    if content_hash != expected {\n        std::println(f\"test_deposit_content_hash: got: {content_hash}\");\n        std::println(f\"test_deposit_content_hash: expected: {expected}\");\n    }\n    assert_eq(content_hash, expected);\n}\n"
    },
    "53": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/portal/src/encoding/register.nr",
      "source": "use aztec::protocol_types::{address::EthAddress, hash::sha256_to_field, traits::ToField};\n\n// bytes4(keccak256(register(address,string,string,uint8))) = 0x611a7a19\ncomptime global REGISTER_SIGNATURE: [u8; 4] = [0x61, 0x1a, 0x7a, 0x19];\n\npub fn register_content_hash(\n    eth_token: EthAddress,\n    name: str<31>,\n    name_len: u8,\n    symbol: str<31>,\n    symbol_len: u8,\n    decimals: u8,\n) -> Field {\n    let encoded = abi_encode_register(eth_token, name, name_len, symbol, symbol_len, decimals);\n    let content_hash = sha256_to_field(encoded);\n\n    // Debug log the ABI-encoded data\n    // let field_array: [Field; 9] = aztec::utils::bytes::bytes_to_fields::<260, 9>(encoded);\n    // dep::aztec::oracle::debug_log::debug_log_format(\"ABI Encoded: {}\", field_array);\n    content_hash\n}\n\npub fn abi_encode_register(\n    eth_token: EthAddress,\n    name: str<31>,\n    name_len: u8,\n    symbol: str<31>,\n    symbol_len: u8,\n    decimals: u8,\n) -> [u8; 260] {\n    // abi.encodeWithSignature(REGISTER_SIGNATURE, tokenAddr, token.name(), token.symbol(), token.decimals())\n    // This encodes the following data:\n    // offset - data\n    // 0x00 - 4 bytes for the signature\n    // 0x04 - 32 bytes for the token address\n    // 0x24 - 32 bytes for the name offset\n    // 0x44 - 32 bytes for the symbol offset\n    // 0x64 - 32 bytes for the decimals\n    // 0x84 - 32 bytes for the name length\n    // 0xa4 - 32 bytes for the name // Limited to 31 bytes\n    // 0xc4 - 32 bytes for the symbol length\n    // 0xe4 - 32 bytes for the symbol // Limited to 31 bytes\n    // Total: 260 bytes\n    let mut encoded = [0; 260];\n\n    let eth_token_bytes: [u8; 32] = eth_token.to_field().to_be_bytes();\n    let decimals_bytes: [u8; 32] = decimals.to_field().to_be_bytes();\n\n    let name_len_bytes: [u8; 32] = name_len.to_field().to_be_bytes();\n    let symbol_len_bytes: [u8; 32] = symbol_len.to_field().to_be_bytes();\n\n    // Fixed offsets for name and symbol\n    // Offset for the name is 0x80 per the ABI encoding, but 0x84 in the raw data\n    let name_offset_bytes: [u8; 32] = 0x80.to_field().to_be_bytes();\n    // Offset for the symbol is 0xc0 per the ABI encoding, but 0xc4 in the raw data\n    let symbol_offset_bytes: [u8; 32] = 0xc0.to_field().to_be_bytes();\n\n    let name_bytes: [u8; 31] = name.as_bytes();\n    let symbol_bytes: [u8; 31] = symbol.as_bytes();\n\n    for i in 0..32 {\n        // First 4 bytes are the function signature\n        if i < 4 {\n            encoded[i] = REGISTER_SIGNATURE[i];\n        }\n\n        encoded[i + 0x4] = eth_token_bytes[i];\n        encoded[i + 0x24] = name_offset_bytes[i];\n        encoded[i + 0x44] = symbol_offset_bytes[i];\n        encoded[i + 0x64] = decimals_bytes[i];\n        encoded[i + 0x84] = name_len_bytes[i];\n        encoded[i + 0xc4] = symbol_len_bytes[i];\n\n        // Copy name & symbol\n        if i < name_len {\n            encoded[i + 0xa4] = name_bytes[i];\n        }\n        if i < symbol_len {\n            encoded[i + 0xe4] = symbol_bytes[i];\n        }\n    }\n\n    encoded\n}\n\nunconstrained fn pad_31<let N: u32>(s: str<N>) -> str<31> {\n    let mut padded = [0; 31];\n    let s = s.as_bytes();\n    for i in 0..31 {\n        if i < N {\n            padded[i] = s[i];\n        }\n    }\n    padded.as_str_unchecked()\n}\n\n#[test]\nunconstrained fn test_abi_encode_register() {\n    let eth_token = EthAddress::from_field(0xbbEda607223492F9dce036A21C459fE1dcab56c7);\n    let name = pad_31(\"Test Token\");\n    let symbol = pad_31(\"TT\");\n    let decimals = 18;\n    let encoded = abi_encode_register(eth_token, name, 10, symbol, 2, decimals);\n\n    // abi.encodeWithSignature(\"register(address,string,string,uint8)\", address(0xbbEda607223492F9dce036A21C459fE1dcab56c7), \"Test Token\", \"TT\", 18) =\n    // 0x611a7a19000000000000000000000000bbeda607223492f9dce036a21c459fe1dcab56c7000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000a5465737420546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000025454000000000000000000000000000000000000000000000000000000000000\n    let expected: [u8; 260] = [\n        0x61, 0x1a, 0x7a, 0x19, // Function selector - register(address,string,string,uint8)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0xbbEda607223492F9dce036A21C459fE1dcab56c7\n        0xbb, 0xed, 0xa6, 0x07, 0x22, 0x34, 0x92, 0xf9, 0xdc, 0xe0, 0x36, 0xa2, 0x1c, 0x45, 0x9f,\n        0xe1, 0xdc, 0xab, 0x56, 0xc7,\n        // Name Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x80,\n        // Symbol Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0xc0,\n        // Decimals: 18\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12,\n        // Name Length: 10\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x0a,\n        // Name: Test Token\n        0x54, 0x65, 0x73, 0x74, 0x20, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n        // Symbol Length: 2\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x02,\n        // Symbol: TT\n        0x54, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n\n    if encoded != expected {\n        std::println(f\"test_abi_encode_register: got: {encoded}\");\n        std::println(f\"test_abi_encode_register: expected: {expected}\");\n    }\n    assert_eq(encoded, expected);\n}\n\n#[test]\nunconstrained fn test_register_content_hash() {\n    let content: [u8; 260] = [\n        0x61, 0x1a, 0x7a, 0x19, // Function selector - register(address,string,string,uint8)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0xbbEda607223492F9dce036A21C459fE1dcab56c7\n        0xbb, 0xed, 0xa6, 0x07, 0x22, 0x34, 0x92, 0xf9, 0xdc, 0xe0, 0x36, 0xa2, 0x1c, 0x45, 0x9f,\n        0xe1, 0xdc, 0xab, 0x56, 0xc7,\n        // Name Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x80,\n        // Symbol Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0xc0,\n        // Decimals: 18\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12,\n        // Name Length: 10\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x0a,\n        // Name: Test Token\n        0x54, 0x65, 0x73, 0x74, 0x20, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n        // Symbol Length: 2\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x02,\n        // Symbol: TT\n        0x54, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    // sha256(content) = 0x0448b4e27885c9528619c3ccd291634a7aa4f66d562d479904429803f535d9f4\n    // sha256_to_field uses the first 31 bytes of the hash\n    let expected: Field = 0x0448b4e27885c9528619c3ccd291634a7aa4f66d562d479904429803f535d9;\n    let content_hash = sha256_to_field(content);\n    if content_hash != expected {\n        std::println(f\"test_register_content_hash: got: {content_hash}\");\n        std::println(f\"test_register_content_hash: expected: {expected}\");\n    }\n    assert_eq(content_hash, expected);\n}\n"
    },
    "54": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/portal/src/encoding/withdraw.nr",
      "source": "use aztec::protocol_types::{address::EthAddress, hash::sha256_to_field, traits::ToField};\n\n// bytes4(keccak256(\"withdraw(address,address,uint256)\")) = 0xd9caed12\nglobal WITHDRAW_SIGNATURE: [u8; 4] = [0xd9, 0xca, 0xed, 0x12];\n\npub fn withdraw_content_hash(eth_token: EthAddress, recipient: EthAddress, amount: Field) -> Field {\n    let encoded = abi_encode_withdraw(eth_token, recipient, amount);\n    let content_hash = sha256_to_field(encoded);\n    content_hash\n}\n\npub fn abi_encode_withdraw(\n    eth_token: EthAddress,\n    recipient: EthAddress,\n    amount: Field,\n) -> [u8; 100] {\n    // abi.encodeWithSignature(WITHDRAW_SIGNATURE, tokenAddr, recipient, amount)\n    // This encodes the following data:\n    // offset - data\n    // 0x00 - 4 bytes for the signature\n    // 0x04 - 32 bytes for the token address\n    // 0x24 - 32 bytes for the recipient\n    // 0x44 - 32 bytes for the amount\n    // Total: 100 bytes\n    let mut encoded = [0; 100];\n    for i in 0..4 {\n        encoded[i] = WITHDRAW_SIGNATURE[i];\n    }\n\n    let eth_token_bytes: [u8; 32] = eth_token.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = amount.to_be_bytes();\n\n    for i in 0..32 {\n        encoded[i + 0x4] = eth_token_bytes[i];\n        encoded[i + 0x24] = recipient_bytes[i];\n        encoded[i + 0x44] = amount_bytes[i];\n    }\n\n    encoded\n}\n\n#[test]\nfn test_abi_encode_withdraw() {\n    let eth_token = EthAddress::from_field(0xbbEda607223492F9dce036A21C459fE1dcab56c7);\n    let recipient = EthAddress::from_field(0x52b1D2CEBF3C80813f82dC4B5F56fCB4e04aC439);\n    let amount = 0x1234567890abcdef;\n    let encoded = abi_encode_withdraw(eth_token, recipient, amount);\n\n    // abi.encodeWithSignature(\"withdraw(address,address,uint256)\", address(0xbbEda607223492F9dce036A21C459fE1dcab56c7), address(0x52b1D2CEBF3C80813f82dC4B5F56fCB4e04aC439), 0x1234567890abcdef) =\n    // 0xd9caed12000000000000000000000000bbeda607223492f9dce036a21c459fe1dcab56c700000000000000000000000052b1d2cebf3c80813f82dc4b5f56fcb4e04ac4390000000000000000000000000000000000000000000000001234567890abcdef\n    let expected: [u8; 100] = [\n        0xd9, 0xca, 0xed, 0x12, // Function selector - withdraw(address,address,uint256)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0xbbEda607223492F9dce036A21C459fE1dcab56c7\n        0xbb, 0xed, 0xa6, 0x07, 0x22, 0x34, 0x92, 0xf9, 0xdc, 0xe0, 0x36, 0xa2, 0x1c, 0x45, 0x9f,\n        0xe1, 0xdc, 0xab, 0x56, 0xc7,\n        // Recipient Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0x52b1D2CEBF3C80813f82dC4B5F56fCB4e04aC439\n        0x52, 0xb1, 0xd2, 0xce, 0xbf, 0x3c, 0x80, 0x81, 0x3f, 0x82, 0xdc, 0x4b, 0x5f, 0x56, 0xfc,\n        0xb4, 0xe0, 0x4a, 0xc4, 0x39,\n        // Amount: 0x1234567890abcdef\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,\n        0xcd, 0xef,\n    ];\n\n    assert_eq(encoded, expected);\n}\n"
    },
    "55": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/portal/src/main.nr",
      "source": "mod constants;\nmod encoding;\n\nuse aztec::macros::aztec;\n\n#[aztec]\npub contract Portal {\n    use std::meta::derive;\n\n    use aztec::{\n        event::event_interface::EventInterface,\n        hash::hash_args,\n        macros::{\n            events::event,\n            functions::{\n                initialization_utils::compute_initialization_hash, initializer, internal, private,\n                public, utility,\n            },\n            storage::storage,\n        },\n        protocol_types::{\n            address::{AztecAddress, EthAddress, PartialAddress},\n            contract_class_id::ContractClassId,\n            public_keys::PublicKeys,\n            traits::{FromField, Serialize, ToField},\n        },\n        state_vars::{Map, PublicImmutable},\n        unencrypted_logs::unencrypted_event_emission::encode_event,\n    };\n\n    use authwit::auth::assert_current_call_valid_authwit_public;\n\n    use token::Token;\n\n    use crate::{\n        constants::PUBLIC_NOT_SECRET_SECRET,\n        encoding::{\n            deposit::deposit_content_hash, register::register_content_hash,\n            withdraw::withdraw_content_hash,\n        },\n    };\n\n    #[storage]\n    struct Storage<Context> {\n        l1_portal: PublicImmutable<EthAddress, Context>,\n        l1_tokens: Map<EthAddress, PublicImmutable<AztecAddress, Context>, Context>,\n        l2_tokens: Map<AztecAddress, PublicImmutable<EthAddress, Context>, Context>,\n        token_contract_class_id: PublicImmutable<ContractClassId, Context>,\n        shield_gateway_beacon: PublicImmutable<AztecAddress, Context>,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Register {\n        eth_token: EthAddress,\n        aztec_token: AztecAddress,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Deposit {\n        eth_token: EthAddress,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Withdraw {\n        token: EthAddress,\n        from: AztecAddress,\n        to: EthAddress,\n        amount: u128,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(\n        l1_portal: Field,\n        token_contract_class: Field,\n        shield_gateway_beacon: AztecAddress,\n    ) {\n        assert(l1_portal != 0, \"L1 portal address cannot be zero\");\n        assert(token_contract_class != 0, \"Token contract class cannot be zero\");\n\n        storage.l1_portal.initialize(EthAddress::from_field(l1_portal));\n        storage.token_contract_class_id.initialize(ContractClassId::from_field(\n            token_contract_class,\n        ));\n        storage.shield_gateway_beacon.initialize(shield_gateway_beacon);\n    }\n\n    #[private]\n    fn register_private(\n        eth_token: Field,\n        aztec_token: AztecAddress,\n        name: str<31>,\n        name_len: u8,\n        symbol: str<31>,\n        symbol_len: u8,\n        decimals: u8,\n        message_leaf_index: Field,\n    ) {\n        aztec::oracle::debug_log::debug_log_format(\n            \"Registering L1 token {0} as L2 token {1}\",\n            [eth_token, aztec_token.to_field()],\n        );\n\n        let eth_token = EthAddress::from_field(eth_token);\n\n        assert(storage.l1_tokens.at(eth_token).read().is_zero(), \"Token already registered\");\n\n        // L1->L2 message content hash from token name, symbol, decimals\n        let content_hash =\n            register_content_hash(eth_token, name, name_len, symbol, symbol_len, decimals);\n        aztec::oracle::debug_log::debug_log_format(\"Register content hash: {0}\", [content_hash]);\n\n        // Set the shield gateway beacon\n        Token::at(aztec_token)\n            .set_shield_gateway_beacon(storage.shield_gateway_beacon.read())\n            .enqueue(&mut context);\n\n        // Ensure the supplied token address matches the expected address. This ensures its deployed with\n        // the correct code and initialization parameters.\n        let initializer = Token::interface().init(context.this_address(), name, symbol, decimals);\n        let args_hash = hash_args(initializer.args);\n        let init_hash = compute_initialization_hash(initializer.selector, args_hash);\n        let partial_address = PartialAddress::compute(\n            storage.token_contract_class_id.read(),\n            0x9876543210, // salt, hardcoded\n            init_hash,\n            AztecAddress::from_field(0),\n        );\n\n        let computed_address = AztecAddress::compute(PublicKeys::default(), partial_address);\n        // aztec::oracle::debug_log::debug_log_format(\n        //     \"Supplied Address: {0}, Computed address: {1}\",\n        //     [aztec_token.to_field(), computed_address.to_field()]\n        // );\n        // aztec::oracle::debug_log::debug_log_format(\"Gas left 4: {0}\", [context.l2_gas_left()]);\n        assert(\n            computed_address == aztec_token,\n            \"Expected address did not match supplized token address\",\n        );\n\n        // Consume the message\n        aztec::oracle::debug_log::debug_log_format(\n            \"Consuming message with leaf index {0}\",\n            [message_leaf_index],\n        );\n\n        let l1Portal = storage.l1_portal.read();\n        aztec::oracle::debug_log::debug_log_format(\"L1 Portal: {0}\", [l1Portal.to_field()]);\n\n        context.consume_l1_to_l2_message(\n            content_hash,\n            PUBLIC_NOT_SECRET_SECRET,\n            storage.l1_portal.read(),\n            message_leaf_index,\n        );\n\n        Portal::at(context.this_address())._register_public(aztec_token, eth_token).enqueue(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _register_public(aztec_token: AztecAddress, eth_token: EthAddress) {\n        // Initialize the token mappings\n        storage.l1_tokens.at(eth_token).initialize(aztec_token);\n        storage.l2_tokens.at(aztec_token).initialize(eth_token);\n        Register { eth_token, aztec_token }.emit(encode_event(&mut context));\n    }\n\n    #[private]\n    fn claim_public(\n        eth_token: Field,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        let eth_token = EthAddress::from_field(eth_token);\n\n        let content_hash = deposit_content_hash(eth_token, recipient, amount.to_field());\n        aztec::oracle::debug_log::debug_log_format(\"Deposit content hash: {0}\", [content_hash]);\n\n        // Consume the message\n        context.consume_l1_to_l2_message(\n            content_hash,\n            PUBLIC_NOT_SECRET_SECRET,\n            storage.l1_portal.read(),\n            message_leaf_index,\n        );\n\n        Portal::at(context.this_address())\n            ._claim_public(eth_token, recipient, amount, message_leaf_index)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _claim_public(\n        eth_token: EthAddress,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        Token::at(storage.l1_tokens.at(eth_token).read()).mint_to_public(recipient, amount).call(\n            &mut context,\n        );\n\n        Portal::at(context.this_address())\n            ._log_claim(eth_token, recipient, amount, message_leaf_index)\n            .call(&mut context);\n    }\n\n    #[private]\n    fn claim_shielded(\n        eth_token: Field,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        let eth_token = EthAddress::from_field(eth_token);\n\n        let content_hash = deposit_content_hash(eth_token, recipient, amount.to_field());\n        aztec::oracle::debug_log::debug_log_format(\"Deposit content hash: {0}\", [content_hash]);\n\n        // Consume the message\n        context.consume_l1_to_l2_message(\n            content_hash,\n            PUBLIC_NOT_SECRET_SECRET,\n            storage.l1_portal.read(),\n            message_leaf_index,\n        );\n\n        Token::at(storage.l1_tokens.at(eth_token).read()).mint_shielded(recipient, amount).call(\n            &mut context,\n        );\n\n        Portal::at(context.this_address())\n            ._log_claim(eth_token, recipient, amount, message_leaf_index)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _log_claim(\n        eth_token: EthAddress,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        Deposit { eth_token, recipient, amount, message_leaf_index }.emit(encode_event(\n            &mut context,\n        ));\n    }\n\n    #[public]\n    fn withdraw_public(\n        eth_token: EthAddress,\n        from: AztecAddress,\n        recipient: EthAddress,\n        amount: u128,\n        withdrawNonce: Field,\n        burnNonce: Field,\n    ) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(withdrawNonce == 0, \"Invalid nonce\");\n        }\n\n        // Burn the tokens\n        Token::at(storage.l1_tokens.at(eth_token).read()).burn_public(from, amount, burnNonce).call(\n            &mut context,\n        );\n\n        // Message the L1 Portal\n        let content_hash = withdraw_content_hash(eth_token, recipient, amount.to_field());\n        context.message_portal(storage.l1_portal.read(), content_hash);\n\n        aztec::oracle::debug_log::debug_log_format(\"Withdraw L2ToL1 Message {0}\", [content_hash]);\n\n        Withdraw { token: eth_token, from, to: recipient, amount }.emit(encode_event(&mut context));\n    }\n\n    #[utility]\n    unconstrained fn is_registered_l1(eth_token: Field) -> pub bool {\n        let eth_token = EthAddress::from_field(eth_token);\n        !storage.l1_tokens.at(eth_token).read().is_zero()\n    }\n\n    #[utility]\n    unconstrained fn is_registered_l2(aztec_token: AztecAddress) -> pub bool {\n        !storage.l2_tokens.at(aztec_token).read().is_zero()\n    }\n\n    #[utility]\n    unconstrained fn get_l2_token(eth_token: Field) -> pub AztecAddress {\n        let eth_token = EthAddress::from_field(eth_token);\n        storage.l1_tokens.at(eth_token).read()\n    }\n\n    #[utility]\n    unconstrained fn get_l1_token(aztec_token: AztecAddress) -> pub EthAddress {\n        storage.l2_tokens.at(aztec_token).read()\n    }\n\n    #[utility]\n    unconstrained fn get_l1_portal() -> pub EthAddress {\n        storage.l1_portal.read()\n    }\n}\n"
    },
    "57": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/authwit/src/auth.nr",
      "source": "use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\nuse dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::ToField,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\npub global IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "65": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "66": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let N: u32, T> UtilityCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\n// UtilityVoidCallInterface\n\npub struct UtilityVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n}\n\nimpl<let N: u32> UtilityVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: () }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "73": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "74": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "75": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "76": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "78": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/event/event_interface.nr",
      "source": "use dep::protocol_types::abis::event_selector::EventSelector;\n\npub trait EventInterface {\n    fn get_event_type_id() -> EventSelector;\n\n    fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n}\n"
    },
    "80": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "92": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "97": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.87.8/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    }
  }
}
