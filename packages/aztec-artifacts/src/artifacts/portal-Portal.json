{
  "transpiled": true,
  "noir_version": "1.0.0-beta.5+0000000000000000000000000000000000000000",
  "name": "Portal",
  "functions": [
    {
      "name": "_claim_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7069518359247663558": {
            "error_kind": "string",
            "string": "Function _claim_public can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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CqcuAIADgAUBAIAFAAKADi4EgAuADiMAAArsKACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uBIALgA4BAIAOAAKADi4EgAmADiMAAArsIwAAC0UoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4EgAuADwEAgA8AAoAPLgSADoAPIwAAC0UoAIANBAADAQCABYANgAwLAIADgAWADSQAgA0AAAupAQCACoAIgA8uAIAKgBAuAIAMgBELAIAQgA+AEiQAgBIAAAupLgGAEIAOLgSADoARAQCAEAACgBABAIARAAKAESMAAAt4AQCADIAIgAYmLgGAA4AHAQCAAwACgAsuAYALgAgBAIALAAKACy4BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANJACADAAADAEjAAAMcSQAgA0AAAwOIwAADCcuAIADgAUBAIAFAAKADi4EgAuADiMAAAxsKACADwQAAwEAgAmAD4AOLgAAAYAFAQAAAYAOAAEoAYAFBAABAQCABQACgA4uBIALgA4BAIAOAAKADi4EgAmADiMAAAxsIwAADMUoAIAPBAACBQCAC4APgA4oAIAQBAADAQCADoAQgA8uAAABgAUBAAABgA8AASgBgAUEAAEBAIAFAAKADy4EgAuADwEAgA8AAoAPLgSADoAPIwAADMUoAIANBAADAQCABYANgAwBAIAMgASADQMAgAgAAoAOAQCADYAOgA8BAIAKgA6AEA0AgBCACoAOJACADgAADSUuAYAQgBEuBIARgA8DAIAQAAKAEAMAgA8AAoAPIwAADPQuAIAMgAYmKgEAAQXFa8RaDhAAAjwEAgEmLgGAA4AGCwCABgACgAckAIAHAAANWSMAAA1kLgCAA4AFIwAADcsuAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAANty4BgAqACC4EgAiACwEAgAoAAoAKAQCACwACgAsjAAANhigBgAUEAAEDAIAGAAKABiMAAA3LJioBAAEFRafKcRlB5BU8BAIBJg==",
      "debug_symbols": "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",
      "brillig_names": [
        "_claim_public"
      ]
    },
    {
      "name": "_log_claim",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "11430482739715627628": {
            "error_kind": "string",
            "string": "Function _log_claim can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgUEBCcCBgQAHwoABQAGgEQdAIBGgEYGLgiARAABLgiARQACLgiARgADLgiARwAEJQAAAF4lAAAAXygCAAEEgEgnAgIEADsOAAIAASYlAAACOB4CAAYAHgIABwAzKgAGAAcACCcCBgEBJAIACAAAAIglAAACYR4CAAYBHgIABwAKKgYHCCQCAAgAAACkJQAAAnMcCgMGACkCAAMAIxDODy0IAQcnAggEBgAIAQgBJwMHBAEAIgcCCC0KCAktDgEJACIJAgktDgIJACIJAgktDgYJACIJAgktDgQJACIJAgktDgMJJwIBAAAtCAECJwIDBAYACAEDAScDAgQBACICAgMtCgMELQ4BBAAiBAIELQ4BBAAiBAIELQ4BBAAiBAIELQ4BBAAiBAIELQ4BBC0IAQEAAAECAS0OAgEnAgIEACcCAwQFJwIEBAEtCgIFIwAAAWQMKgUDAiQCAAIAAAHuIwAAAXYtCwECJwIFBAUGIgUCAScCBwQDACoFBwYtCAEEAAgBBgEnAwQEAQAiBAIGLQ4FBgAiBgIGLQ4FBicCBwQDACoEBwYAIgICBy4CAAeAAy4CAAaABC4CAAWABSUAAAKFACIEAgYtCwYFJwIHBAIAKgYHAjcLAAIABSYAIgcCBgAqBgUILQsIAi0LAQYuAgAGgAMoAIAEBAAGJQAAAssuCIAFAAgAIggCCQAqCQUKLQ4CCi0OCAEAKgUEAi0KAgUjAAABZCgAgAQEeAANAAAAgASAAyQAgAMAAAJgKgEAAQX3ofOvpa3UyjwEAgEmKgEAAQW+Hj//PqT2+jwEAgEmKgEAAQWeoTt9j/vabDwEAgEmAQCAA4AFgAcuAIADgAguAIAEgAkLAIAIgAeACiQAgAoAAALKLgGACIAGLgSABoAJAQCACAACgAgBAIAJAAKACSMAAAKZJi4BgAOABgsAgAYAAoAHJACABwAAAuYjAAAC8S4AgAOABSMAAANYLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAAA0QuAYAKgAguBIAIgAsBAIAKAAKACgEAgAsAAoALIwAAAxMoAYAFBAABAwCABgACgAYjAAADWCY=",
      "debug_symbols": "tZfdjuIwDIXfpddcxHZ+eZUVGjFMZ4RUFdSBlVYj3n3tNm7pSInYQXtDv7jk1Cd2Av1q3trX68fLsX8/fTbbX1/N63DsuuPHS3c67C/HU8/Rr8bIBxi+2A1fXbMNfAUegxGIDMCAlIFAwTPIJCsRmWUlEhkcKKQM3jZbJAGOoMwKMUNEhZAhaSTlCBpU8BkkwwmcQlZGtAr5EUikoIJWBSVn5ORRcp7AZfBGQSNBI2GOpAyRFGKG0cUIYQIyoJAfSmAUnEIWJCSFLEhOZvFiUhCDSYBvEZeJ5OkTaCRpJOWIlTWcIGQAjYBGEBR8BjIKLoPViNWI01lOdTwpyNORIZBCyCB1n0AjiX0RCaQJnLEKosP1cpKzeHfSmSOgyyCpTuAzSGdOoBGn33HjGt5um0a3w8tlaFvZDXf7g3fNeT+0/aXZ9teu2zS/9911/NLned+P18t+4Lvste3f+MqC78euFbptltmmPBWIkk4HYjuzBJi0EoGKiEFUDWPxTsKvJLAsYZMJWcIm8LNEsCsFKitEa2NWiNbbkkLVRkpqAyAVbbinbfj/a8PFuRqxXI1YkXBBbYAnKiWRygrJyYYZFRKLPWkDsGyj1twINGvwWe3LzV1pTd7+ukMYY9FKrTcdOC0qnxQliboVj4uVVVm/WXm+PeH5/ny8KtEWrVREInrSNPhHapZwbu2k0qL8A58V0NxVNa6PrFoOYS5qgsUE80qh0uOEaoIolhUqzQkhSbWmxQwJl94iEx/Ow0XV8PgzJ97pHvGBygqV3oxzDgmg1FZY6UwKRutBAZckyMHjGtFoFozhZxrJ6FpQgorGY4uBxeOiKhDMLFA8v6lS0BRQN2kKLv2oIJHmgsS7vwX/tpi4LCZ9K+qOh/vDcVi9VNxEbDjuX7s2D9+v/eHu7uXPWe/oS8l5OB3at+vQitLyZsIfv/hNY8M/hzv+MysjXnP+m7STtxUZ8qHPbykyhHGYNnyi7W6S2l8=",
      "brillig_names": [
        "_log_claim"
      ]
    },
    {
      "name": "_register_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "aztec_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14788743618517749904": {
            "error_kind": "string",
            "string": "Function _register_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBLJwAABAMnAgMEAicCBAQAHwoAAwAEgEkuCIBJAAEuCIBKAAIlAAAASyUAAAB4KAIAAQSASycCAgQAOw4AAgABKQCAQwA7msoAKACARAQAAygAgEUBAAAoAIBGBAAAKACARwEAASgAgEgEAAEmJQAABlceAgADAB4CAAQAMyoAAwAEAAUkAgAFAAAAnCUAAAaAHgIAAwEeAgAEAAoqAwQFJAIABQAAALglAAAGkicCAwAALQgBBCcCBQQEAAgBBQEnAwQEAQAiBAIFLQoFBi0OAwYAIgYCBi0OAwYAIgYCBi0OAwYrAgAFAAAAAAAAAAACAAAAAAAAAAAtCAEGJwIHBAUACAEHAScDBgQBACIGAgctCgcILQ4DCAAiCAIILQ4DCAAiCAIILQ4DCAAiCAIILQ4FCC0IAQcAAAECAS0OBActCAEEAAABAgEtDgYELQgBBgAAAQIBLgyARgAGLQgBCAAAAQIBLgyARQAIJwIJAAMnAgoECy0IAAstCgcMLQoEDS0KBg4tCggPLQoJEAAIAAoAJQAABqQtAgAAJwIJBAotCAAKLQoHCy0KBAwtCgYNLQoIDi0KAg8ACAAJACUAAAakLQIAACcCCgQLLQgACy0KBwwtCgQNLQoGDi0KCA8ACAAKACUAAAfNLQIAAC0KDAkKKgkDBAsiAASARQAGJAIABgAAAhclAAAIQQEogEMACQAELwoABAAGCioGAwckAgAHAAACNyUAAAhTKAIABgDerTAKAAYABC0IAQQnAgcEBAAIAQcBJwMEBAEAIgQCBy0KBwgtDgMIACIIAggtDgMIACIIAggtDgMIKwIABwAAAAAAAAAAAQAAAAAAAAAALQgBCCcCCgQFAAgBCgEnAwgEAQAiCAIKLQoKCy0OAwsAIgsCCy0OAwsAIgsCCy0OAwsAIgsCCy0OBwstCAEKAAABAgEtDgQKLQgBBAAAAQIBLQ4IBC0IAQgAAAECAS4MgEYACC0IAQsAAAECAS4MgEUACycCDAQNLQgADS0KCg4tCgQPLQoIEC0KCxEtCgESAAgADAAlAAAGpC0CAAAnAg0EDi0IAA4tCgoPLQoEEC0KCBEtCgsSAAgADQAlAAAHzS0CAAAtCg8MMAoAAQAJJwIEAAEAKgkECDAKAAwACC0IAQgnAgkEBAAIAQkBJwMIBAEAIggCCS0KCQotDgMKACIKAgotDgMKACIKAgotDgMKLQgBCScCCgQFAAgBCgEnAwkEAQAiCQIKLQoKCy0OAwsAIgsCCy0OAwsAIgsCCy0OAwsAIgsCCy0OBQstCAEFAAABAgEtDggFLQgBCAAAAQIBLQ4JCC0IAQkAAAECAS4MgEYACS0IAQoAAAECAS4MgEUACicCCwAEJwIMBA0tCAANLQoFDi0KCA8tCgkQLQoKES0KCxIACAAMACUAAAakLQIAACcCCwQMLQgADC0KBQ0tCggOLQoJDy0KChAtCgERAAgACwAlAAAGpC0CAAAnAgwEDS0IAA0tCgUOLQoIDy0KCRAtCgoRAAgADAAlAAAHzS0CAAAtCg4LCioLAwULIgAFgEUACCQCAAgAAASvJQAACEEBKIBDAAsABS8KAAUACAoqCAMJJAIACQAABM8lAAAIUzAKAAYABS0IAQUnAgYEBAAIAQYBJwMFBAEAIgUCBi0KBggtDgMIACIIAggtDgMIACIIAggtDgMILQgBBicCCAQFAAgBCAEnAwYEAQAiBgIILQoICS0OAwkAIgkCCS0OAwkAIgkCCS0OAwkAIgkCCS0OBwktCAEDAAABAgEtDgUDLQgBBQAAAQIBLQ4GBS0IAQYAAAECAS4MgEYABi0IAQcAAAECAS4MgEUABycCCAQMLQgADC0KAw0tCgUOLQoGDy0KBxAtCgIRAAgACAAlAAAGpC0CAAAnAgkEDC0IAAwtCgMNLQoFDi0KBg8tCgcQAAgACQAlAAAHzS0CAAAtCg0IMAoAAgALACoLBAMwCgAIAAMpAgADANPNMTgnAgUEAycCBwQDACoFBwYtCAEEAAgBBgEnAwQEAQAiBAIGLQ4FBgAiBgIGLQ4FBicCBgQDACoEBgUtCgUGLQ4CBgAiBgIGLQ4BBgAiBgIGLQ4DBgAiBAIDLQsDAicCBQQCACoDBQE3CwABAAImKACABAR4AA0AAACABIADJACAAwAABn8qAQABBfeh86+lrdTKPAQCASYqAQABBb4eP/8+pPb6PAQCASYqAQABBc08K/eIE1CQPAQCASYlAAAGVy0LBAYLIgAGgEUAByQCAAcAAAbGJwIIBAA8BggBLQsDBgsiAAaARAAHJAIABwAAB1kjAAAG3y0LAwYtCwEHLQsCCC0LBAkNIgAGgEQACiQCAAoAAAcEJQAACGUuAgAHgAMoAIAEBAAEJQAACHcuCIAFAAoAIgoCCwAqCwYMLQ4FDAEiAAaASAAFDioGBQckAgAHAAAHRCUAAAkFLQ4KAS0OCAItDgUDLQ4JBCMAAAfMJwIGBActCAAHLQoBCC0KAgktCgMKLQoECwAIAAYAJQAACRctAgAALQsBBi0LAgctCwQILgIABoADKACABAQABCUAAAh3LgiABQAJACIJAgoBIgAKgEYACy0OBQstDgkBLQ4HAi4MgEgAAy0OCAQjAAAHzCYlAAAGVy0LBAULIgAFgEUABiQCAAYAAAfvJwIHBAA8BgcBJwIFBAYtCAAGLQoBBy0KAggtCgMJLQoECgAIAAUAJQAACRctAgAALQsBBS0LAgYtCwMHLQ4FAS0OBgItDgcDLgyARwAEASIABoBIAAItCwIBJioBAAEFAtxuJ4B2Ep08BAIBJioBAAEFHwotJ9yCh6I8BAIBJioBAAEFxWvEWg4QAAI8BAIBJi4BgAOABgsAgAYAAoAHJACABwAACJIjAAAInS4AgAOABSMAAAkELgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAACPAuAYAKgAguBIAIgAsBAIAKAAKACgEAgAsAAoALIwAACL8oAYAFBAABAwCABgACgAYjAAAJBCYqAQABBUWnynEZQeQVPAQCASYlAAAGVy4IgEYABSMAAAknDSIABYBEAAYkAgAGAAAJlyMAAAk8LQsCBS0LBQYAIgYCBi0OBgUnAgYEBC0IAQcnAggEBQAIAQgBJwMHBAEAIgUCCCcCCQQEACIHAgo/DwAIAAotCwEFLQsDBi0LBAgtDgUBLQ4HAi0OBgMtDggEJi0LAwYMKgUGByQCAAcAAAmtIwAAChktCwIGACIGAggAKggFCS0LCQctCwEIACIIAgoAKgoFCy0LCwkAKgcJCi0LAwctCwQJLgIABoADKACABAQABSUAAAh3LgiABQALACILAgwAKgwFDS0OCg0tDggBLQ4LAi0OBwMtDgkEIwAAChkBIgAFgEgABi0KBgUjAAAJJw==",
      "debug_symbols": "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",
      "brillig_names": [
        "_register_public"
      ]
    },
    {
      "name": "claim_public",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17288131482828810359": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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RedvQOdvFp2/A52/W3T+AXT+YdH5J9D5p0XnX0DnXxadR4DOIxadR4HOoxadx4DOYxadfwOdf1t0Hgc6j1t0/gN0/mPReQLoPGHReRLoPGnR+S/Q+a9F5ymg85RF52mg87RF5xmg84xF51mg86xF5zmg85xF53mg87xF5wWg84JF50Wg86JF5yWg85JF52Wg87JF5xWg84pF51Wg86pF5zWg85pF53Wg87pF5w2g84ZF502g86ZF5y2g85ZF522g87ZF5x2g845F512g865F5z2g855F532g875F5wOg84FF50Og86FF5yOg85FF52Og87FF5xOg84lF51Og86lF5zOg85lF53Og87lF5wug84VF50ug86VF5yug85VF539A538Wna+BztcWnW+AzjcWnW+BzrcWnWB2TsecY50I0IlYdKqATpVFpxroVFt0aoBOjUWnFujUWnQGAJ0BFp2BQGegRWcQ0Blk0akDOnUWnXqgU2/RGQx0Blt0hgCdIRadBqDTYNEZCnSGWnSGAZ1hFp1GoNNo0RkOdIZbdEYAnREWnSag02TRGQl0Rlp0lgM6y1l0lgc6y1t0RgGdURadFYDOChadFYHOihadlYDOShad0UBntEVnZaCzskVnFaCzikVnVaCzqkVnNaCzmkVnDNAZY9FZHeisbtFZA+isYdFZE+isadFZC+isZdFZG+isbdFZB+isY9FZF+isC3Sqgc56QGc9pEOt09HXx2Z+R0s44PYdftYrpKKu7cj8bluRCiMovSAA/R34X6nbnRW7NWmh23hVR3J6uG7htYFw/Z+pv9QWNabewk/bLn5nI9KbO4xTjdIPgr7rkn2URTKMtXneFjdKlV227878rwFh+D3xQspOH23AX5RlvTywnaftjEPXenlTVwamg+yRHXuCa8Z+S+sdz4YMQCW/4zkgE6kc23ga/C294IdRg7+VH/4Jg7+1F/xE1KwhPjNTJr7XEeJ3qU0aMG0/21+GBffL8BN0/sYJuX65Evbf0HU5gvAhH+ozWqYs64gwg5X9LAvAgvqDQB6hPjw38eE182maRgIT729C7csAr0HftAoao8CyiVj+G1x8zeA2Bn1tgz9ZNgDk03Ck1vzjz3dvFslxXx+NefJ9chS/L2FsUugnR43+xmDcdV6ExrTly4YZA/mKojKhPo2oryUt+Y8EbpsWmv8qC9cWkP8LLVwhH8jVte+E/v9Dh14toRdBXKsDeqxv+iuXP+5vPYd5xr7Lz54w0QT2N1S+cfpaBoM8VAd9fRDWp+oUxMefp86+RxLQvhR+9hHq7wTq/zYFtGt4v4Q/z0zV60La4A5Eu6bKGNZrw3sYkVcTh7r/1sfYzP9oaUfot66logYf1pMIH/8s/mA/+EnqvVboS3ZH9Y36FLer/hj9X4I6vCeqF9C3FLI/z2AQbu6fgqB0X9UAdPC4YSiIQ7Uz40ONfiNItxphUPrmHg36hkbAAfc3Rr8DtMtLUP8whMiPtn9XhE4blukQgitOeyoo0/1RmcK0jV2HBX3tjMeIQwku0M5bpntzMfrjgR0uB3bQB5z/yN5vZ/7XgDDO+wvN4ypUHrD8a9O98z0MhFH1BbYDWDeg/jCgg+s2rEtDUBgsA/ypeuozy1T/QrVX+Elw7EcaHfnF9UfLcIBF6Ru8WqQ/nei3MCasa9BONRbMNKj3R6EyhmVQDzifYEkb5r+ayI/RH0HkH+oPR1yNfo8j/41E/ocDzDqEafTnEW0N84T5ioBruB43EfojiHwNC/raxcSlbG/0oO0pjAbEx6QHPzkP9QcjrjAMpg/zTrXt4QRXV1kPJ9LBZX0aUdZU3zYMpUfxg+0et/EhBBbsVyr9felzMwDftT2Qi/0M7Hft89pL/fPWRX7e2+fnra8DfdQNoI9arEukp/Xud+hFLP8XYxDXatK9r1HPBCrp89b3gD5CH5X4eetbkd+Ceeeei16cJsKH1zA3U3d0vY5lrsve46elW/Y+EJXzqZr+7vGT7zM0Zp8afT4KpKWPbdI5HrB+YDzqnqYsz/8zn0LyVz6xVl/P/1dH9vHyjB+sC/LTPmLJQvbE2wjYBNrB6EM7+Hk2GEsW0ufC9Cvx0zfm+wf7p6bsGO4+ccfYTqmDO1KHTj5g3CGZnc6rkGVhqcPU1kXoAdKDx7qAnU0Pt35YI6i7CngUs3oJWkfSTuEbZn5X8iqStTLnEnbrCjO/l/bdp+k9he/E2LxsN133wbWbrpn1GRT0nkWPeC5bj7Z3fqzbjACMb9P5N21mwsQp47qP3OLQVPuUVNfOh40fP657XOrQAB24l6H6cZNSpXut5TK/l7bXMt9ZEO61OoTfW7ZWyr1lNdLDcXS4y7N53hO22bOdmv2uk1z26Xd9uNY0fR8+/U7NI1ShsBoQVug7IGOAHm6D+C4K9lVmX0+NsSHAg5/I9jgq6ViaoxIpd40bZH5X8l3jmpnzwUFutBcHeLY2Qs0VmmfL0B/gNW6e2nPMcK0huEL/YtLXI1kzntOfIk5tN2GrI1Kdh00ZN3HCFu2dB6QCdNimT6oCe8cMM0phVIP41CFhUJzM/F7ag2Kz6bvwQXGyXINiT4OxhN+JYHpQTDkcU4fNwxJ4bjgZnW2ADnxoog8fD26oAaJJVztgs9BFn5t677lDT1bCNINxyNo5j8mcL5lm2GrCpMNSh6W6lnwbdOvDJnQucdTjxwfoKPZD8Ngn1xA4+IDxIiAPle6rzQOIpe2rTf2Gi+u47aUPuNDfA362L/B1kwJftgpQWtBuuC7Cc8OpDtmcmWt7dlAOOFSjNDFHqEO1N/x4qwZdry5AlxpbmbDs4NsRD78sh6/hG72A0M8O5DP/ay1YA0E41B+IdH2VYRPBKWJJezk/HLJtaqQf/CjVppYD5yNRPmG9GsvEweCZOlAb9D3worbsjR/iF+HnF2IulH8xh6kzI8G15SxcYb/DefNn8Af7wSfrDHwZdzAKM2VH+bSI5XcV+u/SjThwKT9kME1ZQb4mH/8PZI3bS0DuHQA=",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "build_msg_block",
        "attach_len_to_msg_block",
        "debug_log_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "get_l1_to_l2_membership_witness",
        "notify_created_nullifier_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_to_radix",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "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\n0wjG1j0HkTruZrSFZmQJ4zJievrMBCtdWDUY"
    },
    {
      "name": "claim_shielded",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17288131482828810359": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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6ztKO4/SzqO08yi+o/iO4mvF14qvlXa2cr5WztfK+VrxtXJ9rbSzlXb20s5efL34evH14uvF10s7ezlfL+db8qod8G1HK9wLU2EuLEVHC4/CVrj4lrxqJa9ayatW8qq14tuksBYeha1w8e3Ft+RVK3nVSl61klet5FUredVKXrVefDuubyt51UpetZJXjYovFd+SV63kVSt51UpetZJXreRVK3nVuPhyub4lr1rJq1byqnHx5eJb8qqVvGolr1rJq1byqpW8aiWvmhRfKde35FUredVKXjUtvlp8S161klet5FUredVKXrWSV63kVRvFd5TrW/KqlbxqJa/aKL6j+Ja8aiWvWsmrVvKqlbxqJa9ayatmxdfK9S151UpetZJXzYqvF9+SV63kVSt51UpetZJXreRVK3nVvPg6rm8vedVLXvWSV/2Abz+4sBTWwqOwFcb59pJXveRVb8W3UWEuLIW1cPFtxbfkVS951Ute9ZJXveRVL3nVS171Xnz7KGyFSzuXvOpUfKn4lrzqJa96yate8qqXvOolr3rJq87Fl8v1LXnVS171klediy8X35JXveRVL3nVS171kle95FUvedWl+Eq5viWvesmrXvKqS/HV4lvyqpe86iWvesmrXvKql7zqJa+6Fl8t17fkVS951Ute9VF8R/EtedVLXvWSV73kVS951Ute9ZJX3Yqvletb8qqXvOolr7oVXyu+Ja96yate8qqXvOolr3rJq17yqnvx9XJ9S171kldU8orK70E6emEqzIWlsBYeha0wzpda8W2tcC9Mhblw8W3Ft+QVlbyikldU8opKXlHJKyp5Rb34dimshUdhK1x8qfiWvKKSV1TyikpeUckrKnlFJa+Iii+V61vyikpeUckrKr8HiYtvySsqeUUlr6jkFZW8opJXVPKKpPhKub4lr6jkFZW8ovJ7kEpeUXm/ovJ+RSWvqPweJC2+WnxLXlHJKyp5ReX9iu680pOvvOo9uBXuhakwF5bCWngUtsIOtuJrxdeKrxVfK75WfK34Xnl1LnPQ6Mqrc2moRldeXXzl1fnlcKMrr27u5W+oMJe/kcJa/mYUNhyDw5evvLoZvnzl1c1U/oYLS/kbLTzK31hhz2PgVnyvvLq5+F55dXPxvfLq5uJ75dXNxbeV873y6jqGXnx7L1x8Oxcuvl0LF98rr24uvlTO98qr6xio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cn1LXnHJKy55xVx8pfiWvOKSV1zyiktecckrLnnFJa+4vF9xeb/ikldc8opLXnF5v+LyfsUlr7jkFZe84pJXXPKKS15xySsexXeU61vyiktecckrHsV3FN+SV1zyiktecckrLnnFJa+45BVb8bVyfUtecckrLnnFXny9+Ja84pJXXPKKS15xySsuecUlr+SArxytcC9MhbmwFB0tPApb4eJb8kpKXknJKyl5Ja34NimshUdhK1x8e/EteSUlr6TklZS8kpJXUvJKSl5JL74d11dKXknJKyl5JVR8qfiWvJKSV1LySkpeSckrKXklJa+Eiy+X61vySkpeSckr4eLLxbfklZS8kpJXUvJKSl5JySspeSVSfKVc35JXUvJKSl5J+T0o5feglLySkldS8kpKXknJKyl5JSWvZBTfUa5vySspeSUlr6T8HpRRfEteSckrKXklJa+k5JWUvJKSV2LF18r1LXklJa+k5JWU34PixbfklZS8kpJXUvJKSl5JySspeSVefB3XV0teackrLXml5fegHlxYCmvhUdgK43y15JWWvNJWfBsV5sJSWAsX31Z8S15pySsteaUlr7TklZa80pJX2otvH4WtcGnnkldafg8qFd+SV1rySkteackrLXmlJa+05JVy8eVyfUteackrLXml5fegcvEteaUlr7TklZa80pJXWvJKS16pFF8p17fklZa80pJXWn4PaskrLe9XWt6vtOSVlt+DqsW39F9pySsteaUlr7S8X+mdVxJ8+VowFebCUlgLj8JW2MF3Xl3cChdfK75WfK34WvG14mvF14qvF18vvl58vfh68fXi68XXi68XX4fvOI7CrXAvTIW5sBQO3xjHvOa3T7bC4XvOO+3X/PbJrXAvTIUZOlde3Vx8r7y6/94KF99efHvx7cW3F99efHvx7cW3l/Pt5Xx78aXiS8WXii8V3yuvbpbCWricLxXfK68uvvLq5la4Fy6+XHy5+HLx5eLLpZ25nK+U85VyvlJ8r7y6ubSzlHaW0s5SfKX4SvHV4qvFV0s7azlfLeer5Xy1+Gq5vlraWUs7j9LOo/iO4juK7yi+o/iO0s6jnO8o5zvK+VrxtXJ9rbSzlXa20s5WfK34WvG14mvF10s7ezlfL+fr5Xy9+Hq5vl7a2Us7e2lnh+81v31yK9wLU2EuLIW18CgMXztwfa0dhVvhXrj4tuLbim8rviWvrOSVlbyykldW8sp68e1UmAtLYS1cfHvxLXllJa+s5JWVvLKSV1byykpeGRVfGoVLO5e8spJXxsWXi2/JKyt5ZSWvrOSVlbyykldW8sqk+Eq5viWvrOSVlbwyKb5SfEteWckrK3llJa+s5JWVvLKSV6bFV8v1LXllJa+s5JVp8R3Ft+SVlbyykldW8spKXlnJKyt5ZaP4jnJ9S15ZySsreWVWfK34lryykldW8spKXlnJKyt5ZSWvzIuvl+tb8spKXlnJK/Pi68W35JWXvPKSV17yykteeckrL3nl5f3Ky/uVl7zyklde8srL+5WX9ysveeUlr7zklZe88pJXXvLKS155L769Fe6FqTAXLr69+Ja88pJXXvLKS155ySsveeUlr5yKL0nh0s4lr7zklVPx5eJb8spLXnnJKy955SWvvOSVl7xyLr5crm/JKy955SWvXIqvFN+SV17yykteeckrL3nlJa+85JVr8dVyfUteeckrL3nlWny1+Ja88pJXXvLKS155ySsveeUlr3wU31Gub8krL3nlJa/ciq8V35JXXvLKS155ySsveeUlr7zklXvx9XJ9S155ySsveeVefL34lrzykleOvKIDeUUH8ooO5BUdyCs6jvSl45DCWngUtsLFtxXfVnxb8W3FF3lFB/KKDuQVHcgrOlrxbQ5GXtGBvKIDeUVHL769+Pbi24tvL77IKzp6OV8q50vlfKn4EhUu7Uylnam0MxVfKr5UfLn4cvHl0s5czpfL+XI5Xy6+XK4vl3bm0s5S2lmKrxRfKb5SfKX4SmlnKecr5XylnK8WXy3XV0s7a2lnLe2sxVeLrxZfLb5afEdp51HOd5TzHeV8R/Ed5fqO0s6jtPMo7TyKrxVfK75WfK34WmlnK+dr5XytnK8VXyvX10s7e2lnL+3sxdeLrxdfL75efL20c8mrVvKqlbxqB3zbQYW5sBTWwqPoWPnfcb4N71fUSl61Vnxb8W3Ft+RVK3nVSl41vF9Ru/OKTr7zSoNb4V6YCnNhKayFR2Er7GAqvlR8qfhS8aXiS8WXii8VXyq+VHy5+HLx5eLLxZeLLxdfLr5cfLn4cvGV4ivFV4qvFN87ryxYCmvhy9eDrbCD77y6uBXu0Lnz6uLie+fV9fdauPhq8dXiO4rvKL6j+I7iO4rvKOc7yvmO4juK7yi+Vnyt+N55dTEV5sLlfK343nl1sRV28J1XFxdfL75efL34evH10s5eztfL+TrOtx/w7XdeXdwLU2EuLEVHC4/CVrj4tqNwK9wLU+Hi26SwFh6FrXDx7cW3F99efHvx7Vy4nG8v59vL+fbi23F97/ntN5d2ptLOVHyp+FLxpeJLxZdKO1M5Xy7ny+V8ufhyub5c2plLO3NpZy6+XHy5+ErxleIrpZ2lnK+U85VyviWv7vntN5d2ltLOWtq55NU9v/3m4qvFt+RVL3nVS171kle95NU9v/3yHeX6lrzqJa96yat7fvutU3xLXvWSV73kVS951Ute9ZJXveTVPb/98rVyfUte9ZJXveTVPb/90vHiW/Kql7zqJa96yate8qqXvOolr+757Zev4/pSySsqeUUlr+757aFzz2+/WQpr4VHYCuN8qeQVlby657dfvo0Kc2EprIWLbyu+Ja+o5BWVvKKSV1TyikpeUcmre3775dtHYStc2rnk1T2//dKh4lvyikpeUckrKnlFJa+o5BWVvLrnt1++XK5vySsqeUUlr+757bdO8S15RSWvqOQVlbyikldU8opKXlF5v6LyfkUlr6jkFZW8ovJ+ReX9ikpeUckrKnlFJa+o5BWVvKKSV/f89stXy/UteUUlr6jk1T2//dIZxbfkFZW8opJXVPKKSl5RySsqeXXPb798rVzfkldU8opKXt3z22+d4lvyikpeUckrKnlFJa+o5BWVvLrnt1++Xq5vySsqecUlr+757f9/YXezI8mSHFb4XWbdi/KfcDPXqxADgqRGwgADDjEiBQjCfXdlult2fjttiNPVUXHCPTJPZdQ19pzz1Hx78YAn/MALDjjh73prvv16W4M7POAJ42146dWkV5NeTXo16dWkV5Ne1Xz79fYHXnDACeMdeOnVpFeTXk16NenVpFeTXtV8+/UO7i+9mvRq0quab7/nmXjp1aRXk15NejXp1aRXk17VfPv1PtxfejXp1aRXk+fByfPgpFeTXk16NenVpFeTXk16VfPt17u4v/Rq0qtJrybPgzXfXoyXXk16NenVpFeTXk16VfPt15vcX3o16dWkV5PnwZpvL8ZLrya9mvRq0qtJrya9qvn2693cX3o16dWkV5PnwZpvL25whwc84QdecMBfb823X6ZXD7166NXD82DNtxfjpVcPvXro1UOvHnr10Kuab7/ePuAJP/CC8Xa89OqhVw+9eujVQ68eevXQq5pvv94RMPtMrx569fA8WPPtxXjp1UOvHnr10KuHXj30qubbr/fh/tKrh1499OrhefChVw+frx4+Xz306uF5sObbi/HSq4dePfTq4fNVzbfPdvh43/8W8aj59su3V8UN7vCAJ/zACw4Yb+BNvIk38SbexJt4E2/iTbyJd+PdeDfejXfj3Xg33o13491fb823Fzf4etfhAU/4euPwggNOeH/59uqe5/aqGO/tVR0/YbwNb8Pb8Da8HW/H2/F21ttZb8fb8Xa8HW/He3tV3OAOs96B9/aqeMEBJ4x34p14J96Jd7LPk/VO1jtZ78R7e3X5YZ8f9vlhnx+8D94H74P3wfuwzw/rXax3sd6Fd3F/F/u82OfFPi+8C+/CG3gDb7DPwXqD9QbrDbzB/Q32OdjnZJ8Tb+JNvIk38Sb7nKw3WW+y3o13c383+7zZ580+b7wb78a78e6vt+bbixvc4QF/vTXfXrzggBPG2/A2vA0vvQp6FfQq6FXQq5pvv972vb9Br4JeBb2q+fZ7no6XXgW9CnoV9CroVdCroFc13369Y8DsM70KelXz7XUevPQq6FXQq6BXQa+CXgW9qvn2653cX3oV9CroVc233/M8eOlV0KugV0Gvgl4FvQp6VfPt17u4v/Qq6FXQq5pvr/PgpVdBr4JeBb0KehX0KuhVzbdfb3B/6VXQq6BXNd9+z5N46VXQq6BXQa+CXgW9CnpV8+3Xm9xfehX0KuhVzbff82y89CroVdCroFdBr5JeJb1KPl8ln6+SXiW9SnqVfL5KPl8lvUp6lfQq6VXSq6RXSa9qvv16W8AJf/c56VXNt9/zdLz0KulV0qukV0mvkl4lvar59usdDWaf6VXSq5pvr/PgpVdJr5JeJb1KepX0KulVzbdf7+T+0qukV0mvar79nufBS6+SXiW9SnqV9CrpVdKrmm+/3of7S6+SXiW9qvn2e56Fl14lvUp6lfQq6VXSq6RXNd9+vcH9pVdJr5Je1Xx7nQcvvUp6lfQq6VXSq6RXSa9qvv16k/tLr5JeJb2q+fZ7no2XXiW9SnqV9CrpVdKrpFc13368Nd9e3OEBT/jhPAsOOGG89GrTq02vNr2q+fbrbQ+84IATxtvx0qtNrza92vRq06tNrza9qvn26+3f+7vp1aZXm15tngdrvr0YL73a9GrTq02vNr3a9Krm2693cn/p1aZXm15tngdrvr0YL73a9GrTq02vNr3a9Krm26/34f7Sq02vNr3aPA/WfHsxXnq16dWmV5tebXq16VXNt19vcH/p1aZXm15tngdrvr0YL73a9GrTq02vNr3a9Krm2683ub/0atOrTa82z4M1316Ml15terXp1aZXm15telXz7de7f9/f+fPt1fz59mr+fHs1f77Pg/Pn26v58/18NX++n6/mz7dX8+f7PDhrvv1yw/vt1fz59mr+NLzfz1ez5tvf/67srPn2978rO2u+vTjh/eXbq+IGd3jAE35gvB1vx9vxDrwD78A78A68A+/AO/AOvAPvxDvxTrwT78Q78U68E+/EO/HeXr3/Ld9Z8+3FHb7e5/CEH3jBASfn2V9eeG+v7vG3V8V4F96Fd+FdeBfehTfwBusN1ht4A2/gDbyB9/aqeH/59qqY9Sbe26viCT/wgvEm3sS78W68m33erHez3s16N97bq2L2eX/3uebbi7/emm8vHvCEH3jBASf8XW/Nt19va3CHBzxhvA1vw9vwNrz9B2a9nfV21tvx9gdecMAJ4x14B96Bd+Ad7PNgvYP1DtY78A7u72SfJ/s82eeJd+KdeCfeiXeyz5P1Pqz3Yb30qubbi9nnh31+2Gd6VfPtxXgXXnrV6FWjV41eNXpV8+3Xu7i/9KrRq0avar79nifw0qtGrxq9avSq0atGrxq9qvn2603uL71q9KrRq5pvr/PgpVeNXjV61ehVo1eNXjV6VfPt17u5v/Sq0atGr2q+/Zyn5tuLG9zhAU/4gRcc8Ndb8+2X6VWnV51e1Xz7PU/DS686ver0qtOrTq86ver0qubbr7cPeMIPvGC8HS+96vSq06tOrzq96vSq06uab7/eETD7TK86var59nueiZdedXrV6VWnV51edXrV6VXn81Xn81WnV51edXrV+XzV+XzV6VWnV51edXrV6VWnV51e1Xz79S7uL73q9KrTq5pvv+cJvPSq06tOrzq96vSq06tOr2q+/XqD+0uvOr3q9Krm2+95Ei+96vSq06tOrzq96vSq06uab7/ezf2lV51edXpV8+11Hrz0atCrQa8GvRr0atCrQa9qvv14a769OOHvPg96VfPt9zwNL70a9GrQq0GvBr0a9GrQq5pvv97e4A4PeMJ4O156NejVoFeDXg16NejVoFc1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//DxPpc7POAJP/CCA054f/n06sN4H7wP3gfvg/fB++B98D54F96Fd+FdeBfehXfhXXgX3oU38AbewBt4A2/gDbyBN/AG3sSbeBNv4k28iTfxJt7Em3g33o134914N96Nd+PdeDfe/du77nz7hxvc4QFP+IEXHHDCeBvehrfhbXgb3oa34W14G96Gt+PteDvejrfj7Xg73o634+14B96Bd+AdeAfegXfgHXgH3oF34p14J96Jd+KdeCfeiXfinXgfvA/eB++D98H74H3wPngfvA/ehXfhXXgX3oV34V14F96Fd+ENvIE38AbewBt4A2/gDbyBN/Em3sSbeBNv4k28iTfxJt6Nd+PdeDfejXfj3Xg33o2XXjV61ehVo1eNXjV61ehVo1eNXjV61ehVo1eNXjV61ehVo1eNXjV61ehVo1eNXjV61ehVo1eNXjV61ehVo1eNXjV61ehVo1eNXjV61ehVo1eNXjV61ehVo1etepVvvr16//9prjvf/uEOD/h41zz8wMe74vDxvp+V1p1v//D+8u3V+7lp3fn2Dx9vnHPeXhVP+HjjrOX2qvh48zmc8P7y7VWe67y9Kj7ePNd2e7XP9dxeFR/vPvtwe1V8vPtcw+1V8f7y7dU+e357Vfz2vn6je3jAE34On2s7vfrw2/v67e7hhN/eeD+vrTvf/uEGH+/7GW3d+fYPH28/e3V69frt6+EFB3y8/VxP7i+fXr1++3q4wR0+3nHu6enVh493nr09vfpwwMc7z3WeXl2+8+3x/t+dWXe+Pd7/uzPrzrd/+HifdnjCx/v+/cC68+0fDvh4z/vozrcXn17FOtdwevXhDh/veY/c+fYPH+95X9z59g8f73sWa9359g/vL59evX5LebjBx3te83e+/cMTfuDjzbOW06sPH+95X9z59jjvhTvf/uEGH+95X9z59g8f73kv3Pn2Dy/4eM/74s63f/jtzfNeuPPtH25wP3yu8/Tqw29vnvfFnW9//Rbx8ILj8NmH06sPH28713B69eEGH+95T9359g8f73kv3Pn2Dy/4eMe5ttOrDx/vONd2evXh4539cIcHfLzzvFZPrz58vPd9cXqV971wevXh/eXTq7zvi9OrDx/vfS+cXn14wsd73xenVx8+3vteOL368P7y6VXe98Xp1YeP974vTq/y/Ly48+0fPt44e3V69eHjPT8j7nz7h/eXT6/yvqdOrz58vOdnxJ1v//CEj/e+R06vPny8931xevXht3e/f9e37nz7hxvcD/fDA56H5+Hn8HN4HV6HA87DcXh/uf3ADb7ePDzgCV/vPny87X79eM/PkTvf/vrt0+H95dOrfX6+3Pn2Dx/v+Zly59tfvzU6POEHXvDxntf/nW//8P7y6dWHj/f8vLjz7a/fAh0e8PE+P3/8+tP//pd//PVf/vVvf/lff/pv//f1x//xX//+b//517//e/3xP//Pf3z+5l//8de//e2v//Of/+Mff/+3v/z3//rHX/75b3//t/ff/emn/s8/rffL7fUxI/7860+vq/in139v/Pn1+g+N+frzeP/59QD86/UfhOf779/f8P4XZn69/6mY9xfOd7wem15HrPjzH+cU97yv186v1x7WWV6fCH+9Pp19zvF6w/x6vfA/Z3i9pn+9Xr/v7++f73+9l8/X7vc/P7/Wz+/vfp5f/f7xfPdqrz+O93eP93e/j3+v4ffxe/96PQW8/36+//587XU98/cZZvs1z/c/n+9/feVpn+9//a7+OYtbv7+97V/9nDF+f+m1TX2/v5TfL8VrC95f2p9Vzddra85Vq3p19XXl+/fOvl7ws/XvVa3XH/Ps6s/nwl7dfV3q5xteN+IoW/te2frV2/la/y7259d4ztd+b9Dr887svxf4Wu06f//doNcOrudzKa+q5BU9/58TfLeov+/Kn//4448///H/AA==",
      "brillig_names": [
        "discover_new_messages",
        "build_msg_block",
        "attach_len_to_msg_block",
        "debug_log_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "get_l1_to_l2_membership_witness",
        "notify_created_nullifier_oracle_wrapper",
        "storage_read",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_to_radix",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "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\n0wjG1j0HkTruZrSFZmQJ4zJievrMBCtdWDUY"
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "l1_portal",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "token_contract_class",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "shield_gateway_beacon",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "8459146718181593566": {
            "error_kind": "string",
            "string": "L1 portal address cannot be zero"
          },
          "8606784891595333955": {
            "error_kind": "string",
            "string": "Token contract class cannot be zero"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "get_l1_portal",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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uxhAdJEUtSIt6kVW5EWjaBaVY5VjlWOVY5VjlWOVY5VjlWOVY6UjBhVdJEWtSIt6kRV50SiaReWQckg5pBxSDimHlEPKIeWQckg5WjlaOVo5WjlaOVo5WjlaOVo5Wjm0HFoOLYeWQ8uh5dByaDm0HFqOXo5ejl6OXo5ejl6OXo5ejl6OXg4rh5XDymHlsHJYOawcVg4rh5XDy+Hl8HJ4ObwcXg4vh5fDy+HliDzXIClqRVrUi6zIi0bRLFpJsxyzHLMcsxyzHLMcsxyzHLMcsxyrHKscqxyrHKscqxyrHKscqxwrHTFw6SIpakVa1IusyItG0Swqh5RDyiHlkHJIOaQcUg4ph5RDytHK0crRytHK0crRytHK0crRytHKoeXQcmg5tBxaDi2HlkPLoeXQcvRy9HL0cvRy9HJEno8gLxpFd8e6Ba2kI88vkqJWpEW9yIq8aBSVw8rh5fByeDm8HF4OL4eXw8vh5fByjHKMcoxyjHKMcoxyjHKMcoxyjHLMcsxyzHLMcsxyzHLMcsxyzHLMcqxyrHKscqxyrHKscqxyrHKscqx0xOCoi6SoFWlRL7IiLxpFs6gcUg4ph5RDyiHlkHJIOaQcUg4pRytHK0crRytHK0crRytHK0crRyuHlkPLoeXQcmg5tBxaDi2HlkPL0cvRy9HL0cvRy9HL0cvRy1F5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXno/J8VJ6P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",
      "brillig_names": [
        "get_l1_portal"
      ]
    },
    {
      "name": "get_l1_token",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "aztec_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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kRb1IivyolE0i1bSkecXlWOVY5VjlWOVY5VjlWOVY6UjJhVdJEWtSIt6kRV50SiaReWQckg5pBxSDimHlEPKIeWQckg5WjlaOVo5WjlaOVo5WjlaOVo5Wjm0HFoOLYeWQ8uh5dByaDm0HFqOXo5ejl6OXo5ejl6OXo5ejl6OXg4rh5XDymHlsHJYOawcVg4rh5XDy+Hl8HJ4ObwcXg4vh5fDy+HlGOUY5Yg81yAt6kVW5EWjaBatpMjzk6SoHLMcsxyzHLMcsxyzHLMcqxyrHKscqxyrHKscqxyrHKscKx0xcekiKWpFWtSLrMiLRtEsKoeUQ8oh5ZBySDmkHFIOKYeUQ8rRytHK0crRytHK0crRytHK0crRyqHl0HJoObQcWg4th5ZDy6Hl0HL0cvRy9HL0cvRy9HL0ckSej6BZtJKOPF+3IClqRVrUi6zIi0bRLFpJXg4vh5fDy+Hl8HJ4ObwcXg4vxyjHKMcoxyjHKMcoxyjHKMcoxyjHLMcsxyzHLMcsxyzHLMcsxyzHLMcqxyrHKscqxyrHKscqxyrHKsdKR0yOukiKWpEW9SIr8qJRNIvKIeWQckg5pBxSDimHlEPKIeWQcrRytHK0crRytHK0crRytHK0crRyaDm0HFoOLYeWQ8uh5dByaDm0HL0cvRy9HL0cvRy9HL0cvRy9HL0cledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnk+Ks9H5fmoPB+V56Py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",
      "brillig_names": [
        "get_l1_token"
      ]
    },
    {
      "name": "get_l2_token",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_l2_token"
      ]
    },
    {
      "name": "is_registered_l1",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "is_registered_l1"
      ]
    },
    {
      "name": "is_registered_l2",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "aztec_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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K9IiK/KiXjSKZtFKOvL8onKscqxyrHKscqxyrHKscqx0xKSii6SoFWmRFXlRLxpFs6gcUg4ph5RDyiHlkHJIOaQcUg4pRytHK0crRytHK0crRytHK0crRyuHlkPLoeXQcmg5tBxaDi2HlkPLYeWwclg5rBxWDiuHlcPKYeWwcng5vBxeDi+Hl8PL4eXwcng5vBy9HL0cvRy9HL0cvRy9HL0cvRy9HKMcoxyR5xqkRVbkRb1oFM2ilRR5fpIUlWOWY5ZjlmOWY5ZjlmOWY5VjlWOVY5VjlWOVY5VjlWOVY6UjJi5dJEWtSIusyIt60SiaReWQckg5pBxSDimHlEPKIeWQckg5WjlaOVo5WjlaOVo5WjlaOVo5Wjm0HFoOLYeWQ8uh5dByaDm0HFoOK4eVw8ph5bByWDmsHJHnI2gWraQjz9ctSIpakRZZkRf1olE0i1ZSL0cvRy9HL0cvRy9HL0cvRy9HL8coxyjHKMcoxyjHKMcoxyjHKMcoxyzHLMcsxyzHLMcsxyzHLMcsxyzHKscqxyrHKscqxyrHKscqxyrHSkdMjrpIilqRFlmRF/WiUTSLyiHlkHJIOaQcUg4ph5RDyiHlkHK0crRytHK0crRytHK0crRytHK0cmg5tBxaDi2HlkPLoeXQcmg5tBxWDiuHlcPKYeWwclg5rBxWDitH5blXnnvluVeee+W5V5575blXnnvluVeee+W5V5575blXnnvluVeee+W5V5575blXnnvluVeee+W5V5575blXnnvluVeee+W5V5575blXnnvluVeee+W5V5575blXnnvluVeee+W5V5575blXnnvluVeee+W5V5575blXnvfK81553ivPe+V5rzzvlee98rxXnvfK81553ivPe+V5rzzvlee98rxXnvfK81553ivPe+V5rzzvlee98rxXnvfK81553ivPe+V5rzzvlee98rxXnvfK81553ivPe+V5rzzvlee98rxXnvfK81553ivPe+V5rzzvlee98rxXnvfK81553ivPe+V5rzzvlee98rxXnvfK81553ivPe+V5rzzvlee98rxXnvfK81553ivPe+V5rzzvlee98rxXnvfK81553ivPe+V5rzzvlee98rxXnvfK81553ivPe+V5rzzvlee98rxXnvfK81553ivPe+V5rzzvlee98rxXnvfK81553ivPe+X5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",
      "brillig_names": [
        "is_registered_l2"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7069518359247663558": {
            "error_kind": "string",
            "string": "Function _claim_public can only be called internally"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8459146718181593566": {
            "error_kind": "string",
            "string": "L1 portal address cannot be zero"
          },
          "8606784891595333955": {
            "error_kind": "string",
            "string": "Token contract class cannot be zero"
          },
          "11430482739715627628": {
            "error_kind": "string",
            "string": "Function _log_claim can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14788743618517749904": {
            "error_kind": "string",
            "string": "Function _register_public can only be called internally"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AhwCVCcCHQIxJwIeAk0nAh8CMC0IASAnAiEEHAAIASEBJwMgBAEAIiACIS0KISItDhYiACIiAiItDhIiACIiAiItDgQiACIiAiItDhciACIiAiItDhgiACIiAiItDgsiACIiAiItDhQiACIiAiItDgciACIiAiItDggiACIiAiItDhoiACIiAiItDhsiACIiAiItDhwiACIiAiItDgYiACIiAiItDhoiACIiAiItDh0iACIiAiItDggiACIiAiItDh4iACIiAiItDgoiACIiAiItDgkiACIiAiItDgkiACIiAiItDhQiACIiAiItDhMiACIiAiItDgoiACIiAiItDggiACIiAiItDgwiACIiAiItDh8iACIiAiItDg0iJwITBAEnAhYEAwAqExYULQgBEgAIARQBJwMSBAEAIhICFC0OExQAIhQCFC0OExQnAhQEAwAqEhQTLQoTFC0OAxQAIiACAwAiEgIWLQsWFCcCFwQCACoWFxM+LwADABMAFAAbKQIAAwA4lsJWJwITBBotCAAaLQoDGwAIABMAJQAAPmItAgAALQobEhwKEgMALQgBEicCEwQGAAgBEwEnAxIEAQAiEgITLQoTFC0ODxQAIhQCFC0OERQAIhQCFC0OEBQAIhQCFC0OGRQAIhQCFC0OAxQnAgMEFi0IABYtCgUXLQoOGC0KFRktChIaAAgAAwAlAABExi0CAAAAIgICDi0LDgUnAg8EAgAqDg8DOw4ABQADIwAAKOInAgICbicCAwJsJwIFAmMnAg4CVScCDwJrLQgBECcCEQQcAAgBEQEnAxAEAQAiEAIRLQoREi0ODhIAIhICEi0OAhIAIhICEi0ODxIAIhICEi0OAhIAIhICEi0OBhIAIhICEi0OBxIAIhICEi0OAhIAIhICEi0OCBIAIhICEi0OCRIAIhICEi0OChIAIhICEi0OAxIAIhICEi0OChIAIhICEi0OBRIAIhICEi0OBBIAIhICEi0OBhIAIhICEi0OCxIAIhICEi0OCBIAIhICEi0ODBIAIhICEi0OCRIAIhICEi0OChIAIhICEi0OAxIAIhICEi0OChIAIhICEi0OBRIAIhICEi0OBBIAIhICEi0OBhIAIhICEi0OCxIAIhICEi0ODRILIIBbgF8AAiQCAAIAACqBJwIDBB4tCAEEJwIFBB4ACAEFAS0KBAUqAwAF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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "register_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "aztec_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "name",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          },
          {
            "name": "name_len",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "symbol",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          },
          {
            "name": "symbol_len",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "decimals",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "8998099065237381256": {
            "error_kind": "string",
            "string": "Expected address did not match supplized token address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17288131482828810359": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18159344801564042747": {
            "error_kind": "string",
            "string": "Token already registered"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+ydB5gUxdr9B9hMzhgJJlDQ7t1lgxGzknOOm0iKilkxYMAEgkRBkpJBFETFrCBIzjkIiIqKCQWz4L9Lhs/ZsfdedM6Zr87/236eenZp99at+r2n3n5Pd01PkcDR46ErAoGXUo7+XsRrxYI/i3qtWti5Yz9Df4/1+bviPudK+pwr7XOurM+5Sl6rF3auqs/fVfM5V93nXA2fc2f5nDvbawlh587xOVfb51wdn3Pn+pw7z+ec43PO9TmX7HMuxedcqs+5uj7n0nzOpfucy/A5l+lz7nyfcxf4nLvQ59xFPucu9jl3ic+5ej7nLvU5d5nPuct9zl3hc+5Kn3NX+Zy72ufcNcFz5t/mqBr8afRm9GX0ZPRj9GL0YfRg4p8cjG9qMH5pwfhkBPmfH+R7YZDfxUE+9YLzvyw4vyuC478qOL5rgv//oWO81mfc9X3ONfA519DnXCOfc419zjXxOdfU51wzn3PNfc618DnX0udcK59zrX3OtfE519bnXDufc+19znXwOdfR51wnn3Odfc518TnX1edcN59zWT7nsn3O5ficy/U5l+dzrrvPuR4+53r6nOsVPBd6FAn+rBf8meKkpabmpifnuiluNyc5MyujrpNaNystw81w62bUzUnOSEnJzUjNSM/Mykx3Mt3UlFw3r25mSp5z9Gha7K++nIiO5GzmOJv963Gm1g0/Y8ZWzmsxIWM1HI4Ef68Z+Ov3WiG/Nwv+zbH/XXPv3y281tJrrYr9df7YUSyMgRPZ4Z4N7Kt5MVxsWsM05DhMfucA+2oB5NdGhF9tYF8tgfzaAvn55YbWIbmhTcjvbUN+bxWWG9p5/27vtQ5e6xiF3FAH2Fc7YGw6iWj7XGBf7YH8OovwOw/YVwcgvy7k3NApJAd0Dvm9S8jvHcNyQ1fv3928luW17CjkBgfYV1dgbHJEtO0C++oG5Jcrwi8Z2FcWkF8eOTfkhOSA3JDf80J+zw7LDd29f/fwWk+v9YpCbkgB9tUdGJveItpOBfbVA8jvOhF+dYF99QTyu56cG3qH5IDrQn6/PuT3XmG5oY/37xu8dqPXbopCbkgD9tUHGJu+ItpOB/Z1A5DfzSL8MoB93Qjkdws5N/QNyQE3h/x+S8jvN4Xlhlu9f9/mtdu9dkcUckMmsK9bgbG5U0Tb5wP7ug3I7y4RfhcA+7odyO9ucm64MyQH3BXy+90hv98Rlhv6ef++x2v3eu2+KOSGC4F99QPG5n4RbV8E7OseIL/+IvwuBvZ1L5DfA+TccH9IDugf8vsDIb/fF5YbHvT+/ZDXHvbagCjkhkuAfT0IjM0jItquB+zrISC/R0X4XQrs62Egv8fIueGRkBzwaMjvj4X8PiAsNzzu/fsJrw302qAo5IbLgH09DozNkyLavhzY1xNAfoNF+F0B7GsgkN8Qcm54MiQHDA75fUjI74PCcsNT3r+Hem2Y14ZHITdcCezrKWBsRoho+ypgX0OB/EaK8Lsa2NcwIL9R5NwwIiQHjAz5fVTI78PDcsPT3r9He22M156JQm64BtjX08DYjBXR9rXAvkYD+Y0T4Vcf2NcYIL/x5NwwNiQHjAv5fXzI78+E5YYJ3r8neu1Zrz0XhdzQANjXBGBsJolouyGwr4lAfpNF+DUC9vUskN8Ucm6YFJIDJof8PiXk9+fCcsNU79/TvDbdazOikBsaA/uaCozNTBFtNwH2NQ3Ib5YIv6bAvqYD+T1Pzg0zQ3LArJDfnw/5fUZYbpjt/fsFr73otTlRyA3NgH3NBsZmroi2mwP7egHI7yURfi2Afb0I5DePnBvmhuSAl0J+nxfy+5yw3PCy9+9XvPaq1+ZHITe0BPb1MjA2r4louxWwr1eA/F4X4dca2NerQH5vkHPDayE54PWQ398I+X1+WG540/v3W15722vvRCE3tAH29SYwNu+KaLstsK+3gPzeE+HXDtjX20B+C8i54d2QHPBeyO8LQn5/Jyw3LPT+/b7XFnltcRRyQ3tgXwuBsflARNsdgH29D+S3RIRfR2Bfi4D8lpJzwwchOWBJyO9LQ35fHJYblnn/Xu61FV5bGYXc0AnY1zJgbFaJaLszsK/lQH6rRfh1Afa1AshvDTk3rArJAatDfl8T8vvKsNyw1vv3Oq+t99qGKOSGrsC+1gJjs1FE292Afa0D8tskwi8L2Nd6IL/N5NywMSQHbAr5fXPI7xvCcsMW799bvbbNa9ujkBuygX1tAcZmh4i2c4B9bQXy2ynCLxfY1zYgvw/JuWFHSA7YGfL7hyG/bw/LDbu8f+/22h6vfRSF3JAH7GsXMDZ7RbTdHdjXbiC/j0X49QD2tQfI7xNybtgbkgM+Dvn9k5DfPwrLDZ96/97ntc+89nkUckNPYF+fAmPzhYi2ewH72gfkt1+EX29gX58B+X1Jzg1fhOSA/SG/fxny++dhueEr799fe+0br33rkxuKgmNzVgDH8wCOpxv6bnTTbzUyhwNAXX1H4vBdkENMGIPQowiYS5EAJ8cEsOPM+58OY4IQioYAqRnwPzD/53WTOf2m1SX1m07qN5PTb3oKqd9UEgdS3NJZOiPFLS2X1C9Jv8kOp9/UbE6/Ka4WB9p6yyP1m0Xql5XXSeuNpgcS3xTWeHO0+KaR8gPreiyXf0nX48L8G+y3MP/+ecjlX1beyQn1dccOtOGtievLYY2xFmGM+b6NzkCYGPjPoCO9S/I97i5JCnOcB0l3WdHjPPTvx5kcfsLvbub3xfy/Ne9gyPlDYXczf/D+/aPXfvLaz8G7maZVCJn/f2LiRHa4P4Dv8B47filGHPD/dA4Uh4FeMRCdW4YVApwFE8CM0z32SyiLX4PMfzuWAY/9NP9hV9i533zuR6OfmVSIPPjJweC7vwLvbf9Gyobh9/MjHSdyzr/7zPnf9hmqo9+D2vonGRHJBTGXY8fhYsQBm84LeuDzb/s/DHxIcwQoNhZDM8YiYIZHwMmgoBj/y8P9LThvZJyPFAOOM+/PIxepnz/AJc+xZPVHyMPHooG/Lnihh8rDR5vLTOY4fwNr43+OmP8ihEhFXSTmXw/c9Rt4uLcx//DzM6G/F4nJ722Ker8U81qM12Jj+AziYlDBc/M9QEMn3R+AySw+BjcuZmwS/v04U8JP+OkzLkSfph37PT7kfEKYPhO9X5K8VtxrJWL+8t7FAtGxgb+JJMVEnMacuJBxlgwGolTwZ+ngzzLBn2Vj8m9OKef9u7zXKnitotcqea2y16p47QSvnei1k7x2stdO8dqpXqvqtWpeq+61Gl47zWune+0Mr53ptbO8VtNrtbx2ttfO8Vptr9Xx2rleO89r5t6A67Vkr6V4LdVrdb2W5rV0r2V4LfPYrppj1YAZfLVAdG/mlIrhXL3OjyEO+PwYfL8XxHDthhPZ8ee8Lwi5HIL6daIpttIksV0YQxzwhQSxXWS52My8LxIXWxmS2C6OIQ74YoLYLrFcbGbelxDExhjrBcGFga5168VoLrKypEV2aQxxwJcSFtllli8yM+/LRBbZnwmLsMguj8HOu6BFFek4r/j340wNP+FnfEuFGNzSIb+XDfn9ijDje6X3y1Veu9pr18TwP14HvHq7VwLX5rXghBcem2tDYnBVyO9Xh/x+TVhs6nu/NPBaQ681igm7CQfUpckflxPWZWNgrM3cKwWicye9JCmfBKDjTM7g9e0kFwlhe+ymSxOPS1OvNfNac6+18FpLr7XyWmuvtfFaW6+181p7r3XwWkevdfJaZ6918VpXr3XzWpbXsr2W47Vcr+V5rbvXenitp9d6ea23167z2vVe6+O1G7x2o9du8lpfr93stVu8dqvXbgu/6dIk5q87gMfONfU518znXHOfcy18zrX0OdfK51xrn3NtfM619TnXzudce59zHXzOdfQ518nnXGefc118znX1OdfN51yWz7lsn3M5Pudyfc7l+Zzr7nOuh8+5nj7nevmc6+1z7jqfc9f7nOvjc+4Gn3M3+py7yedcX59zN/ucu8Xn3K0+524LSe7HjlrBn/WCP53IjnxJM9ILRxNAX7lHHxfnNcX1ldMM11dmc1xfbgtYX7luS1hf2W4rWF8ZbmtYX47bBtVXruO2RfWV7bjtUH1lOG57VF/m/bKgvnLNu1ZBfWWbd4OC+sow78kE9WVyYRdMX7mmr66YvrJNX90wfWWYvrIwff157ciG9JX7Z185kL6y/+wrF9JXxp995UH6Onqt7Y7oK/doXz0QfWUf7asnoq+Mo331QvQVrE16A/rKCfZ1HaCvrGBf1wP6Sg/21Sfyvv5nD/QNkfflHuvrxoj7ysg71tdNkfeVdayvvpH3daxedW+OuK/0/+nrloj7qvs/fd0acV/u//R1G+mmSPiOKhu8w7G+bsfN+c8dVegbVeYGYWPCjbs7wLFG75ozu3+aAGNj4nwHgeOdAhyRGm9C4ngXkKMZW/jNeROnYzfh74o5vk/r3e390s9r93jt3piCb847kR2u2eXWlMB0Um3uw8JIx2fmfDdh3pNrc65jMeC43w28jt0HXONA3bgqsSgPjMX9MZw1bNO68Mux94Xk1fuPM8f29355wGsPeu0hYo41u4ibEXLNFMtzrJlzf8K8p4qs6/7AtfgwMMcCdeOqxKICMBYDYjhr2KZ14ZdjHw7JqwOOM8c+4v3yqNce89rjxBxrPqXRnJBrplmeY82cHyHMe7rIun4EuBafAOZYoG5clVhUBMZiYAxnDdu0Lvxy7BMheXXgcebYQd4vT3ptsNeGEHOs+RRcC0KumWF5jjVzHkSY90yRdT0IuBafAuZYoG5clVhUAsZiaAxnDdu0Lvxy7FMheXXocebYYd4vw702wmsjiTnWfMq4JSHXzLI8x5o5DyPM+3mRdT0MuBZHAXMsUDeuSiwqA2PxdAxnDdu0Lvxy7KiQvPr0cebY0d4vY7z2jNfGEnOseYtDK0KumW15jjVzHk2Y9wsi63o0cC2OA+ZYoG5clVhUAcZifAxnDdu0Lvxy7LiQvDr+OHPsBO+XiV571mvPEXOseUtOa0KuedHyHGvmPIEw7zki63oC8vkzMMcCdeOqxOIEYCwmx3DWsE3rwi/HTgrJq5OPM8dO8X6Z6rVpXptOzLHmLWRtCLlmruU51sx5CmHeL4ms6ynI+3bAHAvUjasSixOBsZgZw1nDNq0Lvxw7IySvzjzOHDvL++V5r8322gvEHGve8tiWkGvmWZ5jzZxnEeb9ssi6noWsd4A5FqgbVyUWJwFjMSeGs4ZtWhd+OfbFkLw65zhz7Fzvl5e8Ns9rLxNzrHmLbjtCrnnF8hxr5jyXMO9XRdb1XOBafAWYY4G6cVVicTIwFq/GcNawTevCL8e+EpJXXz3OHDvf++U1r73utTeIOda8pbw9IdfMtzzHmjnPJ8z7NZF1PR+4Ft8E5ligblyVWJwCjMVbMZw1bNO68Muxb4bk1beOM8e+7f3yjtfe9dp7xBxrvgWiAyHXvG55jjVzfpsw7zdE1vXbwLW4AJhjgbpxVWJxKjAWC2M4a9imdeGXYxeE5NWFx5lj3/d+WeS1xV77gJhjzbfsdCTkmjctz7Fmzu8T5v2WyLp+H7gWlwBzLFA3rkosqgJjsTSGs4ZtWhd+OXZJSF5depw5dpn3y3KvrfDaSmKOrRbz13ucQ/uNlOnbludYM+dlhHm/I7KulwHX4ipgjgXqxlWJRTVgLFbHcNawTevCL8euCsmrq48zx67xflnrtXVeW0/MseZbIjsTcs27ludYM+c1hHm/J7Ku1wDX4gZgjgXqxlWJRXVgLDbGcNawTevCL8duCMmrG48zx27yftnstS1e20rMseZbeLsQcs0Cy3OsmfMmwrwXiqzrTcC1uA2YY4G6cVViUQMYi+0xnDVs07owazY8x24LyavbjzPH7vB+2em1D722i5hjzbecdyXkmvctz7FmzjsI814ksq53ANfibmCOBerGVYnFacBY7InhrGGb1oVfjt0dklf3HGeO/cj7Za/XPvbaJ8Qce3rMX9+DF9pvpEwXW55jzZw/Isz7A5F1/RFwLX4KzLFA3bgqsTgdGIt9MZw1bNO68Muxn4bk1X3HmWM/83753GtfeG0/MceeEfPX94qG9hvxs2bLc6yZ82eEeS8VWdefAdfil8AcC9SNqxKLM4Cx+CqGs4ZtWhd+OfbLkLz61XHm2K+9X77x2rdeO0DMsWfG/PU9zaH9Rsp0meU51sz5a8K8l4us66+Ba/E7YI4F6sZVicWZwFh8H8NZwzatC78c+11IXv3+OHPsQe+XQ177wWs/EnPsWTF/fe99aL+RMl1heY41cz5ImPdKkXV9ELgWfwLmWKBuXJVYnAWMxc8xnDVs07rwy7E/heTVn48zx/7i/fKr137z2u/EHFvT6ziXkGtWWZ5jzZx/Icx7tci6/gW4Fg8DcyxQN65KLGoCY3EkhrOGbVoXfjn2cEhePXKcOfYP80us99+8VjSWl2NreR3nEXLNGstzrJnzH4R5rxVZ138A12KxWNy4gLpxVWJRCxiLmFjOGrZpXfjlWKPBY7k0Jvb4cmys93dxXov3WgIxx57tddydkGvWWZ5jzZwNY3S/60XWdSxwLSYCcyxQN65KLM4G5tikWM4atmld+OXYxJC8mnScOba493clvFbSa6WIOfYcr+MehBy7wfIca+ZcnJBjN4qs6+LAtVgamGOBunFVYnEOMMeWieWsYZvWhV+OLR2SV8scZ44t6/1dOa+V91oFYo6t7XXck5BjN1meY82cyxJy7GaRdV0WuBYrAnMsUDeuSixqA3NspVjOGrZpXfjl2IohebXScebYyt7fVfHaCV47kZhj63gd9yLk2C2W51gz58qEHLtVZF1XBq7Fk4A5FqgbVyUWdYA59uRYzhq2aV345diTQvLqyceZY0/x/u5Ur1X1WjVijj3X67g3IcduszzHmjmfQsix21XeCw1ci9WBORaoG1clFucCc2yNWM4atmld+OXY6iF5tcZx5tjTvL873WtneO1MYo49z+v4OkKO3WF5jjVzPo2QY3eqfEYeuBbPAuZYoG5clVicB8yxNWM5a9imdeGXY88Kyas1jzPH1vL+7myvneO12sQc63gdX0/IsR9anmPNnGsRcuwulf1CwLVYB5hjgbpxVWLhAHPsubGcNWzTuvDLsXVC8uq5x5ljz/P+zvGa67VkYo51vY77EHLsbstzrJnzeYQcu0eldgKuxRRgjgXqxlWJhQvMsamxnDVs07rwy7EpIXk19ThzbF3v79K8lu61DGKOTfY6voGQYz+yPMeaOdcl5Ni9Iuu6LnAtZgJzLFA3rkoskoE59vxYzhq2aV345djMkLx6/nHm2Au8v7vQaxd57WJijk3xOr6RkGM/tjzHmjlfQMixn4is6wuAa/ESYI4F6sZViUUKMMfWi+WsYZvWhV+OvSQkr9Y7zhx7qfd3l3ntcq9dQcyxqV7HNxFy7KeW51gz50sJOXafyLq+FLgWrwTmWKBuXJVYpAJz7FWxnDVs07rwy7FXhuTVq44zx17t/d01XrvWa/WJObau13FfQo79zPIca+Z8NSHHfi6yrq8GrsUGwBwL1I2rEou6wBzbMJazhm1aF345tkFIXm14nDm2kfd3jb3WxGtNiTk2zev4ZkKO/cLyHGvm3IiQY/eLrOtGwLXYDJhjgbpxVWKRBsyxzWM5a9imdeGXY5uF5NXmx5ljW3h/19JrrbzWmphj072ObyHk2C8tz7Fmzi0IOfYrkXXdArgW2wBzLFA3rkos0oE5tm0sZw3btC78cmybkLza9jhzbDvv79p7rYPXOhJzbIbX8a2EHPu15TnWzLkdIcd+I7Ku2wHXYidgjgXqxlWJRQYwx3aO5axhm9aFX47tFJJXOx9nju3i/V1Xr3XzWhYxx2Z6Hd9GyLHfWp5jzZy7EHLsAZF13QW4FrOBORaoG1clFpnAHJsTy1nDNq0LvxybHZJXc44zx+Z6f5fnte5e6xGSY48dRcFxLhPA8cyN5Wi7GHjOiUBtlwL21RPIz+imQuCva0nogb5eI8cdOt5escQB94rF99sbmOhY8+4d+xdgUL9/is20ogG+2EIXrxPhwRxnqRjOorguRLf4t7kAqyYztmLBMR4btBFJbCA6WQkZgFBhXx9cQH3MnBgBuI6Qma4DX5pZ8y5KnHfEH60hM3QiO1wjzBsI9vFG8OX9WFIw/d4f7BfNog+JxU0kFjf9BxYRv9qAxOL7/93bKdn/ZXw0DRysbXceMBe+Gwi5FBhvF8nQFBVxAf/qM/APGfw3TYX2ycjfKCahBVbf/1QxOpEd7g2khBg66H84Zve//f+YMfclJIZDltzb+yeFTMT722LtTDCHanN0eXPIhfrfxue/MUfG55aQvtyUFG9t5KS7eTl5KXXTM5Oz3LSUtLS81Lz0tIzUnLy6qd1y0nPd1G4pyZm56U6em5Gbm143JTs9LS8zJzstLzRpuzkpKak5mVnZbt3ktG5ZTkZOSjcnLzU9JdnplpOSnpOTkpGW1i0lJSctIy8jMyM5uVteSoZTNz0900lLTslMZsXnlmB8ouk0E0lO89ag07xNJYGzxncrIVnfTrpw3U50NYbFbQQWd5BY3EF0NSxd/Gi5q2Fp4CfLXU0iydUA4+3+VOhqwg/3VpKruVPR1dxJdjV3EhLDz/8HXc1dsXYmmJ9JVfNdYq7mbqCr+QnoaljxuTvE1RR0UbD5dhRznKwLTD/FC0w/8gWmH+EC8wvpAhMLHicygd0D7At52wx5sfqFlAzvOY6LVaRM743FXRTy3Taz6GLFis+9/x/dgrsvmETu99vs4UR2uAVtekDu4on4u0eAlTAj8McYFhNhGGlf/S2Ph1kw/QlFwgOkgukB4u3a+0ksHiSxeJB4u5ali98tv13L0sBhgdu1/Qm3a4Hxdg8X3q4NP/7M3ygmoYXfQ0w33Z+UEB8iumkz5ocIieGIyO3a/sCi6OFYOxPMEZLDejgKt2uR8RkAvF17GOiAWfEZ8L/ggFkfd3gk6IAfVUngrPE9QkjWj5EuXI8RXY1h8SiBxeMkFo8TXQ1LF4E6drsalgaK1LE7D5QiuRpgvF0kw/9fXM0jJFfzhKKreYLsap4gJIai4MRw7LDZ1QyMtTPBIGMRqsuBYq5mENDVhCbtSF0NKz6D/hc2odwXy1n3KheYJxUvME+SLzBPEi4wxUgXmFjwOJEJbDCwL+RtM+TFqhgpGQ6OwiaUIcBNKIdr23mxYsVniE980HsEgJtO3DLA90g9Bczr0XyP1FOki+jQWOKAh8bi+x0GTMyseQ+L/QswqN+ovkeqjMh7pJA720IXxfBY4nukhgGta2hWPzbo/x+2Fo4ILqCRsYT3SJkADCdkpuHkBzWoeRclzjvSMY6y/GGXEeYogsV6mmQ3nyY+7BpJYjGaxGI08WEXSxdxlj/sYmkg3vKHXebCN4qQS4HxduMLH3aFH3/mbxST0AJrDPNe5ChSQhxDvBdpxjyGkBgSRB52jQIWRc/E2plgEkj3p56JwsMuZHzGAh92xQPvH7LiM/Z/YQtfGZLTHBd0muNVEjhrfOMIyXoC6cI1gehqDIvxBBYTSSwmEl0NSxdJlrsalgaKW+5qypBcDTDebvFCVxN+uONIruZZRVfzLNnVPEtIDCX+D7qa52LtTDAlSFXzc2KuZhLQ1RQHuhpWfCb9L2zhGxHLWfcqF5jJiheYyeQLzGTCBaakyBY+ZAKbAuwLedsMebEqSUqGU6KwhW8qcAtfvttmFl2sWPGZ+v/RLbhpwSQy3W+zhxPZ4Ra06QG5iyfSvoAbRyjvLTrGEL1HlMUw0r5mWB4Ps2BmEIqEmaSCaSbxdu10EotZJBaziLdrWbooY/ntWpYGygrcrp1BuF0LjLdbtvB2bfjxZ/5GMQkt/J5nuukZpIT4PNFNmzE/T0gM5URu184AFkWzY+1MMOVIDmt2FG7XIuPzAvB2bVmgA2bF54X/BQfM+rjDi0EHPEclgbPG9yIhWc8lXbjmEl2NYTGHwOIlEouXiK6GpYsKlrsalgYqCmytZ7gaYLzdioWuJvxwXyS5mnmKrmYe2dXMIySGSv8HXc3LsXYmmEqkqvllMVfzCtDVVAS6GlZ8Xvlf2IQyLZaz7lUuMK8qXmBeJV9gXiVcYCqLbEJBJrD5wL6Qt82QF6vKpGQ4PwqbUF4DbkIpW8fOixUrPq8R74Bc4gX6shh8DnqdfBcMkXte99lr4UR2IK9D7uvAnPaG5fEw7xR8g3AtfBO8x6QoeHzmLgxyjKWC/QWwuqbcgSodHCs65m8BtR7Nd8+9RSq8344lDvjtWHy/7wATH2ve7/wfX2TvktwsOsEitfSe5ReTol6skWM0MX5PROfGsbDW5LGDMWbUOM2FqlLgr4KWOe6aAQ5fbOySeX27f11gzc9qwd8XePpb6LX3vbbIa4u99oHXlnhtqdeWeW2511Z4baXXVnlttdfWeG2t19Z5bb3XNnhto9c2eW2z17Z4bavXtnltu9d2eG2n1z702i6v7fbanmObM465RjOYhLBzC33Ove9zbpHPucU+5z7wObfE59xSn3PLfM4t9zm3wufcSp9zq3zOrfY5t8bn3Fqfc+t8zq33ObfB59xGn3ObfM5t9jm3xefcVp9z23zObfc5t8Pn3E6fcx/6nNvlc263z7k9wXOhR/Xgz3rBn05kR76kE+mFcgGgKMjNM4fjLgT1Zeb4PqSvo7wWRd5X8rHn2Ysj7Sv1r2fjH0TWlxP6nH1JJH0l539mv/Tf9+WEP/9f9i/78m5K/m0vwfJ/11eG376EFf+mrwz/PQ4r/3lf6QXtl1j1T/tKL3jvxep/1lfyf9rHseaf9JX+n/eErD3+vv7rnqV1x9tX+n/Nhe764+vLOY686m44nr6c48rR7sb/3lfd48z37qb/1lfqcV873M3/sa/UvH9wHXK3/Ke+0v/RNc3dWnBfGf/w+uhuK6CvzLx/fK11t/v35fyL67a7w68v51/VAO7Ov/fl/st6wv0wvK+cf12buLvy95USQZ3j7g7pKzkvoprJ3SN6V3UPrNbLcUPH+1EsccCmc9TdoWOD/wgXQHcvACrzDq1huBd41/MYw73gRVAxEJ29R7jFm0O9qxLK4uPgAvsk/M7Gx8HAhp77xMeBop/t4jKJ434MXECfgIOLFp9ZNB8DF+OxeX8sekXaDdNRZk7oeD+NJQ74U/gVKTPnU+AVaZ/lVyTDcB/8ipSZs0/0irQbNu7MbJ/hUq5InwUX2OfhV6TPfK5In0fhirQbeEX6DLiAPicFF/3AFDnnL4DJLBDAXy33BhNQUbAGkVZgPzCZ+TF0IjtcE+P9hEpmv2glswuWf7JSQsf7ZSxxwF/CK5mslC+Bi/8ryysZw/AreCWTlfIVefEjEuh+yxPo12CGxw70hRep8W+Aay+aFfAu2Lizkn2GS6mAvw0m5gPhFfC3PhXwgShUwLgrkON+CxTlAVJw0QsROefvyBWwE9nhmuT4DaF6+97yqtXE5XuBebM0/j1Q4wct13hBRQqi+EH1dQh8wY6W2/kQdq3JyAsd7w+xxAH/AHc7GXk/AAP4o+VuxzD8Ee52MvJ+tNztmER3KNbuZPwTOBkfO9BzRmr8Z1G38yFs3Bm5PsOluJ1fgon513C384uP2/k1Cm4HdwVy3F+AovyVFFz0QkTO+TfLK0GTHH8mVP2/W+52TFx+F5g3S+O/AzV+2HKNF1SkOJEdLrJIOSL6bGcn7FqTnO/T6H/EEgf8B9ztJDt/IBdBnN1uxzA0Y8S6nWQndN5OhIffvBGJ7kis3cm4SBw2GR870HNGarwocM7RdDs7YTnDzfMZLsXtFIs7+jMmLpDf2RSL+7vbMX/Edjs7gW6nGFCUMXGc4KIXInLOseDkg15wJjkWjcNfGOLIFy4nssM1cYkTmDdL43FAjcdbrvGCihQnssNFFikJQN1E0+3sgF1rcvK5ncQ44oBN51i3k+MkAhdBkuVuxzBMgrudHCfJcrdjEl1CnN3JuLiI20FqvISo29kBczvZUXM7JYOJuVS42ynp43ZKRcHt7AC6nZJAUZaK4wQXvRCRcy5teSVokmMJQtVfxnK3Y+JSRmDeLI2XAWq8rOUaL6hIcSI7XGSRUk7U7WyHXWvS8r0To3wcccDl4W4nzS0PXAQVLHc7hmEFuNtJyzdvJ8LDb96IRFcuzu5kXFHE7SA1XknU7WyHuZ20qL1LpXIwMVcJdzuVfdxOlSi4ne1At1MZKMoqcZzgohcics4nWF4JmuRYiVD1n2i52zFxOVFg3iyNnwjU+EmWa7ygIsWJ7HCRRcrJom5nG+7ZTkboeE+JIw74FPyznYxTgIvgVMvdjmF4Kv7ZTsaplrsdk+hOjrM7GVcVcTtIjVcTdTvbYG4nJ91nuBS3Uz2YmGuEu53qPm6nRhTczjag26kOFGWNOE5w0QsROefTLK8ETXKsRqj6T7fc7Zi4nC4wb5bGTwdq/AzLNV5QkeJEdrjIIuVMUbezFXatSc0MHe9ZccQBnwV3O6mZZwEXQU3L3Y5hWBPudlIza1rudkyiOzPO7mRcS8TtIDV+tqjb2QpzO6kZPsOluJ1zgom5drjbOcfH7dSOgtvZCnQ75wBFWTuOE1z0QkTOuY7llaBJjmcTqv5zLXc7Ji7nCsybpfFzgRo/z3KNF1SkOJEdLrJIcUTdzhbcG6jz7WRz44gDduFuJ8t1gYsg2XK3Yxgmw91OVr55OxEefvNGJDonzu5knCLidpAaTxV1O1twLymO2k62usHEnBbudur6uJ20KLidLUC3UxcoyrQ4TnDRCxE553TLK0GTHFMJVX+G5W7HxCVDYN4sjWcANZ5pucYLKlKcyA4XWaScL+p2NuPcTnboeC+IIw74Arzbyb4AuAgutNztGIYX4t1O9oWWux2T6M6PszsZXyTidpAav1jU7WzGuZ0sn+FS3M4lwcRcL9ztXOLjdupFwe1sBrqdS4CirBfHCS56ISLnfKnllaBJjhcTqv7LLHc7Ji6XCcybpfHLgBq/3HKNF1SkOJEdLrJIuULU7WzC7WTLCh3vlXHEAV+J38mWdSVwEVxludsxDK/C72TLuspyt2MS3RVxdifjq0XcDlLj14i6nU24nWzdfIZLcTvXBhNz/XC3c62P26kfBbezCeh2rgWKsn4cJ7johYiccwPLK0GTHK8hVP0NLXc7Ji4NBebN0nhDoMYbWa7xgooUJ7LDRRYpjUXdzkbct4vmewN1kzjigJvA3U6G0wS4CJpa7nYMw6Zwt5PhNLXc7ZhE1zjO7mTcTMTtIDXeXNTtbIS5nfQ8n+FS3E6LYGJuGe52Wvi4nZZRcDsbgW6nBVCULeM4wUUvROScW1leCZrk2JxQ9be23O2YuLQWmDdL462BGm9jucYLKlKcyA4XWaS0FXU7G0hup10cccDtCG6nHXARtLfc7RiG7Qlup73lbsckurZxdifjDiJuB6nxjqJuZ4Og2+kUTMydw91OJx+30zkKbmcD0O10Aoqys4jbQc65i+WVoEmOHQlVf1fL3Y6JS1eBebM03hWo8W6Wa7ygIsWJ7HCRRUqWqNtZD7vWdMv3TrbsOOKAs+Fup1tmNnAR5FjudgzDHLjb6ZaZY7nbMYkuK87uZJwr4naQGs8TdTvrYW6nW9TeydY9mJh7hLud7j5up0cU3M56oNvpDhRljzhOcNELETnnnpZXgiY55hGq/l6Wux0Tl14C82ZpvBdQ470t13hBRYoT2eEii5TrRN3OOpzbSQ0d7/VxxAFfj3c7qdcDF0Efy92OYdgH73ZS+1judkyiuy7O7mR8g4jbQWr8RlG3sw7ndlJ8hktxOzcFE3PfcLdzk4/b6RsFt7MO6HZuAoqybxwnuOiFiJzzzZZXgiY53kio+m+x3O2YuNwiMG+Wxm8BavxWyzVeUJHiRHa4yCLlNlG3sxb37aL5nu3cHkcc8O1wt5OTeTtwEdxhudsxDO+Au52czDssdzsm0d0WZ3cyvlPE7SA1fpeo21mL+3bRqD3buTuYmPuFu527fdxOvyi4nbVAt3M3UJT94jjBRS9E5JzvsbwSNMnxLkLVf6/lbsfE5V6BeR87ihLHGWlf91mu8YKKFCeyw0UWKfeLup01sGtNdm7oePvHEQfcH+52snP7AxfBA5a7HcPwAbjbyc59wHK3YxLd/XF2J+MHRdwOUuMPibqdNTC3k53jM1yK23k4mJgHhLudh33czoAouJ01QLfzMFCUA+I4wUUvROScH7G8EjTJ8SFC1f+o5W7HxOVRgXmzNP4oUOOPWa7xgooUJ7LDRRYpj4u6ndWwa42b79nOE3HEAT8Bdztu5hPARTDQcrdjGA6Eux03c6Dlbsckusfj7E7Gg0TcDlLjT4q6ndUwt+NG7dnO4GBiHhLudgb7uJ0hUXA7q4FuZzBQlEPiOMFFL0TknJ+yvBI0yfFJQtU/1HK3Y+IyVGDeLI0PBWp8mOUaL6hIcSI7XGSRMlzU7azCfbtoPrczIo444BFwt5OVOQK4CEZa7nYMw5Fwt5OVOdJyt2MS3fA4u5PxKBG3g9T406JuZxXu20Wj5nZGBxPzmHC3M9rH7YyJgttZBXQ7o4GiHBPHCS56ISLn/IzllaBJjk8Tqv6xlrsdE5exAvNmaXwsUOPjLNd4QUWKE9nhIouU8aJuZyXuDdQZoeOdEEcc8AS428nImABcBBMtdzuG4US428nImGi52zGJbnyc3cn4WRG3g9T4c6JuZyXM7WSk+wyX4nYmBRPz5HC3M8nH7UyOgttZCXQ7k4CinBzHCS56ISLnPMXyStAkx+cIVf9Uy92OictUgXmzND4VqPFplmu8oCLFiexwkUXKdFG3swJ2rUnN53ZmxBEHPAPudlIzZgAXwUzL3Y5hOBPudlIzZlrudkyimx5ndzKeJeJ2kBp/XtTtrIC5ndSouZ3ZwcT8Qrjbme3jdl6IgttZAXQ7s4GifCGOE1z0QkTO+UXLK0GTHJ8nVP1zLHc7Ji5zBObN0vgcoMbnWq7xgooUJ7LDRRYpL4m6neWwa02mGzreeXHEAc+Du51Mdx5wEbxsudsxDF+Gu53MfPN2Ijz85o1IdC/F2Z2MXxFxO0iNvyrqdpbD3E6m4zNcituZH0zMr4W7nfk+bue1KLid5UC3Mx8oytfiOMFFL0TknF+3vBI0yfFVQtX/huVux8TlDYF5szT+BlDjb1qu8YKKFCeyw0UWKW+Jup1lsGtNuhM63rfjiAN+G+520p23gYvgHcvdjmH4DtztpDvvWO52TKJ7K87uZPyuiNtBavw9UbezDOZ20vJ8hktxOwuCiXlhuNtZ4ON2FkbB7SwDup0FQFEujOMEF70QkXN+3/JK0CTH9whV/yLL3Y6JyyKBebM0vgio8cWWa7ygIsWJ7HCRRcoHom5nKe4tBfneQL0kjjjgJXC3k5W7BLgIllrudgzDpXC3k5W71HK3YxLdB3F2J+NlIm4HqfHlom5nKe4tBVF7A/WKYGJeGe52Vvi4nZVRcDtLgW5nBVCUK+M4wUUvROScV1leCZrkuJxQ9a+23O2YuKwWmDdL46uBGl9jucYLKlKcyA4XWaSsFXU7S2DXmuR8z3bWxREHvA7udpKddcBFsN5yt2MYroe7nWRnveVuxyS6tXF2J+MNIm4HqfGNom5nCe4N1Hk+w6W4nU3BxLw53O1s8nE7m6PgdpYA3c4moCg3x3GCi16IyDlvsbwSNMlxI6Hq32q52zFx2Sowb5bGtwI1vs1yjRdUpDiRHS6ySNku6nY+wF1rskPHuyOOOOAdcLfjZO8ALoKdlrsdw3An3O042Tstdzsm0W2PszsZfyjidpAa3yXqdj6AuR0ny2e4FLezO5iY94S7nd0+bmdPFNwO8Ark7gaKck8cJ7johYic80eWV4ImOe4iVP17LXc7Ji57BebN0vheoMY/tlzjBRUpTmSHiyxSPhF1O4th15q0fDvZPo0jDvhTuNtJy/0UuAj2We52DMN9cLeTlrvPcrdjEt0ncXYn489E3A5S45+Lup3FuM/tRG0n2xfBxLw/3O184eN29kfB7SwGup0vgKLcH8cJLnohIuf8peWVoEmOnxOq/q8sdzsmLl8JzJul8a+AGv/aco0XVKQ4kR0uskj5RtTtLIJda9x872T7No444G/hbsd1vwUuggOWux3D8ADc7bj55u1EePjNG5HovomzOxl/J+J2kBr/XtTtLMLtZIvaO9kOBhPzoXC3c9DH7RyKgttZBHQ7B4GiPBTHCS56ISLn/IPllaBJjt8Tqv4fLXc7Ji4/CsybpfEfgRr/yXKNF1SkOJEdLrJI+VnU7byP24yR73M7v8QRB/xLHL7fXy13KGbev8b9BRjUL8VVmITyc5zdSe83EVeB1OXv5ESPiMnvBI1HM6EuJCXUw3HEAR8mJNQjlidUM+8jUUqoTmSHaxbGkTjOgkPNO5qLbEEsjkHoeP+IIw74D8IV8Q9kRo+3e8EahmaM6EUQOm8nwsNv3ohFasaItj+/ARN0kXi7E6jRjhljANsv1eIXAa7HovHAPEGIT0GOwYnscJGOoZjlGjcxLhaP7xepQ1MkVAr8dcs89ECPu1eAs84D0HEmU59zFAlhWy34e4wXz1ivxXkt3msJXkv0WpLXinuthNdKeq2U10p7rYzXynqtnNfKe62C1yp6rZLXKnutitdO8NqJXjvJayd77RSvneq1ql6r5rXqXqvhtdPiA/mfp5jBJISdi/U5F+dzLt7nXILPuUSfc0k+54r7nCvhc66kz7lSPudK+5wr43OurM+5cj7nyvucq+BzrqLPuUo+5yr7nKvic+4En3Mn+pw7yefcyT7nTvE5d6rPuao+56r5nKvuc66Gz7nT4v/+7K568Ge94E8nsiNf0ok4WQIS77HngLGgvswc4yB9HeUVH3lfyUFebkKkfaX+D3s3MbK+nJA4ukmR9JWcTxNu8X/flxOmL7fEv+wrLe9vWnVL/ru+Mnx075b6N31l+K4ht/Q/7yu9gPXolvmnfaUXuLbdsv+sr+T/kCfccv+kr/T/mHPc8sffV/Z/yV9uhePtK/2/5kK34vH15RxHXnUrHU9fznHlaLfyf++r7nHme7fKf+sr9bivHe4J/7Gv1Lx/cB1yT/xPfaX/o2uae1LBfWX8w+uje3IBfWXm/eNrrXuKf1/Ov7huu6f69eX8qxrArfr3vtx/WU+41cL7yvnXtYlbPX9fKRHUOW6NkL6S8yKqmdzTgCY9mne0T4PVejn5dh2fHk8c8Onx6F3HOe7puAC6ZwCgMu9oG4ZnAO9oH2N4BngRRGv3KG7x5kRt9+iZwQV2VvidjTPj/7579Kx4/u5RXCZx3DOBC+gscHDR4jOL5kzgYjw27zNFr0g1YDrKzAkdb8144oBrwq9ImTk1gVekWpZfkQzDWvArUmZOLdErUg3YuDOzfYZLuSKdHVxg54Rfkc72uSKdE4UrUg3gFels4AI6hxRc9INg5JxrA5NZIIC/Wp4RTEDoB8FIK1AHmMz8GDqRHa6JcR1CJVNHtJKpDss/WSmh4z03njjgc+GVTFbKucDFf57llYxheB68kslKOY+8+BEJtI7lCdQBMzx2oC+8SI27wLUXzQq4OmzcWck+w6VUwMnBxJwSXgEn+1TAKVGogHFXIMdNBooyhRRc9EJEzjmVXAE7kR2uSY4uoXqra3nVauJSV2DeLI3XBWo8zXKNF1SkIIofVF/p4At2tNxONdi1JiMvdLwZ8cQBZ8DdTkZeBjCAmZa7HcMwE+52MvIyLXc7JtGlx9udjM8HJ+NjB3rOSI1fIOp2qsHGnZHrM1yK27kwmJgvCnc7F/q4nYui4HZwVyDHvRAoyotIwUUvROScL7a8EjTJ8QJC1X+J5W7HxOUSgXmzNH4JUOP1LNd4QUWKE9nhIouUS0Wf7VSFXWvyf+/4ZfHEAV8GdzvJzmXARXC55W7HMLwc7naSncstdzsm0V0ab3cyvkLE7SA1fqWo26kKG3f0vnf8qmBivjrc7Vzl43aujoLbwV2BHPcqoCivJgUXvRCRc77G8krQJMcrCVX/tZa7HROXawXmzdL4tUCN17dc4wUVKU5kh4ssUhqIup1TYdeanHxup2E8ccAN4W4nx2kIXASNLHc7hmEjuNvJcRpZ7nZMomsQb3cybizidpAabyLqdk6FjTs7am6naTAxNwt3O0193E6zKLgd3BXIcZsCRdmMFFz0QkTOubnllaBJjk0IVX8Ly92OiUsLgXmzNN4CqPGWlmu8oCLFiexwkUVKK1G3cwrsWpOW750YreOJA24NdztpbmvgImhjudsxDNvA3U5avnk7ER5+80YkulbxdifjtiJuB6nxdqJu5xTYuNOi9i6V9sHE3CHc7bT3cTsdouB2cFcgx20PFGUHUnDRCxE5546WV4ImObYjVP2dLHc7Ji6dBObN0ngnoMY7W67xgooUJ7LDRRYpXUTdzsm4ZzsZoePtGk8ccFf8s52MrsBF0M1yt2MYdsM/28noZrnbMYmuS7zdyThLxO0gNZ4t6nZOho07J91nuBS3kxNMzLnhbifHx+3kRsHt4K5AjpsDFGUuKbjohYicc57llaBJjtmEqr+75W7HxKW7wLxZGu8O1HgPyzVeUJHiRHa4yCKlp6jbOQl2rUnNDB1vr3jigHvB3U5qZi/gIuhtudsxDHvD3U5qZm/L3Y5JdD3j7U7G14m4HaTGrxd1OyfBxp2a4TNcitvpE0zMN4S7nT4+bueGKLgd3BXIcfsARXkDKbjohYic842WV4ImOV5PqPpvstztmLjcJDBvlsZvAmq8r+UaL6hIcSI7XGSRcrOo2zkRdq3JyreT7ZZ44oBvgbudLPcW4CK41XK3YxjeCnc7Wfnm7UR4+M0bkehujrc7Gd8m4naQGr9d1O2cCBt3VtR2st0RTMx3hrudO3zczp1RcDu4K5Dj3gEU5Z2k4KIXInLOd1leCZrkeDuh6r/bcrdj4nK3wLxZGr8bqPF+lmu8oCLFiexwkUXKPaJu5wSc28kOHe+98cQB34t3O9n3AhfBfZa7HcPwPrzbyb7PcrdjEt098XYn4/tF3A5S4/1F3c4JuII4y2e4FLfzQDAxPxjudh7wcTsPRsHt4K5AjvsAUJQPkoKLXojIOT9keSVokmN/QtX/sOVux8TlYYF5szT+MFDjAyzXeEFFihPZ4SKLlEdE3U4V3E62rNDxPhpPHPCj+J1sWY8CF8Fjlrsdw/Ax/E62rMcsdzsm0T0Sb3cyflzE7SA1/oSo26mC2+zUzWe4FLczMJiYB4W7nYE+bmdQFNwO7grkuAOBohxECi56ISLn/KTllaBJjk8Qqv7BlrsdE5fBAvNmaXwwUONDLNd4QUWKE9nhIouUp0TdTmXYtSYj3xuoh8YTBzwU7nYynKHARTDMcrdjGA6Du50MZ5jlbsckuqfi7U7Gw0XcDlLjI0TdTmXYuNOj9gbqkcHEPCrc7Yz0cTujouB2cFcgxx0JFOUoUnDRCxE556ctrwRNchxBqPpHW+52TFxGC8ybpfHRQI2PsVzjBRUpTmSHiyxSnhF1O5VIbmdsPHHAYwluZyxwEYyz3O0YhuMIbmec5W7HJLpn4u1OxuNF3A5S4xNE3U4lQbczMZiYnw13OxN93M6zUXA7uCuQ404EivJZEbeDnPNzlleCJjlOIFT9kyx3OyYukwTmzdL4JKDGJ1uu8YKKFCeyw0UWKVNE3U5F2LWmW753sk2NJw54KtztdMucClwE0yx3O4bhNLjb6ZY5zXK3YxLdlHi7k/F0EbeD1PgMUbdTETbublF7J9vMYGKeFe52Zvq4nVlRcDu4K5DjzgSKchYpuOiFiJzz85ZXgiY5ziBU/bMtdzsmLrMF5s3S+Gygxl+wXOMFFSlOZIeLLFJeFHU7FXBuJzV0vHPiiQOeg3c7qXOAi2Cu5W7HMJyLdzupcy13OybRvRhvdzJ+ScTtIDU+T9TtVMAVxCk+w6W4nZeDifmVcLfzso/beSUKbgd3BXLcl4GifIUUXPRCRM75VcsrQZMc5xGq/vmWux0Tl/kC82ZpfD5Q469ZrvGCihQnssNFFimvi7qd8rBrTU6+ZztvxBMH/Abc7eRkvgFcBG9a7nYMwzfhbicn803L3Y5JdK/H252M3xJxO0iNvy3qdsrDxp0TtWc77wQT87vhbucdH7fzbhTcDu4K5LjvAEX5Lim46IWInPN7lleCJjm+Taj6F1judkxcFgjMm6XxBUCNL7Rc4wUVKU5kh4ssUt4XdTvlYNea7NzQ8S6KJw54EdztZOcuAi6CxZa7HcNwMdztZOcuttztmET3frzdyfgDEbeD1PgSUbdTDjbu7Byf4VLcztJgYl4W7naW+ridZVFwO7grkOMuBYpyGSm46IWInPNyyytBkxyXEKr+FZa7HROXFQLzZml8BVDjKy3XeEFFihPZ4SKLlFWibqcs7Frj5nu2szqeOODVcLfjZq4GLoI1lrsdw3AN3O24mWssdzsm0a2KtzsZrxVxO0iNrxN1O2Vh43aj9mxnfTAxbwh3O+t93M6GKLgd3BXIcdcDRbmBFFz0QkTOeaPllaBJjusIVf8my92OicsmgXmzNL4JqPHNlmu8oCLFiexwkUXKFlG3UwZ2rcnK53a2xhMHvBXudrIytwIXwTbL3Y5huA3udrIyt1nudkyi2xJvdzLeLuJ2kBrfIep2ysDGnRU1t7MzmJg/DHc7O33czodRcDu4K5Dj7gSK8kNScNELETnnXZZXgiY57iBU/bstdzsmLrsF5s3S+G6gxvdYrvGCihQnssNFFikfibqd0rBrTUZG6Hj3xhMHvBfudjIy9gIXwceWux3D8GO428nI+Nhyt2MS3UfxdifjT0TcDlLjn4q6ndKwcWek+wyX4nb2BRPzZ+FuZ5+P2/ksCm4HdwVy3H1AUX5GCi56ISLn/LnllaBJjp8Sqv4vLHc7Ji5fCMybpfEvgBrfb7nGCypSnMgOF1mkfCnqdkrBrjWp+dzOV/HEAX8FdzupGV8BF8HXlrsdw/BruNtJzfjacrdjEt2X8XYn429E3A5S49+Kup1SsHGnRs3tHAgm5u/C3c4BH7fzXRTcDu4K5LgHgKL8jhRc9EJEzvl7yytBkxy/JVT9By13OyYuBwXmzdL4QaDGD1mu8YKKFCeyw0UWKT+Iup2SsGtNphs63h/jiQP+Ee52Mt0fgYvgJ8vdjmH4E9ztZOabtxPh4TdvRKL7Id7uZPyziNtBavwXUbdTEjbuTMdnuBS382swMf8W7nZ+9XE7v0XB7eCuQI77K1CUv5GCi16IyDn/bnklaJLjL4Sq/7DlbsfE5bDAvFkaPwzU+BHLNV5QkeJEdrjIIuUPUbdTAnatSXfyjTeBOGDTOdbtpDumT9QYiyTY7XYMQzNGrNvxBJDAvWggEt0f8XYn46IJ2GR87EDPGanxYsA5R9PtlIAl/bQ8n+FS3E5MMDHHJgTyO5uYhL+7HfNHbLdTAuh2YoCijE3gBBe9EJFzjgMnH/SCM8mxWAL+whBPvnA5kR2uiUu8wLxZGo8HajzBco0XVKQ4kR0uskhJBOommm6nOOxak5XvDdRJCcQBJ8HdTlZuEnARFLfc7RiGxeFuJyu3uOVuxyS6xAS7k3EJEbeD1HhJUbdTHOZ2sqL2BupSwcRcOtztlPJxO6Wj4HaKA91OKaAoSydwgoteiMg5l7G8EjTJsSSh6i9rudsxcSkrMG+WxssCNV7Oco0XVKQ4kR0uskgpL+p2kmDXmuR8z3YqJBAHXAHudpKdCsBFUNFyt2MYVoS7nWSnouVuxyS68gl2J+NKIm4HqfHKom4nCeZ23Kg926kSTMwnhLudKj5u54QouJ0koNupAhTlCQmc4KIXInLOJ1peCZrkWJlQ9Z9kudsxcTlJYN4sjZ8E1PjJlmu8oCLFiexwkUXKKaJuJxF3rckOHe+pCcQBnwp3O072qcBFUNVyt2MYVoW7HSe7quVuxyS6UxLsTsbVRNwOUuPVRd1OIm77cpbPcClup0YwMZ8W7nZq+Lid06LgdoBXILcGUJSnJXCCi16IyDmfbnklaJJjdULVf4blbsfE5QyBebM0fgZQ42darvGCihQnssNFFilnibqdBNi1Ji3fTraaCcQB14S7nbTcmsBFUMtyt2MY1oK7nbTcWpa7HZPozkqwOxmfLeJ2kBo/R9TtJOA+txO1nWy1g4m5Trjbqe3jdupEwe0kAN1ObaAo6yRwgoteiMg5n2t5JWiS4zmEqv88y92Oict5AvNmafw8oMYdyzVeUJHiRHa4yCLFFXU78bBrjZvvnWzJCcQBJ8PdjusmAxdBiuVuxzBMgbsdN9+8nQgPv3kjEp2bYHcyThVxO0iN1xV1O/G4nWxReydbWjAxp4e7nTQft5MeBbcTD3Q7aUBRpidwgoteiMg5Z1heCZrkWJdQ9Wda7nZMXDIF5s3SeCZQ4+dbrvGCihQnssNFFikXiLqdOOC75ELHe2ECccAXJuD7vchyh2LmfVFI5QHql+IqTEK5IMHupHexiKtA6vIScqJHxOQSgsajmVBjSQm1XgJzwISEeqnlCdXM+9IoJVQnssM1C+PSBM6CQ807mossBvh+qdDxXpZAHPBlhCviZcCMfrnlC9YwvJywCC63/B6tWaSXE+zPxcB4X2H57QKjnStIyf7YgV7bVwDjc6XlFr8gx+BEdrhIx3CV5Ro3Mb6KUMghdWiKhEqBv26Zhx7ocV8b4KzzAHScydTnHEVC2FYL/n61F89rvHat1+p7rYHXGnqtkdcae62J15p6rZnXmnuthddaeq2V11p7rY3X2nqtndfae62D1zp6rZPXOnuti9e6eq2b17K8lu21HK/lei0v/BnL1cHnKaHnrvE5d63Pufo+5xr4nGvoc66Rz7nGPuea+Jxr6nOumc+55j7nWvica+lzrpXPudY+59r4nGvrc66dz7n2Puc6+Jzr6HOuk8+5zj7nuvic6+pzrpvPuSyfc9k+53J8zuX6nMtL+Puzu+rBn/WCP53IjnxJJ9JkeTUg8R57DngNqK8/5wjp6yiv+pH3lRzk5TaItK/U/2HvNoysLyckjm6jSPpKzqcJt/G/78sJ05fb5F/2lZb3N626Tf9dXxk+uneb/Zu+MnzXkNv8n/eVXsB6dFv8077SC1zbbst/1lfyf8gTbqt/0lf6f8w5buvj7yv7v+Qvt83x9pX+X3Oh2/b4+nKOI6+67Y6nL+e4crTb/r/3Vfc4873b4b/1lXrc1w6343/sKzXvH1yH3E7/qa/0f3RNczsX3FfGP7w+ul0K6Csz7x9fa92u/n05/+K67Xbz68v5VzWAm/X3vtx/WU+42eF95fzr2sTNyd9XSgR1jpsb0ldyXkQ1k5uXoHlHOw9W6+Xk23XcPYE4YNM56q7XscF3xwXQ7QGAyryjbRiaMWJ3Hefkm7cT4RHN3aO4xZsTtd2jPYMLrFe42+yZ8Pfdo70S+LtHcZnEcXsCF1AvcHDR4jOLpidwMR6bd0/RK1IuTEeZOaHj7Z1AHHBv+BUpM6c38Ip0neVXJMPwOvgVKTPnOtErUi5s3JnZPsOlXJGuDy6wPuFXpOt9rkh9onBFygVeka4HLqA+pOCiHwQj53wDMJkFAvirZY9gAkI/CEZagRuBycyPoRPZ4ZoY30ioZG4UrWRyYPknKyV0vDclEAd8E7ySyUq5Cbj4+1peyRiGfeGVTFZKX/LiRyTQGy1PoDeDGR470BdepMZvAa69aFbAObBxZyX7DJdSAd8aTMy3hVfAt/pUwLdFoQLGXYEc91agKG8jBRe9EJFzvp1cATuRHa5JjrcQqrc7LK9aTVzuEJg3S+N3ADV+p+UaL6hIQRQ/qL7uAl+wo+V2smHXmoy80PHenUAc8N1wt5ORdzcwgP0sdzuGYT+428nI62e52zGJ7q4Eu5PxPeBkfOxAzxmp8XtF3U42bNwZuT7Dpbid+4KJ+f5wt3Ofj9u5PwpuB3cFctz7gKK8nxRc9EJEzrm/5ZWgSY73Eqr+Byx3OyYuDwjMm6XxB4Aaf9ByjRdUpDiRHS6ySHlI9NlOFuxak/97xx9OIA74YbjbSXYeBi6CAZa7HcNwANztJDsDLHc7JtE9lGB3Mn5ExO0gNf6oqNvJgo07et87/lgwMT8e7nYe83E7j0fB7eCuQI77GFCUj5OCi16IyDk/YXklaJLjo4Sqf6DlbsfEZaDAvFkaHwjU+CDLNV5QkeJEdrjIIuVJUbfTDXatycnndgYnEAc8GO52cpzBwEUwxHK3YxgOgbudHGeI5W7HJLonE+xOxk+JuB2kxoeKup1usHFnR83tDAsm5uHhbmeYj9sZHgW3g7sCOe4woCiHk4KLXojIOY+wvBI0yXEooeofabnbMXEZKTBvlsZHAjU+ynKNF1SkOJEdLrJIeVrU7XSFXWvS8r0TY3QCccCj4W4nzR0NXARjLHc7huEYuNtJyzdvJ8LDb96IRPd0gt3J+BkRt4PU+FhRt9MVNu60qL1LZVwwMY8PdzvjfNzO+Ci4HdwVyHHHAUU5nhRc9EJEznmC5ZWgSY5jCVX/RMvdjonLRIF5szQ+EajxZy3XeEFFihPZ4SKLlOdE3U4X3LOdjNDxTkogDngS/tlOxiTgIphsudsxDCfjn+1kTLbc7ZhE91yC3cl4iojbQWp8qqjb6QIbd066z3ApbmdaMDFPD3c703zczvQouB3cFchxpwFFOZ0UXPRCRM55huWVoEmOUwlV/0zL3Y6Jy0yBebM0PhOo8VmWa7ygIsWJ7HCRRcrzom6nM+xak5oZOt7ZCcQBz4a7ndTM2cBF8ILlbscwfAHudlIzX7Dc7ZhE93yC3cn4RRG3g9T4HFG30xk27tQMn+FS3M7cYGJ+KdztzPVxOy9Fwe3grkCOOxcoypdIwUUvROSc51leCZrkOIdQ9b9sudsxcXlZYN4sjb8M1Pgrlmu8oCLFiexwkUXKq6JupxPsWpOVbyfb/ATigOfD3U6WOx+4CF6z3O0Yhq/B3U5Wvnk7ER5+80YkulcT7E7Gr4u4HaTG3xB1O51g486K2k62N4OJ+a1wt/Omj9t5KwpuB3cFctw3gaJ8ixRc9EJEzvltyytBkxzfIFT971judkxc3hGYN0vj7wA1/q7lGi+oSHEiO1xkkfKeqNvpiHM72aHjXZBAHPACvNvJXgBcBAstdzuG4UK828leaLnbMYnuvQS7k/H7Im4HqfFFom6nI64gzvIZLsXtLA4m5g/C3c5iH7fzQRTcDu4K5LiLgaL8gBRc9EJEznmJ5ZWgSY6LCFX/UsvdjonLUoF5szS+FKjxZZZrvKAixYnscJFFynJRt9MBt5MtK3S8KxKIA16B38mWtQK4CFZa7nYMw5X4nWxZKy13OybRLU+wOxmvEnE7SI2vFnU7HXCbnbr5DJfidtYEE/PacLezxsftrI2C28FdgRx3DVCUa0nBRS9E5JzXWV4JmuS4mlD1r7fc7Zi4rBeYN0vj64Ea32C5xgsqUpzIDhdZpGwUdTvtYdeajHxvoN6UQBzwJrjbyXA2ARfBZsvdjmG4Ge52MpzNlrsdk+g2JtidjLeIuB2kxreKup32sHGnR+0N1NuCiXl7uNvZ5uN2tkfB7eCuQI67DSjK7aTgohcics47LK8ETXLcSqj6d1rudkxcdgrMm6XxnUCNf2i5xgsqUpzIDhdZpOwSdTvtSG5ndwJxwLsJbmc3cBHssdztGIZ7CG5nj+VuxyS6XQl2J+OPRNwOUuN7Rd1OO0G383EwMX8S7nY+9nE7n0TB7eCuQI77MVCUn4i4HeScP7W8EjTJcS+h6t9nudsxcdknMG+WxvcBNf6Z5RovqEhxIjtcZJHyuajbaQu71nTL9062LxKIA/4C7na6ZX4BXAT7LXc7huF+uNvplrnfcrdjEt3nCXYn4y9F3A5S41+Jup22sHF3i9o72b4OJuZvwt3O1z5u55souB3cFchxvwaK8htScNELETnnby2vBE1y/IpQ9R+w3O2YuBwQmDdL4weAGv/Oco0XVKQ4kR0uskj5XtTttMG5ndTQ8R5MIA74IN7tpB4ELoJDlrsdw/AQ3u2kHrLc7ZhE932C3cn4BxG3g9T4j6Jupw2uIE7xGS7F7fwUTMw/h7udn3zczs9RcDu4K5Dj/gQU5c+k4KIXInLOv1heCZrk+COh6v/Vcrdj4vKrwLxZGv8VqPHfLNd4QUWKE9nhIouU30XdTmvYtSYn37OdwwnEAR+Gu52czMPARXDEcrdjGB6Bu52czCOWux2T6H5PsDsZ/yHidqAaT9R0O61hscqJ2rOdIolBPSQG8jsb8x/C3Y75I7bbwV2BHLdIIk6URRM5wUUvROSciyVikw96wZnkGEjEXxhiErkXLieywzVxiRGYN0vjMUCNx1qu8YKKFCeyw0UWKXFA3UTT7bSCXWuyc0PHG59IHLDpHOt2snPjgYsgAbg4WQwTEtFuJzs3gXzRQCS6uES7k3EiOBkfO9BzRmo8SdTttIK5newcn+FS3E7xYGIuEe52ivu4nRJRcDutgG6nOFCUJRI5wUUvROScS1peCZrkmESo+ktZ7nZMXEoJzJul8VJAjZe2XOMFFSlOZIeLLFLKiLqdlrBrjZvv2U7ZROKAy8LdjptZFrgIylnudgzDcnC342aWs9ztmERXJtHuZFxexO0gNV5B1O20hLkdN2rPdioGE3OlcLdT0cftVIqC22kJdDsVgaKslMgJLnohIudc2fJK0CTHCoSqv4rlbsfEpYrAvFkarwLU+AmWa7ygIsWJ7HCRRcqJom6nBexak5XP7ZyUSBzwSXC3k5V5EnARnGy52zEMT4a7nazMky13OybRnZhodzI+RcTtIDV+qqjbaQFzO1lRcztVg4m5WrjbqerjdqpFwe20ALqdqkBRVkvkBBe9EJFzrm55JWiS46mEqr+G5W7HxKWGwLxZGq8B1Phplmu8oCLFiexwkUXK6aJupznsWpORETreMxKJAz4D7nYyMs4ALoIzLXc7huGZcLeTkXGm5W7HJLrTE+1OxmeJuB2kxmuKup3mMLeTke4zXIrbqRVMzGeHu51aPm7n7Ci4neZAt1MLKMqzEznBRS9E5JzPsbwSNMmxJqHqr2252zFxqS0wb5bGawM1XsdyjRdUpDiRHS6ySDlX1O00g11rUvO5nfMSiQM+D+52UjPOAy4Cx3K3Yxg6cLeTmuFY7nZMojs30e5k7Iq4HaTGk0XdTjOY20mNmttJCSbm1HC3k+LjdlKj4HaaAd1OClCUqYmc4KIXInLOdS2vBE1yTCZU/WmWux0TlzSBebM0ngbUeLrlGi+oSHEiO1xkkZIh6naawq41mW7oeDMTiQPOhLudTDcTuAjOt9ztGIbnw91OZr55OxEefvNGJLqMRLuT8QUibgep8QtF3U5TmNvJdHyGS3E7FwUT88XhbuciH7dzcRTcTlOg27kIKMqLEznBRS9E5JwvsbwSNMnxQkLVX89yt/NnXATmzdJ4PaDGL7Vc4wUVKU5kh4ssUi4TdTtNYNeadCd0vJcnEgd8OdztpDuXAxfBFZa7HcPwCrjbSXeusNztmER3WaLdyfhKEbeD1PhVom6nCcztpOX5DJfidq4OJuZrwt3O1T5u55oouJ0mQLdzNVCU1yRygoteiMg5X2t5JWiS41WEqr++5W7HxKW+wLxZGq8P1HgDyzVeUJHiRHa4yCKloajbaYx7S0G+N1A3SiQOuBHc7WTlNgIugsaWux3DsDHc7WTlNrbc7ZhE1zDR7mTcRMTtIDXeVNTtNMa9pSBqb6BuFkzMzcPdTjMft9M8Cm6nMdDtNAOKsnkiJ7johYiccwvLK0GTHJsSqv6WlrsdE5eWAvNmabwlUOOtLNd4QUWKE9nhIouU1qJupxHsWpOc79lOm0TigNvA3U6y0wa4CNpa7nYMw7Zwt5PstLXc7ZhE1zrR7mTcTsTtIDXeXtTtNMK9gTpqz3Y6BBNzx3C308HH7XSMgttpBHQ7HYCi7JjICS56ISLn3MnyStAkx/aEqr+z5W7HxKWzwLxZGu8M1HgXyzVeUJHiRHa4yCKlq6jbaYi71mSHjrdbInHA3eBux8nuBlwEWZa7HcMwC+52nOwsy92OSXRdE+1Oxtkibgep8RxRt9MQ5nacLJ/hUtxObjAx54W7nVwft5MXBbcDvAK5uUBR5iVygoteiMg5d7e8EjTJMYdQ9few3O2YuPQQmDdL4z2AGu9pucYLKlKcyA4XWaT0EnU7DWDXmrR8O9l6JxIH3BvudtJyewMXwXWWux3D8Dq420nLvc5yt2MSXa9Eu5Px9SJuB6nxPqJupwHucztR28l2QzAx3xjudm7wcTs3RsHtNAC6nRuAorwxkRNc9EJEzvkmyytBkxz7EKr+vpa7HROXvgLzZmm8L1DjN1uu8YKKFCeyw0UWKbeIup36sGuNm++dbLcmEgd8K9ztuO6twEVwm+VuxzC8De523HzzdiI8/OaNSHS3JNqdjG8XcTtIjd8h6nbq43ayRe2dbHcGE/Nd4W7nTh+3c1cU3E59oNu5EyjKuxI5wUUvROSc77a8EjTJ8Q5C1d/Pcrdj4tJPYN4sjfcDavweyzVeUJHiRHa4yCLlXlG3cy1uM0a+z+3cl0gc8H2J+H7vt9yhmHnfn/gXYFC/FFdhEsq9iXYnvf4irgKpywfIiR4RkwcIGo9mQr2GlFAfTCQO+EFCQn3I8oRq5v1QlBKqE9nhmoXxUCJnwaHmHc1FdnUCjkHoeB9OJA74YcIV8WFgRh9g+YI1DAcQFsEAy+/RmkU6gGB/+gPj/YjltwuMdh4hJftjB3ptPwKMz6OWW/yCHIMT2eEiHcNjlmvcxPgxQiGH1KEpEioF/rplHnrAH5IHOOs8AB1nMvU5R5EQttWCvz/uxfMJrw302iCvPem1wV4b4rWnvDbUa8O8NtxrI7w20mujvPa010Z7bYzXnvHaWK+N89p4r03w2kSvPeu157w2yWuTvTbFa1O9Ns1r0702I/wZy+PB5ymh557wOTfQ59wgn3NP+pwb7HNuiM+5p3zODfU5N8zn3HCfcyN8zo30OTfK59zTPudG+5wb43PuGZ9zY33OjfM5N97n3ASfcxN9zj3rc+45n3OTfM5N9jk3xefcVJ9z03zOTfc5NyPx78/uqgd/1gv+dCI78iWdSJPl44DEe+w54BOgvswcB0L6OsprUOR9JQd5uU9G2lfq/7B3B0fWlxMSR3dIJH0l59OE+9S/78sJ05c79F/2lZb3N626w/5dXxk+uneH/5u+MnzXkDvin/eVXsB6dEf+077SC1zb7qh/1lfyf8gT7tP/pK/0/5hz3NHH31f2f8lf7pjj7Sv9v+ZC95nj68s5jrzqjj2evpzjytHuuP/eV93jzPfu+P/WV+pxXzvcCf+xr9S8f3Adcif+p77S/9E1zX224L4y/uH10X2ugL4y8/7xtdad5N+X8y+u2+5kv76cf1UDuFP+3pf7L+sJd2p4Xzn/ujZxp+XvKyWCOsedHtJXcl5ENZM7Q/SO9gxYrZeTb9fxzETigGcmoncd57gzcQF0ZwGgMu9oG4azgHe0jzGcBV4E0do9ilu8OVHbPfp8cIHNDr+z8Xzi33ePzk7k7x7FZRLHfR64gGaDg4sWn1k0zwMX47F5Py96RZoO01FmTuh4X0gkDvgF+BUpM+cF4BXpRcuvSIbhi/ArUmbOi6JXpOmwcWdm+wyXckWaE1xgc8OvSHN8rkhzo3BFmg68Is0BLqC5pOCiHwQj5/wSMJkFAvir5axgAkI/CEZagXnAZObH0InscE2M5xEqmXmilcw0WP7JSgkd78uJxAG/DK9kslJeBi7+VyyvZAzDV+CVTFbKK+TFj0ig8yxPoK+CGR470BdepMbnA9deNCvgabBxZyX7DJdSAb8WTMyvh1fAr/lUwK9HoQLGXYEc9zWgKF8nBRe9EJFzfoNcATuRHa5JjvMJ1dublletJi5vCsybpfE3gRp/y3KNF1SkIIofVF9vgy/Y0XI7U2HXmoy80PG+k0gc8Dtwt5OR9w4wgO9a7nYMw3fhbicj713L3Y5JdG8n2p2M3wMn42MHes5IjS8QdTtTYePOyPUZLsXtLAwm5vfD3c5CH7fzfhTcDu4K5LgLgaJ8nxRc9EJEznmR5ZWgSY4LCFX/YsvdjonLYoF5szS+GKjxDyzXeEFFihPZ4SKLlCWiz3amwK41+b93fGkiccBL4W4n2VkKXATLLHc7huEyuNtJdpZZ7nZMoluSaHcyXi7idpAaXyHqdqbAxh297x1fGUzMq8Ldzkoft7MqCm4HdwVy3JVAUa4iBRe9EJFzXm15JWiS4wpC1b/Gcrdj4rJGYN4sja8Banyt5RovqEhxIjtcZJGyTtTtTIZda3LyuZ31icQBr4e7nRxnPXARbLDc7RiGG+BuJ8fZYLnbMYluXaLdyXijiNtBanyTqNuZDBt3dtTczuZgYt4S7nY2+7idLVFwO7grkONuBopyCym46IWInPNWyytBkxw3Ear+bZa7HROXbQLzZml8G1Dj2y3XeEFFihPZ4SKLlB2ibmcS7FqTlu+dGDsTiQPeCXc7ae5O4CL40HK3Yxh+CHc7afnm7UR4+M0bkeh2JNqdjHeJuB2kxneLup1JsHGnRe1dKnuCifmjcLezx8ftfBQFt4O7AjnuHqAoPyIFF70QkXPea3klaJLjbkLV/7HlbsfE5WOBebM0/jFQ459YrvGCihQnssNFFimfirqd53DPdjJCx7svkTjgffhnOxn7gIvgM8vdjmH4Gf7ZTsZnlrsdk+g+TbQ7GX8u4naQGv9C1O08Bxt3TrrPcCluZ38wMX8Z7nb2+7idL6PgdnBXIMfdDxTll6Tgohcics5fWV4JmuT4BaHq/9pyt2Pi8rXAvFka/xqo8W8s13hBRYoT2eEii5RvRd3Os7BrTWpm6HgPJBIHfADudlIzDwAXwXeWux3D8Du420nN/M5yt2MS3beJdifj70XcDlLjB0XdzrOwcadm+AyX4nYOBRPzD+Fu55CP2/khCm4HdwVy3ENAUf5ACi56ISLn/KPllaBJjgcJVf9PlrsdE5efBObN0vhPQI3/bLnGCypSnMgOF1mk/CLqdibCrjVZ+Xay/ZpIHPCvcLeT5f4KXAS/We52DMPf4G4nK9+8nQgPv3kjEt0viXYn499F3A5S44dF3c5E2LizoraT7UgwMf8R7naO+LidP6LgdnBXIMc9AhTlH6Tgohcics6BJLsrQZMcDxOq/iJJ3AuXE9nhmriYMdo+b5bGQ8cZaV9FLdd4QUWKE9nhIouUYkDdRNPtTMC5nezQ8cYkEQdsOge7newY4CKIBS5OFsPYJLjbyY4lXzQQia5Ykt3JOA6cjI8d6DkjNR4PnHM03c4EXEGc5TNcittJCCbmxKRAfmeTkPR3t2P+iO12JgDdTgJQlIlJnOCiFyJyzkmWV4ImOcYTqv7ilrsdE5fiAvNmabw4UOMlLNd4QUWKE9nhIouUkqJuZzxuJ1tW6HhLJREHXArudlKzSgEXQWnL3Y5hWBrudlKzSlvudkyiK5lkdzIuI+J2kBovK+p2xuM2O3XzGS7F7ZQLJuby4W6nnI/bKR8FtzMe6HbKAUVZPokTXPRCRM65guWVoEmOZQlVf0XL3Y6JS0WBebM0XhGo8UqWa7ygIsWJ7HCRRUplUbczDnatycj3BuoqScQBV4G7nQynCnARnGC52zEMT4C7nQznBMvdjkl0lZPsTsYnirgdpMZPEnU742BuJz1qb6A+OZiYTwl3Oyf7uJ1TouB2xgHdzslAUZ6SxAkueiEi53yq5ZWgSY4nEar+qpa7HROXqgLzZmm8KlDj1SzXeEFFihPZ4SKLlOqibmcsye3USCIOuAbB7dQALoLTLHc7huFpBLdzmuVuxyS66kl2J+PTRdwOUuNniLqdsYJu58xgYj4r3O2c6eN2zoqC2xkLdDtnAkV5lojbQc65puWVoEmOZxCq/lqWux0Tl1oC82ZpvBZQ42dbrvGCihQnssNFFinniLqdZ2DXmm753slWO4k44Npwt9MtszZwEdSx3O0YhnXgbqdbZh3L3Y5JdOck2Z2MzxVxO0iNnyfqdp6BuZ1uUXsnmxNMzG6423F83I4bBbfzDNDtOEBRukmc4KIXInLOyZZXgiY5nkeo+lMsdzsmLikC82ZpPAWo8VTLNV5QkeJEdrjIIqWuqNsZg3M7qaHjTUsiDjgN73ZS04CLIN1yt2MYpuPdTmq65W7HJLq6SXYn4wwRt4PUeKao2xmDczspPsOluJ3zg4n5gnC3c76P27kgCm5nDNDtnA8U5QVJnOCiFyJyzhdaXgma5JhJqPovstztmLhcJDBvlsYvAmr8Yss1XlCR4kR2uMgi5RJRtzMadq3Jyfdsp14Sc8Bwt5OTWQ+4CC613O0YhpfC3U5O5qWWux2T6C5JsjsZXybidpAav1zU7YzGfQFl1J7tXBFMzFeGu50rfNzOlVFwO6OBbucKoCivTOIEF70QkXO+yvJK0CTHywlV/9WWux0Tl6sF5s3S+NVAjV9jucYLKlKcyA4XWaRcK+p2noZda7JzQ8dbP4k44Ppwt5OdWx+4CBpY7nYMwwZwt5Od28Byt2MS3bVJdifjhiJuB6nxRqJu52mY28nO8Rkuxe00DibmJuFup7GP22kSBbfzNNDtNAaKskkSJ7johYicc1PLK0GTHBsRqv5mlrsdE5dmAvNmabwZUOPNLdd4QUWKE9nhIouUFqJuZxTsWuPme7bTMok44JZwt+NmtgQuglaWux3DsBXc7biZrSx3OybRtUiyOxm3FnE7SI23EXU7o2Bux43as522wcTcLtzttPVxO+2i4HZGAd1OW6Ao2yVxgoteiMg5t7e8EjTJsQ2h6u9gudsxcekgMG+WxjsANd7Rco0XVKQ4kR0uskjpJOp2RuK+XTSf2+mcRBxwZ7jbycrsDFwEXSx3O4ZhF7jbycrsYrnbMYmuU5LdybiriNtBarybqNsZift20ai5naxgYs4OdztZPm4nOwpuZyTQ7WQBRZmdxAkueiEi55xjeSVokmM3QtWfa7nbMXHJFZg3S+O5QI3nWa7xgooUJ7LDRRYp3UXdzgjcG6gzQsfbI4k44B5wt5OR0QO4CHpa7nYMw55wt5OR0dNyt2MSXfcku5NxLxG3g9R4b1G3MwLmdjLSfYZLcTvXBRPz9eFu5zoft3N9FNzOCKDbuQ4oyuuTOMFFL0TknPtYXgma5NibUPXfYLnbMXG5QWDeLI3fANT4jZZrvKAixYnscJFFyk2ibmc47FqTms/t9E0iDrgv3O2kZvQFLoKbLXc7huHNcLeTmnGz5W7HJLqbkuxOxreIuB2kxm8VdTvDYW4nNWpu57ZgYr493O3c5uN2bo+C2xkOdDu3AUV5exInuOiFiJzzHZZXgiY53kqo+u+03O2YuNwpMG+Wxu8EavwuyzVeUJHiRHa4yCLlblG3Mwx2rcl0Q8fbL4k44H5wt5Pp9gMugnssdzuG4T1wt5OZb95OhIffvBGJ7u4ku5PxvSJuB6nx+0TdzjCY28l0fIZLcTv3BxNz/3C3c7+P2+kfBbczDOh27geKsn8SJ7johYic8wOWV4ImOd5HqPoftNztmLg8KDBvlsYfBGr8Ics1XlCR4kR2uMgi5WFRtzMUdq1Jd0LHOyCJOOABcLeT7gwALoJHLHc7huEjcLeT7jxiudsxie7hJLuT8aMibgep8cdE3c5QmNtJy/MZLsXtPB5MzE+Eu53HfdzOE1FwO0OBbudxoCifSOIEF70QkXMeaHklaJLjY4Sqf5DlbsfEZZDAvFkaHwTU+JOWa7ygIsWJ7HCRRcpgUbfzFO4tBfneQD0kiTjgIXC3k5U7BLgInrLc7RiGT8HdTlbuU5a7HZPoBifZnYyHirgdpMaHibqdp3BvKYjaG6iHBxPziHC3M9zH7YyIgtt5Cuh2hgNFOSKJE1z0QkTOeaTllaBJjsMIVf8oy92OicsogXmzND4KqPGnLdd4QUWKE9nhIouU0aJuZwjsWpOc79nOmCTigMfA3U6yMwa4CJ6x3O0Yhs/A3U6y84zlbsckutFJdifjsSJuB6nxcaJuZwjuDdRRe7YzPpiYJ4S7nfE+bmdCFNzOEKDbGQ8U5YQkTnDRCxE554mWV4ImOY4jVP3PWu52TFyeFZg3S+PPAjX+nOUaL6hIcSI7XGSRMknU7QzGXWuyQ8c7OYk44Mlwt+NkTwYugimWux3DcArc7TjZUyx3OybRTUqyOxlPFXE7SI1PE3U7g2Fux8nyGS7F7UwPJuYZ4W5nuo/bmREFtwO8ArnTgaKckcQJLnohIuc80/JK0CTHaYSqf5blbsfEZZbAvFkanwXU+POWa7ygIsWJ7HCRRcpsUbfzJOxak5ZvJ9sLScQBvwB3O2m5LwAXwYuWux3D8EW420nLfdFyt2MS3ewku5PxHBG3g9T4XFG38yTucztR28n2UjAxzwt3Oy/5uJ15UXA7TwLdzktAUc5L4gQXvRCRc37Z8krQJMe5hKr/FcvdjonLKwLzZmn8FaDGX7Vc4wUVKU5kh4ssUuaLup1BsGuNm++dbK8lEQf8GtztuO5rwEXwuuVuxzB8He523HzzdiI8/OaNSHTzk+xOxm+IuB2kxt8UdTuDcDvZovZOtreCifntcLfzlo/beTsKbmcQ0O28BRTl20mc4KIXInLO71heCZrk+Cah6n/Xcrdj4vKuwLxZGn8XqPH3LNd4QUWKE9nhIouUBaJuZyBuM0a+z+0sTCIOeGESvt/3LXcoZt7vJ/0FGNQvxVWYhLIgye6kt0jEVSB1uZic6BExWUzQeDQT6hOkhPpBEnHAHxAS6hLLE6qZ95IoJVQnssM1C2NJEmfBoeYdzUX2eCKOQeh4lyYRB7yUcEVcCszoyyxfsIbhMsIiWGb5PVqzSJcR7M8iYLyXW367wGhnOSnZHzvQa3s5MD4rLLf4BTkGJ7LDRTqGlZZr3MR4JaGQQ+rwnzyLiPT/61oUA9eJ2rOIVcEctTr8WcQqn2cRq4/jWQQSYqTPIlYBhbQ6CReAaIqyp6Ao1wRFuTZclGt8RLk2CqLsGcCJcg1QlGtFRQnMlG4gSqJcFxTl+nBRrvMR5XqxTLkOKMr1SZzgostd5Jw3WH6j8+zA0Ss6utw9GzjGjZbb4vqBoxcgNMP6wDFuAt9fE6xSonZB2By8IGwJvyBs9rkgbBGrUjYDk+MW4AVBtEpJDkRJlFuDotwWLsqtPqLcJlalbAWKclsSJ7joKgU55+3gKgV9JTQVGbAKcDcE+0Mnhh2W35g7x+tjA2HeO8HzRutnRuJRN4bsj8HxQ8s5GoabwOtwE4HjLssdQ4PA0WIQHZ8GwDHuLnQMUSvO9gSLs4/Ci7M9PsXZR2KOYQ+wUPkIWJyJOoaUQJREuTcoyo/DRbnXR5QfizmGvUBRfpzECS7aMSDn/InljsG4I2A17m4P9odODJ9aXvEZjjvBHHcSOO6z3HnV9vrYTpj3ZwL6+RCsnw8JHD+3nOP0xKN36pD9MfT4hYAed4H1uIvAcb8Ax91gjrsJHL+0/E5Aw8BRk4eOT0PgGL8qvBMQNdP1ddB0fRNuur72MV3fiN0J+BpoQL4Bmi7ROwGpgSiJ8tugKA+Ei/JbH1EeELsT8C1QlAeSOMFF3wlAzvk7y+8EmLseQJftfhLsD50Yvre84jMc94E57iNwPCjA8TMwx88IHA9ZfkeljtfHJ4R5/yCgn8/B+vmcwPFHAY5fgDl+QeD4k+UcpyUefSKE7I+xrn8W0ON+sB73Ezj+IsDxSzDHLwkcfxXg+BWY41cEjr9ZfoevUeDozRt0fBoBx/h74R2+qN1MORy8mXIk/GbKYZ+bKUfE7vAdBt5YOAK8mSJ6h69uIEqi/CMoykDxMAH+4SNK80dKd/j+AIrSzJ0RXPQdPuScixTHXbX85upEdvx5Bxd498z9LtgfOjEULY6tVBgcD4I5HiRwLCbA8RCY4yECxxgBjj+AOf5A4BgL5oi+U3qu18d3hHnHCejnR7B+fiRwjBfg+BOY408EjgkCHH8Gc/yZwDHRco5TE4/uPED2x8iPSQJ6/AWsx18IHIsLcPwVzPFXAscSAhx/A3P8jcCxpADH38EcfydwLEWumyMdX+PA0Zuy6Pg0Bo6xNJCh6J37qN0kLVP86M+y4TdJzX8Iv0latrjWnfsyxXHjKgu8SSp65z4tECVRlguKsny4KMv5iLK82J37ckBRli/OCS76zj1yzhUsv3NvnlIA74q75klF0eL4xFDR8orPcCwG5liMwLGSAMcYMMcYAsfKAhxjwRxjCRyrCHCMA3OMI3A8wfInIOeZPgnzPlFAP/Fg/cQTOJ4kwDEBzDGBwPFkAY6JYI6JBI6nCHBMAnNMInA81XKOUxKP7nBD9se4zlQV0GNxsB6LEzhWE+BYAsyxBIFjdQGOJcEcSxI41hDgWArMsRSB42kCHEuDOZYmcDzd8idyTQJHH7ag49MEOMYzCp/IRe3hx5nBhx9nhT/8ONPn4cdZYk/kzgQ+CDgL+PBD9IlceiBKoqwZFGWtcFHW9BFlLbEncjWBoqxVnBNc9BM55JzPtvyJnHn6CHza5VYI9odODOdYXvEZjpXAHCsRONYW4FgZzLEygWMdAY5VwByrEDieK8DxBDDHEwgczxPgeCKY44kEjo7lTzZNpxUI83YF9HMSWD8nETgmC3A8GczxZALHFAGOp4A5nkLgmCrA8VQwx1MJHOsKcKwK5liVwDHNco6TE4/upEb2x7hepwvosRpYj9UIHDMEOFYHc6xO4JgpwLEGmGMNAsfzBTieBuZ4GoHjBQIcTwdzPJ3A8UIBjmeAOZ5B4HiR5U/amwaOPkRFx6cpcIwXFz5pj9pDzUuCDzXrhT/UvMTnoWY9sSftlwAf8NUDPtQUfdKe4TNciigvDYrysnBRXuojysvEnrRfChTlZcU5wUU/aUfO+XLLn7SbXQXAp9ju2cH+0InhCssrPsOxNphjbQLHKwU41gFzrEPgeJUAx3PBHM8lcLxagON5YI7nETheI8DRAXN0CByvFeDogjm6BI71yXcWnMgO1xRTZxPm3UBAP8lg/SQTODYU4JgC5phC4NhIgGMqmGMqgWNjAY51wRzrEjg2EeCYBuaYRuDYVIBjOphjOoFjM8s5Tko8+okdZH+Muqe5gB4zwHrMIHBsIcAxE8wxk8CxpQDH88EczydwbCXA8QIwxwsIHFsLcLwQzPFCAsc2AhwvAnO8iMCxrQDHi8EcLyZwbEe+zxVxfRs4ujkCHZ9mwDG2L9xBE7XNCh2CmxU6hm9W6BBcHKHnOortoOkAfHDfEbhZQXQHTWYgSqLsFBRl53BRdvIRZWexHTSdgKLsXJwT3KJgfsg5d7F8B43ZLQTcneJeHuwPnRi6Wl7xGY5XgjleSeDYTYDjVWCOVxE4ZglwvBrM8WoCx2wBjteAOV5D4JgjwPFaMMdrCRxzBTjWB3OsT+CYJ8CxAZhjAwLH7uQ7NE5kh5vs9XE5Yd49BPTTEKyfhgSOPQU4NgJzbETg2EuAY2Mwx8YEjr0FODYBc2xC4HidAMemYI5NCRyvF+DYDMyxGYFjHwGOzcEcmxM43mA5x+cSj34yFNkfo368UUCPLcB6bEHgeJMAx5Zgji0JHPsKcGwF5tiKwPFmAY6twRxbEzjeIsCxDZhjGwLHWwU4tgVzbEvgeJsAx3Zgju0IHG8X4NgezLE9geMd5PuuEX9iIXB00xM6Ps2BY7wTyFB0Z1zUNiHdVfzoz7uLB/JvOLqr+N83IZk/UtoZdxdwQ87dxXHBFd0Z1y0QJVH2C4rynnBR9vMR5T3FtXbG9QOK8p7inOAWBfNDzvleYBXgN1cnsuPPnY/AXWdul2B/6MRwn+UVn+HYDcyxG4Hj/QIcs8Acswgc+wtwzAZzzCZwfECAYw6YYw6B44MCHHPBHHMJHB8S4JgH5phH4PiwAMfuYI7dCRwHCHDsAebYg8DxEfKdLieyw03x+uhCmPejAvrpCdZPTwLHxwQ49gJz7EXg+LgAx95gjr0JHJ8Q4HgdmON1BI4DBTheD+Z4PYHjIAGOfcAc+xA4PinA8QYwxxsIHAcLcLwRzPFGAschlnN8NvHoGwiQ/THq8KcE9HgTWI83ETgOFeDYF8yxL4HjMAGON4M53kzgOFyA4y1gjrcQOI4Q4HgrmOOtBI4jBTjeBuZ4G4HjKAGOt4M53k7g+LQAxzvAHO8gcBwtwPFOMMc7CRzHkJ8DRPxu6cDRzYzo+LQAjvEZIEPRHa9R21w4tvjRn+OKB/JvJBxb/O+bC80fKe14HVscN65xxXHBFd3xmhWIkijHB0U5IVyU431EOaG41o7X8UBRTijOCW5RMD/knCcCqwC/uTqRHX/uaAbuJnXvDfaHTgzPWl7xGY73gzneT+D4nADH/mCO/QkcJwlwfADM8QECx8kCHB8Ec3yQwHGKAMeHwBwfInCcKsDxYTDHhwkcpwlwHADmOIDAcboAx0fAHB8hcJwhwPFRMMdHCRxnku8YOpEdbqrXx72Eec8S0M9jYP08RuD4vADHx8EcHydwnC3A8QkwxycIHF8Q4DgQzHEggeOLAhwHgTkOInCcI8DxSTDHJwkc5wpwHAzmOJjA8SUBjkPAHIcQOM4T4PgUmONTBI4vW85xYuLRN90g+2P4mVcE9DgUrMehBI6vCnAcBuY4jMBxvgDH4WCOwwkcXxPgOALMcQSB4+sCHEeCOY4kcHxDgOMoMMdRBI5vCnB8GszxaQLHtwQ4jgZzHE3g+LYAxzFgjmMIHN8R4PgMmOMzBI7vkp9LRTq+loGjm5TR8WkJHON7QIaiO9mzfIaL6jvfpuEFxY/+XFg8kH+D8ILif980bP5IaSf7guK4cS0sjguu6E727ECURPl+UJSLwkX5vo8oFxXX2sn+PlCUi4pzglsUzA8558XAKsBvrk5kx5+fVADuEncnBvtDJ4YPLK/4DMfnwByfI3BcIsBxEpjjJALHpQIcJ4M5TiZwXCbAcQqY4xQCx+UCHKeCOU4lcFwhwHEamOM0AseVAhyngzlOJ3BcJcBxBpjjDALH1QIcZ4I5ziRwXCPAcRaY4ywCx7XkO69OZIdb1+tjImHe6wT08zxYP88TOK4X4DgbzHE2geMGAY4vgDm+QOC4UYDji2COLxI4bhLgOAfMcQ6B42YBjnPBHOcSOG4R4PgSmONLBI5bBTjOA3OcR+C4TYDjy2COLxM4bhfg+AqY4ysEjjss5zgh8egb1ZD9MXzhTgE9vgrW46sEjh8KcJwP5jifwHGXAMfXwBxfI3DcLcDxdTDH1wkc9whwfAPM8Q0Cx48EOL4J5vgmgeNeAY5vgTm+ReD4sQDHt8Ec3yZw/ESA4ztgju8QOH4qwPFdMMd3CRz3CXB8D8zxPQLHz8jPSSMdX6vA0Q8foOPTCjjGz4EMRT+hErUPA3xR/OjP/cUD+Tf+f1H87x8GMH+k9AmVL4rjxrW/OC64op9QyQlESZRfBkX5Vbgov/QR5VfFtT6h8iVQlF8V5wS3KJgfcs5fA6sAv7k6kR1/fgIJ+OkPd3GwP3Ri+Mbyis9wXALmuITA8VsBjkvBHJcSOB4Q4LgMzHEZgeN3AhyXgzkuJ3D8XoDjCjDHFQSOBwU4rgRzXEngeEiA4yowx1UEjj8IcFwN5riawPFHAY5rwBzXEDj+JMBxLZjjWgLHnwU4rgNzXEfg+Av5DrYT2eGmeX0sJsz7VwH9rAfrZz2B428CHDeAOW4gcPxdgONGMMeNBI6HBThuAnPcROB4RIDjZjDHzQSOfwhw3ALmuIXAMVDCfo5bwRy3EjgWEeC4DcxxG4FjUQGO28EctxM4FhPguAPMcQeBY4wAx51gjjsJHGMt5zg+8eibO5H9Mfx1nIAePwTr8UMCx3gBjrvAHHcROCYIcNwN5ribwDFRgOMeMMc9BI5JAhw/AnP8iMCxuADHvWCOewkcSwhw/BjM8WMCx5ICHD8Bc/yEwLGUAMdPwRw/JXAsLcBxH5jjPgLHMgIcPwNz/IzAsawAx8/BHD8ncCwH5ogeX+vA0Q8VoePTGjjG8kCGop88i9qHfCqUOPqzYolA/g/0mP8Q/iEf80dKnzyrUAI3roolcMEV/eRZbiBKoqwUFGXlcFFW8hFl5RJanzyrBBRl5RKc4BYF80POuQru6kD55Jn5lB3wU13u18H+0InhBMsrPsPxWzDHbwkcTxTgeADM8QCB40kCHL8Dc/yOwPFkAY7fgzl+T+B4igDHg2COBwkcTxXgeAjM8RCBY1UBjj+AOf5A4FhNgOOPYI4/EjhWF+D4E5jjTwSONQQ4/gzm+DOB42kCHH8Bc/yFwPF0AY6/gjn+SuB4BvlJgBPZ4aZ7fXxNmPeZAvr5Dayf3wgczxLg+DuY4+8EjjUFOB4GczxM4FhLgOMRMMcjBI5nC3D8A8zxDwLHcwQ4Aj8d9yfHQAk8x9oCHIuAORYhcKwjwLEomGNRAsdzBTgWA3MsRuB4ngDHGDDHGAJHR4BjLJhjLIGjK8AxDswxjsAx2XKO4xKPviEa2R/jPkWKgB7jwXqMJ+gxVYBjAphjAoFjXQGOiWCOiQSOaQIck8Ackwgc0wU4FgdzLE7gmCHAsQSYYwkCx0wBjiXBHEsSOJ4vwLEUmGMpAscLBDiWBnMsTeB4oQDHMmCOZQgcLxLgWBbMsSyB48UCHMuBOZYjcLxEgGN5MMfyBI71LP9EaZvA0Q8LouPTBjjGSws/URq1D+9dFvzw3uXhH967zOfDe5eLfaL0MuAH2S4HfnhP9BOleYEoifKKoCivDBflFT6ivFLsE6VXAEV5ZQlOcIuC+SHnfJXlnyg1n54FflrTrRLsD50Yrra84jMcTwRzPJHA8RoBjieBOZ5E4HitAMeTwRxPJnCsL8DxFDDHUwgcGwhwPBXM8VQCx4YCHKuCOVYlcGwkwLEamGM1AsfGAhyrgzlWJ3BsIsCxBphjDQLHpgIcTwNzPI3AsZkAx9PBHE8ncGwuwPEMMMczCBxbCHA8E8zxTALHluQnKk5kh5vh9VGFMO9WAvo5C6yfswgcWwtwrAnmWJPAsY0Ax1pgjrUIHNsKcDwbzPFsAsd2AhzPAXM8h8CxvQDH2mCOtQkcOwhwrAPmWIfAsaMAx3PBHM8lcOwkwPE8MMfzCBw7C3B0wBwdAscuAhxdMEeXwLGrAMdkMMdkAsduAhxTwBxTCByzLOc4NvHoNxEg+2Pc78kW0GMqWI+pBI45AhzrgjnWJXDMFeCYBuaYRuCYJ8AxHcwxncCxuwDHDDDHDALHHgIcM8EcMwkcewpwPB/M8XwCx14CHC8Ac7yAwLG3AMcLwRwvJHC8ToDjRWCOFxE4Xi/A8WIwx4sJHPsIcLwEzPESAscbBDjWA3OsR+B4owDHS8EcLyVwvAnMEb5PIXD0Q8Do+LQFjrEvkKHoJ8Wj9qHcm0sc/XlLiUD+D+DeXOLvH8o1f6T0SfGbS+DGdUsJXHA1PynuOoEoifLWoChvCxflrT6ivK2E1ifFbwWK8rYSnOAWBfNDzvl2YBXgN1cnsuPPNwEAP4XtXhXsD50Y7rC84jMcrwFzvIbA8U4BjteCOV5L4HiXAMf6YI71CRzvFuDYAMyxAYFjPwGODcEcGxI43iPAsRGYYyMCx3sFODYGc2xM4HifAMcmYI5NCBzvF+DYFMyxKYFjfwGOzcAcmxE4PiDAsTmYY3MCxwcFOLYAc2xB4PiQAMeWYI4tCRwfFuDYCsyxFYHjAPKTKSeyw830+riKMO9HBPTTGqyf1gSOjwpwbAPm2IbA8TEBjm3BHNsSOD4uwLEdmGM7AscnBDi2B3NsT+A4UIBjBzDHDgSOgwQ4dgRz7Ejg+KQAx05gjp0IHAcLcOwM5tiZwHGIAMcuYI5dCByfEuDYFcyxK4HjUAGO3cAcuxE4DhPgmAXmmEXgOFyAYzaYYzaB4wjLOT6TePQbb5D9Me6bjRTQYw5YjzkEjqMEOOaCOeYSOD4twDEPzDGPwHG0AMfuYI7dCRzHCHDsAebYg8DxGQGOPcEcexI4jhXg2AvMsReB4zgBjr3BHHsTOI4X4HgdmON1BI4TBDheD+Z4PYHjRAGOfcAc+xA4PivA8QYwxxsIHJ8T4HgjmOONBI6TBDjeBOZ4E4HjZAGOfcEc+xI4TgFzhH/DQuDoh/vR8WkHHONUIEPNN0BE78P200oc/Tm9RCD/B+unlfj7h+3NHym9AWJaCdy4ppfABVf0DRBuIEqinBEU5cxwUc7wEeXMElpvgJgBFOXMEpzgFgXzQ855FrAK8JurE9nx5xs+gG9XcG8P9odODM9bXvEZjneCOd5J4DhbgONdYI53ETi+IMDxbjDHuwkcXxTg2A/MsR+B4xwBjveAOd5D4DhXgOO9YI73Eji+JMDxPjDH+wgc5wlwvB/M8X4Cx5cFOPYHc+xP4PiKAMcHwBwfIHB8VYDjg2CODxI4zhfg+BCY40MEjq8JcHwYzPFhAsfXBTgOAHMcQOD4hgDHR8AcHyFwfJP8hM+J7HDP9/q4nTDvtwT08yhYP48SOL4twPExMMfHCBzfEeD4OJjj4wSO7wpwfALM8QkCx/cEOA4EcxxI4LhAgOMgMMdBBI4LBTg+Ceb4JIHj+wIcB4M5DiZwXCTAcQiY4xACx8UCHJ8Cc3yKwPEDAY5DwRyHEjguEeA4DMxxGIHjUgGOw8EchxM4LhPgOALMcQSB43IBjiPBHEcSOK6wnOOYxKPfrIbsj3H/caWAHkeB9TiKwHGVAMenwRyfJnBcLcBxNJjjaALHNQIcx4A5jiFwXCvA8Rkwx2cIHNcJcBwL5jiWwHG9AMdxYI7jCBw3CHAcD+Y4nsBxowDHCWCOEwgcNwlwnAjmOJHAcbMAx2fBHJ8lcNwiwPE5MMfnCBy3CnCcBOY4icBxmwDHyWCOkwkctwtwnALmOIXAcYcAx6lgjlMJHHeCOaLH1z5w9KUd6Pi0B47xQyBD0Te7RO0lGrtKHP25u0Qg/wszdpX4+0s0zB8pvdllVwncuHaXwAVX9M0uyYEoiXJPUJQfhYtyj48oPyqh9WaXPUBRflSCE9yiYH7IOe8FVgF+c3UiO/58cw/wrSnurGB/6MTwseUVn+E4G8xxNoHjJwIcXwBzfIHA8VMBji+COb5I4LhPgOMcMMc5BI6fCXCcC+Y4l8DxcwGOL4E5vkTg+IUAx3lgjvMIHPcLcHwZzPFlAscvBTi+Aub4CoHjVwIcXwVzfJXA8WsBjvPBHOcTOH4jwPE1MMfXCBy/FeD4Opjj6wSOBwQ4vgHm+AaB43cCHN8Ec3yTwPF7AY5vgTm+ReB4kPyk1InscC/w+phFmPchAf28DdbP2wSOPwhwfAfM8R0Cxx8FOL4L5vgugeNPAhzfA3N8j8DxZwGOC8AcFxA4/iLAcSGY40ICx18FOL4P5vg+geNvAhwXgTkuInD8XYDjYjDHxQSOhwU4fgDm+AGB4xEBjkvAHJcQOP4hwHEpmONSAsdASfs5LgNzXEbgWESA43Iwx+UEjkUFOK4Ac1xB4FhMgONKMMeVBI4xlnMcnXj0GzyR/THu48YK6HEVWI+rCBzjBDiuBnNcTeAYL8BxDZjjGgLHBAGOa8Ec1xI4JgpwXAfmuI7AMUmA43owx/UEjsUFOG4Ac9xA4FhCgONGMMeNBI4lBThuAnPcROBYSoDjZjDHzQSOpQU4bgFz3ELgWEaA41Ywx60EjmUFOG4Dc9xG4FhOgON2MMftBI7lBTjuAHPcQeBYQYDjTjDHnQSOFQU4fgjm+CGBYyUwR/T4OgSOvowHHZ8OwDFWBjIUfWNT1F6OU6Xk0Z8nlAzkfxGO+Q/hL8cxf6T0xqYqJXHjOqEkLriib2xKCURJlCcGRXlSuChP9BHlSSW13th0IlCUJ5XkBLcomB9yzifjrg6UNzaZt1MB34bk7g32h04Mp1he8RmOn4A5fkLgeKoAx0/BHD8lcKwqwHEfmOM+AsdqAhw/A3P8jMCxugDHz8EcPydwrCHA8Qswxy8IHE8T4LgfzHE/gePpAhy/BHP8ksDxDAGOX4E5fkXgeKYAx6/BHL8mcDxLgOM3YI7fEDjWFOD4LZjjtwSOtQQ4HgBzPEDgeLYAx+/AHL8jcDxHgOP3YI7fEzjWFuB4EMzxIIFjHQGOh8AcDxE4nkt+4uxEdrgXen3sJcz7PAH9/ADWzw8Ejo4Axx/BHH8kcHQFOP4E5vgTgWOyAMefwRx/JnBMEeD4C5jjLwSOqQIcfwVz/JXAsa4Ax9/AHH8jcEwT4Pg7mOPvBI7pAhwPgzkeJnDMEOB4BMzxCIFjpgDHP8Ac/yBwPF+AI/CtUn9yDJTEc7xAgGMRMMciBI4XCnAsCuZYlMDxIgGOxcAcixE4XizAMQbMMYbA8RIBjrFgjrEEjvUs5/h04tFvikb2x7gffqmAHuPAeowj6PEyAY7xYI7xBI6XC3BMAHNMIHC8QoBjIphjIoHjlQIck8AckwgcrxLgWBzMsTiB49UCHEuAOZYgcLxGgGNJMMeSBI7XCnAsBeZYisCxvgDH0mCOpQkcGwhwLAPmWIbAsaEAx7JgjmUJHBsJcCwH5liOwLGxAMfyYI7lCRybCHCsAOZYgcCxqQDHimCOFQkcmwlwrATmWInAsbkAx8pgjpUJHFtY/ia2joGjL9lCx6cjcIwtC9/EFrWXXrUKvvSqdfhLr1r5vPSqtdib2FoBXwDVGvjSK9E3saUGoiTKNkFRtg0XZRsfUbYVexNbG6Ao25bkBLcomB9yzu0sfxObeesc8C1n7snB/tCJob3lFZ/heCqY46kEjh0EOFYFc6xK4NhRgGM1MMdqBI6dBDhWB3OsTuDYWYBjDTDHGgSOXQQ4ngbmeBqBY1cBjqeDOZ5O4NhNgOMZYI5nEDhmCXA8E8zxTALHbAGOZ4E5nkXgmCPAsSaYY00Cx1wBjrXAHGsROOYJcDwbzPFsAsfuAhzPAXM8h8CxhwDH2mCOtQkcewpwrAPmWIfAsZcAx3PBHM8lcOwtwPE8MMfzCByvIz+5dyI73Iu8Pk4mzPt6Af04YP04BI59BDi6YI4ugeMNAhyTwRyTCRxvFOCYAuaYQuB4kwDHVDDHVALHvgIc64I51iVwvFmAYxqYYxqB4y0CHNPBHNMJHG8V4JgB5phB4HibAMdMMMdMAsfbBTieD+Z4PoHjHQIcLwBzvIDA8U4BjheCOV5I4HiXAMeLwBwvInC8W4DjxWCOFxM49hPgeAmY4yUEjvcIcKwH5liPwPFeAY6XgjleSuB4n+UcRyUGAieWxPbHeK5wv4AeLwPr8TICx/4CHC8Hc7ycwPEBAY5XgDleQeD4oADHK8EcryRwfEiA41VgjlcROD4swPFqMMerCRwHCHC8BszxGgLHRwQ4XgvmeC2B46MCHOuDOdYncHxMgGMDMMcGBI6PC3BsCObYkMDxCQGOjcAcGxE4DhTg2BjMsTGB4yABjk3AHJsQOD4pwLEpmGNTAsfBAhybgTk2I3AcIsCxOZhjcwLHpwQ4tgBzbEHgOFSAY0swx5YEjsPAHOHvXwkcfXkeOj6dgGMcDmQo+obFqL3MbkTJoz9Hlgzkf3HdiJJ/f5md+SOlNyyOKIkb18iSuOCKvmGxbiBKohwVFOXT4aIc5SPKp0tqvWFxFFCUT5fkBLcomB9yzqOBVYDfXJ3Ijj/foNkeOMZ2wf7QiWGM5RWf4dgBzLEDgeMzAhw7gjl2JHAcK8CxE5hjJwLHcQIcO4M5diZwHC/AsQuYYxcCxwkCHLuCOXYlcJwowLEbmGM3AsdnBThmgTlmETg+J8AxG8wxm8BxkgDHHDDHHALHyQIcc8EccwkcpwhwzANzzCNwnCrAsTuYY3cCx2kCHHuAOfYgcJwuwLEnmGNPAscZAhx7gTn2InCcKcCxN5hjbwLHWQIcrwNzvI7A8XkBjteDOV5P4DibvAPCiexwL/b6aEeY9wsC+ukD1k8fAscXBTjeAOZ4A4HjHAGON4I53kjgOFeA401gjjcROL4kwLEvmGNfAsd5AhxvBnO8mcDxZQGOt4A53kLg+IoAx1vBHG8lcHxVgONtYI63ETjOF+B4O5jj7QSOrwlwvAPM8Q4Cx9cFON4J5ngngeMbAhzvAnO8i8DxTQGOd4M53k3g+JYAx35gjv0IHN8W4HgPmOM9BI7vCHC8F8zxXgLHdwU43gfmeB+B43sCHO8Hc7yfwHGB5RxHJgYCbUpi+2M8n1kooMf+YD32J3B8X4DjA2CODxA4LhLg+CCY44MEjosFOD4E5vgQgeMHAhwfBnN8mMBxiQDHAWCOAwgclwpwfATM8RECx2UCHB8Fc3yUwHG5AMfHwBwfI3BcIcDxcTDHxwkcVwpwfALM8QkCx1UCHAeCOQ4kcFwtwHEQmOMgAsc1AhyfBHN8ksBxrQDHwWCOgwkc1wlwHALmOITAcb0Ax6fAHJ8icNwgwHEomONQAseNAhyHgTkOI3DcJMBxOJjjcALHzWCO6PF1Dhx9KSY6Pp2BY9wCZCj65tSovaRya8mjP7eVDOR/IeXWkn9/SaX5I6U3p24tiRvXtpK44Iq+OTUtECVRbg+Kcke4KLf7iHJHSa03p24HinJHSU5wi4L5Iee8E1gF+M3Viez48824wLeSuqOD/aETw4eWV3yG4zNgjs8QOO4S4DgWzHEsgeNuAY7jwBzHETjuEeA4HsxxPIHjRwIcJ4A5TiBw3CvAcSKY40QCx48FOD4L5vgsgeMnAhyfA3N8jsDxUwGOk8AcJxE47hPgOBnMcTKB42cCHKeAOU4hcPxcgONUMMepBI5fCHCcBuY4jcBxvwDH6WCO0wkcvxTgOAPMcQaB41cCHGeCOc4kcPxagOMsMMdZBI7fCHB8HszxeQLHbwU4zgZznE3geECA4wtgji8QOH5H3kniRHa4l3h9jCbM+3sB/bwI1s+LBI4HBTjOAXOcQ+B4SIDjXDDHuQSOPwhwfAnM8SUCxx8FOM4Dc5xH4PiTAMeXwRxfJnD8WYDjK2COrxA4/iLA8VUwx1cJHH8V4DgfzHE+geNvAhxfA3N8jcDxdwGOr4M5vk7geFiA4xtgjm8QOB4R4PgmmOObBI5/CHB8C8zxLQLHQCn7Ob4N5vg2gWMRAY7vgDm+Q+BYVIDju2CO7xI4FhPg+B6Y43sEjjECHBeAOS4gcIwV4LgQzHEhgWOc5RxHJAYCo0pi+2M854oX0OP7YD2+T+CYIMBxEZjjIgLHRAGOi8EcFxM4Jglw/ADM8QMCx+ICHJeAOS4hcCwhwHEpmONSAseSAhyXgTkuI3AsJcBxOZjjcgLH0gIcV4A5riBwLCPAcSWY40oCx7ICHFeBOa4icCwnwHE1mONqAsfyAhzXgDmuIXCsIMBxLZjjWgLHigIc14E5riNwrCTAcT2Y43oCx8oCHDeAOW4gcKwiwHEjmONGAscTBDhuAnPcROB4ogDHzWCOmwkcTxLguAXMcQuB48lgjujxdQkcfdktOj5dgGM8BchQ9I3IUXv57Kmljv6sWiqQ/0Wz5j+Ev3zW/JHSG5FPLYUbV9VSuOCKvhE5PRAlUVYLirJ6uCir+YiyeimtNyJXA4qyeilOcIuC+SHnXAN3daC8Edm8/Rn4tmF3Z7A/dGI4zfKKz3DcBea4i8DxdAGOu8EcdxM4niHAcQ+Y4x4CxzMFOH4E5vgRgeNZAhz3gjnuJXCsKcDxYzDHjwkcawlw/ATM8RMCx7MFOH4K5vgpgeM5Ahz3gTnuI3CsLcDxMzDHzwgc6whw/BzM8XMCx3MFOH4B5vgFgeN5Ahz3gznuJ3B0BDh+Ceb4JYGjK8DxKzDHrwgckwU4fg3m+DWBY4oAx2/AHL8hcEwV4PgtmOO3BI51BTgeAHM8QOCYJsDxOzDH7wgc0wU4fg/m+D2BYwZ5R44T2eGafnYS5p0poJ+DYP0cJHA8X4DjITDHQwSOFwhw/AHM8QcCxwsFOP4I5vgjgeNFAhx/AnP8icDxYgGOP4M5/kzgeIkAx1/AHH8hcKwnwPFXMMdfCRwvFeD4G5jjbwSOlwlw/B3M8XcCx8sFOB4GczxM4HiFAMcjYI5HCByvFOD4B5jjHwSOVwlwBL61+U+OgVJ4jlcLcCwC5liEwPEaAY5FwRyLEjheK8CxGJhjMQLH+gIcY8AcYwgcGwhwjAVzjCVwbCjAMQ7MMY7AsZEAx3gwx3gCx8aWcxyeGAhsL4ntj/G8sImAHhPAekwg6LGpAMdEMMdEAsdmAhyTwByTCBybC3AsDuZYnMCxhQDHEmCOJQgcWwpwLAnmWJLAsZUAx1JgjqUIHFsLcCwN5liawLGNAMcyYI5lCBzbCnAsC+ZYlsCxnQDHcmCO5Qgc2wtwLA/mWJ7AsYMAxwpgjhUIHDsKcKwI5liRwLGTAMdKYI6VCBw7C3CsDOZYmcCxiwDHKmCOVQgcuwpwPAHM8QQCx24CHE8EczyRwDFLgONJYI4nEThmC3A8GczxZALHHAGOp4A5nkLgmEv+XGXE18HA0ZdYo+PTFTjGPCBD0TedR+2l0t1LHf3Zo1Qg/wuku5f6+0ulzR8pvem8eyncuHqUwgVX9E3nGYEoibJnUJS9wkXZ00eUvUppvem8J1CUvUpxglsUzA85597AKsBvrk5kx59vsge+RdytEewPnRius7ziMxxPB3M8ncDxegGOZ4A5nkHg2EeA45lgjmcSON4gwPEsMMezCBxvFOBYE8yxJoHjTQIca4E51iJw7CvA8Wwwx7MJHG8W4HgOmOM5BI63CHCsDeZYm8DxVgGOdcAc6xA43ibA8Vwwx3MJHG8X4HgemON5BI53CHB0wBwdAsc7BTi6YI4ugeNdAhyTwRyTCRzvFuCYAuaYQuDYT4BjKphjKoHjPQIc64I51iVwvFeAYxqYYxqB430CHNPBHNMJHO8X4JgB5phB4NhfgGMmmGMmgeMDYI7oN8Zf6vVRgzDvBwX0cz5YP+cTOD4kwPECMMcLCBwfFuB4IZjjhQSOAwQ4XgTmeBGB4yMCHC8Gc7yYwPFRAY6XgDleQuD4mADHemCO9QgcHxfgeCmY46UEjk8IcLwMzPEyAseBAhwvB3O8nMBxkADHK8AcryBwfFKA45VgjlcSOA4W4HgVmONVBI5DBDheDeZ4NYHjUwIcrwFzvIbAcagAx2vBHK8lcBwmwLE+mGN9AsfhAhwbgDk2IHAcIcCxIZhjQwLHkQIcG4E5NiJwHCXAsTGYY2MCx6cFODYBc2xC4Djaco7DEgOBaqWw/TGeu44R0GNTsB6bEjg+I8CxGZhjMwLHsQIcm4M5NidwHCfAsQWYYwsCx/ECHFuCObYkcJwgwLEVmGMrAseJAhxbgzm2JnB8VoBjGzDHNgSOzwlwbAvm2JbAcZIAx3Zgju0IHCcLcGwP5tiewHGKAMcOYI4dCBynCnDsCObYkcBxmgDHTmCOnQgcpwtw7Azm2JnAcYYAxy5gjl0IHGcKcOwK5tiVwHGWAMduYI7dCByfF+CYBeaYReA4W4BjNphjNoHjCwIcc8AccwgcXxTgmAvmmEvgOEeAYx6YYx6B41wwR/g30ASOvpweHZ9uwDG+BGQo+g0GUXtZ/LxSR3++XCqQ/8Xw80r9/WXx5o+UvsFgXincuF4uhQuu6DcYZAaiJMpXgqJ8NVyUr/iI8tVSWt9g8ApQlK+W4gS3KJgfcs7zgVWA31ydyI4/v6EC+O0Abu9gf+jE8JrlFZ/heD2Y4/UEjq8LcOwD5tiHwPENAY43gDneQOD4pgDHG8EcbyRwfEuA401gjjcROL4twLEvmGNfAsd3BDjeDOZ4M4HjuwIcbwFzvIXA8T0BjreCOd5K4LhAgONtYI63ETguFOB4O5jj7QSO7wtwvAPM8Q4Cx0UCHO8Ec7yTwHGxAMe7wBzvInD8QIDj3WCOdxM4LhHg2A/MsR+B41IBjveAOd5D4LhMgOO9YI73EjguF+B4H5jjfQSOKwQ43g/meD+B40oBjv3BHPsTOK4S4PgAmOMDBI6rBTg+COb4IIHjGjBH9DdBXOb10Zsw77UC+nkIrJ+HCBzXCXB8GMzxYQLH9QIcB4A5DiBw3CDA8REwx0cIHDcKcHwUzPFRAsdNAhwfA3N8jMBxswDHx8EcHydw3CLA8QkwxycIHLcKcBwI5jiQwHGbAMdBYI6DCBy3C3B8EszxSQLHHQIcB4M5DiZw3CnAcQiY4xACxw8FOD4F5vgUgeMuAY5DwRyHEjjuFuA4DMxxGIHjHgGOw8EchxM4fiTAcQSY4wgCx70CHEeCOY4kcPxYgOMoMMdRBI6fCHB8GszxaQLHTwU4jgZzHE3guE+A4xgwxzEEjp9ZznFoYiDQsxS2P8bz688F9PgMWI/PEDh+IcBxLJjjWALH/QIcx4E5jiNw/FKA43gwx/EEjl8JcJwA5jiBwPFrAY4TwRwnEjh+I8DxWTDHZwkcvxXg+ByY43MEjgcEOE4Cc5xE4PidAMfJYI6TCRy/F+A4BcxxCoHjQQGOU8EcpxI4HhLgOA3McRqB4w8CHKeDOU4ncPxRgOMMMMcZBI4/CXCcCeY4k8DxZwGOs8AcZxE4/iLA8Xkwx+cJHH8V4DgbzHE2geNvAhxfAHN8gcDxdwGOL4I5vkjgeFiA4xwwxzkEjkcEOM4Fc5xL4PiHAMeXwBxfInAMlMZyRI8vK3D0SyfQ8ckCjrEIkKHoN5NE7UsgipY++rNY6UD+L3ww/yH8SyDMHyl9M0nR0rhxFSuNC67oN5N0C0RJlDFBUcaGizLGR5SxpbW+mSQGKMrY0pzgFgXzQ845Dnd1oHwzifkWFuC3frjzg/2hE0M8uFJhcHwdzPF1AscEAY5vgDm+QeCYKMDxTTDHNwkckwQ4vgXm+BaBY3EBjm+DOb5N4FhCgOM7YI7vEDiWFOD4LpjjuwSOpQQ4vgfm+B6BY2kBjgvAHBcQOJYR4LgQzHEhgWNZAY7vgzm+T+BYToDjIjDHRQSO5QU4LgZzXEzgWEGA4wdgjh8QOFYU4LgEzHEJgWMlAY5LwRyXEjhWFuC4DMxxGYFjFQGOy8EclxM4niDAcQWY4woCxxMFOK4Ec1xJ4HiSAMdVYI6rCBxPFuC4GsxxNYHjKQIc14A5riFwPFWA41owx7UEjlXJO+2cyA73cq+P+YR5VxPQzzqwftYROFYX4LgezHE9gWMNAY4bwBw3EDieJsBxI5jjRgLH0wU4bgJz3ETgeIYAx81gjpsJHM8U4LgFzHELgeNZAhy3gjluJXCsKcBxG5jjNgLHWgIct4M5bidwPFuA4w4wxx0EjucIcNwJ5riTwLG2AMcPwRw/JHCsI8BxF5jjLgLHcwU47gZz3E3geJ4Axz1gjnsIHB0Bjh+BOX5E4OgKcNwL5riXwDFZgOPHYI4fEzimCHD8BMzxEwLHVAGOn4I5fkrgWFeA4z4wx30EjmkCHD8Dc/yMwDFdgOPnYI6fEzhmWM7xqcRA4JVS2P4Y+wAyBfT4BViPXxA4ni/AcT+Y434CxwsEOH4J5vglgeOFAhy/AnP8isDxIgGOX4M5fk3geLEAx2/AHL8hcLxEgOO3YI7fEjjWE+B4AMzxAIHjpQIcvwNz/I7A8TIBjt+DOX5P4Hi5AMeDYI4HCRyvEOB4CMzxEIHjlQIcfwBz/IHA8SoBjj+COf5I4Hi1AMefwBx/InC8RoDjz2COPxM4XivA8Rcwx18IHOsLcPwVzPFXAscGAhx/A3P8jcCxoQDH38EcfydwbCTA8TCY42ECx8YCHI+AOR4hcGwiwPEPMMc/CBybCnAEfgvNnxwDpfEcmwlwLALmWITAsbnl3ziUHTj6ZTLo+GQDx9ii8BuHuvkMF9R3/i93aRn8cpdW4V/u0tLny11aiX3jUEvgF520An65i+g3DmUFoiTK1kFRtgkXZWsfUbYR+8ah1kBRtinNCW5RMD/knNta/o1D5tuVgN/m48YF+0MnhnaWV3yGYwKYYwKBY3sBjolgjokEjh0EOCaBOSYROHYU4FgczLE4gWMnAY4lwBxLEDh2FuBYEsyxJIFjFwGOpcAcSxE4dhXgWBrMsTSBYzcBjmXAHMsQOGYJcCwL5liWwDFbgGM5MMdyBI45AhzLgzmWJ3DMFeBYAcyxAoFjngDHimCOFQkcuwtwrATmWInAsYcAx8pgjpUJHHsKcKwC5liFwLGXAMcTwBxPIHDsLcDxRDDHEwkcrxPgeBKY40kEjtcLcDwZzPFkAsc+AhxPAXM8hcDxBgGOp4I5nkrgeKMAx6pgjlUJHG8S4FgNzLEagWNfMEf0Nzdd4fURR5j3zQL6qQ7WT3UCx1sEONYAc6xB4HirAMfTwBxPI3C8TYDj6WCOpxM43i7A8QwwxzMIHO8Q4HgmmOOZBI53CnA8C8zxLALHuwQ41gRzrEngeLcAx1pgjrUIHPsJcDwbzPFsAsd7BDieA+Z4DoHjvQIca4M51iZwvE+AYx0wxzoEjvcLcDwXzPFcAsf+AhzPA3M8j8DxAQGODpijQ+D4oABHF8zRJXB8SIBjMphjMoHjwwIcU8AcUwgcBwhwTAVzTCVwfESAY10wx7oEjo8KcEwDc0wjcHxMgGM6mGM6gePjAhwzwBwzCByfEOCYCeaYSeA40HKOQxIDgZjS2P4Y+ykGCejxfLAezydwfFKA4wVgjhcQOA4W4HghmOOFBI5DBDheBOZ4EYHjUwIcLwZzvJjAcagAx0vAHC8hcBwmwLEemGM9AsfhAhwvBXO8lMBxhADHy8AcLyNwHCnA8XIwx8sJHEcJcLwCzPEKAsenBTheCeZ4JYHjaAGOV4E5XkXgOEaA49VgjlcTOD4jwPEaMMdrCBzHCnC8FszxWgLHcQIc64M51idwHC/AsQGYYwMCxwkCHBuCOTYkcJwowLERmGMjAsdnBTg2BnNsTOD4nADHJmCOTQgcJwlwbArm2JTAcbIAx2Zgjs0IHKcIcGwO5ticwHGqAMcWYI4tCByngTnC3xMbOPolUej45ADHOB3IUPSbxLJ8hgvqO/+XNs0offTnzNKB/F/QNKP037+0yfyR0jeJzSiNG9fM0rjgin6TWHYgSqKcFRTl8+GinOUjyudLa32T2CygKJ8vzQluUTA/5JxnA6sAv7k6kR1/flMc8Fu63LbB/tCJ4QXLKz7DsT2YY3sCxxcFOHYAc+xA4DhHgGNHMMeOBI5zBTh2AnPsROD4kgDHzmCOnQkc5wlw7ALm2IXA8WUBjl3BHLsSOL4iwLEbmGM3AsdXBThmgTlmETjOF+CYDeaYTeD4mgDHHDDHHALH1wU45oI55hI4viHAMQ/MMY/A8U0Bjt3BHLsTOL4lwLEHmGMPAse3BTj2BHPsSeD4jgDHXmCOvQgc3xXg2BvMsTeB43sCHK8Dc7yOwHGBAMfrwRyvJ3BcKMCxD5hjHwLH9wU43gDmeAOB4yIBjjeCOd5I4LhYgONNYI43ETh+IMCxL5hjXwLHJQIcbwZzvJnAcSmYI/ob2a70+mhLmPcyAf3cAtbPLQSOywU43grmeCuB4woBjreBOd5G4LhSgOPtYI63EziuEuB4B5jjHQSOqwU43gnmeCeB4xoBjneBOd5F4LhWgOPdYI53EziuE+DYD8yxH4HjegGO94A53kPguEGA471gjvcSOG4U4HgfmON9BI6bBDjeD+Z4P4HjZgGO/cEc+xM4bhHg+ACY4wMEjlsFOD4I5vgggeM2AY4PgTk+ROC4XYDjw2CODxM47hDgOADMcQCB404Bjo+AOT5C4PihAMdHwRwfJXDcJcDxMTDHxwgcdwtwfBzM8XECxz0CHJ8Ac3yCwPEjAY4DwRwHEjjuFeA4CMxxEIHjx5ZzHJwYCLQuje2PsS/lEwE9PgnW45MEjp8KcBwM5jiYwHGfAMchYI5DCBw/E+D4FJjjUwSOnwtwHArmOJTA8QsBjsPAHIcROO4X4DgczHE4geOXAhxHgDmOIHD8SoDjSDDHkQSOXwtwHAXmOIrA8RsBjk+DOT5N4PitAMfRYI6jCRwPCHAcA+Y4hsDxOwGOz4A5PkPg+L0Ax7FgjmMJHA8KcBwH5jiOwPGQAMfxYI7jCRx/EOA4AcxxAoHjjwIcJ4I5TiRw/EmA47Ngjs8SOP4swPE5MMfnCBx/EeA4CcxxEoHjrwIcJ4M5TiZw/E2A4xQwxykEjr8LcJwK5jiVwPGwAMdpYI7TCByPCHCcDuY4ncDxDzBH9PhyA0e//A0dn1zgGANlcAxFvyEwal/GVqTM0Z9FywTyf/Ga+Q/hX8Zm/kjpGwKLlMGNq2gZTnCLgvgx5lysDE50oToq5qMj9GKMgSWRNJc5zljYON1uzHHGwcaZTh1nPI5npukDfaE0X5YI/HI+d3awPzTHBOBFmMXxRTDHFwkcEwU4zgFznEPgmCTAcS6Y41wCx+ICHF8Cc3yJwLGEAMd5YI7zCBxLCnB8GczxZQLHUgIcXwFzfIXAsbQAx1fBHF8lcCwjwHE+mON8AseyAhxfA3N8jcCxnADH18EcXydwLC/A8Q0wxzcIHCsIcHwTzPFNAseKAhzfAnN8i8CxkgDHt8Ec3yZwrCzA8R0wx3cIHKsIcHwXzPFdAscTBDi+B+b4HoHjiQIcF4A5LiBwPEmA40Iwx4UEjicLcHwfzPF9AsdTBDguAnNcROB4qgDHxWCOiwkcqwpw/ADM8QMCx2oCHJeAOS4hcKwuwHEpmONSAscaAhyXgTkuI3A8DcwR/UWMV3l9zCbM+3QB/SwH62c5geMZAhxXgDmuIHA8U4DjSjDHlQSOZwlwXAXmuIrAsaYAx9VgjqsJHGsJcFwD5riGwPFsAY5rwRzXEjieI8BxHZjjOgLH2gIc14M5ridwrCPAcQOY4wYCx3MFOG4Ec9xI4HieAMdNYI6bCBwdAY6bwRw3Ezi6Ahy3gDluIXBMFuC4FcxxK4FjigDHbWCO2wgcUwU4bgdz3E7gWFeA4w4wxx0EjmkCHHeCOe4kcEwX4PghmOOHBI4ZAhx3gTnuInDMFOC4G8xxN4Hj+QIc94A57iFwvECA40dgjh8ROF4owHEvmONeAseLBDh+DOb4MYHjxQIcPwFz/ITA8RLLOT6ZGAjMKo3tj7G/p56AHj8F6/FTAsdLBTjuA3PcR+B4mQDHz8AcPyNwvFyA4+dgjp8TOF4hwPELMMcvCByvFOC4H8xxP4HjVQIcvwRz/JLA8WoBjl+BOX5F4HiNAMevwRy/JnC8VoDjN2CO3xA41hfg+C2Y47cEjg0EOB4AczxA4NhQgON3YI7fETg2EuD4PZjj9wSOjQU4HgRzPEjg2ESA4yEwx0MEjk0FOP4A5vgDgWMzAY4/gjn+SODYXIDjT2COPxE4thDg+DOY488Eji0FOP4C5vgLgWMrAY6/gjn+SuDYWoDjb2COvxE4thHg+DuY4+8Ejm0FOB4GczxM4NhOgOMRMMcjBI7tBTj+Aeb4B4FjBwGOwC+M/JOj6Q/NsSOQo/kevUZeiwkO0nzXnfkeOfMdbeb7z/bEBgK7vbbLax96bafXdnhtu9e2eW2r17Z4bbPXNnlto9c2eG2919Z5ba3X1nhttddWeW2l11Z4bbnXlnltqdeWeO0Dry322iKvHSxW2I610+IDgRpeq+61al6r6rVTvXaK10722kleO9FrJ3ititcqe62S1yp6rYLXynutnNfKeq2M10p7rZTXSnqthNeKey3Ja4leS/BafHz+//+8hEAg12s5Xsv2WpbXunmtq9e6eK2z1zp5raPXOnitvdfaea2t19p4rbXXWnmtpddaeK2515p5ranXmnitsdcaea2h1xp4rX5C/v9/891x5nvPzHd2me+bMt+VZL7nx3xHjfl+FfPdIOZ7Lcx3MpjvEzDvwjfvcTfvIDfvzzbvfjbvLTbv3DXvizXvOjXv6TTvmDTvRzTv9jPvpTPvVDPvAzPvxgr9/zfveDLvJzLv1jHvhTHvNDHv4zDvkjDvQTCf4TefPzefnTaf+zWfWTWftzSfFTSfczOf0TKfLzKfjTGf6zCfSTD76c1ecLOP2ezBNftH/9z76LVBifn//80eNLN/yuz9MftWzJ4Ls1/APOs2z2nNM0bzfMw82zHPJcw9dXM/2NzLNPfhzD0kc//DeHfjO41nMvW+qVVNnWVqBHN9M7m5Y5m/6y/8KArKZYzvGO2EyovBL7Zt9PfpQ69f5kC/Mw7GgDjGzugxokR5TEh5gaNfWoyasOnLTBpdsOQB59wFGBTy4nH/Ly8eZJwCqlnOXJlsH2NXgph8Bxrpyu8GzHSqguomsPKzVASVjRtosqqgsgUElVN4KXHc7wUuJbkqKz8PN9BUVUHlCaz87iqC6oEbaF1VQfUQEFRPFUH1wg00TVVQvQQE1VtFUNfhBpquKqjrBAR1vYqg+uAGmqEqqD4CgrpBRVA34gaaqSqoGwUEdZOKoPriBtpNVVB9BQR1s4qgbsENNEtVULcICOpWFUHdhhtotqqgbhMQ1O0qgroDN9AcVUHdISCoO1UEdRduoLmqgrpLQFB3qwiqH26geaqC6icgqHtUBHUvbKCu7G7KewUEdZ+KoO7HCUp2n9H9AoLqryKoB3CCkt1n9ICAoB5UEdRDOEGlqArqIQFBPawiqAE4QcnuhxogIKhHVAT1KE5QsvuhHhUQ1GMqgnocJyjZ/VCPCwjqicK92o4bF2P/GAeqrPxBuJUvu89okMDKf7Jw5TtuvECgBhcGynFjBQI1RCVFP4VL0bL7Yp4SENRQFUENwwlKdl/MMAFBDVcR1AicoGT3xYwQENRIFUGNwglKdl/MKAFBPa0iqNE4QcnuixktIKgxKoJ6BjbQZNl9Mc8ICGqsiqDG4QQlu41hnICgxqsIagJOULLbGCYICGqiiqCexQlKdhvDswKCek5FUJNwgpLdxjBJQFCTVQQ1BSco2W0MUwQENVVFUNNwgpJ9rcs0AUFNVxHUDJygZLdbzBAQ1EwVQc3CCUr2tS6zBAT1vIqgZuMEJftal9kCgnpBRVAv4gQlu33lRQFBzSncuOa4TQXeAz1XZeW/hFv5sttCXhJY+fNUBPUyTlCy20JeFhDUKyqCehUnKNltIa8KCGq+iqBegw00RXZbyGsCgnpdRVBv4AQl+7qUNwQE9aaKoN7CCUp2n9FbAoJ6W0VQ7+AEJbvP6B0BQb2rIqj3cIKS3Wf0noCgFqgIaiFOULL7jBYKCOp9FUEtwglKdp/RIgFBLVYR1Ac4QcnuM/pAQFBLVAS1FCco2X1GSwUEtUxFUMtxgpLdZ7RcQFArVAS1Eico2X1GKwUEtUpFUKtxgpLdZ7RaQFBrVAS1Fico2dfkrBUQ1DoVQa3HCUp2P9R6AUFtUBHURpygZPdDbRQQ1CYVQW3GCUp2P9RmAUFtURHUVthAU2X3Q20VENQ2FUFtxwlKdvvKdgFB7VAR1E6coGS3r+wUENSHKoLahROU7PaVXQKC2q0iqD04QcluX9kjIKiPVAS1Fyco2e0rewUE9bGKoD7BCUp2+8onAoL6VEVQ+3CCkt2+sk9AUJ+pCOpznKBkt698LiCoL1QEtR8nKNntK/sFBPWliqC+wglKdvvKVwKC+lpFUN/gBCW7feUbAUF9qyKoAzhByW5fOSAgqO9UBPU9TlCy21e+FxDUQRVBHcIJSnb7yiEBQf2gIqgfYQOtK7t95UcBQf2kIqifcYKSfZ3PzwKC+kVFUL/iBCW7H+pXAUH9piKo33GCkt0P9buAoA6rCOoITlCy+6GOCAjqDxVBBcrCBCW7HwrHgDfGImVFBFUUJyjZ/VBFBQRVTEVQMThBye6HihEQVKyKoOJwgpLdDxUnIKh4FUEl4AQlux8qQUBQiSqCSsIJSnY/VJKAoIqrCKoETlCy+6FKCAiqpIqgSuEEJbsfqpSAoEqrCKoMTlCy+6HKCAiqrIqgyuEEJbsfqpyAoMqrCKoCTlCy+6EqCAiqooqgKsEGmia7H6qSgKAqqwiqCk5QsttXqggI6gQVQZ2IE5Ts9pUTBQR1koqgTsYJSnb7yskCgjpFRVCn4gQlu33lVAFBVVURVDWcoGS3r1QTEFR1FUHVwAlKdvtKDQFBnaYiqNNxgpLdvnK6gKDOUBHUmThByW5fOVNAUGepCKomTlCy21dqCgiqloqgzsYJSnb7ytkCgjpHRVC1cYKS3b5SW0BQdVQEdS5OULLbV84VENR5KoJycIKS3b7iCAjKVRFUMk5QsttXkgUElaIiqFTYQNNlt6+kCgiqroqg0nCCkn2dT5qAoNJVBJWBE5TsfqgMAUFlqgjqfJygZPdDnS8gqAtUBHUhTlCy+6EuFBDURSqCuhgnKNn9UBcLCOoSFUHVwwlKdj9UPQFBXaoiqMtwgpLdD3WZgKAuVxHUFThBye6HukJAUFeqCOoqnKBk90NdJSCoq5FjVA1UXBn7x3iNysq/FrfyZfcZXSuw8uurCKoBTlCy+4waCAiqoYqgGuEEJbvPqJGAoBqrCKoJTlCy+4yaCAiqqYqgmuEEJbvPqJmAoJqrCKoFbKAZsvuMWggIqqWKoFrhBCW7LaSVgKBaqwiqDU5QsttC2ggIqq2KoNrhBCW7LaSdgKDaqwiqA05QsttCOggIqqOKoDrhBCW7LaSTgKA6qwiqC05QsttCuggIqquKoLrhBCW7LaSbgKCyVASVjROU7LaQbAFB5agIKhcnKNnX5OQKCCpPRVDdcYKS3b7SXUBQPVQE1RMnKNntKz0FBNVLRVC9cYKS3b7SW0BQ16kI6nqcoGS3r1wvIKg+KoK6ASco2e0rNwgI6kYVQd0EG2im7PaVmwQE1VdFUDfjBCX7mpybBQR1i4qgbsUJSnY/1K0CgrpNRVC34wQlux/qdgFB3aEiqDtxgpLdD3WngKDuUhHU3ThBye6HultAUP1UBHUPTlCy+6HuERDUvSqCug8nKNn9UPcJCOp+FUH1xwlKdj9UfwFBPaAiqAdxgpLdD/WggKAeUhHUwzhBye6HelhAUANUBPUITlCy+6EeERDUoyqCegwnKNn9UI8JCOpxFUE9gROU7H6oJwQENVBFUINwgpLdDzVIQFBPqghqME5QsvuhBgsIaoiKoJ6CDbSb7H6opwQENVRFUMNwgpLdvjJMQFDDVQQ1Aico2e0rIwQENVJFUKNwgpLdvjJKQFBPqwhqNE5QsttXRgsIaoyKoJ7BCUp2+8ozAoIaqyKocThByW5fGScgqPEqgpqAE5Ts9pUJAoKaqCKoZ3GCkt2+8qyAoJ5TEdQknKBkt69MEhDUZBVBTcEJSnb7yhQBQU1VEdQ0nKBkt69MExDUdBVBzcAJSnb7ygwBQc1UEdQsnKBkt6/MEhDU8yqCmo0TlOz2ldkCgnpBRVAvwgaaJbt95UUBQc1REdRcnKBkX+czV0BQL6kIah5OULL7oeYJCOplFUG9ghOU7H6oVwQE9aqKoObjBCW7H2q+gKBeUxHU6zhBye6Hel1AUG+oCOpNnKBk90O9KSCot1QE9TZOULL7od4WENQ7KoJ6Fyco2f1Q7woI6j0VQS3ACUp2P9QCAUEtVBHU+zhBye6Hel9AUItUBLUYJyjZ/VCLBQT1gYqgluAEJbsfaomAoJaqCGoZTlCy+6GWCQhquYqgVuAEJbsfaoWAoFaqCGoVTlCy+6FWCQhqtYqg1sAGmi27H2qNgKDWqghqHU5Qsvuh1gkIar2KoDbgBCW7H2qDgKA2qghqE05QsvuhNgkIarOKoLbgBCW7H2qLgKC2qghqG05QsvuhtgkIaruKoHbgBCW7H2qHgKB2qgjqQ5ygZPdDfSggqF0qgtqNE5TsfqjdAoLaoyKoj3CCkt0P9ZGAoPaqCOpjnKBk90N9LCCoT1QE9SlOULL7oT4VENQ+FUF9hhOU7H6ozwQE9bmKoL7ACUp2P9QXAoLaryKoL3GCkt0P9aWAoL5SEdTXOEHJ7of6WkBQ36gI6lvYQHNk90N9KyCoAyqC+g4nKNn9UN8JCOp7FUEdxAlKdj/UQQFBHVIR1A84Qcnuh/pBQFA/qgjqJ5ygZPdD/SQgqJ9VBPULTlCy+6F+ERDUryqC+g0nKNn9UL8JCOp3FUEdxglKdj/UYQFBHVER1B84Qcnuh/pDQFCBciKCKgIbaI7sfqgi5ewfY1EVQRXDCUp2P1QxAUHFqAgqFico2f1QsQKCilMRVDxOULL7oeIFBJWgIqhEnKBk90MlCggqSUVQxXGCkt0PVVxAUCVUBFUSJyjZ/VAlBQRVSkVQpWEDzZXdD1VaQFBlVARVFico2e0rZQUEVU5FUOVxgpLdvlJeQFAVVARVESco2e0rFQUEVUlFUJVxgpLdvlJZQFBVVAR1Ak5QsttXThAQ1IkqgjoJJyjZ7SsnCQjqZBVBnYITlOz2lVMEBHWqiqCq4gQlu32lqoCgqqkIqjpOULLbV6oLCKqGiqBOwwlKdvvKaQKCOl1FUGfgBCW7feUMAUGdqSKos3CCkt2+cpaAoGqqCKoWTlCy21dqCQjqbBVBnYMTlOz2lXMEBFVbRVB1YAPNk92+UkdAUOeqCOo8nKBkX+dznoCgHBVBuThBye6HcgUElawiqBScoGT3Q6UICCpVRVB1cYKS3Q9VV0BQaSqCSscJSnY/VLqAoDJUBJWJE5TsfqhMAUGdryKoC3CCkt0PdYGAoC5UEdRFOEHJ7oe6SEBQF6sI6hKcoGT3Q10iIKh6KoK6FCco2f1QlwoI6jIVQV2OE5TsfqjLBQR1hYqgrsQJSnY/1JUCgrpKRVBX4wQlux/qagFBXaMiqGtxgpLdD3WtgKDqqwiqAU5QsvuhGggIqqGKoBqhBuo6svuhGgkIqrGKoJrgBCW7H6qJgKCaqgiqGU5QsvuhmgkIqrmKoFrgBCW7H6qFgKBaIscY43VS0WtFfYIFd30oCK6bE2CJK1ivHTtalTv6s3W5IJBiwZ/mPxQJO2f+KCFsUMWIEP9tX7l55nDcVuVw42pdjhPcomB+yDm3wa1ENxDAL7giZQKBrmX+rkEnoiPNNf2i5t21DG6+bcHZmxGPLHg83G7IeGQB49FOIB458HikQ+ORA4xHe4F45OLXRyYyHrnAeHQAx6MolJvj7on1YlwGG9/uZfDj7A4cY0fLY7KbEJOehJj0BI6xk+Ux2UWISW9CTHoDx9jZ8ph8SIjJ9YSYXA8cYxfLY7KTEJMbCDG5ATjGrpbHZAchJjcRYnITcIzdLI/JdkJMbibE5GbgGLMsj8k2QkxuJcTkVuAYsy2PyVZCTG4nxOR24BhzLI/JFkJM7iTE5E7gGHMtj8lmQkzuJsTkbuAY8yyPySZCTO4hxOQe4Bi7Wx6TjYSY3EeIyX3AMfawPCYbCDHpT4hJf+AYe1oek/WEmDxIiMmDwDH2sjwm6wgxeZgQk4eBY+xteUzWEmLyCCEmjwDHeJ3lMVlDiMljhJg8Bhzj9ZbHZDUhJk8QYvIEcIx9LI/JKkJMBhJiMhA4xhssj8lKQkyeJMTkSeAYb7Q8JisIMRlMiMlg4BhvsjwmywkxGUKIyRDgGPtaHpNlhJgMJcRkKHCMN1sek6WEmAwnxGQ4cIy3WB6TJYSYjCTEZCRwjLdaHpMPCDF5mhCTp4FjvM3ymCwmxGQMISZjgGO83fKYLCLEZCwhJmOBY7xDYE/9eALD8UCGdwownEhgOBHI8C4Bhs8RGD4HZHi3AMPJBIaTgQz7CTCcSmA4FcjwHgGG0wkMpwMZ3ivAcCaB4Uwgw/sEGD5PYPg8kOH9AgxfIDB8AciwvwDDOQSGc4AMHxBgOJfAcC6Q4YMCDOcRGM4DMnxIgOErBIavABk+LMBwPoHhfCDDAQIMXycwfB3I8BEBhm8SGL4JZPioAMO3CQzfBjJ8TIDhuwSG7wIZPi7AcAGB4QIgwycEGL5PYPg+kOFAAYaLCQwXAxkOEmC4hMBwCZDhkwIMlxEYLgMyHCzAcAWB4QogwyECDFcRGK4CMnxKgOEaAsM1QIZDBRiuIzBcB2Q4TIDhBgLDDUCGwwUYbiIw3ARkOEKA4RYCwy1AhiMFGG4jMNwGZDhKgOEOAsMdQIZPCzD8kMDwQyDD0QIMdxMY7gYyHCPA8CMCw4+ADJ8RYPgxgeHHQIZjBRh+SmD4KZDhOAGGnxEYfgZkOF6A4RcEhl8AGU4QYPglgeGXQIYTBRh+TWD4NZDhswIMvyUw/BbI8DkBht8RGH4HZDhJgOFBAsODQIaTBRj+QGD4A5DhFAGGPxEY/gRkOFWA4S8Ehr8AGU4TYPgbgeFvQIbTBRgeJjA8DGQ4Q4DhHwSGfwAZzhRgWKQsnqHpEzXGWQIMixEYFgMyfF6AYSyBYSyQ4WwBhvEEhvFAhi8IMEwkMEwEMnxRgGFxAsPiQIZzBBiWJDAsCWQ4V4BhaQLD0kCGLwkwLEtgWBbIcJ4Aw/IEhuWBDF8WYFiRwLAikOErAgwrExhWBjJ8VYDhCQSGJwAZzhdgeBKB4UlAhq9Z/k7K0+Lx76Q8hRCTU4Axed3ymNQgxKQqISZVgTF5w/KYVCfEpDohJtWBMXnT8phUI8TkNEJMTgPG5C3LY1KVEJMzCDE5AxiTty2PyamEmJxFiMlZwJi8Y3lMTiHEpBYhJrWAMXnX8picTIjJOYSYnAOMyXuWx+QkQkzqEGJSBxiTBZbH5ERCTM4jxOQ8YEwWWh6TEwgxcQkxcYExed/ymFQhxCSFEJMUYEwWWR6TyoSY1CXEpC4wJostj0klQkzSCTFJB8bkA8tjUpEQk0xCTDKBMVlieUwqEGJyASEmFwBjstTymJQnxOQiQkwuAsZkmeUxKUeIySWEmFwCjMlyy2NSlhCTSwkxuRQYkxWWx6QMISaXE2JyOTAmKy2PSWlCTK4kxORKYExWWR6TUoSYXE2IydXAmKy2PCYlCTG5hhCTa4AxWWN5TEoQYlKfEJP6wJistTwmxQkxaUiISUNgTNZZHpMkQkwaE2LSGBiT9ZbHJJEQk6aEmDQFxmSD5TFJIMSkOSEmzYEx2Wh5TOIJMWlJiElLYEw2CeyDb01g2BrIcLMAw7YEhm2BDLdYnhvyEvC5oT0hJu2BMdlqeUxyCTHpSIhJR2BMtlkekxxCTDoTYtIZGJPtlsckmxCTroSYdAXGZIflMckixCSLEJMsYEx2Wh6TboSY5BBikgOMyYeWx6QrISZ5hJjkAWOyy/KYdCHEpAchJj2AMdlteUw6E2LSixCTXsCY7LE8Jp0IMbmOEJPrgDH5yPKYdCTEpA8hJn2AMdlreUw6EGJyIyEmNwJj8rHlMWlPiElfQkz6AmPyieUxaUeIyS2EmNwCjMmnlsekLSEmtxFichswJvssj0kbQkzuIMTkDmBMPrM8Jq0JMbmLEJO7gDH53PKYtCLEpB8hJv2AMfnC8pi0JMTkXkJM7gXGZL/lMWlBiMn9hJjcD4zJl5bHpDkhJg8QYvIAMCZfWR6TZoSYPESIyUPAmHxteUyaEmIygBCTAcCYfGN5TJoQYvIoISaPAmPyreUxaUyIyeOEmDwOjMkBy2PSiBCTgYSYDATG5DvLY9KQEJMnCTF5EhiT7y2PSQNCTIYQYjIEGJODlsekPiEmQwkxGQqMySGBffDDCQyHAxn+IMBwJIHhSCDDHy3PDYZhAjg3PE2IydPAmPwkEJNEcEzGEGIyBhiTnwVikgSOyVhCTMYCY/KLQEyKg2MynhCT8cCY/CoQkxLgmEwkxGQiMCa/CcSkJDgmzxFi8hwwJr8LxKQUOCaTCTGZDIzJYYGYlAbHZCohJlOBMTkiEJMy4JhMJ8RkOjAmfwjEpCw4JjMJMZkJjEmgvP0xKQeOyfOEmDwPjEkRgZiUB8fkBUJMXgDGpKhATCqAYzKHEJM5wJgUE4hJRXBMXiLE5CVgTGIEYlIJHJOXCTF5GRiTWIGYVAbH5FVCTF4FxiROICZVwDF5jRCT14AxiReIyQngmLxBiMkbwJgkCMTkRHBM3iLE5C1gTBIFYnISOCbvEGLyDjAmSQIxORkck/cIMXkPGJPiAjE5BRyThYSYLATGpIRATE4Fx2QRISaLgDEpKRCTquCYfECIyQfAmJQSiEk1cEyWEmKyFBiT0gIxqQ6OyXJCTJYDY1JGICY1wDFZSYjJSmBMygrE5DRwTFYTYrIaGJNyAjE5HRyTtYSYrAXGpDw4Jox98OsJDNcDGVYQYLiRwHAjkGFFAYabCQw3AxlWEsivZ4Dz61ZCTLYCY1JZICZngmOynRCT7cCYVBGIyVngmOwkxGQnMCYnCMSkJjgmuwgx2QWMyYkCMakFjskeQkz2AGNykkBMzgbHZC8hJnuBMTlZICbngGPyCSEmnwBjcopATGqDY7KPEJN9wJicKhCTOuCYfE6IyefAmFQViMm54JjsJ8RkPzAm1QRich44Jl8RYvIVMCbVBWLigGPyDSEm3wBjUkMgJi44JgcIMTkAjMlpAjFJBsfke0JMvgfG5HSBmKSAY3KIEJNDwJicIRCTVHBMfiTE5EdgTM4UiEldcEx+JsTkZ2BMzhKISRo4Jr8SYvIrMCY1BWKSDo7J74SY/A6MSS2BmGSAY3KEEJMjwJicLRCTTHBMAuXw4wyUw43xHIGYnA+OSVFCTIoCY1JbICYXgGMSQ4hJDDAmdQRiciE4JnGEmMQBY3KuQEwuAsckgRCTBGBMzhOIycXgmCQRYpIEjIkjEJNLwDEpQYhJCWBMXIGY1APHpBQhJqWAMUm2PCaDEvHf7VCGEJMywJikCOyDL0dgWA7IMFWAYQUCwwpAhnUF8vWl4NxQiRCTSsCYpAnE5DJwTKoQYlIFGJN0gZhcDo7JiYSYnAiMSYZATK4Ax+RkQkxOBsYkUyAmV4JjciohJqcCY3K+QEyuAsekGiEm1YAxuUAgJleDY1KDEJMawJhcKBCTa8AxOZ0Qk9OBMblIICbXgmNyJiEmZwJjcrFATOqDY1KTEJOawJhcIhCTBuCYnE2IydnAmNQTiElDcExqE2JSGxiTSwVi0ggck3MJMTkXGJPLBGLSGBwThxATBxiTywVi0gQck2RCTJKBMblCICZNwTFJJcQkFRiTKwVi0gwckzRCTNKAMblKICbNwTHJIMQkAxiTqwVi0gIck/MJMTkfGJNrBGLSEhyTCwkxuRAYk2sFYtIKHJOLCTG5GBiT+gIxaQ2OST1CTOoBY9JAICZtwDG5jBCTy4AxaSgQk7bgmFxBiMkVwJg0EohJO3BMriLE5CpgTBoLxKQ9OCbXEGJyDTAmTQRi0gEck/qEmNQHxqSpQEw6gmPSkBCThsCYNBPYc92YwLAxkGFzAYZNCQybAhm2EGDYnMCwOZBhSwGGLQkMWwIZtgIyjPH6qBj4a76hB5ptTxRP183xGS6ob8cJZdG6/NGfbcoHgRQL/jT/oUjYOfNHCWGDKkaE+G/7ys0zh+O2Lo8bV5vynOAWBfELztlBzrktbM5eYReio7YhOkInolZeImpbDtdfm2B/6GTRzvJC3HBsB+bYjsCxvQDH9mCO7QkcOwhw7ADm2IHAsaMAx45gjh0JHDsJcOwE5tiJwLGzAMfOYI6dCRy7CHDsAubYhcCxqwDHrmCOXQkcuwlw7Abm2I3AMUuAYxaYYxaBY7YAx2wwx2wCxxwBjjlgjjkEjrkCHHPBHHMJHPMEOOaBOeYROHYX4NgdzLE7gWMPAY49wBx7EDj2FODYE8yxJ4FjLwGOvcAcexE49hbg2BvMsTeB43UCHK8Dc7yOwPF6AY7XgzleT+DYR4BjHzDHPgSONwhwvAHM8QYCxxsFON4I5ngjgeNNAhxvAnO8icCxrwDHvmCOfQkcbxbgeDOY480EjrcIcLwFzPEWAsdbBTjeCuZ4K4HjbQIcbwNzvI3A8XYBjreDOd5O4HiHAMc7wBzvIHC803KO78cGAq3KYftrQ+B4l4Ae7wTr8U4Cx7sFON4F5ngXgWM/AY53gzneTeB4jwDHfmCO/Qgc7xXgeA+Y4z0EjvcJcLwXzPFeAsf7BTjeB+Z4H4FjfwGO94M53k/g+IAAx/5gjv0JHB8U4PgAmOMDBI4PCXB8EMzxQQLHhwU4PgTm+BCB4wABjg+DOT5M4PiIAMcBYI4DCBwfFeD4CJjjIwSOjwlwfBTM8VECx8cFOD4G5vgYgeMTAhwfB3N8nMBxoADHJ8AcnyBwHCTAcSCY40ACxycFOA4CcxxE4DhYgOOTYI5PEjgOEeA4GMxxMIHjUwIch4A5DiFwHCrA8Skwx6cIHIcJcBwK5jiUwHG4AMdhYI7DCBxHCHAcDuY4nMBxpADHEWCOIwgcRwlwHAnmOJLA8WkBjqPAHEcROI4W4Pg0mOPTBI5jBDiOBnMcTeD4jADHMWCOYwgcxwpwfAbM8RkCx3ECHMeCOY4lcBwvwHEcmOM4AscJAhzHgzmOJ3CcKMBxApjjBALHZwU4TgRznEjg+JwAx2fBHJ8lcJwkwPE5MMfnCBwnC3CcBOY4icBxigDHyWCOkwkcpwpwnALmOIXAcZoAx6lgjlMJHKcLcJwG5jiNwHGGAMfpYI7TCRxnCnCcAeY4g8BxlgDHmWCOMwkcnxfgOAvMcRaB42wBjs+DOT5P4PiCAMfZYI6zCRxfFOD4ApjjCwSOcwQ4vgjm+CKB41wBjnPAHOcQOL4kwHEumONcAsd5AhxfAnN8icDxZQGO88Ac5xE4viLA8WUwx5cJHF8V4PgKmOMrBI7zBTi+Cub4KoHjawIc54M5zidwfF2A42tgjq8ROL4hwPF1MMfXCRzfFOD4BpjjGwSObwlwfBPM8U0Cx7cFOL4F5vgWgeM7AhzfBnN8m8DxXQGO74A5vkPg+J4Ax3fBHN8lcFwgwPE9MMf3CBwXCnBcAOa4gMDxfQGOC8EcFxI4LhLg+D6Y4/sEjosFOC4Cc1xE4PiBAMfFYI6LCRyXCHD8AMzxAwLHpQIcl4A5LiFwXCbAcSmY41ICx+UCHJeBOS4jcFwhwHE5mONyAseVAhxXgDmuIHBcJcBxJZjjSgLH1QIcV4E5riJwXCPAcTWY42oCx7UCHNeAOa4hcFwnwHEtmONaAsf1AhzXgTmuI3DcIMBxPZjjegLHjQIcN4A5biBw3CTAcSOY40YCx80CHDeBOW4icNwiwHEzmONmAsetAhy3gDluIXDcJsBxK5jjVgLH7QIct4E5biNw3CHAcTuY43YCx50CHHeAOe4gcPxQgONOMMedBI67BDh+COb4IYHjbgGOu8AcdxE47hHguBvMcTeB40cCHPeAOe4hcNwrwPEjMMePCBw/FuC4F8xxL4HjJwIcPwZz/JjA8VMBjp+AOX5C4LhPgOOnYI6fEjh+JsBxH5jjPgLHzwU4fgbm+BmB4xcCHD8Hc/ycwHG/AMcvwBy/IHD8UoDjfjDH/QSOXwlw/BLM8UsCx68FOH4F5vgVgeM3Ahy/BnP8msDxWwGO34A5fkPgeECA47dgjt8SOH4nwPEAmOMBAsfvBTh+B+b4HYHjQQGO34M5fk/geEiA40Ewx4MEjj8IcDwE5niIwPFHAY4/gDn+QOD4kwDHH8EcfyRw/FmA409gjj8ROP4iwPFnMMefCRx/FeD4C5jjLwSOvwlw/BXM8VcCx98FOP4G5vgbgeNhAY6/gzn+TuB4RIDjYTDHwwSOfwhwPALmeITAMVDBfo5/gDn+QeBYRIBjoDyWo+kPzbGoAMciYI5FCByLCXAsCuZYlMAxRoBjMTDHYgSOsQIcY8AcYwgc4wQ4xoI5xhI4xgtwjANzjCNwTBDgGA/mGE/gmCjAMQHMMYHAMUmAYyKYYyKBY3EBjklgjkkEjiUEOBYHcyxO4FhSgGMJMMcSBI6lBDiWBHMsSeBYWoBjKTDHUgSOZQQ4lgZzLE3gWFaAYxkwxzIEjuUEOJYFcyxL4FhegGM5MMdyBI4VBDiWB3MsT+BY0XKOV3t9tCmHjUsFAsdKAnqsCNZjRQLHygIcK4E5ViJwrCLAsTKYY2UCxxMEOFYBc6xC4HiiAMcTwBxPIHA8SYDjiWCOJxI4nizA8SQwx5MIHE8R4HgymOPJBI6nCnA8BczxFALHqgIcTwVzPJXAsZoAx6pgjlUJHKsLcKwG5liNwLGGAMfqYI7VCRxPE+BYA8yxBoHj6QIcTwNzPI3A8QwBjqeDOZ5O4HimAMczwBzPIHA8S4DjmWCOZxI41hTgeBaY41kEjrUEONYEc6xJ4Hi2AMdaYI61CBzPEeB4Npjj2QSOtQU4ngPmeA6BYx0BjrXBHGsTOJ4rwLEOmGMdAsfzBDieC+Z4LoGjI8DxPDDH8wgcXQGODpijQ+CYLMDRBXN0CRxTBDgmgzkmEzimCnBMAXNMIXCsK8AxFcwxlcAxTYBjXTDHugSO6QIc08Ac0wgcMwQ4poM5phM4ZgpwzABzzCBwPF+AYyaYYyaB4wUCHM8HczyfwPFCAY4XgDleQOB4kQDHC8EcLyRwvFiA40VgjhcROF4iwPFiMMeLCRzrCXC8BMzxEgLHSwU41gNzrEfgeJkAx0vBHC8lcLxcgONlYI6XETheIcDxcjDHywkcrxTgeAWY4xUEjlcJcLwSzPFKAserBTheBeZ4FYHjNQIcrwZzvJrA8VoBjteAOV5D4FhfgOO1YI7XEjg2EOBYH8yxPoFjQwGODcAcGxA4NhLg2BDMsSGBY2MBjo3AHBsRODYR4NgYzLExgWNTAY5NwBybEDg2E+DYFMyxKYFjcwGOzcAcmxE4thDg2BzMsTmBY0sBji3AHFsQOLYS4NgSzLElgWNrAY6twBxbETi2AXIs5vXR2GsxwUG288bb3msdvNbRa5281tlrXbzW1WvdvJbltWyv5Xgt12t5XuvutR5e6+m1Xl7r7bXrvHa91/p47Qav3ei1m7zW12s3e+0Wr93qtdu8drvX7vDanV67y2t3e62f1+7x2r1eu89r93utv9ce8NqDXnvIaw97bYDXHvHao157zGuPe+0Jrw302iCvPem1wV4b4rWnvDbUa8O8NtxrI7w20mujvPa010Z77aAHZYz38xmvjfXaOK+N99oEr0302rNee85rk7w22WtTvDbVa9O8Nt1rM7w202uzvPa812Z77QWvvei1OV6b67WXvDbPay977RWvveq1+V57Lfj//7r38w2vvem1t7z2ttfe8dq7XnvPawu8ttBr73ttkdcWe+0Dry3x2lKvLfPacq+t8NpKr63y2mqvrfHaWq+t89p6r23w2kavbfLaZq9t8VpcfCCw1fu5zWvbvbbDazu99qHXdnltt9f2eO0jr+312sde+8Rrn3ptn9c+89rnXvvCa/u99qXXvvLa1177xmvfeu2A177z2vdmvl475LUfvPaj165NCATMd7yb7yc3361tvhfafKex+T5e812y5ntQzXd4mu+fNN+daL73z3xnnfm+NfNdYeZ7rsx3NJnvFzLfjWO+18V8J4n5Pg3zXRDmewzMO/jN++PNu8/Ne7vNO6fN+5LNu37Ne2rNO1bN+0HNuy3NexnNOwXN+/DMu9zMe8jMO7TM+5/Mu4vMe3fMO2PM+07MuzrMeybMOxLM5/vNZ9PN56rNZ4LN51nNZzHN5wjNZ+DM57fMZ4/M52bMZz7M5xXMXvuBiYGA2Stu9jmbPbpmf6nZG2n29Zk9aWY/ldkL9Oc+Fq+Z/QPm2bd5bmueOZrnZeZZj3lOYe6xm/vD5t6muS9n7imZ+yHGyxsfajyUqf9N7WrqLlMzmOudydUmz4QfRUG5LDfPHN41oTwuL7ZF5UXXcYsG82L4AenfOXr9MkcRbL8ujAFxjO3QY0SJ8piQunt9hArTiexwTV9m0uiCpTtwzu2BQSEvHpclTIXFg4xTQDXLmQrJ9jF2KAyU43YrY/8YOxYGynGzBQLVqTBQjvu9QOrrXBgox80TWFFdCgPluD0EAtW1MFCO20sgUN0KA+W41wkEKqswUI7bRyBQ2YWBctwbBQKVUxgox+0rEKjcwkA57i0CgcorDJTj3iYQqO6FgXLcOwQC1aMwUI57l0CgehYGynH7CQSqV2GgHPdegUD1LgyU494vEKjrCgPluA8IBOr6wkA57kMCgepTGCjHHSAQqBsKA+W4jwoE6sbCQDnu4wKBuqkwUI4bFyNw47gwUI47SGBF3VwYKMeNFwjULYWBctxYgUDdWhgox31KIFC3FQbKcYcJBOr2wkA57giBQN1RGCjHHSUQqDsLA+W4owUCdVdhoBz3GYFA3U34sJ3vQCP9ZGQ/2ECTZT9W3K+C/WO8p3DlO+4EgZV/b2GgHPdZgUDdVxgox50kEKj7CwPluFMEAtW/MFCOO00gUA8UBspxZwgE6sHCQDnuLIFAPVQYKMedLRCohwsD5bgvCgRqQGGgHLepwPswHikMlOO+JLCiHi0MlOO+LBCoxwoD5bivCgTq8cJAOe5rAoF6ojBQjvuGQKAGFgbKcd8SCNSgwkA57jsCgXqyMFCO+55AoAYXBspxFwoEakhhoBx3kUCgnioMlON+IBCooYWBctylAoEaVhgox10uEKjhhYFy3JUCgRpRGCjHXS0QqJGFgXLctQKBGlUYKMddLxCopwsD5bgbBQI1ujBQjrtZIFBjCgPluFsFAvWMyseDxsIGmir78aCxFewf47jCle+4OwVW/vjCQDnuLoFATSgMlOPuEQjUxMJAOe5egUA9Wxgox/1EIFDPFQbKcfcJBGpSYaAc93OBQE0uDJTj7hcI1JTCQDnuVwKBmloYKMf9RiBQ0woD5bgHBAI1vTBQjvu9QKBmFAbKcQ8JBGpmYaAc90eBQM0qDJTj/iwQqOcLA+W4vwoEanZhoBz3d4FAvVAYKMc9IhCoFwsD5biBsvaPcU5hoBy3qECg5hYGynFjBAL1UmGgHDdOIFDzCgPluAkCgXq5MFCOmyQQqFcKA+W4JQQC9WphoBy3lECg5hcGynHLCATq/7F3HnBSVNkaH3KSnBkY2kxS6k4eM0GCSJIkSYQJ5JxRgqIiICICkkFABERAco5KkJxzlCw5Z3i3ZGYpeO067nxf77lu9e+dN0Vt79l7/985371VU9M91xXKUpkMEGqeK5Slshgg1HxXKEtlM0CoBa5Q+s6EATdlF7pCWSqXAR21yBXKUrkNEGqxK5SlAgwQaokrlKU8Bgi11BXKUk8ZINQyVyhLPWOAUMtdoSz1nAFC/ewKZal8Bgj1iyuUpQoYINQKVyhLFTJAqJWuUJZ60QChVrlCWcoyQKjVrlCWCjRAqF9doSwVbIBQa1yhLBVqgFBrXaEsFW6AUOtcoSz1kgFCrXeFstQrBgi1wRXKUq8ZINRGVyhLvWGAUJtcoSxV1AChNrtCWaq4AUJtcYWyVAkDhNrqCmWp5Bnkj3GbK5SlShvQUdtdoSxVxgChdrhCWaqsAULtdIWyVHkDhNrlCmWpigYItdsVylKVDBBqjynfyrMXNtBwY7+VZ28W+WPc53a+paoZ0Pn7XaEsVd0AoQ64QlmqpgFCHXSFslRtA4Q65AplqToGCHXYFcpSdQ0Q6jdXKEtFGiDUEVcoS0UbINRRVyhL1TdAqGOuUJZqaIBQx12hLNXYAKFOuEJZqqkBQp10hbJUcwOEOuUKZamWBgj1uyuUpVobINRpVyhLtTVAqDOuUJZqb4BQZ12hLNXRAKHOuUJZ6gMDhDrvCmWpzgYIdcEVylJdDRDqoiuUpT4yQKhLrlCW6m6AUJddoSz1qQFCXXGFslQPA4S66gplqZ4GCHXNFcpSvQ0Q6rorlKX6GCDUDVcoS/U1QKibrlCW6meAULdM+fOg27CB1jX2z4NuZ5E/xjtu51tqoAGdf9cVylKDDBDqniuUpYYYINR9VyhLDTNAKL+srlBqhAFCJXKFstQoA4RK7AplqdEGCJXEFcpSYw0QKqkrlKXGGSBUMlcoS403QKjkrlCWmmiAUClcoSw1yQChUrpCWWqyAUKlcoWy1FQDhErtCmWpaQYIlcYVylIzDBDqCVcoS80yQKi0rlCWmmOAUOlcoSw1zwCh0rtCWWqBAUJlcIWy1CIDhMroCmWpJQYIlckVylLLDBAqsyuUpX42QKgsrlCWWmGAUFldoSy1ygChsrlCWepXA4TK7gplqbUGCJXDFcpS6w0QKqcrlKU2GiBULlcoS202QCh/VyhLbTVAqNyuUJbaboBQeVyhLLXTAKECXKEstdsAofK6QllqrwFCeVyhLLXfAKGedIWy1EEDhHrKFcpShw0Q6mlXKEsdMUCoZ1yhLHXMAKGedYWy1AkDhHrOFcpSpwwQ6nlXKEudNkCofK5QljprgFD5XaEsdd4AoQq4QlnqogFCFXSFstRlA4Qq5AplqasGCPWCK5Slrhsg1IuuUJa6aYBQhV2hLHXbAKEsVyhL3TVAKOUKZan7BggV6AplqUSZ5I8xyBXKUkkMECrYFcpSyQwQKsQVylIpDBAq1BXKUqkMECrMFcpSaQwQKtwVylJpDRAqwhXKUukNEOqlrPgxeh1oQr8+6WXYQKON/fqkl7PKH+MrbudbKrMBnf+qK5Slshog1GuuUJbKboBQr7tCWSqnAUK94QplKX8DhCriCmWpPAYIVdQVylJ5DRCqmCuUpZ40QKjirlCWetoAod50hbLUswYIVcIVylLPGyBUSVcoS+U3QKhSrlCWKmiAUKVdoSz1ggFCveUKZanCBghVxhXKUsoAod52hbJUkAFClXWFslSIAUKVc4WyVJgBQpV3hbJUhAFCVXCFstTLBghV0RXKUq8aINQ7rlCWet0AoSq5QulfcxsgVGVXKP3bUwOEquIKpX8pZ4BQVV2h9O96DBCqmiuU/hWCAUK96wql70wbIFR1Vyh9w9MAoWq4Qun7aAYIVdMVSt+eMUCoWq5Q+qrfAKFqI4VKqpPofH8I9vgL/ZeSpVEQlIr2YxWXsiwni/eyPvhZJ2sskCSxP+3/INFj5+w3pXxsUEmIEP/TXNEx9stS72XFjatOVo64icH8kHN+H9eJyttcrYS9VNXMfn7VM+Pma+ermQU/Tjsnaox1wX+KzNCkBliTWgRNagE1qWeAJjXBmtQmaFIbqEmkAZrUAmvyHkGT94CaRBmgSW2wJnUImtQBahJtgCbvgTV5n6DJ+0BNYgzQpA5Yk7oETeoCNalvgCbvgzWpR9CkHlCTBgZoUhesSSRBk0igJg0N0KQeWJMogiZRQE0aGaBJJFiTaIIm0UBNGhugSRRYkxiCJjFATZoYoEk0WJP6BE3qAzVpaoAmMWBNGhA0aQDUpJkBmtQHa9KQoElDoCbNDdCkAViTRgRNGgE1aWGAJg3BmjQmaNIYqElLAzRpBNakCUGTJkBNWhmgSWOwJk0JmjQFatLaAE2agDVpRtCkGVCTNgZo0hSsSXOCJs2BmrQ1QJNmYE1aEDRpAdSknQGaNAdr0pKgSUugJu0N0KQFWJNWBE1aATXpYIAmLcGatCZo0hqoSUcDNGkF1qQNQZM2QE06GaBJa7AmbQmatAVq8oEBmrQBa9KOoEk7oCYfGqBJW7Am7QmatAdq0tkATdqBNelA0KQDUJMuBmjSHqxJR4ImHYGadDVAkw5gTToRNOkE1KSbAZp0BGvyAUGTD4CafGSAJp3AmnQmaNIZqMnHBmjyIViTLgRNugA16W6AJp3BmnQlaNIVqMknBmjSBaxJN4Im3YCafGqAJl3BmnxE0OQjoCafGaBJN7AmHxM0+RioSQ8DNPkIrEl3gibdgZp8boAmH4M1+YSgySdATXoaoEl3sCafEjT5FKhJLwM0+QSsyWcETT4DatLbAE0+BWvSg6BJD6AmXxigyWdgTT4naPI5UJM+BmjSA6xJT4ImPYGafGmAJp+DNelF0KQXUJO+BmjSE6xJb4ImvYGafGWAJr3AmnxB0OQLoCb9DNCkN1iTPgRN+gA1+doATb4Aa/IlQZMvgZr0N0CTPmBN+hI06QvUZIABmnwJ1uQrgiZfATUZaIAmfcGa9CNo0g+oyTcGaPIVWJOvCZp8DdRkkAGa9ANr0p+gSX+gJoMN0ORrsCYDCJoMAGoyxABN+oM1GUjQZCBQk6EGaDIArMk3BE2+AWoyzABNBoI1GUTQZBBQk+EGaPINWJPBBE0GAzUZYYAmg8CaDCFoMgSoyUgDNBkM1mQoQZOhQE1GGaDJELAmwwiaDANq8i1YE/QXDtkMRxAYjgAyHG1AXQ8D1/VIgiYjgZqMMUCT4WBNRhE0GQXUZKwBmowAa/ItQZNvgZp8Z4AmI8GajCZoMhqoyTgDNBkF1mQMQZMxQE2+N0CTb8GajCVoMhaoyXgDNBkN1uQ7gibfATWZYIAmY8CajCNoMg6oyUQDNBkL1uR7gibfAzX5wQBNvgNrMp6gyXigJpMM0GQcWJMJBE0mADX50QBNvgdrMpGgyUSgJpMN0GQ8WJMfCJr8ANRkigGaTABrMomgySSgJlMN0GQiWJMfCZr8CNTkJwM0+QGsyWSCJpOBmkwzQJNJYE2mEDSZAtRkugGa/AjWZCpBk6lATWYYoMlksCY/ETT5CajJTAM0mQLWZBpBk2lATWYZoMlUsCbTCZpMB2oy2wBNfgJrMoOgyQygJnMM0GQaWJOZBE1mAjWZa4Am08GazCJoMguoyTwDNJkB1mQ2QZPZQE3mG6DJTLAmcwiazAFqssAATWaBNZlL0GQuUJOFBmgyG6zJPIIm84CaLDJAkzlgTeYTNJkP1GSxAZrMBWuygKDJAqAmSwz424SFBIYLgQyXGlDX88F1vYigySKgJssM0GQBWJPFBE0WAzVZboAmC8GaLCFosgSoyc8GaLIIrMlSgiZLgZr8YoAmi8GaLCNosgyoyQoDNFkC1mQ5QZPlQE1WGqDJUrAmPxM0+RmoySoDNFkG1uQXgia/ADVZbYAmy8GarCBosgKoya8GaPIzWJOVBE1WAjVZY4Amv4A1WUXQZBVQk7UGaLICrMlqgiargZqsM0CTlWBNfiVo8itQk/UGaLIKrMkagiZrgJpsMECT1WBN1hI0WQvUZKMBmvwK1mQdQZN1QE02GaDJGrAm6wmarAdqstkATdaCNdlA0GQDUJMtBmiyDqzJRoImG4GabDVAk/VgTTYRNNkE1GSbAZpsAGuymaDJZqAm2w3QZCNYky0ETbYANdlhgCabwJpsJWiyFajJTgM02QzWZBtBk21ATXYZoMkWsCbbCZpsB2qy2wBNtoI12UHQZAdQkz0GaLINrMlOgiY7gZrsNUCT7WBNdhE02QXUZJ8BmuwAa7KboMluoCb7DdBkJ1iTPQRN9gA1OSBck+Qp/PyqgjXZR9BkH1CTgwb0yW6wJvsJmuwHanLIAE32gDU5QNDkAFCTwwZoshesyUGCJgeBmvxmgCb7wJocImhyCKjJEQM02Q/W5DBBk8NATY4aoMkBsCa/ETT5DajJMQM0OQjW5AhBkyNATY4boMkhsCZHCZocBWpywgBNDoM1OUbQ5BhQk5MGaPIbWJPjBE2OAzU5ZYAmR8CanCBocgKoye8GaHIUrMlJgiYngZqcNkCTY2BNThE0OQXU5IwBmhwHa/I7QZPfgZqcNUCTE2BNThM0OQ3U5JwBmpwEa3KGoMkZoCbnDdDkFFiTswRNzgI1uWCAJr+DNTlH0OQcUJOLBmhyGqzJeYIm54GaXDJAkzNgTS4QNLkA1OSyAZqcBWtykaDJRaAmVwzQ5BxYk0sETS4BNblqgCbnwZpcJmhyGajJNQM0uQDW5ApBkytATa4boMlFsCZXCZpcBWpywwBNLoE1uUbQ5BpQk5sGaHIZrMl1gibXgZrcMkCTK2BNbhA0uQHU5LYBmlwFa3KToMlNoCZ3DNDkGliTWwRNbgE1uStck9Ip8X/rcIegyR2gJvcM6JMbYE3uEjS5C9TkvgGa3ARrco+gyT2gJn7Z5GtyC6zJfYIm94GaJDJAk9tgTfyy4sfplxU3xsQGaHIHrEkigiaJgJokMUCTu2BNEhM0SQzUJKkBmtwDa5KEoEkSoCbJDNDkPliTpARNkgI1SW6AJn5ZsJokI2iSDKhJCgM0SQTWJDlBk+RATVIaoElisCYpCJqkAGqSygBNkoA1SUnQJCVQk9QGaJIUrEkqgiapgJqkMUCTZGBNUhM0SQ3U5AkDNEkO1iQNQZM0QE3SGqBJCrAmTxA0eQKoSToDNEkJ1iQtQZO0QE3SG6BJKrAm6QiapANqksEATVKDNUlP0CQ9UJOMBmiSBqxJBoImGYCaZDJAkyfAmmQkaJIRqElmAzRJC9YkE0GTTEBNshigSTqwJpkJmmQGapLVAE3SgzXJQtAkC1CTbAZokgGsSVaCJlmBmmQ3QJOMYE2yETTJBtQkhwGaZAJrkp2gSXagJjkN0CQzWJMcBE1yADXJZYAmWcCa5CRokhOoib8BmmQFa5KLoEkuoCa5DdAkG1gTf4Im/kBN8higSXawJrkJmuQGahJggCY5wJrkIWiSB6hJXgM0yQnWJICgSQBQE48BmuQCa5KXoEleoCZPGqCJP1gTD0ETD1CTpwzQJDdYkycJmjwJ1ORpAzTJA9bkKYImTwE1ecYATQLAmjxN0ORpoCbPGqBJXrAmzxA0eQaoyXMGaOIBa/IsQZNngZo8b4AmT4I1eY6gyXNATfIZoMlTYE2eJ2jyPFCT/AZo8jRYk3wETfIBNSlggCbPgDXJT9AkP1CTggZo8ixYkwIETQoANSlkgCbPgTUpSNCkIFCTFwzQ5HmwJoUImhQCavKiAZrkA2vyAkGTF4CaFDZAk/xgTV4kaPIiUBPLAE0KgDUpTNCkMFATZYAmBcGaWARNLKAmgQZoUgisiSJoooCaBBmgyQtgTQIJmgQCNQk2QJMXwZoEETQJAmoSYoAmhcGaBBM0CQZqEmqAJhZYkxCCJiFATcIM0ESBNQklaBIK1CTcAE0CwZqEETQJA2oSYYAmQWBNwgmahAM1eckATYLBmkQQNIkAavKyAZqEgDV5iaDJS0BNXhGuyRep8N+18QpBk1eAmrxqQJ+EgfvkVYImrwI1ec0ATcLBmrxG0OQ1oCavG6BJBFiT1wmavA7U5A0DNHkJrMkbBE3eAGpSxABNXgZrUoSgSRGgJkUN0OQVsCZFCZoUBWpSzABNXgVrUoygSTGgJsUN0OQ1sCbFCZoUB2rypgGavA7W5E2CJm8CNSlhgCZvgDUpQdCkBFCTkgZoUgSsSUmCJiWBmpQyQJOiYE1KETQpBdSktAGaFANrUpqgSWmgJm8ZoElxsCZvETR5C6hJGQM0eROsSRmCJmWAmrxtgCYlwJq8TdDkbaAmZQ3QpCRYk7IETcoCNSlngCalwJqUI2hSDqhJeQM0KQ3WpDxBk/JATSoYoMlbYE0qEDSpANSkogGalAFrUpGgSUWgJu8YoMnbYE3eIWjyDlCTSgZoUhasSSWCJpWAmlQ2QJNyYE0qEzSpDNSkigGalAdrUoWgSRWgJlUN0KQCWJOqBE2qAjWpZoAmFcGaVCNoUg2oybsGaPIOWJN3CZq8C9SkugGaVAJrUp2gSXWgJjUM0KQyWJMaBE1qADWpaYAmVcCa1CRoUhOoSS0DNKkK1qQWQZNaQE1qG6BJNbAmtQma1AZq8h5Qk6Q6R1aHLs5XoscYJHTcDVE8lYr2MlxQbstysqiT7cHP97PFAkkS+9P+DxI9ds5+U8rHBpWECPE/zRUdY78sVScbblzvZ+OImxjE74856/+HnHNd2JytQGcd1XXUEdqI3tPdXjcrLt/7sfnQZlFP+MJjc6wH5liPwDHSAI6RYI6RBI5RBnCMAnOMInCMNoBjNJhjNIFjjAEcY8AcYwgc6xvAsT6YY30CxwYGcGwA5tiAwLGhARwbgjk2JHBsZADHRmCOjQgcGxvAsTGYY2MCxyYGcGwC5tiEwLGpARybgjk2JXBsZgDHZmCOzQgcmxvAsTmYY3MCxxYGcGwB5tiCwLGlARxbgjm2JHBsZQDHVmCOrQgcWxvAsTWYY2sCxzYGcGwD5tiGwLGtARzbgjm2JXBsZwDHdmCO7Qgc2xvAsT2YY3sCxw4GcOwA5tiBwLGjARw7gjl2JHDsZADHTmCOnQgcPzCA4wdgjh8QOH5oAMcPwRw/JHDsbADHzmCOnQkcuxjAsQuYYxcCx64GcOwK5tiVwLGbARy7gTl2I3D8yACOH4E5fkTg+LEBHD8Gc/yYwLG7cI7Lk/n5vZcVm+99AsdPDKjH7uB67E7g+KkBHD8Bc/yEwPEzAzh+Cub4KYFjDwM4fgbm+BmB4+cGcOwB5tiDwLGnARw/B3P8nMCxlwEce4I59iRw7G0Ax15gjr0IHL8wgGNvMMfeBI59DOD4BZjjFwSOXxrAsQ+YYx8Cx74GcPwSzPFLAsevDODYF8yxL4FjPwM4fgXm+BWB49cGcOwH5tiPwLG/ARy/BnP8msBxgAEc+4M59idwHGgAxwFgjgMIHL8xgONAMMeBBI6DDOD4DZjjNwSOgw3gOAjMcRCB4xADOA4GcxxM4DjUAI5DwByHEDgOM4DjUDDHoQSOww3gOAzMcRiB4wgDOA4HcxxO4DjSAI4jwBxHEDiOMoDjSDDHkQSO3xrAcRSY4ygCx9EGcPwWzPFbAscxBnAcDeY4msBxrAEcx4A5jiFw/M4AjmPBHMcSOI4zgON3YI7fETh+bwDHcWCO4wgcxxvA8Xswx+8JHCcYwHE8mON4AseJBnCcAOY4gcDxBwM4TgRznEjgOMkAjj+AOf5A4PijARwngTlOInCcbADHH8EcfyRwnGIAx8lgjpMJHKcawHEKmOMUAsefDOA4FcxxKoHjNAM4/gTm+BOB43QDOE4Dc5xG4DjDAI7TwRynEzjONIDjDDDHGQSOswzgOBPMcSaB42wDOM4Cc5xF4DjHAI6zwRxnEzjONYDjHDDHOQSO8wzgOBfMcS6B43wDOM4Dc5xH4LjAAI7zwRznEzguNIDjAjDHBQSOiwzguBDMcSGB42IDOC4Cc1xE4LjEAI6LwRwXEzguNYDjEjDHJQSOywzguBTMcSmB43IDOC4Dc1xG4PizARyXgzkuJ3D8xQCOP4M5/kzguMIAjr+AOf5C4LjSAI4rwBxXEDiuMoDjSjDHlQSOqw3guArMcRWB468GcFwN5riawHGNARx/BXP8lcBxrQEc14A5riFwXGcAx7VgjmsJHNcbwHEdmOM6AscNBnBcD+a4nsBxowEcN4A5biBw3GQAx41gjhsJHDcbwHETmOMmAsctBnDcDOa4mcBxqwEct4A5biFw3GYAx61gjlsJHLcbwHEbmOM2AscdBnDcDua4ncBxpwEcd4A57iBw3GUAx51gjjsJHHcbwHEXmOMuAsc9BnDcDea4m8BxrwEc94A57iFw3GcAx71gjnsJHPcbwHEfmOM+AscDBnDcD+a4n8DxoAEcD4A5HiBwPGQAx4NgjgcJHA8bwPEQmOMhAsffDOB4GMzxMIHjEQM4/gbm+BuB41EDOB4BczxC4HjMAI5HwRyPEjgeN4DjMTDHYwSOJwzgeBzM8TiB40kDOJ4AczxB4HjKAI4nwRxPEjj+bgDHU2COpwgcTxvA8Xcwx98JHM8YwPE0mONpAsezBnA8A+Z4hsDxnAEcz4I5niVwPG8Ax3NgjucIHC8YwPE8mON5AseLBnC8AOZ4gcDxkgEcL4I5XiRwvGwAx0tgjpcIHK8YwPEymONlAserBnC8AuZ4hcDxmgEcr4I5XiVwvG4Ax2tgjtcIHG8YwPE6mON1AsebBnC8AeZ4g8DxlgEcb4I53iRwvG0Ax1tgjrcIHO8YwPE2mONtAse7BnC8A+Z4h8DxngEc74I53iVwvG8Ax3tgjvcIHP2yy+d4H8zxPoFjIgM4+mXDcrTzoTkmNoBjIjDHRASOSQzgmBjMMTGBY1IDOCYBc0xC4JjMAI5JwRyTEjgmN4BjMjDHZASOKQzgmBzMMTmBY0oDOKYAc0xB4JjKAI4pwRxTEjimNoBjKjDHVASOaQzgmBrMMTWB4xMGcEwD5piGwDGtARyfAHN8gsAxnQEc04I5piVwTG8Ax3RgjukIHDMYwDE9mGN6AseMBnDMAOaYgcAxkwEcM4I5ZiRwzGwAx0xgjpkIHLMYwDEzmGNmAsesBnDMAuaYhcAxmwEcs4I5ZiVwzG4Ax2xgjtkIHHMYwDE7mGN2AsecBnDMAeaYg8AxlwEcc4I55iRw9DeAYy4wx1wEjrkN4OgP5uhP4JjHAI65wRxzEzgGGMAxD5hjHgLHvMI5ltI53s+K1SWAwNFjQD3mBddjXgLHJw3g6AFz9BA4PmUAxyfBHJ8kcHzaAI5PgTk+ReD4jAEcnwZzfJrA8VkDOD4D5vgMgeNzBnB8FszxWQLH5w3g+ByY43MEjvkM4Pg8mOPzBI75DeCYD8wxH4FjAQM45gdzzE/gWNAAjgXAHAsQOBYygGNBMMeCBI4vGMCxEJhjIQLHFw3g+AKY4wsEjoUN4PgimOOLBI6WARwLgzkWJnBUBnC0wBwtAsdAAzgqMEdF4BhkAMdAMMdAAsdgAzgGgTkGETiGGMAxGMwxmMAx1ACOIWCOIQSOYQZwDAVzDCVwDDeAYxiYYxiBY4QBHMPBHMMJHF8ygGMEmGMEgePLBnB8CczxJQLHVwzg+DKY48sEjq8awPEVMMdXCBxfM4Djq2COrxI4vm4Ax9fAHF8jcHzDAI6vgzm+TuBYxACOb4A5vkHgWNQAjkXAHIsQOBYzgGNRMMeiBI7FDeBYDMyxGIHjmwZwLA7mWJzAsYQBHN8Ec3yTwLGkARxLgDmWIHAsZQDHkmCOJQkcSxvAsRSYYykCx7cM4FgazLE0gWMZAzi+Beb4FoHj2wZwLAPmWIbAsawBHN8Gc3ybwLGcARzLgjmWJXAsbwDHcmCO5QgcKxjAsTyYY3kCx4oGcKwA5liBwPEdAzhWBHOsSOBYyQCO74A5vkPgWNkAjpXAHCsROFYxgGNlMMfKBI5VDeBYBcyxCoFjNQM4VgVzrErg+K4BHKuBOVYjcKxuAMd3wRzfJXCsYQDH6mCO1QkcaxrAsQaYYw0Cx1oGcKwJ5liTwLG2ARxrgTnWInB8zwCOtcEcaxM41jGA43tgju8ROL4P5JhE5yivI2nsIOvp8UbqiNIRrSNGR30dDXQ01NFIR2MdTXQ01dFMR3MdLXS01NFKR2sdbXS01dFOR3sdHXR01NFJxwc6PtTRWUcXHV11dNPxkY6PdXTX8YmOT3V8pqOHjs919NTRS0dvHV/o6KPjSx19dXylo5+Or3X01zFAx0Ad3+gYpGOwjiE6huoYpmO4jhE6RuoYpeNbHaN1jNExVsdlDeY7/XOcju91jNcxQcdEHT/omKTjRx2TdUzRMVXHTzqm6ZiuY4aOmTpm6ZitY46OuTrm6ZivY4GOhToW6VisY4mOpTqW6Vge+7//s/75i44VOlbqWKVjtY5fdazRsVbHOh3rdWzQsVHHJh2bdWzRsVXHNh3bdezQsVPHLh27dezRsVfHPh37dRzQcVDHIR2HdSRL4ef3m/55RMdRHcd0HNdxQsdJHad0/K7jtI4zOs7qOKfjvI4LOi7quGTPQ8cVHVd1XNNxXccNHTd13NJxW8cdHXd13NNxX4f9/e6lUuq+0T/t79a2vxfa/k5j+/t47e+Stb8H1f4OT/v7J+3vTrS/98/+zjr7+9bs7wqzv+fK/o4m+/uF7O/Gsb/Xxf5OEvv7NOzvgrC/x8D+DH778+Ptzz63P7fb/sxp+/OS7c/6tT+n1v6MVfvzQe3PtrQ/l9H+TEH78/Dsz3KzP4fM/gwt+/Of7M8usj93x/7MGPvzTuzP6rA/Z8L+jAT77/vtv023/67a/ptg++9Z7b/FtP+O0P4bOPvvt+y/PbL/bsb+mw/77xXsZ+3t58R7p9I9rn/az+jaz5faz0baz/XZz6TZz1PZzwLZz7HYz2DYzw/Yv/u2f29r/87R/n2Z/bse+/cU9j12+/6wfW/Tvi9n31Oy74fY1/L2dah9DWXv/+29q73vsvcM9npne7XtM4+/EoO8LDpGv/T/q5MN54t1Ub6orMDEsb74+Avlu3H5EmHzKhgD4hjroceIKsq4QmqgczgL00rYS9m57EmjNywNgHOOBIpCbh7FKkwTmgepk5+pLmfvjqSPMcoVSndUBvljjHaF0rZigFAxrlCWumSA9dV3hdLVakBHNXCF0hAMEKqhK5SlGhkgVCNXKEs1MUCoxq5QlmpmgFBNXKEs1cIAoZq6QlmqlQFCNXOFslQbA4Rq7gplqXYGCNXCFcpSHQwQqqUrlKU6GSBUK1coS31ogFCtXaEs1cUAodq4QlmqmwFCtXWFstTHBgjVzhXKUp8YIFR7VyhLfWaAUB1coSz1uQFCdXSFslQvA4Tq5AplqeRJ5Y/xA1coS/UxoKM+dIWyVAoDhOrsCmWpZAYI1cUVylL9DBCqqyuUpfobIFQ3VyhLDTRAqI9coSw1yAChPnaFstQQA4Tq7gplqWEGCPWJK5S+mMwif4yfukJZaoQBHfWZK5SlRhsgVA9XKEuNNUCoz12hLDXOAKF6ukJZarwBQvVyhbLURAOE6u0KZalJBgj1hSuUpSYbIFQfVyhLTTVAqC9doSxVwYDPmejrCmWp6QZ01FeuUJaaaYBQ/VyhLDXbAKG+doWy1FwDhOrvCmWp+QYINcAVylILDRBqoCuUpRYbINQ3rlCWWmqAUINcoSy13AChBrtCWeoXA4Qa4gplqZUGCDXUFcpSqw0QapgrlKXWGCDUcFcoS60zQKgRrlCW2mCAUCNdoSy1yQChRrlCWWqLAUJ96wplqW0GCDXaFcpSOwwQaowrlKV2GSDUWFcofY1iwJ/dfOcKZak9BnTUOFcoSx0wQKjvXaEsdcgAoca7QlnqNwOEmuAKZamjBgg10RXKUscNEOoHVyhLnTRAqEmuUJb63QChfnSFstQZA4Sa7AplqXMGCDXFFcpSFwwQaqorlKUuGSDUT65QlrpigFDTXKEsdc0Aoaa7QlnqhgFCzXCFstQtA4Sa6QplqTsGCDXLFcpS9wwQarYrlKX8Msof4xxXKEslNkCoua5QlkpqgFDzXKEsldwAoea7QlkqpQFCLXCFslRqA4Ra6AplqScMEGqRK5Sl0hkg1GJXKEtlMECoJa5QlspkgFBLXaEslcUAoZa5QlkqmwFCLXeF0ncmDLgp+7MrlKVyGNBRv7hCWSq3AUKtcIWyVIABQq10hbKUxwChVrlCWeopA4Ra7QplqWcMEOpXVyhLPWeAUGtcoSyVzwCh1rpCWaqAAUKtc4WyVCEDhFrvCmWpFw0QaoMrlKUsA4Ta6AplqUADhNrkCmWpYAOE2uwKZalQA4Ta4gplqXADhNrqCmWplwwQapsrlKVeMUCo7a5QlnrNAKF2uEJZ6g0DhNrpCmWpogYItcsVylLFDRBqtyuUpUoYINQeVyhLJc8gf4x7XaEsVdqAjtrnCmWpMgYItd8VylJlDRDqgCuUpcobINRBVyhLVTRAqEOuUJaqZIBQh12h9NbXgG+7+c0VylJVDOioI65QlqpugFBHXaEsVdMAoY65QlmqtgFCHXeFslQdA4Q64QplqboGCHXSFcpSkQYIdcoVylLRBgj1uyuUpeobINRpVyhLNTRAqDOuUJZqbIBQZ12hLNXUAKHOuUJZqrkBQp13hbJUSwOEuuAKZanWBgh10RXKUm0NEOqSK5Sl2hsg1GVXKEt1NECoK65QlvrAAKGuukJZqrMBQl1zhbJUVwOEuu4KZamPDBDqhiuUpbobINRNVyhLfWqAULdcoSzVwwChbrtCWaqnAULdcYWyVG8DhLrrCmWpPgYIdc8VylJ9DRDqviuUpfoZIJRfDlcodduAP7tJ5Aplqf4GdFRiVyhLDTJAqCSuUJYaYoBQSV2hLDXMAKGSuUJZaoQBQiV3hbLUKAOESuEKZanRBgiV0hXKUmMNECqVK5SlxhkgVGpXKEuNN0CoNK5QlppogFBPuEJZapIBQqV1hbLUZAOESucKZampBgiV3hXKUtMMECqDK5SlZhggVEZXKEvNMkCoTK5QlppjgFCZXaEsNc8AobK4QllqgQFCZXWFstQiA4TK5gplqSUGCJXdFcpSywwQKocrlKV+NkConK5QllphgFC5XKEstcoAofxdoSz1qwFC5XaFstRaA4TK4wplqfUGCBXgCmWpjQYIldcVylKbDRDK4wplqa0GCPWkK5Slthsg1FOuUJbaaYBQT7tCWWq3AUI94wplqb0GCPWsK5Sl9hsg1HOuUJY6aIBQz7tCWeqwAULlc4Wy1BEDhMrvCmWpYwYIVcAVylInDBCqoCuUpU4ZIFQhVyhLnTZAqBdcoSx11gChXnSFstR5A4Qq7AplqYsGCGW5QlnqsgFCKVcoS101QKhAVyhLXTdAqCBXKEvdNECoYFcoS902QKgQVyhL3TVAqFBXKEvdN0CoMFcoSyXKJH+M4a5QlkpigFARrlCWSmaAUC+5QlkqhQFCvewKZalUBgj1iiuUpdIYINSrrlCWSmuAUK+5QlkqvQFCve4KpRfqrPLH+IYrlKUyGtBRRVyhLJXVAKGKukJZKrsBQhVzhbJUTgOEKu4KZSl/A4R60xXKUnkMEKqEK5Sl8hogVElXKEs9aYBQpVyhLPW0AUKVdoWy1LMGCPWWK5SlnjdAqDKuUJbKb4BQb7tCWaqgAUKVdYWy1AsGCFXOFcpShQ0QqrwrlKWUAUJVcIWyVJABQlV0hbJUiAFCveMKZakwA4Sq5AplqQgDhKrsCmWplw0QqoorlKVeNUCoqq5QlnrdAKGquUJZqogBQr3rCmWpYgYIVd0VylJvGiBUDVcoS5U0QKiarlD619wGCFXLFUr/9tQAoWq7Qulfyhkg1HuuUPp3PQYIVccVSv8KwQCh3neF0nemDRCqLlKopDpJVh2JvYj1+MCDrNDg4OiwwGgVpOpagRH1wkOs4JB6oeEqXIWEh0QFhgcFRYcHh4dF1IsIsyJUcFC0igmJCIqJ/R8rjYKgVIwfq7iUZTlZ1Mvx4GdkjlggSWJ/2idSPjaAJERg/2mu6Bj7Zal6OXDjiszBERLdKcg5e2sQ4Fh5n0CaRP4Yo0x1tIZ+5jladKyjxTzuaDE+cLSGfjhHiwZ2dwzJ0RKD+P0x5+iYaOSc68PmbAU566i+lzpCOwaSg20YKRy1bo81aSLv+lkJe6k62fSWIhtu7Ha+qOwER86Oc2QGw0gww2gCw2jhDKPADGMIDGOEM4wGM6xPYFhfOMMYMMMGBIYNhDOsD2bYkMCwoXCGDcAMGxEYNhLOsCGYYWMCw8bCGTYCM2xCYNhEOMPGYIZNCQybCmfYBMywGYFhM+EMm4IZNicwbC6cYTMwwxYEhi2EM2wOZtiSwLClcIYtwAxbERi2Es6wJZhhawLD1sIZtgIzbENg2EY4w9Zghm0JDNsKZ9gGzLAdgWE74Qzbghm2JzBsL5xhOzDDDgSGHYQzbA9m2JHAsKNwhh3ADDsRGHYSzrAjmOEHBIYfCGfYCczwQwLDD4Uz/ADMsDOBYWfhDD8EM+xCYNhFOMPOYIZdCQy7CmfYBcywG4FhN+EMu4IZfkRg+JFwht3ADD8mMPxYOMOPwAy7Exh2F87wYzDDTwgMPxHOsDuY4acEhp8KZ/gJmOFnBIafARnGpoGPcVky2Tp/Bta5B0HnHsJ7pQeY4ecEhp8LZ/g5mGFPAsOewhn2BDPsRWDYSzjDXmCGvQkMewtn2BvM8AsCwy+EM/wCzLAPgWEf4Qz7gBl+SWD4pXCGX4IZ9iUw7CucYV8ww68IDL8SzvArMMN+BIb9hDPsB2b4NYHh18IZfg1m2J/AsL9whv3BDAcQGA4QznAAmOFAAsOBwhkOBDP8hsDwG+EMvwEzHERgOEg4w0FghoMJDAcLZzgYzHAIgeEQ4QyHgBkOJTAcKpzhUDDDYQSGw4QzHAZmOJzAcLhwhsPBDEcQGI4QznAEmOFIAsORwhmOBDMcRWA4SjjDUWCG3xIYfiuc4bdghqMJDEcLZzgazHAMgeEY4QzHgBmOJTAcK5zhWDDD7wgMvwMyRH8wrj3ncYQ5jyM8j+cHHWM4pR7Hgevxe4I23wvv6e/BDMcTGI4XznA8mOEEAsMJwhlOADOcSGA4UTjDiWCGPxAY/iCc4Q9ghpMIDCcJZzgJzPBHAsMfhTP8EcxwMoHhZOEMJ4MZTiEwnCKc4RQww6kEhlOFM5wKZvgTgeFPwhn+BGY4jcBwmnCG08AMpxMYThfOcDqY4QwCwxnCGc4AM5xJYDhTOMOZYIazCAxnCWc4C8xwNoHhbOEMZ4MZziEwnCOc4Rwww7kEhnOFM5wLZjiPwHCecIbzwAznExjOF85wPpjhAgLDBcIZLgAzXEhguFA4w4VghosIDBcJZ7gIzHAxgeFi4QwXgxkuITBcIpzhEjDDpQSGS4UzXApmuIzAcJlwhsvADJcTGC4XznA5mOHPBIY/C3+G7hfCnH8R/wxdJKUefwHX4wqCNiuE9/QKMMOVBIYrhTNcCWa4isBwlXCGq8AMVxMYrhbOcDWY4a8Ehr8KZ/grmOEaAsM1whmuATNcS2C4VjjDtWCG6wgM1wlnuA7McD2B4XrhDNeDGW4gMNwgnOEGMMONBIYbhTPcCGa4icBwk3CGm8AMNxMYbhbOcDOY4RYCwy3CGW4BM9xKYLhVOMOtYIbbCAy3CWe4DcxwO4HhduEMt4MZ7iAw3CGc4Q4ww50EhjuFM9wJZriLwHCXcIa7wAx3ExjuFs5wN5jhHgLDPcIZ7gEz3EtguFc4w71ghvsIDPcJZ7gPzHA/geF+4Qz3gxkeIDA8IJzhATDDgwSGB4UzPAhmeIjA8JBwhofADA8TGB4WzvAwmOFvBIa/CWeYLAWW4RECwyOEZ/LQY0yaQrbOR8C9cpSg81HhvXIUzPAYgeEx4QyPgRkeJzA8LpzhcTDDEwSGJ4QzPAFmeJLA8KRwhifBDE8RGJ4SzvAUmOHvBIa/C2f4O5jhaQLD08IZngYzPENgeEY4wzNghmcJDM8KZ3gWzPAcgeE54QzPgRmeJzA8L5zheTDDCwSGF4QzvABmeJHA8KJwhhfBDC8RGF4SzvASmOFlAsPLwhleBjO8QmB4RTjDK2CGVwkMrwpneBXM8BqB4TXhDK+BGV4nMLwunOF1MMMbBIY3hDO8AWZ4k8DwpnCGN8EMbxEY3hLO8BaY4W0Cw9vCGd4GM7xDYHhHOMM7YIZ3CQzvCmd4F8zwHoHhPeEM74EZ3icwvC+c4X0wQ78ceIZ2TskM/bJjGSYiMEwknGGplFiGiQkMEwMZxqaBj7FkStk6Jwb3ShKCzkmE90oSMMOkBIZJhTNMCmaYjMAwmXCGycAMkxMYJhfOMDmYYQoCwxTCGaYAM0xJYJhSOMOUYIapCAxTCWeYCswwNYFhauEMU4MZpiEwTCOcYRowwycIDJ8QzvAJMMO0BIZphTNMC2aYjsAwnXCG6cAM0xMYphfOMD2YYQYCwwzCGWYAM8xIYJhROMOMYIaZCAwzCWeYCcwwM4FhZuEMM4MZZiEwzCKcYRYww6wEhlmFM8wKZpiNwDCbcIbZwAyzExhmF84wO5hhDgLDHMIZ5gAzzElgmFM4w5xghrkIDHMJZ5gLzNCfwNBfOEN/MMPcBIa5hTPMDWaYh8Awj3CGecAMAwgMA4QzDAAzzEtgmFc4w7xghh4CQ49whh4wwycJDJ8UzvBJMMOnCAyfEs7wKTDDpwkMnxbO8Gkww2cIDJ8RzvAZMMNnCQyfFc7wWTDD5wgMnxPO8Dkww+cJDJ8XzvB5MMN8BIb5hDPMB2aYn8Awv3CG+cEMCxAYFhDOsACYYUECw4LCGRYEMyxEYFhIOMNCYIYvEBi+IJzhC2CGLxIYviic4YtghoUJDAsLZ1gYzNAiMLSEM7TADBWBoRLOUIEZBhIYBgpnGAhmGERgGCScYRCYYTCBYbBwhsFghiEEhiHCGYaAGYYSGIYKZxgKZhhGYBgmnGEYmGE4gWG4cIbhYIYRBIYRwhlGgBm+RGD4knCGL4EZvkxg+LJwhi+DGb5CYPiKcIavgBm+SmD4qnCGr4IZvkZg+Jpwhq+BGb5OYPi6cIavgxm+QWD4hnCGvVNhGRYhMCxiwOcL9kolW+ci4F4pStC5qPBeKQpmWIzAsJhwhsXADIsTGBYXzrA4mOGbBIZvCmf4JphhCQLDEsIZlgAzLElgWFI4w5JghqUIDEsJZ1gKzLA0gWFp4QxLgxm+RWD4lnCGb4EZliEwLCOcYRkww7cJDN8WzvBtMMOyBIZlhTMsC2ZYjsCwnHCG5cAMyxMYlhfOsDyYYQUCwwrCGVYAM6xIYFhROMOKYIbvEBi+I5zhO2CGlQgMKwlnWAnMsDKBYWXhDCuDGVYhMKwinGEVMMOqBIZVhTOsCmZYjcCwmnCG1cAM3yUwfFc4w3fBDKsTGFYXzrA6mGENAsMawhnWADOsSWBYUzjDmmCGtQgMawlnWAvMsDaBYW3hDGuDGb5HYPiecIbvgRnWITCsI5xhHTDD9wkM3xfO8H0ww7oEhnUJz0g6X5Dcygqm5bYeam+zzRB73EBzaaijkY7GOproaKqjmY7mOlroaKmjlY7WOtroaKujnY72OR7k6JAjNmmS2J92Us9j5xp6OdfIy7nGXs418XKuqZdzzbyca+7lXAsv51p6OdfKy7nWXs618XKurZdz7byca+/lXIfYc/YrKbII1IMGq5cNawCR2RJuANEx9utBviiwoURnf8AWydE5RithLxUNnG9HoNE5a7KjoybjXtDFRD069oRy6ETi0MnBgbGYRmXD1n4Muvb1OGOAtd8JqPkHJM0/8EHtfwDk8CGJw4fk2o8G1359Qu3XB9b+h0DNO5M078yufc2hgVAOdg7G/isGvP+qD95/NQDvvxoS9l8NgH3YEDjfLqQ+7OKDNagLsA+7kjh0Ja9BDcBrUCPCGtQIWPtdgZp3I2nezQe13w3I4SMSh4/Itd8QXPuNCbXfGFj7HwE1/5ik+cc+2H81FMrBzsHYfzUC778ag/dfTcD7r6aE/VcTYB82Bc63O6kPu/tgDeoO7MNPSBw+Ia9BTcBrUDPCGtQMWPufADX/lKT5pz6o/U+BHD4jcfiMXPtNwbXfnFD7zYG1/xlQ8x4kzXv4YP/VSCgHOwdj/9UMvP9qDt5/tQDvv1oS9l8tgH3YEjjfz0l9+LkP1qDPgX3Yk8ShJ3kNagFeg1oR1qBWwNrvCdS8F0nzXj6o/V5ADr1JHHqTa78luPZbE2q/NbD2ewM1/4Kk+Rc+2H81FsrBzsHYf7UC779ag/dfbcD7r7aE/VcbYB+2Bc63D6kP+/hgDeoD7MMvSRy+JK9BbcBrUDvCGtQOWPtfAjXvS9K8rw9qvy+Qw1ckDl+Ra78tuPbbE2q/PbD2vwJq3o+keT8f7L+aCOVg52Dsv9qB91/twfuvDuD9V0fC/qsDsA87Auf7NakPv/bBGvQ1sA/7kzj0J69BHcBrUCfCGtQJWPv9gZoPIGk+wAe1PwDIYSCJw0By7XcE1/4HhNr/AFj7A4Gaf0PS/Bsf7L+aCuVg52DsvzqB918fgPdfH4L3X50J+68PgX3YGTjfQaQ+HOSDNWgQsA8HkzgMJq9BH4LXoC6ENagLsPYHAzUfQtJ8iA9qfwiQw1ASh6Hk2u8Mrv2uhNrvCqz9oUDNh5E0H+aD/VczoRzsHIz9Vxfw/qsreP/VDbz/+oiw/+qG/DsY4HyHk/pwuA/WoOHAPhxB4jCCvAZ1A69BHxPWoI+BtT8CqPlIkuYjfVD7I4EcRpE4jCLX/kfg2u9OqP3uwNofBdT8W5Lm3/pg/9VcKAc7B2P/9TF4/9UdvP/6BLz/+pSw//oE2IefAuc7mtSHo32wBo0G9uEYEocx5DXoE/Aa9BlhDfoMWPtjgJqPJWk+1ge1PxbI4TsSh++8cEDX1rJkuFzfAZmOIzEd54P9TQuhHOwcjP3NZ+D9TQ/w/qYHeH/zOWF/0wPo8Z8D5/s9qQ+/94HHfw/sw/EkDuPJ+5vPwfubnoT9TU9g7Y8Haj6BpPkEH9T+BCCHiSQOE8m13xNc+70Itd8LWPsTgZr/QNL8Bx/sv1oK5WDnYOy/eoH3X73B+6/e4P3XF4T9V29gH34BnO8kUh9O8sEaNAnYhz+SOPxIXoO+AK9BfQhrUB9g7f8I1HwySfPJPqj9yUAOU0gcppBrvw+49r8k1P6XwNqfAtR8KknzqT7Yf7USysHOwdh/fQnef/UF77/6gvdfXxH2X32Rf+cLnO9PpD78yQdr0E/APpxG4jCNvAZ9BV6D+hHWoH7A2p8G1Hw6SfPpPqj96UAOM0gcZpBrvx+49r8m1P7XwNqfAdR8JknzmT7Yf7UWysHOwdh/fQ3ef/UH77/6g/dfAwj7r/7APhwAnO8sUh/O8sEaNAvYh7NJHGaT16AB4DVoIGENGgis/dlAzeeQNJ/jg9qfA+Qwl8RhLrn2B4Jr/xtC7X8DrP25QM3nkTSf54P9VxuhHOwcjP3XN+D91yDw/msQeP81mLD/GoT8G3fgfOeT+nC+D9ag+cA+XEDisIC8Bg0Gr0FDCGvQEGDtLwBqvpCk+UIf1P5CIIdFJA6LyLU/BFz7Qwm1PxRY+4uAmi8mab7YB/uvtkI52DkY+6+h4P3XMPD+axh4/zWcsP8aBuzD4cD5LiH14RIfrEFLgH24lMRhKXkNGg5eg0YQ1qARwNpfCtR8GUnzZT6o/WVADstJHJaTa38EuPZHEmp/JLD2lwM1/5mk+c8+2H+1E8rBzsHYf40E779Ggfdfo8D7r28J+69RwD78FjjfX0h9+IsP1qBfgH24gsRhBXkN+ha8Bo0mrEGjgbW/Aqj5SpLmK31Q+yuBHFaROKwi1/5ocO2PIdT+GGDtrwJqvpqk+Wof7L/aC+XgnHOix+ac0HH+ChhnaF0rIjo0NIw5zjWAcdarFxpWNzo8hDnOtYBxBkWGRscEhQUyx7kOMM66IcExMSFBdZnjXA8YZ4iyokMCw2KY49wAGGdEPSskNDw8kjnOjYBxqpjwoKiIuvWY49yE0L1etBUZpSLssWWOHWOD2HXEPm7oOG7kOG7sOG7iOG7qOG7mOG7uOG7hOG7pOG7lOG7tOG7jOG7rOG7nOG7vOP7VcbzGcbzWcbzOcbzecbzBcbzRcbwp9niz/rlFx1Yd23Rs17FDx04du3I8uAeQwu/hXsb+7yaNFZ6xD6sH3odFZf//dWol7KWicPswi8EwEswwmsAwWjjDKDDDGALDGOEMo8EM6xMY1hfOMAbMsAGBYQPhDOuDGTYkMGwonGEDMMNGBIaNhDNsCGbYmMCwsXCGjcAMmxAYNhHOsDGYYVMCw6bCGTYBM2xGYNhMOMOmYIbNCQybC2fYDMywBYFhC+EMm4MZtiQwbCmcYQsww1YEhq2EM2wJZtiawLC1cIatwAzbEBi2Ec6wNZhhWwLDtsIZtgEzbEdg2E44w7Zghu0JDNsLZ9gOzLADgWEH4Qzbgxl2JDDsKJxhBzDDTgSGnYQz7Ahm+AGB4QfCGXYCM/yQwPBD4Qw/ADPsTGDYWTjDD8EMuxAYdhHOsDOYYVcCw67CGXYBM+xGYNhNOMOuYIYfERh+JJwh47vd0Qw/Fs6Q8R3haIbdhTP8GMzwEwLDT4Qz7A5m+CmB4afCGTK+axnNEPhdy//6exf0GIHf2UvR+TOwzj0IOvcQ3is9wAw/JzD8XDhDxnefohn2FM6Q8R2aaIa9hDPsBWbYm8Cwt3CGvcEMvyAw/EI4Q8Z3EaIZ9hHOkPGddmiGXwpn+CWYYV8Cw77CGfYFM/yKwPAr4QwZ3w2GZthPOEPGd0yhGX4tnOHXYIb9CQz7C2fYH8xwAIHhAOEMGd/Vg2Y4UDhDxne+oBl+I5zhN2CGgwgMBwlnOAjMcDCB4WDhDBnfnYFmOEQ4Q8Z3MKAZDhXOcCiY4TACw2HCGQ4DMxxOYDhcOEPGZ9mjGY4QzpDxmehohiOFMxwJZjiKwHCUcIajwAy/JTD8VjhDxmdLoxmOFs6Q8RnFaIZjhDMcA2Y4lsBwrHCGY8EMvyMw/A7IEP05p/acxxHmPI7wPJ4fdIzhlHocB67H7wnafC+8p78HMxxPYDheOMPxYIYTCAwnCGc4AcxwIoHhROEMJ4IZ/kBg+INwhj+AGU4iMJwknOEkMMMfCQx/FM7wRzDDyQSGk4UznAxmOIXAcIpwhlPADKcSGE4VznAqmOFPBIY/CWf4E5jhNALDacIZTgMznE5gOF04w+lghjMIDGcIZzgDzHAmgeFM4QxnghnOIjCcJZzhLDDD2QSGs4UznA1mOIfAcI5whnPADOcSGM4VznAumOE8AsN5whnOAzOcT2A4XzjD+WCGCwgMFwhnuADMcCGB4ULhDBeCGS4iMFwknOEiMMPFBIaLhTNcDGa4hMBwiXCGS8AMlxIYLhXOcCmY4TICw2XCGS4DM1xOYLhcOMPlYIY/Exj+LPwZul8Ic/5F/DN0kZR6/AVcjysI2qwQ3tMrwAxXEhiuFM5wJZjhKgLDVcIZrgIzXE1guFo4w9Vghr8SGP4qnOGvYIZrCAzXCGe4BsxwLYHhWuEM14IZriMwXCec4Toww/UEhuuFM1wPZriBwHCDcIYbwAw3EhhuFM5wI5jhJgLDTcIZbgIz3ExguFk4w81ghlsIDLcIZ7gFzHArgeFW4Qy3ghluIzDcJpzhNjDD7QSG24Uz3A5muIPAcIdwhjvADHcSGO4UznAnmOEuAsNdwhnuAjPcTWC4WzjD3WCGewgM9whnuAfMcC+B4V7hDPeCGe4jMNwnnOE+MMP9BIb7hTPcD2Z4gMDwgHCGB8AMDxIYHhTO8CCY4SECw0PCGR4CMzxMYHhYOMPDYIa/ERj+JpxhshRYhkcIDI8QnslDjzFpCtk6HwH3ylGCzkeF98pRMMNjBIbHhDM8BmZ4nMDwuHCGx8EMTxAYnhDO8ASY4UkCw5PCGZ4EMzxFYHhKOMNTYIa/Exj+Lpzh72CGpwkMTwtneBrM8AyB4RnhDM+AGZ4lMDwrnOFZMMNzBIbnhDM8B2Z4nsDwvHCG58EMLxAYXhDO8AKY4UUCw4vCGV4EM7xEYHhJOMNLYIaXCQwvC2d4GczwCoHhFeEMr4AZXiUwvCqc4VUww2sEhteEM7wGZnidwPC6cIbXwQxvEBjeEM7wBpjhTQLDm8IZ3gQzvEVgeEs4w1tghrcJDG8LZ3gbzPAOgeEd4QzvgBneJTC8K5zhXTDDewSG94QzvAdmeJ/A8L5whvfBDP1y4BnaOSUz9MuOZZiIwDCRcIalUmIZJiYwTAxkGJsGPsaSKWXrnBjcK0kIOicR3itJwAyTEhgmFc4wKZhhMgLDZMIZJgMzTE5gmFw4w+RghikIDFMIZ5gCzDAlgWFK4QxTghmmIjBMJZxhKjDD1ASGqYUzTA1mmIbAMI1whmnADJ8gMHxCOMMnwAzTEhimFc4wLZhhOgLDdMIZpgMzTE9gmF44w/RghhkIDDMIZ5gBzDAjgWFG4QwzghlmIjDMJJxhJjDDzASGmYUzzAxmmIXAMItwhlnADLMSGGYVzjArmGE2AsNswhlmAzPMTmCYXTjD7GCGOQgMcwhnmAPMMCeBYU7hDHOCGeYiMMwlnGEuMEN/AkN/4Qz9wQxzExjmFs4wN5hhHgLDPMIZ5gEzDCAwDBDOMADMMC+BYV7hDPOCGXoIDD3CGXrADJ8kMHxSOMMnwQyfIjB8SjjDp8AMnyYwfFo4w6fBDJ8hMHxGOMNnwAyfJTB8VjjDZ8EMnyMwfE44w+fADJ8nMHxeOMPnwQzzERjmE84wH5hhfgLD/MIZ5gczLEBgWEA4wwJghgUJDAsKZ1gQzLAQgWEh4QwLgRm+QGD4gnCGL4AZvkhg+KJwhi+CGRYmMCwsnGFhMEOLwNASztACM1QEhko4QwVmGEhgGCicYSCYYRCBYZBwhkFghsEEhsHCGQaDGYYQGIYIZxgCZhhKYBgqnGEomGEYgWGYcIZhYIbhBIbhwhmGgxlGEBhGCGcYAWb4EoHhS8IZvgRm+DKB4cvCGb4MZvgKgeErwhm+Amb4KoHhq8IZvgpm+BqB4WvCGb4GZvg6geHrwhm+Dmb4BoHhG8IZ9k6FZViEwLCIAZ8v2CuVbJ2LgHulKEHnosJ7pSiYYTECw2LCGRYDMyxOYFhcOMPiYIZvEhi+KZzhm2CGJQgMSwhnWALMsCSBYUnhDEuCGZYiMCwlnGEpMMPSBIalhTMsDWb4FoHhW8IZvgVmWIbAsIxwhmXADN8mMHxbOMO3wQzLEhiWFc6wLJhhOQLDcsIZlgMzLE9gWF44w/JghhUIDCsIZ1gBzLAigWFF4Qwrghm+Q2D4jnCG74AZViIwrCScYSUww8oEhpWFM6wMZliFwLCKcIZVwAyrEhhWFc6wKphhNQLDasIZVgMzfJfA8F3hDN8FM6xOYFhdOMPqYIY1CAxrCGdYA8ywJoFhTeEMa4IZ1iIwrCWcYS0ww9oEhrWFM6wNZvgegeF7whm+B2ZYh8CwjnCGdcAM3ycwfF84w/fBDOsSGNYlPCPpfEFyKyuYltsK/pf2NtsMsce7NZc9Ovbq2Kdjv44DOg7qOKTjsI7fdBzRcVTHMR3HdZzQcTLHgxyncsQmTRL7007qeezcHi/n9no5t8/Luf1ezh3wcu6gl3OHvJw77OXcb17OHfFy7qiXc8e8nDvu5dwJL+dOejl3Kvac/UqKLAL1oMHGZMMawNhsCTeA6Bj7FZsPbCjfZX/AFsnROUYrYS/1HXC+vwONzlmTvztqMu4FXUzUo2NPKIfTJA6nHRweX6QQtToOXaua7DhgrZ4GanSGpNEZH9TqGSCHsyQOZ9kcNImzQA7nYBzCH+Fwzgccdovk8GCzythDjAPvIb4H7yG+B+8hxhP2EN8DfXk8cL7nSX503ge+fB7YhxdIHC44ODAuyMdnw9b+BMKeZAKw9i8ANb9I0vyiD2r/IpDDJRKHS+TanwCu/YmE2p8IrP1LQM0vkzS/7IP91x6hHOwcjP3XRPD+6wfw/usH8P5rEmH/9QOwDycB53uF1IdXfLAGXQH24VUSh6vkNWgSeA36kbAG/Qis/atAza+RNL/mg9q/BuRwncThOrn2fwTX/mRC7U8G1v51oOY3SJrf8MH+a69QDnYOxv5rMnj/NQW8/5oC3n9NJey/pgD7cCpwvjdJfXjTB2vQTWAf3iJxuEVeg6aC16CfCGvQT8DavwXU/DZJ89s+qP3bQA53SBzukGv/J3DtTyPU/jRg7d8Ban6XpPldH+y/9gnlYOdg7L+mgfdf08H7r+ng/dcMwv5rOrAPZwDne4/Uh/d8sAbdA/bhfRKH++Q1aAZ4DZpJWINmAmv/PlBzv5wcze28Hj9u7TvHnlAOiUgcEuXk1v5McO3PItT+LGDtJwJqnpikeeKc/P3X/hwyOdg5GPuvWeD912zw/ms2eP81h7D/mg3swznA+SYh9WESH6xBSYB+lJTEISl5DZoDXoPmEtagucDaTwrUPBlJ82Q+qP1kQA7JSRySk2t/Lrj25xFqfx6w9pMDNU9B0jyFD/ZfB3LI5GDnYOy/5oH3X/PB+6/54P3XAsL+az6wDxcA55uS1IcpfbAGpQT6USoSh1TkNWgBeA1aSFiDFgJrPxVQ89QkzVP7oPZTAzmkIXFIQ679heDaX0So/UXA2k8D1PwJkuZP+GD/dTCHTA52Dsb+axF4/7UYvP9aDN5/LSHsvxYD+3AJcL5pSX2Y1gdrUFqgH6UjcUhHXoOWgNegpYQ1aCmw9tMBNU9P0jy9D2o/PZBDBhKHDOTaXwqu/WWE2l8GrP0MQM0zkjTP6IP916EcMjnYORj7r2Xg/ddy8P5rOXj/9TNh/7Uc2Ic/A+ebidSHmXywBmUC+lFmEofMObmfYfULYc34BVirmYEaZSFplMUHtZoFyCEriUNWH6ydWYEcssE4RD7CIZsPOBzOIZEDbw/xC3gPsQK8h1gB3kOsJOwhVgB9eSVwvtlJfpTdB76cHehHOUgccpCvY1eCr2NXEfYkq4C1nwOoeU6S5jl9UPs5gRxykTjkItf+KnDtrybU/mpg7ecCau5P0tzfB/uv33LI5GDnYOy/VoP3X7+C91+/gvdfawj7r1+BfbgGON/cpD7M7YM1KDfQj/KQOOQhr0FrwGvQWsIatBZY+3mAmgeQNA/wQe0HADnkJXHIS679teDaX0eo/XXA2s8L1NxD0tzjg/3XkRwyOdg5GPuvdeD913rw/ms9eP+1gbD/Wg/sww3A+T5J6sMnfbAGPQn0o6dIHJ4ir0EbwGvQRsIatBFY+08BNX+apPnTPqj9p4EcniFxeIZc+xvBtb+JUPubgLX/DFDzZ0maP+uD/dfRHDI52DkY+69N4P3XZvD+azN4/7WFsP/aDOzDLcD5Pkfqw+d8sAY9B/Sj50kcnievQVvAa9BWwhq0FVj7zwM1z0fSPJ8Paj8fkEN+Eof85NrfCq79bYTa3was/fxAzQuQNC/gg/3XsRwyOdg5GPuvbeD913bw/ms7eP+1g7D/2g7swx3A+RYk9WFBH6xBBYF+VIjEoRB5DdoBXoN2EtagncDaLwTU/AWS5i/4oPZfAHJ4kcThRXLt7wTX/i5C7e8C1v6LQM0LkzQv7IP91/EcMjnYORj7r13g/ddu8P5rN3j/tYew/9oN7MM9wPlapD60fLAGWUA/UiQOirwG7QGvQXsJa9BeYO0roOaBJM0DfVD7gUAOQSQOQeTa3wuu/X2E2t8HrP0goObBJM2DfbD/OpFDJgc7B2P/tQ+8/9oP3n/tB++/DhD2X/uBfXgAON8QUh+G+GANCgH6USiJQyh5DToAXoMOEtagg8DaDwVqHkbSPMwHtR8G5BBO4hBOrv2D4No/RKj9Q8DaDwdqHkHSPMIH+6+TOeRyyBzLYXfsd6fZx3scx3sdx/scx/sdxwccxwcdx4ccx4cdx785jo84jo86jo85jo87jk84jk86jjc7jrc4jrc6jrc5jrc7jnc4jnc6jnfFHr+kmb+s4xUdr+p4Tcfrtg46iuR8sIdN4fewF+3/btJEnFqy+74e2Eeisv//z0uyEvZSUTgfsRgMI8EMowkMo4UzjAIzjCEwjBHOMBrMsD6BYX3hDGPADBsQGDYQzrA+mGFDAsOGwhk2ADNsRGDYSDjDhmCGjQkMGwtn2AjMsAmBYRPhDBuDGTYlMGwqnGETMMNmBIbNhDNsCmbYnMCwuXCGzcAMWxAYthDOsDmYYUsCw5bCGbYAM2xFYNhKOMOWYIatCQxbC2fYCsywDYFhG+EMW4MZtiUwbCucYRsww3YEhu2EM2wLZtiewLC9cIbtwAw7EBh2EM6wPZhhRwLDjsIZdgAz7ERg2Ek4w45ghh8QGH4gnGEnMMMPCQw/FM7wAzDDzgSGnYUz/BDMsAuBYRfhDDuDGXYlMOwqnGEXMMNuBIbdhDPsCmb4EYHhR8IZdgMz/JjA8GPhDD8CM+xOYNhdOMOPwQw/ITD8RDjD7mCGnxIYfiqc4Sdghp8RGH4GZBibBj7GZclk6/wZWOceBJ17CO+VHmCGnxMYfi6c4edghj0JDHsKZ9gTzLAXgWEv4Qx7gRn2JjDsLZxhbzDDLwgMvxDO8Aswwz4Ehn2EM+wDZvglgeGXwhl+CWbYl8Cwr3CGfcEMvyIw/Eo4w6/ADPsRGPYTzrAfmOHXBIZfC2f4NZhhfwLD/sIZ9gczHEBgOEA4wwFghgMJDAcKZzgQzPAbAsNvhDP8BsxwEIHhIOEMB4EZDiYwHCyc4WAwwyEEhkOEMxwCZjiUwHCocIZDwQyHERgOE85wGJjhcALD4cIZDgczHEFgOEI4wxFghiMJDEcKZzgSzHAUgeEo4QxHgRl+S2D4rXCG34IZjiYwHC2c4WgwwzEEhmOEMxwDZjiWwHCscIZjwQy/IzD8Dsjw8bEh5jyOMOdxhOfx/KBjDKfU4zhwPX5P0OZ74T39PZjheALD8cIZjgcznEBgOEE4wwlghhMJDCcKZzgRzPAHAsMfhDP8AcxwEoHhJOEMJ4EZ/khg+KNwhj+CGU4mMJwsnOFkMMMpBIZThDOcAmY4lcBwqnCGU8EMfyIw/Ek4w5/ADKcRGE4TznAamOF0AsPpwhlOBzOcQWA4QzjDGWCGMwkMZwpnOBPMcBaB4SzhDGeBGc4mMJwtnOFsMMM5BIZzhDOcA2Y4l8BwrnCGc8EM5xEYzhPOcB6Y4XwCw/nCGc4HM1xAYLhAOMMFYIYLCQwXCme4EMxwEYHhIuEMF4EZLiYwXCyc4WIwwyUEhkuEM1wCZriUwHCpcIZLwQyXERguE85wGZjhcgLD5cIZLgcz/JnA8Gfhz9D9QpjzL+KfoYuk1OMv4HpcQdBmhfCeXgFmuJLAcKVwhivBDFcRGK4SznAVmOFqAsPVwhmuBjP8lcDwV+EMfwUzXENguEY4wzVghmsJDNcKZ7gWzHAdgeE64QzXgRmuJzBcL5zhejDDDQSGG4Qz3ABmuJHAcKNwhhvBDDcRGG4SznATmOFmAsPNwhluBjPcQmC4RTjDLWCGWwkMtwpnuBXMcBuB4TbhDLeBGW4nMNwunOF2MMMdBIY7hDPcAWa4k8Bwp3CGO8EMdxEY7hLOcBeY4W4Cw93CGe4GM9xDYLhHOMM9YIZ7CQz3Cme4F8xwH4HhPuEM94EZ7icw3C+c4X4wwwMEhgeEMzwAZniQwPCgcIYHwQwPERgeEs7wEJjhYQLDw8IZHgYz/I3A8DfhDJOlwDI8QmB4hPBMHnqMSVPI1vkIuFeOEnQ+KrxXjoIZHiMwPCac4TEww+MEhseFMzwOZniCwPCEcIYnwAxPEhieFM7wJJjhKQLDU8IZngIz/J3A8HfhDH8HMzxNYHhaOMPTYIZnCAzPCGd4BszwLIHhWeEMz4IZniMwPCec4Tkww/MEhueFMzwPZniBwPCCcIYXwAwvEhheFM7wIpjhJQLDS8IZXgIzvExgeFk4w8tghlcIDK8IZ3gFzPAqgeFV4QyvghleIzC8JpzhNTDD6wSG14UzvA5meIPA8IZwhjfADG8SGN4UzvAmmOEtAsNbwhneAjO8TWB4WzjD22CGdwgM7whneAfM8C6B4V3hDO+CGd4jMLwnnOE9MMP7BIb3hTO8D2bolwPP0M4pmaFfdizDRASGiYQzLJUSyzAxgWFiIMPYNPAxlkwpW+fE4F5JQtA5ifBeSQJmmJTAMKlwhknBDJMRGCYTzjAZmGFyAsPkwhkmBzNMQWCYQjjDFGCGKQkMUwpnmBLMMBWBYSrhDFOBGaYmMEwtnGFqMMM0BIZphDNMA2b4BIHhE8IZPgFmmJbAMK1whmnBDNMRGKYTzjAdmGF6AsP0whmmBzPMQGCYQTjDDGCGGQkMMwpnmBHMMBOBYSbhDDOBGWYmMMwsnGFmMMMsBIZZhDPMAmaYlcAwq3CGWcEMsxEYZhPOMBuYYXYCw+zCGWYHM8xBYJhDOMMcYIY5CQxzCmeYE8wwF4FhLuEMc4EZ+hMY+gtn6A9mmJvAMLdwhrnBDPMQGOYRzjAPmGEAgWGAcIYBYIZ5CQzzCmeYF8zQQ2DoEc7QA2b4JIHhk8IZPglm+BSB4VPCGT4FZvg0geHTwhk+DWb4DIHhM8IZPgNm+CyB4bPCGT4LZvgcgeFzwhk+B2b4PIHh88IZPg9mmI/AMJ9whvnADPMTGOYXzjA/mGEBAsMCwhkWADMsSGBYUDjDgmCGhQgMCwlnWAjM8AUCwxeEM3wBzPBFAsMXhTN8EcywMIFhYeEMC4MZWgSGlnCGFpihIjBUwhkqMMNAAsNA4QwDwQyDCAyDhDMMAjMMJjAMFs4wGMwwhMAwRDjDEDDDUALDUOEMQ8EMwwgMw4QzDAMzDCcwDBfOMBzMMILAMEI4wwgww5cIDF8SzvAlMMOXCQxfFs7wZTDDVwgMXxHO8BUww1cJDF8VzvBVMMPXCAxfE87wNTDD1wkMXxfO8HUwwzcIDN8QzrB3KizDIgSGRQz4fMFeqWTrXATcK0UJOhcV3itFwQyLERgWE86wGJhhcQLD4sIZFgczfJPA8E3hDN8EMyxBYFhCOMMSYIYlCQxLCmdYEsywFIFhKeEMS4EZliYwLC2cYWkww7cIDN8SzvAtMMMyBIZlhDMsA2b4NoHh28IZvg1mWJbAsKxwhmXBDMsRGJYTzrAcmGF5AsPywhmWBzOsQGBYQTjDCmCGFQkMKwpnWBHM8B0Cw3eEM3wHzLASgWEl4QwrgRlWJjCsLJxhZTDDKgSGVYQzrAJmWJXAsKpwhlXBDKsRGFYTzrAamOG7BIbvCmf4LphhdQLD6sIZVgczrEFgWEM4wxpghjUJDGsKZ1gTzLAWgWEt4QxrgRnWJjCsLZxhbTDD9wgM3xPO8D0wwzoEhnWEM6wDZvg+geH7whm+D2ZYl8CwLuEZSecLkltZwbTcVvi/tLfZZog9LprTz6+YjuI63tRRQkdJHaV0lNbxlo4yOt7WUVZHOR3ldVTQUTHngxzv5IxNmiT2p53U89i5Yl7OFfdy7k0v50p4OVfSy7lSXs6V9nLuLS/nyng597aXc2W9nCvn5Vx5L+cqeDlX0cu5d2LP2a+kyCJQDxrsUDasARzOlnADiI6xX7H5wIbyW/YHbJEcnWO0EvZSvwHnWyknzuicNVnJUZNxL+hioh4de0I5VCZxqOzggF5Mk6XQG5Js2No/gq59Pc4jwNqvDNS8CknzKj6o/SpADlVJHKp64YCuraQpgDf4gUyrkZhWY9eW/YcjQjnYORj7myPg/c1R8P7mKHh/c4ywvzkK9PhjwPm+S+rDd33g8e8C+7A6iUN14v7mj1oF72+OE/Y3x4G1Xx2oeQ2S5jV8UPs1gBxqkjjUJNf+cXDtnyDU/glg7dcEal6LpHktH+y/ignlYOdg7L9OgPdfJ8H7r5Pg/dcpwv7rJLAPTwHnW5vUh7V9sAbVBvbheyQO75HXoFPgNeh3whr0O7D23wNqXoekeR0f1H4dIIf3SRzeJ9f+7+DaP02o/dPA2n8fqHldkuZ1fbD/Ki6Ug52Dsf86Dd5/nQHvv86A919nCfuvM8A+PAucbz1SH9bzwRpUD9iHkSQOkeQ16Cx4DTpHWIPOAWs/Eqh5FEnzKB/UfhSQQzSJQzS59s+Ba/88ofbPA2s/Gqh5DEnzGB/sv94UysHOwdh/nQfvvy6A918XwPuvi4T91wVgH14Ezrc+qQ/r+2ANqg/swwYkDg3Ia9BF8Bp0ibAGXQLWfgOg5g1Jmjf0Qe03BHJoROLQiFz7l8C1f5lQ+5eBtd8IqHljkuaNfbD/KiGUg52Dsf+6DN5/XQHvv66A919XCfuvK8A+vAqcbxNSHzbxwRrUBNiHTUkcmpLXoKvgNegaYQ26Bqz9pkDNm5E0b+aD2m8G5NCcxKE5ufavgWv/OqH2rwNrvzlQ8xYkzVv4YP9VUigHOwdj/3UdvP+6Ad5/3QDvv24S9l83gH14EzjflqQ+bOmDNaglsA9bkTi0Iq9BN8Fr0C3CGnQLWPutgJq3Jmne2ge13xrIoQ2JQxty7d8C1/5tQu3fBtZ+G6DmbUmat/XB/quUUA52Dsb+6zZ4/3UHvP+6A95/3SXsv+4A+/AucL7tSH3YzgdrUDtgH7YncWhPXoPugtege4Q16B6w9tsDNe9A0ryDD2q/A5BDRxKHjuTavweu/fuE2r8PrP2OQM07kTTv5IP9V2mhHOwcjP3XffD+yw+wf3Duv/xyYPswUQ78/ssP94F9KhFwvh+Q+vADH6xBHwD78EMShw+Ja1CplPjP10qcA78GJQbW/odAzTuTNO/sg9rvDOTQhcShiw8+X6tkSlyuLkCmXUlMu/pgf/OWUA52Dsb+JjFwj2znSwLe3yQB72+SEvY3SYAenxQ4326kPuzmA4/vBuzDj0gcPiJfYycF31tNRtjfJAPW/kdAzT8maf6xD2r/YyCH7iQO3cm1nwxc+8kJtZ8cWPvdgZp/QtL8Ex/sv8oI5WDnYOy/koP3XynA+68U4P1XSsL+KwWwD1MC5/spqQ8/9cEa9CmwDz8jcfiMvAalBK9BqQhrUCpg7X8G1LwHSfMePqj9HkAOn5M4fE6u/VTg2k9NqP3UwNr/HKh5T5LmPX2w/3pbKAc7B2P/lRq8/0oD3n+lAe+/niDsv9IA+/AJ4Hx7kfqwlw/WoF7APuxN4tCbvAY9AV6D0hLWoLTA2u8N1PwLkuZf+KD2vwBy6EPi0Idc+2nBtZ+OUPvpgLXfB6j5lyTNv/TB/qusUA52Dsb+Kx14/5UevP9KD95/ZSDsv9ID+zADcL59SX3Y1wdrUF9gH35F4vAVeQ3KAF6DMhLWoIzA2v8KqHk/kub9fFD7/YAcviZx+Jpc+xnBtZ+JUPuZgLX/NVDz/iTN+/tg/1VOKAc7B2P/lQm8/8oM3n9lBu+/shD2X5mBfZgFON8BpD4c4IM1aACwDweSOAwkr0FZwGtQVsIalBVY+wOBmn9D0vwbH9T+N0AOg0gcBpFrPyu49rMRaj8bsPYHATUfTNJ8sA/2X+WFcrBzMPZf2cD7r+zg/Vd28P4rB2H/lR3YhzmA8x1C6sMhPliDhgD7cCiJw1DyGpQDvAblJKxBOYG1PxSo+TCS5sN8UPvDgByGkzgMJ9d+TnDt5yLUfi5g7Q8Haj6CpPkIH+y/KgjlYOdg7L9ygfdf/uD9lz94/5WbsP/yB/ZhbuB8R5L6cKQP1qCRwD4cReIwirwG5QavQXkIa1AeYO2PAmr+LUnzb31Q+98COYwmcRhNrv084NoPINR+ALD2RwM1H0PSfIwP9l8VBXPIHMuhaCwH+7iY47i44/hNx3EJx3FJx3Epx3Fpx/FbjuMyjuO3HcdlHcflHMflHccVHMcVHccvOY5fdhy/4jh+1XH8muP4dcfxG47jIrHHY/XP73SM0/G9jvE6JuiYqOOHnA/2sCn8Hvai/d9NmohTS3bf1wN/RlJU9gdjRo4zCrcHtxgMI8EMowkMo4UzjAIzjCEwjBHOMBrMsD6BYX3hDGPADBsQGDYQzrA+mGFDAsOGwhk2ADNsRGDYSDjDhmCGjQkMGwtn2AjMsAmBYRPhDBuDGTYlMGwqnGETMMNmBIbNhDNsCmbYnMCwuXCGzcAMWxAYthDOsDmYYUsCw5bCGbYAM2xFYNhKOMOWYIatCQxbC2fYCsywDYFhG+EMW4MZtiUwbCucYRsww3YEhu2EM2wLZtiewLC9cIbtwAw7EBh2EM6wPZhhRwLDjsIZdgAz7ERg2Ek4w45ghh8QGH4gnGEnMMMPCQw/FM7wAzDDzgSGnYUz/BDMsAuBYRfhDDuDGXYlMOwqnGEXMMNuBIbdhDPsCmb4EYHhR8IZdgMz/JjA8GPhDD8CM+xOYNhdOMOPwQw/ITD8RDjD7mCGnxIYfiqc4Sdghp8RGH4GZBibBj7GZclk6/wZWOceBJ17CO+VHmCGnxMYfi6c4edghj0JDHsKZ9gTzLAXgWEv4Qx7gRn2JjDsLZxhbzDDLwgMvxDO8Aswwz4Ehn2EM+wDZvglgeGXwhl+CWbYl8Cwr3CGfcEMvyIw/Eo4w6/ADPsRGPYTzrAfmOHXBIZfC2f4NZhhfwLD/sIZ9gczHEBgOEA4wwFghgMJDAcKZzgQzPAbAsNvhDP8BsxwEIHhIOEMB4EZDiYwHCyc4WAwwyEEhkOEMxwCZjiUwHCocIZDwQyHERgOE85wGJjhcALD4cIZDgczHEFgOEI4wxFghiMJDEcKZzgSzHAUgeEo4QxHgRl+S2D4rXCG34IZjiYwHC2c4WgwwzEEhmOEMxwDZjiWwHCscIZjwQy/IzD8Dsjw8bEh5jyOMOdxhOfx/KBjDKfU4zhwPX5P0OZ74T39PZjheALD8cIZjgcznEBgOEE4wwlghhMJDCcKZzgRzPAHAsMfhDP8AcxwEoHhJOEMJ4EZ/khg+KNwhj+CGU4mMJwsnOFkMMMpBIZThDOcAmY4lcBwqnCGU8EMfyIw/Ek4w5/ADKcRGE4TznAamOF0AsPpwhlOBzOcQWA4QzjDGWCGMwkMZwpnOBPMcBaB4SzhDGeBGc4mMJwtnOFsMMM5BIZzhDOcA2Y4l8BwrnCGc8EM5xEYzhPOcB6Y4XwCw/nCGc4HM1xAYLhAOMMFYIYLCQwXCme4EMxwEYHhIuEMF4EZLiYwXCyc4WIwwyUEhkuEM1wCZriUwHCpcIZLwQyXERguE85wGZjhcgLD5cIZLgcz/JnA8Gfhz9D9QpjzL+KfoYuk1OMv4HpcQdBmhfCeXgFmuJLAcKVwhivBDFcRGK4SznAVmOFqAsPVwhmuBjP8lcDwV+EMfwUzXENguEY4wzVghmsJDNcKZ7gWzHAdgeE64QzXgRmuJzBcL5zhejDDDQSGG4Qz3ABmuJHAcKNwhhvBDDcRGG4SznATmOFmAsPNwhluBjPcQmC4RTjDLWCGWwkMtwpnuBXMcBuB4TbhDLeBGW4nMNwunOF2MMMdBIY7hDPcAWa4k8Bwp3CGO8EMdxEY7hLOcBeY4W4Cw93CGe4GM9xDYLhHOMM9YIZ7CQz3Cme4F8xwH4HhPuEM94EZ7icw3C+c4X4wwwMEhgeEMzwAZniQwPCgcIYHwQwPERgeEs7wEJjhYQLDw8IZHgYz/I3A8DfhDJOlwDI8QmB4hPBMHnqMSVPI1vkIuFeOEnQ+KrxXjoIZHiMwPCac4TEww+MEhseFMzwOZniCwPCEcIYnwAxPEhieFM7wJJjhKQLDU8IZngIz/J3A8HfhDH8HMzxNYHhaOMPTYIZnCAzPCGd4BszwLIHhWeEMz4IZniMwPCec4Tkww/MEhueFMzwPZniBwPCCcIYXwAwvEhheFM7wIpjhJQLDS8IZXgIzvExgeFk4w8tghlcIDK8IZ3gFzPAqgeFV4QyvghleIzC8JpzhNTDD6wSG14UzvA5meIPA8IZwhjfADG8SGN4UzvAmmOEtAsNbwhneAjO8TWB4WzjD22CGdwgM7whneAfM8C6B4V3hDO+CGd4jMLwnnOE9MMP7BIb3hTO8D2bolwPP0M4pmaFfdizDRASGiYQzLJUSyzAxgWFiIMPYNPAxlkwpW+fE4F5JQtA5ifBeSQJmmJTAMKlwhknBDJMRGCYTzjAZmGFyAsPkwhkmBzNMQWCYQjjDFGCGKQkMUwpnmBLMMBWBYSrhDFOBGaYmMEwtnGFqMMM0BIZphDNMA2b4BIHhE8IZPgFmmJbAMK1whmnBDNMRGKYTzjAdmGF6AsP0whmmBzPMQGCYQTjDDGCGGQkMMwpnmBHMMBOBYSbhDDOBGWYmMMwsnGFmMMMsBIZZhDPMAmaYlcAwq3CGWcEMsxEYZhPOMBuYYXYCw+zCGWYHM8xBYJhDOMMcYIY5CQxzCmeYE8wwF4FhLuEMc4EZ+hMY+gtn6A9mmJvAMLdwhrnBDPMQGOYRzjAPmGEAgWGAcIYBYIZ5CQzzCmeYF8zQQ2DoEc7QA2b4JIHhk8IZPglm+BSB4VPCGT4FZvg0geHTwhk+DWb4DIHhM8IZPgNm+CyB4bPCGT4LZvgcgeFzwhk+B2b4PIHh88IZPg9mmI/AMJ9whvnADPMTGOYXzjA/mGEBAsMCwhkWADMsSGBYUDjDgmCGhQgMCwlnWAjM8AUCwxeEM3wBzPBFAsMXhTN8EcywMIFhYeEMC4MZWgSGlnCGFpihIjBUwhkqMMNAAsNA4QwDwQyDCAyDhDMMAjMMJjAMFs4wGMwwhMAwRDjDEDDDUALDUOEMQ8EMwwgMw4QzDAMzDCcwDBfOMBzMMILAMEI4wwgww5cIDF8SzvAlMMOXCQxfFs7wZTDDVwgMXxHO8BUww1cJDF8VzvBVMMPXCAxfE87wNTDD1wkMXxfO8HUwwzcIDN8QzrB3KizDIgSGRQz4fMFeqWTrXATcK0UJOhcV3itFwQyLERgWE86wGJhhcQLD4sIZFgczfJPA8E3hDN8EMyxBYFhCOMMSYIYlCQxLCmdYEsywFIFhKeEMS4EZliYwLC2cYWkww7cIDN8SzvAtMMMyBIZlhDMsA2b4NoHh28IZvg1mWJbAsKxwhmXBDMsRGJYTzrAcmGF5AsPywhmWBzOsQGBYQTjDCmCGFQkMKwpnWBHM8B0Cw3eEM3wHzLASgWEl4QwrgRlWJjCsLJxhZTDDKgSGVYQzrAJmWJXAsKpwhlXBDKsRGFYTzrAamOG7BIbvCmf4LphhdQLD6sIZVgczrEFgWEM4wxpghjUJDGsKZ1gTzLAWgWEt4QxrgRnWJjCsLZxhbTDD9wgM3xPO8D0wwzoEhnWEM6wDZvg+geH7whm+D2ZYl8CwLuEZSecLkltZwbTcVuS/tLfZZog9npTTz+9HHZN1TNExVcdPOqbpmK5jho6ZOmbpmK1jjo65OubpmJ/zQY4FOWOTJon9aSf1PHbuRy/nJns5N8XLualezv3k5dw0L+emezk3w8u5mV7OzfJybraXc3O8nJvr5dw8L+fmezm3IPac/UqKLAIV+4HG2bEGgPig2+gY+xWbLwfWUOwPuU0C5gj88OFHPoQ3ofNdmBNndM6aXOioybgXdDFRj449oRwWkTgscnBgLKaMDzxOAh4n8AOP1SKg5otJmi/2Qe0vBnJYQuKwhFz7jA+qRtc+8IOq1RKg5ktJmi9l177mMEkoBzsHY//1FHj/9TR4//U0eP/1DGH/Bfyw80c+9Duh811G6sNlPliDlgH7cDmJw3LyGsT4gHX0GgT8gHW1HKj5zyTNf/ZB7f8M5PALicMv5NpnfDA+uvaBH4yvfgFqvoKk+Qof7L9+FMrBzsHYfz0H3n89D95/PQ/ef+Uj7L+AX67wyJcMJHS+K0l9uNIHa9BKYB+uInFYRV6DGF/ogF6DgF/ooFYBNV9N0ny1D2p/NZDDryQOv5Jrn/FFHOjaB34Rh/oVqPkakuZrfLD/miyUg52Dsf8qAN5/FQTvvwqC91+FCPsv4Je5PPKlJgmd71pSH671wRq0FtiH60gc1pHXIMYXyKDXIOAXyKh1QM3XkzRf74PaXw/ksIHEYQO59hlf/IOufeAX/6gNQM03kjTf6IP91xShHOwcjP3Xi+D9V2Hw/qsweP9lEfZfwC+PeuRLlBI6302kPtzkgzVoE7APN5M4bCavQYwvrEKvQcAvrFKbgZpvIWm+xQe1vwXIYSuJw1Zy7TO+aAxd+8AvGlNbgZpvI2m+zQf7r6lCOdg5GPuvQPD+Kwi8/woC77+CCfsv4JfVPfKlbQmd73ZSH273wRq0HdiHO0gcdpDXIMYX5KHXIOAX5KkdQM13kjTf6YPa3wnksIvEYRe59hlfbIiufeAXG6pdQM13kzTf7YP9109COdg5GPuvUPD+Kwy8/woD77/CCfsv4JdjPvIlkQmd7x5SH+7xwRq0B9iHe0kc9pLXIMYXcqLXIOAXcqq9QM33kTTf54Pa3wfksJ/EYT+59hlfpIqufeAXqar9QM0PkDQ/4IP91zShHOwcjP3XS+D918vg/dfL4P3XK4T9F/DLeB/5UtqEzvcgqQ8P+mANOgjsw0MkDofIaxDjC4DRaxDwC4DVIaDmh0maH/ZB7R8GcviNxOE3cu0zvrgZXfvAL25WvwE1P0LS/IgP9l/ThXKwczD2X6+B91+vg/dfr4P3X28Q9l/AL/9+5EuwEzrfo6Q+POqDNegosA+PkTgcI65B9peN/1GvwNovQliDgF84ro4BNT9O0vy4D2r/OJDDCRKHE144oGsL+EXx6gSQ6UkS05M+2N/MEMrBzsHY3xQB72+Kgvc3RcH7m2KE/U1RoMcXA873FKkPT/nA408B+/B3EoffydfYxcDX2MUJ+5viwNr/Haj5aZLmp31Q+6eBHM6QOJwh135xcO2/Saj9N4G1fwao+VmS5md9sP+aKZSDnYOx/3oTvP8qAd5/lQDvv0oS9l8lgH1YEjjfc6Q+POeDNegcsA/PkzicJ69BJcFrUCnCGlQKWPvngZpfIGl+wQe1fwHI4SKJw0Vy7ZcC135pQu2XBtb+RaDml0iaX/LB/muWUA52Dsb+qzR4//UWeP/1Fnj/VYaw/3oL2IdlgPO9TOrDyz5Ygy4D+/AKicMV8hpUBrwGvU1Yg94G1v4VoOZXSZpf9UHtXwVyuEbicI1c+2+Da78sofbLAmv/GlDz6yTNr/tg/zVbKAc7B2P/VRa8/yoH3n+VA++/yhP2X+WAfVgeON8bpD684YM16AawD2+SONwkr0HlwWtQBcIaVAFY+zeBmt8iaX7LB7V/C8jhNonDbXLtVwDXfkVC7VcE1v5toOZ3SJrf8cH+a45QDnYOxv6rInj/9Q54//UOeP9VibD/egfYh5WA871L6sO7PliD7gL78B6Jwz3yGlQJvAZVJqxBlYG1fw+o+X2S5vd9UPv3gRz8cnE42Hk9jPnH1n5lcO1XIdR+FWDtO3VK6HwTkTRPlIu//5qbUyYHOwdj/1UFvP+qCt5/VQXvv6oR9l9VgX1YDTjfxKQ+TJyLvwYlBvpREhKHJOQ1qBp4DXqXsAa9C6z9JEDNk5I0T+qD2k8K5JCMxCEZufbfBdd+dULtVwfWfjKg5slJmif3wf5rXk6ZHOwcjP1XdfD+qwZ4/1UDvP+qSdh/1QD2YU3gfFOQ+jCFD9agFEA/SknikJK8BtUEr0G1CGtQLWDtpwRqnoqkeSof1H4qIIfUJA6pybVfC1z7tQm1XxtY+6mBmqchaZ7GB/uv+Tnlcsgcy2FS7D1w+/hHx/Fkx/EUx/FUx/FPjuNpjuPpjuMZjuOZjuNZjuPZjuM5juO5juN5juP5juOxjuPvHMfjHMffO47HO44nOI4nOo5/iD1+QjNPqyOdjvQ6MujIqCOTjsy5HuxhU/g97MU/rmkTcWrJ7vt64M9Iisoee/8fOM4o3B7cYjCMBDOMJjCMFs4wCswwhsAwRjjDaDDD+gSG9YUzjAEzbEBg2EA4w/pghg0JDBsKZ9gAzLARgWEj4Qwbghk2JjBsLJxhIzDDJgSGTYQzbAxm2JTAsKlwhk3ADJsRGDYTzrApmGFzAsPmwhk2AzNsQWDYQjjD5mCGLQkMWwpn2ALMsBWBYSvhDFuCGbYmMGwtnGErMMM2BIZthDNsDWbYlsCwrXCGbcAM2xEYthPOsC2YYXsCw/bCGbYDM+xAYNhBOMP2YIYdCQw7CmfYAcywE4FhJ+EMO4IZfkBg+IFwhp3ADD8kMPxQOMMPwAw7Exh2Fs7wQzDDLgSGXYQz7Axm2JXAsKtwhl3ADLsRGHYTzrArmOFHBIYfCWfYDczwYwLDj4Uz/AjMsDuBYXfhDD8GM/yEwPAT4Qy7gxl+SmD4qXCGn4AZfkZg+BmQYWwa+BiXJZOt82dgnXsQdO4hvFd6gBl+TmD4uXCGn4MZ9iQw7CmcYU8ww14Ehr2EM+wFZtibwLC3cIa9wQy/IDD8QjjDL8AM+xAY9hHOsA+Y4ZcEhl8KZ/glmGFfAsO+whn2BTP8isDwK+EMvwIz7Edg2E84w35ghl8TGH4tnOHXYIb9CQz7C2fYH8xwAIHhAOEMB4AZDiQwHCic4UAww28IDL8RzvAbMMNBBIaDhDMcBGY4mMBwsHCGg8EMhxAYDhHOcAiY4VACw6HCGQ4FMxxGYDhMOMNhYIbDCQyHC2c4HMxwBIHhCOEMR4AZjiQwHCmc4Ugww1EEhqOEMxwFZvgtgeG3whl+C2Y4msBwtHCGo8EMxxAYjhHOcAyY4VgCw7HCGY4FM/yOwPA7IMPHx4aY8zjCnMcRnsfzg44xnFKP48D1+D1Bm++F9/T3YIbjCQzHC2c4HsxwAoHhBOEMJ4AZTiQwnCic4UQwwx8IDH8QzvAHMMNJBIaThDOcBGb4I4Hhj8IZ/ghmOJnAcLJwhpPBDKcQGE4RznAKmOFUAsOpwhlOBTP8icDwJ+EMfwIznEZgOE04w2lghtMJDKcLZzgdzHAGgeEM4QxngBnOJDCcKZzhTDDDWQSGs4QznAVmOJvAcLZwhrPBDOcQGM4RznAOmOFcAsO5whnOBTOcR2A4TzjDeWCG8wkM5wtnOB/McAGB4QLhDBeAGS4kMFwonOFCMMNFBIaLhDNcBGa4mMBwsXCGi8EMlxAYLhHOcAmY4VICw6XCGS4FM1xGYLhMOMNlYIbLCQyXC2e4HMzwZwLDn4U/Q/cLYc6/iH+GLpJSj7+A63EFQZsVwnt6BZjhSgLDlcIZrgQzXEVguEo4w1VghqsJDFcLZ7gazPBXAsNfhTP8FcxwDYHhGuEM14AZriUwXCuc4Voww3UEhuuEM1wHZriewHC9cIbrwQw3EBhuEM5wA5jhRgLDjcIZbgQz3ERguEk4w01ghpsJDDcLZ7gZzHALgeEW4Qy3gBluJTDcKpzhVjDDbQSG24Qz3AZmuJ3AcLtwhtvBDHcQGO4QznAHmOFOAsOdwhnuBDPcRWC4SzjDXWCGuwkMdwtnuBvMcA+B4R7hDPeAGe4lMNwrnOFeMMN9BIb7hDPcB2a4n8Bwv3CG+8EMDxAYHhDO8ACY4UECw4PCGR4EMzxEYHhIOMNDYIaHCQwPC2d4GMzwNwLD34QzTJYCy/AIgeERwjN56DEmTSFb5yPgXjlK0Pmo8F45CmZ4jMDwmHCGx8AMjxMYHhfO8DiY4QkCwxPCGZ4AMzxJYHhSOMOTYIanCAxPCWd4CszwdwLD34Uz/B3M8DSB4WnhDE+DGZ4hMDwjnOEZMMOzBIZnhTM8C2Z4jsDwnHCG58AMzxMYnhfO8DyY4QUCwwvCGV4AM7xIYHhROMOLYIaXCAwvCWd4CczwMoHhZeEML4MZXiEwvCKc4RUww6sEhleFM7wKZniNwPCacIbXwAyvExheF87wOpjhDQLDG8IZ3gAzvElgeFM4w5tghrcIDG8JZ3gLzPA2geFt4QxvgxneITC8I5zhHTDDuwSGd4UzvAtmeI/A8J5whvfADO8TGN4XzvA+mKFfDjxDO6dkhn7ZsQwTERgmEs6wVEosw8QEhomBDGPTwMdYMqVsnRODeyUJQeckwnslCZhhUgLDpMIZJgUzTEZgmEw4w2RghskJDJMLZ5gczDAFgWEK4QxTgBmmJDBMKZxhSjDDVASGqYQzTAVmmJrAMLVwhqnBDNMQGKYRzjANmOETBIZPCGf4BJhhWgLDtMIZpgUzTEdgmE44w3RghukJDNMLZ5gezDADgWEG4QwzgBlmJDDMKJxhRjDDTASGmYQzzARmmJnAMLNwhpnBDLMQGGYRzjALmGFWAsOswhlmBTPMRmCYTTjDbGCG2QkMswtnmB3MMAeBYQ7hDHOAGeYkMMwpnGFOMMNcBIa5hDPMBWboT2DoL5yhP5hhbgLD3MIZ5gYzzENgmEc4wzxghgEEhgHCGQaAGeYlMMwrnGFeMEMPgaFHOEMPmOGTBIZPCmf4JJjhUwSGTwln+BSY4dMEhk8LZ/g0mOEzBIbPCGf4DJjhswSGzwpn+CyY4XMEhs8JZ/gcmOHzBIbPC2f4PJhhPgLDfMIZ5gMzzE9gmF84w/xghgUIDAsIZ1gAzLAggWFB4QwLghkWIjAsJJxhITDDFwgMXxDO8AUwwxcJDF8UzvBFMMPCBIaFhTMsDGZoERhawhlaYIaKwFAJZ6jADAMJDAOFMwwEMwwiMAwSzjAIzDCYwDBYOMNgMMMQAsMQ4QxDwAxDCQxDhTMMBTMMIzAME84wDMwwnMAwXDjDcDDDCALDCOEMI8AMXyIwfEk4w5fADF8mMHxZOMOXwQxfITB8RTjDV8AMXyUwfFU4w1fBDF8jMHxNOMPXwAxfJzB8XTjD18EM3yAwfEM4w96psAyLEBgWMeDzBXulkq1zEXCvFCXoXFR4rxQFMyxGYFhMOMNiYIbFCQyLC2dYHMzwTQLDN4UzfBPMsASBYQnhDEuAGZYkMCwpnGFJMMNSBIalhDMsBWZYmsCwtHCGpcEM3yIwfEs4w7fADMsQGJYRzrAMmOHbBIZvC2f4NphhWQLDssIZlgUzLEdgWE44w3JghuUJDMsLZ1gezLACgWEF4QwrgBlWJDCsKJxhRTDDdwgM3xHO8B0ww0oEhpWEM6wEZliZwLCycIaVwQyrEBhWEc6wCphhVQLDqsIZVgUzrEZgWE04w2pghu8SGL4rnOG7YIbVCQyrC2dYHcywBoFhDeEMa4AZ1iQwrCmcYU0ww1oEhrWEM6wFZlibwLC2cIa1wQzfIzB8TzjD98AM6xAY1hHOsA6Y4fsEhu8LZ/g+mGFdAsO6hGcknS9IbmUFE3P/S3ubbYbY4yy5/Pyy6simI7uOHDpy6silw19Hbh15dAToyKvDo+NJHU/peDrXgxzP5IpNmiT2p53U89i5Z2LP2a+k4Ik9vqBYCXvBzDU6xn7F5suBN+skYI7ABe8R40/ofJ/NhWteZ00+66jJuBfUINWjY08oh+dIHJ5zcDBlkU0CHidwkVXPATV/nqT58z6o/eeBHPKROOQj1z5jc4SufeDmSOUDap6fpHl+du1rDlmEcnDOGf7FYYaMM5sh48xuyDhzGDLOnIaMM5ch4/Q3ZJy5DRlnHkPGGWDIOPMaMk6PIeN80pBxPmXIOJ8GjtO+p5bS7+G1gfMmH2v8WUicEWMMJ+VljdfN6+Z187p5/25eYO4QWm79i624tce5LhXQ60dBHYV0vKDjRR2FdVg6lI5AHUE6gnWE6AjVEaYjXEfE4790KuDll07hXs5FxJ6zF8ysfg9v/Dhf8G9eyCW8ANSDH04WL8X+du/lx0Hb/0HKxwaAviNZEHD3LPrB7TP1EvBO3MuG7CxNGWchQ8b5giHjfNGQcRY2ZJyWIeNUhowz0JBxBhkyzmBDxhliyDhDDRlnmCHjROzjwmJzOcf5+G9rE7qvA97JUgVI2oB+Q63iDsKB++JXSL+pd+YFc4h7qQig9q9Arlv0Kyz6kXpPBK731wBzjrvDao8ts9//f/LzNcfx5SSyjp03BiIcx084jtM6jtM5jtM7jjM4jjM6jjM5jjPHHr9uM9dRREdRHcV0FNfxpo4SuR7ckMjm9/Ba+t/pbyXspV6XfkPiwYv6OLTzjlTcE8klNZdSOkrreOvxGx8lY298OM+V8nKutJdzb3m5aZIMC+sRURNqECVRRhZjqVKgXPYcSwNvDL0F/vWbr5r3Dbd5vTZvGc3lbR1ldZR7vHnLeGnKt72cK+vlXDkfNO8bwOYtA2zet4HNWxbYvOUMbd4ibvN6bd7ymksFHRV1vPN485b30pQVvJyr6OXcOz5o3iLA5i0PbN4KwOatCGzedwxt3qJu83pt3kqaS2UdVXRUfbx5K3lpyspezlXxcq6qD5q3KLB5KwGbtzKweasAm7eqoc1bzG1er81bTXN5V0d1HTUeb95qXpryXS/nqns5V8MHzVsM2LzVgM37LrB5qwObt4ahzVvcbV6vzVtTc6mlo7aO9x5v3ppemrKWl3O1vZx7zwfNWxzYvDWBzVsL2Ly1gc37nqHN+6bbvF6bt47m8r6OujrqPd68dbw05fteztX1cq6eD5r3TWDz1gE27/vA5q0LbN56hjZvCbd5vTZvpOYSpSNaR8zjzRvppSmjvJyL9nIuxgfNWwLYvJHA5o0CNm80sHljwM2byu/hcwy25rn8vL8w/5shgZy8oSGkvGGkvBGcvGFBpLzBZukWRqqzQNJf04SSdAuNIeWN5uQ1rc5M40Cr33BSXkXiy+o3Eoegupy8rHoIq0fiwBpvlL33SfRY7rx/9r+hrP/oVfL/793+w0yWVerxXP9xJssq/WiuBGSyrH/7KNPfzFzmz3P97TG+/We5/oPZlvWe6z/iFq+nR+KZufxf54r3GCv8Va6/MduK/z7X3+L2t35h/xeZK8U/11+OsXJ8c8VjtlXilyte3P6j35H+SeZqfz/Xn47x3b+b69/Mtvrfy/VvuSXo11KPZa75n+f6f2Os9Z/m8jLb2v9ZLq/cIL8JiM1cJ+G5/jXG9xOayzHbugnL9Qg34M3XR+5RWQl56RFGY3L9MVfkPSq/uJd9s8q+UeWLO82J/AgTcLxAucOYDG4nwTFwbqzrx92hzuT38BZ2otj/4J7fw7+Q8XacKOmD47j/XgP932moo5GOxrkenPeWO3lSRw6/h8fNMjw8TvlY7iY6X1MdzXQ0j81th12Aif3+/0uyAMxxNgF2e3LHOFvE3opuGfuzVezP1rE/2+R6MJd8se9vq//dTkd7HR10dNTRSccHOj7U0VlHFx1ddXTT8ZGOj3V01/GJjk91fKajh47PdfTU0UtHbx1f6Oij40sdfXV8paOfjq919NcxQMdAHd/oGKRjsI4hOobqGKZj+OO/lrEH74ktqCx+///SkyFUy1ycjh6RizjgEbnweUcCf+fEmvfIXA8Bg/Javiy2VqRiG5WLOOBRhGL7Vnix2fP+1vBia00qttG5iAMeTSi2McKLzZ73GEKxMcY6MrYxHs+bUK5jc5nZZG1ITfZdLuKAvyM02TjhTWbPe5whTWabwVhCk30PLtbHLyhbOi5WWzmO2ziOiz92QTle/2cTdEzU8UOuh+fjXuiPLgSuimo8sOYnkbWZ5NBgguN4ouP4h1yPavOj/vdkHVN0TM31aD5kXdp9+T2h3n8Cau3LZzpbMG4VOl6Y3IHhvNxWoPOZzribGdM0l+k6ZuiYqWOWjtk65uiYq2Oejvk6FuhYqGORjsU6luhYqmOZjuU6ftbxi44VOlbqWKVjtY5fdazRsVbHOh3rdWzQsVHHJh2bdWzRsVXHNh3bdezQsVPHrsdvZkzL9fDOWty56V7OzfBybqaXc7O8nJvt5dwcL+fmejk3z8u5+V7OLfBybqGXc4u8nFvs5dwSL+eWejm3zMu55V7O/ezl3C9ezq3wcm6ll3OrvJxb7eXcr17OrfFybq2Xc+u8nFvv5dwGL+c2ejm3ycu5zV7ObfFybquXc9u8nNvu5dwOL+d2ejm3y2Huca/8sT/fiP1pJez1iGkmdOGYBsj14JnpmJjpuFxRM3C5ImbicqlZsFzRajYsV6SaA8sVrubCcllqHipXtKXmo3JFWmoBKle4pRaicuneXgTKFa1zLQblitS5loByhetcS0G5bC9chskVbedajskVaef6GZPL/mhD9Qsm1x9rxwpIrug/cq2E5Ir8I9cqSK4/PglSrYbkerDW/orIFf0g1xpErsgHudYicj344Ey1DpErdm+yHpArKjbXBkCuerG5NgJyxX3+76aE5wqM3X+pzQnPpeJybUlwrvCYuFxbE56rXlyubQnPFbdfVdsTnCvsX7l2JDhXyL9y7UxwLvWvXLtIN0XinlpJaB8grx3icu3GzfmPvxlB36iybxD+RLhxtwesdWLwvO2naqYBtbF13kPguNcAjsgan0biuA/I0R7b4zfnbZ3ibsLvy+X9Kb8rSR69Ob9fv++AjoM6DuX685vzVsJeyn56bDqBafEi3F/CJXR89pz3E+b9ZhHOOpYUrPt+4Dp2GNjjwLpRpmjRDqjFb7k4PSypL7x57GGHr/4WT489ot93VMcxHceJHms/nTuD4DUlhHusPecjhHmXNKSvjwB78QTQY4F1o0zRoj1Qi5O5OD0sqS+8eewJh6+ejKfHntLv+13HaR1niB5r//XDTILXlBLusfacTxHmXdqQvj4F7MWzQI8F1o0yRYsOQC3O5eL0sKS+8OaxZx2+ei6eHntev++Cjos6LhE91v7rslkEr3lLuMfacz5PmHcZQ/r6PLAXLwM9Flg3yhQtOgK1uJKL08OS+sKbx152+OqVeHrsVf2+azqu67hB9Fj7r3dnE7zmbeEea8/5KmHeZQ3p66vAXrwJ9Fhg3ShTtOgE1OJWLk4PS+oLbx570+Grt+Lpsbf1++7ouGu/n+ix9qcjzCF4TTnhHmvP+TZh3uUN6evbwF68D/RYYN0oU7T4AKiFnz+nhyX1hTePve/wVZtBfDw2kX5fYh1JdCT153ms/ekzcwleU0G4x/4xZ3983oqG9HUiYC8m88eNC1g3yhQtPgR6bHJ/Tg9L6gtvHpvM4avJ4+mxKfT7UupIpSM10WPtT/eaR/DYd4R7rD3nFASPrWRIX6cA9mIaoMcC60aZokVnoMc+4c/pYUl94c1j0zh89Yl4emxa/b50OtLryED0WPvTE+cTPLaycI+155yW4LFVDOnrtMBezAj0WGDdKFO06AL02Ez+nB6W1BfePDajw1czxdNjM+v3ZdGRVUc2osfan067gOCxVYV7rD3nzASPrWZIX2cG9mJ2oMcC60aZokVXoMfm8Of0sKS+8Oax2R2+miOeHptTvy+XDn8duYkea3/690KCx74r3GPtOeckeGx1Q/o6J7AX8wA9Flg3yhQtugE9NsCf08OS+sKbx+Zx+GpAPD02r36fR8eTOp4ieqz97QqLCB5bQ7jH2nPOS/DYmob0dV5gLz4N9Fhg3ShTtPgI6LHP+HN6WFJfePPYpx2++kw8PfZZ/b7ndDyvIx/RY+1vr1lM8Nhawj3WnvOzBI+tbUhfPwvsxfxAjwXWjTJFi4+BHlvAn9PDkvrCm8fmd/hqgXh6bEH9vkI6XtDxItFj7W8HW0Lw2PeEe6w954IEj61jSF8XBPZiYaDHAutGmaJFd6DHWv6cHpbUF948trDDV614eqzS7wvUEaQjmOix9rcvLiV47PvCPdaesyJ4bF1D+loBezEE6LHAulGmaPEJ0GND/Tk9LKkvvHlsiMNXQ+PpsWH6feE6InS8RPRY+9ttlxE8tp5wj7XnHEbw2EhD+joM2IsvAz0WWDfKFC0+BXrsK/6cHpbUF9489mWHr74ST499Vb/vNR2v28yIHmt/e/hygsdGCfdYe86vEjw22pC+fhXYi0WAHgusG2WKFp8BPbaoP6eHJfWFN48t4vDVovH02GL6fcV1vKmjBNFje+R6+D14zrwJZRoj3GPtORcjeGx9Q/q6GLAXSwI9Flg3yhQteiA/j9Cf08OS+sKbx5Z0+GqpeHpsaf2+t3SU0fE20WM/z/Xwe0WdeRPKtIFwj7XnXJrgsQ0N6evSwF4sC/RYYN0oU7T4HOix5fw5PSypL7x5bFmHr5aLp8eW1++roKOijneIHtsz18PvaXbmTSjTRsI91p5zeYLHNjakr8sDe7ES0GOBdaNM0aIn0GMr+3N6WFJfePPYSg5frRxPj62i31dVRzUd7xI9tleuh99778ybUKZNhHusPecqBI9takhfVwH2YnWgxwLrRpmiRS+gx9bw5/SwpL7w5rHVHb5aI54eW1O/r5aO2jreI3psb63vKoLHNhPusfacaxI8trkhfV0T2It1gB4LrBtliha9gR77vj+nhyX1hTePrePw1ffj6bF19fvq6YjUEUX02C+0vqsJHttCuMfac65L8NiWhvR1XWAvRgM9Flg3yhQtvgB6bIw/p4cl9YU3j412+GpMPD22vn5fAx0NdTQiemwfre+vBI9tJdxj7TnXJ3hsa0P6uj6wFxsDPRZYN8oULfoAPbaJP6eHJfWFN49t7PDVJvH02Kb6fc10NNfRguixX2p91xA8to1wj7Xn3JTgsW0N6eumwF5sCfRYYN0oU7T4Euixrfw5PSypL7x5bEuHr7aKp8e21u9ro6OtjnZEj+2r9V1L8Nh2wj3WnnNrgse2N6SvWwN7sT3QY4F1o0zRoi/QYzv4c3pYUl9489j2Dl/tEE+P7ajf10nHBzo+JHrsV1rfdQSP7SDcY+05dyR4bEdD+rojsBc7Az0WWDfKFC2+AnpsF39OD0vqC28e29nhq13i6bFd9fu66fhIx8dEj+2n9V1P8NhOwj3WnnNXgsd+YEhfdwX2YnegxwLrRpmiRT+gx37iz+lhSX3hzWO7O3z1k3h67Kf6fZ/p6KHjc6LHfq313UDw2A+Fe6w9508JHtvZkL7+FNiLPYEeC6wbZYoWXwM9tpc/p4cl9YU3j+3p8NVe8fTY3vp9X+joo+NLosf21/puJHhsF+Eea8+5N8Fju5ryTCawF/sCPRZYN8oULfoDPfYrf04PS+oLbx7b1+GrX8XTY/vp932to7+OAUSPHaD13UTw2G7CPdaecz+Cx35kyvUpsBcHAj0WWDfKFC0GAD32G39OD0vqC28eO9Dhq9/E02MH6fcN1jFEx1Cixw7U+m4meOzHwj3WnvMggsd2N6SvBwF7cRjQY4F1o0zRYiDQY4f7c3pYUl9489hhDl8dHk+PHaHfN1LHKB3fEj32G63vFoLHfiLcY+05jyB47KeG9PUIYC+OBnossG6UKVp8A/TYMf6cHpbUF948drTDV8fE02PH6vd9p2Ocju+JHjtI67uV4LGfCfdYe85jCR7bw5C+HgvsxfFAjwXWjTJFi0FAj53gz+lhSX3hzWPHO3x1Qjw9dqJ+3w86Jun4keixg7W+2wge+7lwj7XnPJHgsT0N6euJwF6cDPRYYN0oU7QYDPTYKf6cHpbUF948drLDV6fE02On6vf9pGOajulEjx2i9d1O8Nhewj3WnvNUgsf2NqSvpwJ7cQbQY4F1o0zRYgjQY2f6c3pYUl9489gZDl+dGU+PnaXfN1vHHB1ziR47VOu7g+CxXwj3WHvOswge28eQvp4F7MV5QI8F1o0yRYuhQI+d78/pYUl94c1j5zl8dX48PXaBft9CHYt0LCZ67DCt706Cx34p3GPtOS8geGxfQ/p6AbAXlwA9Flg3yhQthgE9dqk/p4cl9YU3j13i8NWl8fTYZfp9y3X8rOMXoscO1/ruInjsV8I91p7zMoLH9jOkr5cBe3EF0GOBdaNM0WI40GNX+nN6WFJfePPYFQ5fXRlPj12l37dax6861jg8Nu6VGKxzBj8cz1X+nNpOAp5zE2BttwTmWgvkZ9dNFr+Ha4nzhV6vkeN2jnedP3HA6/zxedcDjY417/X+DwGD8v5RbHYk9uMXm7N5rQS+mONsmYvTFBscdYv/NBfgrskeW5LYMcYN2i6SZH6+cSWkAM7C3hjbQJvsOTEE2EBwpg3gpZk178TEeSf4T2vIDK2EvZRdmJsJl49bwMt7nCnYebvF5kWz2ERisZXEYuu/YZHgjzYgsej/372dEvkX46PVwIAisn3AXvg2E7wUqLdCMrQ3Fcn9vO8+/f4mg7+qKWdOhn+jmDg3WNv+3Y7RSthLbSYZonPQf3PM6q/+d+wxbyMYw0Ah9/b+zkYmwc+3+cs0GKQWzrrc7lio/1N9/oo5Up8djlwqKEj3RlSYiomKCQoJiwisp0KDQkNjgmPCQsODo2JCgutGhUWr4LpBgRHRYVaMCo+ODgsJigwLjYmIigyNcZq2igoKCo6KqBepQgJD69azwqOC6loxwWFBgVbdqKCwqKig8NDQukFBUaHhMeER4YGBdWOCwq2QsLAIKzQwKCKQpc+OWH18eaXZhHSluTP2SnOXKQbOGt9OglnvJi1cu4lXNTaLXQQWe0gs9hCvalh1MUj4VQ2rBgYLv6ppQrqqAeqtkAz/KVc1O0lXNXtNvKrZS76q2UswhiH/g1c1+/xlGgxSC2dd7jPsqmY/8KpmMPCqhqXPfsdVzZ8tCpJvRzHHyVpgDpi4wBwgLzAHCAvMUNICkww8TqSBHQTmQt42Qy5WQ0lmeDAei1VCmR7yxy0Kj9w2E7RYsfQ59A+6BXc49hbcb94e9rAS9lJ/9tAD8imeBH/3CHAnzBA+jmESQxgmNNcR4XrYDXOEsEk4StowHSXerv2NxOIYicUx4u1aVl2MEH67llUDIw24XXuEcLsWqLdCMvyn3K49TLqaPs68mj5CMsTjxKtpe8zHCcYwypDbtUeAm6IT/jINBqmFsy5P+OB2LVKfk8DbtSOBV8AsfU7+F66AWX/ucCr2Cvh3UwycNb5TBLM+TVq4ThOvamwWvxNYnCGxOEO8qmHVxWjhVzWsGhgj/KqmJemqBqi3QjL8p1zVnCJd1Zw18armLPmq5izBGMb+D17VnPOXaTBILZx1ec6wq5rzwKuaMcCrGpY+5/8LD6Ec9uf0vSkLzAUTF5gL5AXmAmGB+c6Qh1CQBnYRmAt52wy5WH1HMsOLPngI5RLwIZSRRWQuVix9LnnRB/2MAPChE9Ua+DlSl4G+7svPkbpMWkSv+BMHfMUfn/cq0JhZ877q/xAwKK9PP0eqtSGfI9WE9DlS1/yJnyN1FXjp6nT1uEH/Ex4tvB7bQDf8CZ8jZQtwjeBM18i/qEHNOzFx3gkd403hv+yyC/Mm4RLrFuly8xbxl103SCxuk1jcJv6yi1UX44v8Vz3lL3/ZxaqBCQY8wneT4KVAvRWS4T/ll13XSZdRd5j3Im+SDPEO8V6kPeY7BGOYaMgvu24CN0V3/WUaDFILZ13e9cEvu5D63AP+smsC8P4hS597/4VH+FqTrjTvx92qyW2IgbPGd59g1olycwrQztuNqJWzGFAsEpNYJM7Nu6ph1cUk4Vc1rBr4UfhVTWvSVQ1Qb4Vk+E+5qrlPuqpJYsqi6DRE56AZVzVJCMYw+X/wqiZpbpkGg9TCWZdJc5t1VZMsN+6q5kfgVQ1Ln2S5ff8I33V/Tt+bssAkN3GBSU5eYJITFpgppAUG/Qgf0sBS5Bb5exjoYjWFZIYpcvMf4UuZG7coTCgic7Fi6ZMy9z/nFlyq3A9+ps5N+BypP3voAfkUT0JzAR8coXxuURxD9DOiLIYJzZUmt2w97IZJQ9gkPEG6RfkE8XZtahKLtCQWaYm3a1l1MU347VpWDUw34HatPW/07Vqg3grJ8J9yuzYV2FviXumYV9NpSIaYjng1bY85HcEYZhhyuzYN8Ao4fW6ZBoPUwlmX6X1wuxapTwbg7drpwCtglj4Z/gtXwKw/d8gYewWcyRQDZ40vI8GsM5MWrszEqxqbRSYCiywkFlmIVzWsupgl/KqGVQOzhV/VNCFd1QD1VkiG/5Srmoykq5qsJl7VZCVf1WQlGMOc/8Grmmy5ZRoMUgtnXWYz7KomO/CqZjbwqoalT/b/wkMoqXJz+t6UBSaHiQtMDvICk4OwwMw15CEUpIHlBOZC3jZDLlZzSWaY0wcPoeQCPoQyvYjMxYqlTy7iHZAx+ipwXC68B/mT74IhvMceYxIwT+QzDf5AT8stXA/7MwVzE9bCPOBnTNDPN9l3YZBjbBmbzw9b15Q7UK1ix4rWPABY67787LkA0sY7b27igPPmxuf1AI2PNW/P/3iTPUm6mkUbLLKWnhK+mDTQWiPHaGv8lCF1Xj8XryfjXugeehqgVd3IunUjomNC7bFl8nt44Wb/e2oGP797scf2/1bcsc0q7jhl0gfHcf+9Z/T7ntXxnI7ncz84b0dqv4ebZW+vNzC8A+0xJSb9b8Sx+jM9rYS9/qhBUC7qHb5nSN79rxf6d4oXk+CaLh/QIJ1X6XZej9+DZknj97ChmELm9/vfLjj0OJ11ZiXwxRxnEj9yA6NXuvz/cQEE/7/b6N5WugpJHq5odsQdF3Ac58/96EpXQP+7oI5COl7I/f8bFn1rqCAwVwHgrvZFUnOi+RVCagHkV9gQfi8gtQDys8C3PR73hhcdO9/CjmPLcfzCY96g9L8DdQTpCPaBN7wIzKWA2oQYUtuFgbkCgfxCDeFnAXMFAfmFkb0hxOEBoY7jMMdx8GPeEK7/HaHjJR0v+8AbFDBXOFCbVwyp7UBgrgggv1cN4RcEzPUSkN9rZG94xeEBrzqOX3Mcv/yYN7xuj0lHER1FfeANwcBcrwO1KWZIbYcAc70B5FfcEH6hwFxFgPzeJHtDMYcHFHccv+k4LvqYN5TQ/y6po5SO0j7whjBgrhJAbd4ypLbDgblKAvmVMYRfBDBXKSC/t8ne8JbDA8o4jt92HJd+zBvK6n+X01FeRwUfeMNLwFxlgdpUNKS2XwbmKgfk944h/F4B5ioP5FeJ7A0VHR7wjuO4kuO4wmPeUFn/u4qOqjqq+cAbXgXmqgzU5l1Davs1YK4qQH7VDeH3OjBXVSC/GmRveNfhAdUdxzUcx9Ue84aa+t+1dNTW8Z4PvOENYK6aQG3qGFLbRYC5agH5vW8Iv6LAXLWB/OqSvaGOwwPedxzXdRy/95g31NP/jtQRpSPaB95QDJirHlCbGENquzgwVySQX31D+L0JzBUF5NeA7A0xDg+o7zhu4DiOfswbGup/N9LRWEcTH3hDCWCuhkBtmhpS2yWBuRoB+TUzhF8pYK7GQH7Nyd7Q1OEBzRzHzR3HTR7zhhb63y11tNLR2gfe8BYwVwugNm0Mqe0ywFwtgfzaGsLvbWCuVkB+7cje0MbhAW0dx+0cx60f84b2+t8ddHTU0ckH3lAWmKs9UJsPDKntcsBcHYD8PjSEX3lgro5Afp3J3vCBwwM+dBx3dhx3eswbuuh/d9XRTcdHPvCGCsBcXYDafGxIbVcE5uoK5NfdEH7vAHN1A/L7hOwNHzs8oLvj+BPH8UePecOn+t+f6eih43MfeEMlYK5Pgdr0NKS2KwNzfQbk18sQflWAuXoA+fUme0NPhwf0chz3dhx//pg3fKH/3UfHlzr6+sAbqgJzfQHU5itDarsaMFcfIL9+hvB7F5jrSyC/r8ne8JXDA/o5jr92HPd9zBv6638P0DFQxzc+8IbqwFz9gdoMMqS2awBzDQDyG2wIv5rAXAOB/IaQvWGQwwMGO46HOI6/ecwbhup/D9MxXMcIH3hDLWCuoUBtRhpS27WBuYYB+Y0yhN97wFzDgfy+JXvDSIcHjHIcf+s4HvGYN4zW/x6jY6yO73zgDXWAuUYDtRlnSG2/D8w1Bsjve0P41QXmGgvkN57sDeMcHvC943i84/i7x7xhgv73RB0/6JjkA2+oB8w1AajNj4bUdiQw10Qgv8mG8IsC5voByG8K2Rt+dHjAZMfxFMfxpMe8Yar+9086pumY7gNviAbmmgrUZoYhtR0DzPUTkN9MQ/jVB+aaBuQ3i+wNMxweMNNxPMtxPP0xb5it/z1Hx1wd83zgDQ2AuWYDtZlvSG03AuaaA+S3gFzb8x01vMBxPNdxPO+x2l6o/71Ix2IdS7zUNvrzYJcCGEREqcB6wcorgw4ZHs51qWPeC3P/+SefL9P/2XIdP+v4JffDTz5/ws/7J5+jP9Q3kR+nr/yw4wxhMridBNsbca8VuWMH+3ihrHAUxOUk3o8TPVYoK/V/Z5WO1Tp+jS0Ub7mTJ/X+ocSNMvx5Ea7R+dbqWKdjvaMI7QJM7Pf/X5IFYI5zDdBEkzvGuSH3g58bY39uiv25Ofbnltyxn/Ye+/6t+t/bdGzXsUPHTh27dOzWsUfHXh37dOzXcUDHQR2HdBzW8ZuOIzqO6jim47iOEzpO6jil43cdp3Wc0XFWxzkd53Vc0HFRxyUdl3Vc0XFVxzUd13Xc0HFTx624oo/7iHp78J7YgvLVlxptzM3p6Nu5iQO+nRuf9w5wC8Ga953cDwGD8vr0G7Q2kYrtbm7igO8Siu2e8GKz533P8GLbTCq2+7mJA75PKDa/PLKL7Y+1O48fvNgYY70T2xjoC65Eecxssi2kJkuchzhgOzk6bxLhTWbPO4khTWabQaI8+CZLmgdbrI9fUG50XKxuchxvcRwXf+yCMpkeU3IdKXSkzMO/awlcFVUyYM2nImtj54/TILnjOIXjOGWeR7VJrf+dRscTOtLmeTQfsi7tvkxKqPd0OKbKnns2P9/cadtAuoPtBx1nYDgv94PvWYxjG3czI73WM4OOjDoy6cisI4uOrDqy6ciuI4eOnDpy6fDXkVtHHh0BOvLq8Oh4UsdTOp7W8YyOZ3U8p+N5Hfl05NdRQEdBHYV0vKDjRR2FdVg6lI5AHUE6gnWE6AjN4/fozYz0eR7eWYs7l8HLuYxezmXyci6zl3NZvJzL6uVcNi/nsns5l8PLuZxezuXycs7fy7ncXs7l8XIuwMu5vF7Oebyce9LLuae8nHvay7lnvJx71su557yce97LuXxezuX3cq6Al3MFvZwr5OXcC17OvejlXGEv5ywv55SXc4FezgV5ORfs5VyIl3OhDnOPe+WP/flG7E8rYa9HTDOhC0d6wMIeHfPglQGXKyojLldEJlwulRmWK1plgeWKVFlhucJVNlguS2VH5Yq2VA5UrkhL5UTlCrdULlQu3dv+oFzROlduUK5InSsPKFe4zhUAymV7YV5Mrmg7lweTK9LO9SQmV7id6ylMrj/WjqchuaL/yPUMJFfkH7meheQK/yPXc5BcD9ba5xG5oh/kyofIFfkgV35ErvAHuQogcsXuTQoCckXF5ioEyFUvNtcLgFxhsbleTHiuwNj9lyqc8FwqLpeV4FzhMXG5VMJz1YvLFZjwXHH7VRWU4Fxh/8oVnOBcIf/KFZLgXOpfuUJxN3MeuSkS99RKQvsAee3wr68Xxc3Z/pZO+I0q+wZhOsKNu3Cw1onB87afqkkP1MbWOZzAMcIAjsgaT0/i+BKQ4x/39/wevZlu6xR3E/6lPN6f8ruS5NGb8y/r972i41Udr+X585vzVsJeyn56LAOB6fYi3F/CJXR89pxfJsx7RxHOOpYUrPvLwHXsdWCPA+tGmaLFNuC9zTfycHpYUl9489jXHb76Rjw9toh+X1EdxXQUJ3qs/XRuRoLX7BTusfacixDmvcuQvi4C7MU3gR4LrBtlihbbgR5bIg+nhyX1hTePfdPhqyXi6bEl9ftK6Sit4y2ix9p//ZCJ4DW7hXusPeeShHnvMaSvSwJ7sQzQY4F1o0zRYgfQY9/Ow+lhSX3hzWPLOHz17Xh6bFn9vnI6yuuoQPRY+6/LMhO8Zq9wj7XnXJYw732G9HVZYC9WBHossG6UKVrsBHrsO3k4PSypL7x5bEWHr74TT4+tpN9XWUcVHVWJHmv/9W4WgtfsF+6x9pwrEeZ9wJC+rgTsxWpAjwXWjTJFi11Aj303D6eHJfWFN4+t5vDVd+PpsdX1+2roqKmjFtFj7U9HyErwmoPCPdaec3XCvA8Z0tfVgb1YG+ixwLpRpmixG+ix7+Xh9LCkvvDmsbUdvvpePD22jn7f+zrq6qhH9Fj702eyEbzmsHCPtedchzDv3wzp6zrAXowEeiywbpQpWuwBemxUHk4PS+oLbx4b6fDVqHh6bLR+X4yO+joaED3W/nSv7ASvOSLcY+05RxPmfdSQvo4G9mJDoMcC60aZosVeoMc2ysPpYUl94c1jGzp8tVE8Pbaxfl8THU11NCN6rP3piTkIXnNMuMfac25MmPdxQ/q6MbAXmwM9Flg3yhQt9gE9tkUeTg9L6gtvHtvc4ast4umxLfX7WuloraMN0WPtT6fNSfCaE8I91p5zS8K8TxrS1y2BvdgW6LHAulGmaLEf6LHt8nB6WFJfePPYtg5fbRdPj22v39dBR0cdnYgea3/6dy6C15wS7rH2nNsT5v27IX3dHtiLHwA9Flg3yhQtDgA99sM8nB6W1BfePPYDh69+GE+P7azf10VHVx3diB5rf7uCP8FrTgv3WHvOnQnzPmNIX3cG9uJHQI8F1o0yRYuDQI/9OA+nhyX1hTeP/cjhqx/H02O76/d9ouNTHZ8RPdb+9prcBK85K9xj7Tl3J8z7nCF93R3Yiz2AHgusG2WKFoeAHvt5Hk4PS+oLbx7bw+Grn8fTY3vq9/XS0VvHF0SPtb8dLA/Ba84L91h7zj0J875gSF/3BPZiH6DHAutGmaLFYaDHfpmH08OS+sKbx/Zx+OqX8fTYvvp9X+nop+Nrosfa374YQPCai8I91p5zX8K8LxnS132Bvdgf6LHAulGmaPEb0GMH5OH0sKS+8Oax/R2+OiCeHjtQv+8bHYN0DCZ6rP3ttnkJXnNZuMfacx5ImPcVQ/p6ILAXhwA9Flg3yhQtjgA9dmgeTg9L6gtvHjvE4atD4+mxw/T7husYoWMk0WPtbw/3ELzmqnCPtec8jDDva4b09TBgL44CeiywbpQpWhwFeuy3eTg9LKkvvHnsKIevfhtPjx2t3zdGx1gd3xE99ljuh9+D58ybUKbXhXusPefRhHnfMKSvRwN7cRzQY4F1o0zR4hjQY7/Pw+lhSX3hzWPHOXz1+3h67Hj9vgk6Jur4geixx3M//F5RZ96EMr0p3GPtOY8nzPuWIX09HtiLk4AeC6wbZYoWx4Ee+2MeTg9L6gtvHjvJ4as/xtNjJ+v3TdExVcdPRI89kfvh9zQ78yaU6W3hHmvPeTJh3ncM6evJwF6cBvRYYN0oU7Q4AfTY6Xk4PSypL7x57DSHr06Pp8fO0O+bqWOWjtlEjz2Z++H33jvzJpTpXeEea895BmHe9wzp6xnAXpwD9Fhg3ShTtDgJ9Ni5eTg9LKkvvHnsHIevzo2nx87T75uvY4GOhUSPPaX1fZbgNfeFe6w953mEefsVNaOv5wF7cRHQY4F1o0zR4hTQYxfn4fSwpL7w5rGLHL66OJ4eu0S/b6mOZTqWEz32d63vcwSvSVRUtsfac15CmHdiQ/p6CbAXfwZ6LLBulCla/A702F/ycHpYUl9489ifHb76Szw9doV+30odq3SsJnrsaa3v8wSvSSLcY+05ryDMO6khfb0C2Iu/Aj0WWDfKFC1OAz12TR5OD0vqC28e+6vDV9fE02PX6vet07Fexwaix57R+uYjeE0y4R5rz3ktYd7JDenrtcBe3Aj0WGDdKFO0OAP02E15OD0sqS+8eexGh69uiqfHbtbv26Jjq45tRI89q/XNT/CaFMI91p7zZsK8UxrS15uBvbgd6LHAulGmaHEW6LE78nB6WFJfePPY7Q5f3RFPj92p37dLx24de4gee07rW4DgNamEe6w9552Eeac2pK93AntxL9BjgXWjTNHiHNBj9+Xh9LCkvvDmsXsdvrovnh67X7/vgI6DOg4RPfa81rcgwWvSCPdYe877CfN+wpC+3g/sxcNAjwXWjTJFi/NAj/0tD6eHJfWFN4897PDV3+LpsUf0+47qOKbjONFjL2h9CxG8Jq1wj7XnfIQw73SG9PURYC+eAHossG6UKVpcAHrsyTycHpbUF9489oTDV0/G02NP6ff9ruO0jjNEj72o9X2B4DXphXusPedThHlnMKSvTwF78SzQY4F1o0zR4iLQY8/l4fSwpL7w5rFnHb56Lp4ee16/74KOizouET32ktb3RYLXZBTusfaczxPmncmU61NgL14GeiywbpQpWlwCeuyVPJweltQX3jz2ssNXr8TTY6/q913TcV3HDaLHXtb6FiZ4TWbhHmvP+Sph3lkM6eurwF68CfRYYN0oU7S4DPTYW3k4PSypL7x57E2Hr96Kp8fe1u+7o+Ou/X6ix17R+loEr8kq3GPtOd8mzDubIX19G9iL94EeC6wbZYoWV4Ae6xfA6WFJfeHNY+87fNVmEB+PTaTfl1hHEh1JA3gee1Xrqwhek124x/4x5wB83hyG9HUiYC8mC8CNC1g3yhQtrgI9NnkAp4cl9YU3j03m8NXk8fTYFPp9KXWk0pGa6LHXtL6BBI/NKdxj7TmnIHhsLkP6OgWwF9MAPRZYN8oULa4BPfaJAE4PS+oLbx6bxuGrT8TTY9Pq96XTkV5HBqLHXtf6BhE81l+4x9pzTkvw2NyG9HVaYC9mBHossG6UKVpcB3pspgBOD0vqC28em9Hhq5ni6bGZ9fuy6MiqIxvRY29ofYMJHptHuMfac85M8NgAQ/o6M/KaEuixwLpRpmhxA+ixOQI4PSypL7x5bHaHr+aIp8fm1O/LpcNfR26ix97U+oYQPDavcI+155yT4LEeQ/o6J7IXgR4LrBtlihY3gR4bEMDpYUl94c1j8zh8NSCeHptXv8+j40kdTxE99pbWN5TgsU8K91h7znkJHvuUIX2dF9iLTwM9Flg3yhQtbgE99pkATg9L6gtvHvu0w1efiafHPqvf95yO53Xkc3hs3CsxWOcMfjiezwZwajsJeM5rgLW9EZgrP5CfXTdZ/B6uJc4Xer1Gjts53gIBxAEXCMDnLQg0Ota8CwY8BAzK+0ex2ZHYj19szua1EvhijnNjbk5TFHLULf7TXIC7JntsSWLHGDdou0iS+fnGlZACOAv7hdgGetGeE0OAQgRnKgRemlnzTkycd4L/tIbM0ErYS9mFWZhw+WiBl/c4U7DzdovNi2bxIomFIrFQ/4ZFgj/agMTimf/u7ZTIvxgfrQaeLSrbB+yFrzDBS4F6KyRDe1OR3M/77tPvbzL4q5py5mT4N4qJc4MV+O92jFbCXqowyRCdg/6bY1Z/9b9jjzmQYAzPgY0h7vV37+39nY1Mgp9vC5BpMEgtnHUZ5Fio/1N9/oo5Up9gRy4VFKR7IypMxUTFBIWERQTWU6FBoaExwTFhoeHBUTEhwXWjwqJVcN2gwIjoMCtGhUdHh4UERYaFxkRERYbGOE1bRQUFBUdF1ItUIYGhdetZ4VFBda2Y4LCgQKtuVFBYVFRQeGho3aCgqNDwmPCI8MDAujFB4VZIWFiEFRoYFBHI0ic4Vh9fXmmuIV1phsReaYaaYuCs8YUQzDqMtHCFEa9qbBahBBbhJBbhxKsaVl3kE35Vw6qB/MKvataQrmqAeiskw3/KVU0I6aomwsSrmgjyVU0EwRgK/A9e1bwUINNgkFo46/Ilw65qXgZe1eQHXtWw9HnZcVXzZ4uC5NtRzHGyFphXTFxgXiEvMK8QFpiCpAUmGXicSAN7FZgLedsMuVgVJJnhq/FYrBLK9LUA3KLwyG0zQYsVS5/X/kG34F6PvQX3hreHPayEvdSfPfSAfIonwd89AtwJM4SPY5jEEIYJzVVEuB52wxQhbBKKkjZMRYm3a98gsShGYlGMeLuWVRcvCr9dy6qBwgbcri1CuF0L1FshGf5Tbte+TrqaLs68mi5CMsTixKtpe8zFCcZgka6m0bdriwA3RW8GyDQYpBbOunzTB7drkfqUAN6uLQy8AmbpU+K/cAXM+nOHkrFXwKVMMXDW+EoSzLo0aeEqTbyqsVmUIrB4i8TiLeJVDasuAoVf1bBqIEj4Vc1G0lUNUG+FZPhPuaopSbqqKWPiVU0Z8lVNGYIxBP8PXtW8HSDTYJBaOOvybcOuasoCr2qCgFc1LH3K/hceQnk9gNP3piww5UxcYMqRF5hyhAUmhLTAoB9CQRpYeWAu5G0z5GIVQjLD8j54CKUC8CGUR26bCVqsWPpU8KIP+hkB4EMnajPwc6QqAn3dl58jVZG0iL4TQBzwOwH4vJWAxsyad6WAh4BBeX36OVKbDfkcqTWkz5GqHED8HKlKwEtXp6vHDfqf8GhhldgGqhpA+BwpW4DKBGeqTP5FDWreiYnzTugYqwn/ZZddmNUIl1jvki433yX+sqsqiUV1EovqxF92seoiXPgvu1g1ECH8l132wleN4KVAvRWS4T/ll11VSJdRNZj3IquRDLEG8V6kPeYaBGN4CWwMcS/0L7uqATdFNQNkGgxSC2dd1vTBL7uQ+tQC/rIrAnj/kKVPrf/CI3ybSVeatWOvNN8zxcBZ46tNMOs6pIWrDvGqxmbxHoHF+yQW7xOvalh18YrwqxpWDbwq/KpmM+mqBqi3QjL8p1zV1CZd1dQ18aqmLvmqpi7BGF77H7yqqRcg02CQWjjrsp5hVzWRwKuaV4FXNSx9Iv8Lj/BVCeD0vSkLTJSJC0wUeYGJIiwwr5MWGPQjfEgDiwbmQt42Qy5Wr5PMMNoHj/DFAB/he+S2maDFiqVPzD/oFlz92FtwDbw97GEl7KX+7KEH5FM8Cc0FfHCE8rlFcQzRz4iyGCY0V0PhetgN05CwSWhE2jA1It6ubUBi0ZjEojHxdi2rLooKv13LqoFiBtyubUi4XQvUWyEZ/lNu19YnXU03YV5NNyQZYhPi1bQ95iYEYyhOuppG365tCNwUNQ2QaTBILZx12dQHt2uR+jQD3q4tBrwCZunT7L9wBcz6c4fmsVfALUwxcNb4mhPMuiVp4WpJvKqxWbQgsGhFYtGKeFXDqosSwq9qWDVQUvhVzRrSVQ1Qb4Vk+E+5qmlOuqppbeJVTWvyVU1rgjGU+h+8qmkTINNgkFo467KNYVc1bYFXNSWBVzUsfdr+Fx5CqR/A6XtTFph2Ji4w7cgLTDvCAlOatMCgH0JBGlh7YC7kbTPkYlWaZIbtffAQSgfgQyiP3DYTtFix9OlAvAPil0f/7+TBe1BH8l0whPd09PKshZWwF3IdUh2BntZJuB72Zwp2IqyFH4CfMUkMHp99FwY5xo2x+fywdU25A7UpdqxozT8E1rovP3vuQ9LGu3MAccCdA/B5uwCNjzXvLv/jTdaVdDWLNlhkLXUTvpis1Fojx2hr3M1HdZ7Qua/IzevJuBd6zB8lWKuI8LDQkOCgQPWH4Wfye3jhZv+7XwY/v3uxx/b/VtzxstwPj4snfXAc99/7WL+vu45PdHwa8OC8t9wfO/J1dxx/4jj+NODR3J/pf/fQ8bmOnv8mt3PcKxxj/cyRO+Vj4+6l/7PeOr7Q0Sfg4XmWdl8+ekFbL0bF1IsIqhttRUdERtUND6oXaAVFRUWoSP0f1QuOCKwbUTc6MibIio6MsKKVvmqMjoyOsmKs6NDAKG8MPnQw+NIx717/hkFf/Z99paOfjq9jGfjyuY2+wDUhsWOc/WP7ekBA7KDjroz7x14ZO88NCPjrT122EvZ6ZKIJLaT+8c/1l7/LHgDe+f4Tfl/an7SrHvh4MQ4M+P9dhv5Tjr8xmb+8/TwQWMTfBMCK4ZFbX9/Eo5kTOvYBQA5IpoP+BtO/+t9yMh3kMM2UDp5OplbCXurev88XGBmjgkL0jVgrtG5wSFRoUGBUYJgVFRwSo/SAAyOCNZqYyODwqPDAoJjAsMDIe9jx/VFjccYWt5DEraoDYo8H659DdAyNXUl9dRtgsEP3wJi6wVaE9v2QSH1HOzpaRQYGhteNjI4OjtT6WvWi7LvaUdFBEeHhgdF24UTGhIcqFWzVVXXDIiJCnOMdFkAc8DAvTxIldPDDgJcyw4XfUrAZDvdymZ5QhsMNvRc2xLm9Dg4OCVZRGkNoRFRgdJClIqNirPC64SomVLtGTJD+v0CNRrOoF2GpuiFhdUPDYlTdmKjgwODoeo+s2iMCiAMe4aUJEjr4EcAmGCm8CWyGI700QUIZjiTdq0JfVgwWanijwFvoVLG1M8qx6g5xHF9O4q22tOEF17P0sCPty2vtiVH16kaHRURGKr2XUCEhESGhdUOD9Rz1vCL0/4+OiAgOi4kOiQ7Rv7b9fzsIFalirMi6gcHBkWGRUcGhmkZgSEhgvZiYcJ1VW6r23XoR+ve9YSoq2goLjdYX8mGhYeExgfWi6qmQv9rh/EdcvtUMRusYE9sDcZwG/wmnobHvi897xuqf3+kYF2uA6N4d/ie9m9Da+x7cu+jxseY9HnyvOe6Fvuc8FOgzE8j3162EvZTdn0hd7J78nlA7E8k9YyXspWydJwbgazG/H269GAreOKf1e/SK81k/7y/M/2ZwECdvaAwpbzQnbxiJQ1gIiUMUKW8EKS9Jt9AwTt5AyzDdSHVG6wuW7yhSXlKdsXRj1W8YiwPJd8KCSeMN5+Sl+U4kKS9rfWP1cSgnL00309ZjVr+x1jfD+jisHidvEGu8UXH3nZwv9HViY1yuhxzsi7F0fo/+2pM1gUSMCcDF5D5/cTsJ5/mLH+Kev3j8yakfHruT7O040WNPTk3S/50fdUzWMeXfPJmWPKkjh9/D48gMf/5U1lSd7ycd03RMdzyVZRdgYr///5IsAHOcU4F3XJI7xjkj9o73zNifs2J/zo79OSf2Dly+2PfP1f+ep2O+jgU6FupYpGOxjiU6lupYpmO5jp91/KJjhY6VOlbpWK3jVx1rdKzVsU7Heh0bdGzUsUnHZh1bdGzVsU3Hdh07dOzUsUvHbh17dOzVsU/Hfh0HdByMK/q4hznswXv8fPuAwswATkcfCiAO+FAAPu9h4b9Pted9OOAhYFBenz4IMItUbL8FEAf8G6HYjggvNnveRwwvttmkYjsaQBzwUUKxHRNebPa8jxGKjTHWw7GNgf4t3/EAM5tsDqnJTgQQB3yC0GQnhTeZPe+ThjSZbQbHCU12Clysj19QznRcrM5yHM8J+PM/0fpd/2endZzRcTbg//+pE/qxNOCqqH4H1vw5sjbnHBqcdhyfcRyfDXhUm/P63xd0XNRxKeDRfMi6tPvyFKHeLwO1tueezc83d9pmBGD96fEXJndgOC+3FZjIwTbuZsYVzeWqjms6ruu4oeOmjls6buu4o+OuXcM67tten1f/93Uk1pFER1IdyXQk15FCR0odqXSk1pFGxxM60upIpyO9jgw6MurIpCOzjiw6surIpiO7jhw6curIpcM/r9+jNzOuBDy8sxZ37qqXc9e8nLvu5dwNL+duejl3y8u5217O3fFy7q6Xc/e8nLvv5dwfsB87l8jLucReziXxci6pl3PJvJxL7uVcCi/nUno5l8rLudRezqXxcu4JL+fSejmXzsu59F7OZfByLqOXc5m8nMvs5VwWL+eyejmXzcu57F7O5fByLqeXc7m8nPPP+9Ak4175Y3++EfvTStjrEdNM6MJxBZArOubB6youV9Q1XK6I67hc6gYsV7S6CcsVqW7BcoWr27BclrqDyhVtqbuoXJGWuofKFW6p+6hc9q/08mJyRdu/xgTlitS5EoNyhetcSUC5bC9MiskVbedKhskVaedKjskVbudKgcn1x9qREpIr+o9cqSC5Iv/IlRqSK/yPXGkguR6stU8gckU/yJUWkSvyQa50iFzhD3KlR+SK3ZtkAOSKis2VEZCrXmyuTIBcYbG5Mic8V2DcR2hkSXguFZcra4JzhcfE5cqW8Fz14nJlT3iuf33kSI4E5wr7V66cCc4V8q9cuRKcS/0rl39ezk2RuKdWEtoHyGuHuFy5cXOmfKmsfYPwMuHGXR6w1onB87afqrkCvLlo65wnL55jgAEckTVua8LgmBfI8Y97OH6P3ky3dboXe5w3r/en/K4kefTmvEe/70kdT+l4Ou+f35y3EvZS8wIe3rdEMm1QlPtLuISOz56zh1BLDYty1rG/+40sf/FSnry4OT8D7HFg3ShTtJgH3FM8m5fTw5L6wpvHPuPw1Wfj6bHP6fc9ryOfjvxEj50f8PD3QM68CWXaSLjH2nN+juCxjQ3p6+eAvVgA6LHAulGmaDEf6LEF83J6WFJfePPYAg5fLRhPjy2k3/eCjhd1FCZ67IKAh79Xd+ZNKNMmwj3WnnMhgsc2NaSvCwF70QJ6LLBulClaLAB6rMrL6WFJfeHNYy2Hr6p4emygfl+QjmAdIUSPXRjw8DklZ96EMm0m3GPtOQcSPLa5IX0dCOzFUKDHAutGmaLFQqDHhuXl9LCkvvDmsaEOXw2Lp8eG6/dF6HhJx8tEj10U8PC5T2fehDJtIdxj7TmHEzy2pSF9HQ7sxVeAHgusG2WKFouAHvtqXk4PS+oLbx77isNXX42nx76m3/e6zUtHEaLHLg54+By9M29CmbYS7rH2nF8jeGxrQ/r6NWAvFgV6LLBulClaLAZ6bLG8nB6W1BfePLaow1eLxdNji+v3vamjhI6SRI9dEvDw75KceRPKtI1wj7XnXJzgsW0N6eviwF4sBfRYYN0oU7RYAvTY0nk5PSypL7x5bCmHr5aOp8e+pd9XRsfbOsoSPXZpwMO/83TmTSjTdsI91p7zWwSPbW9IX78F7MVyQI8F1o0yRYulQI8tn5fTw5L6wpvHlnP4avl4emwF/b6KOt7RUYnoscsCHv7dvDNvQpl2EO6x9pwrEDy2oyF9XQHYi5WBHgusG2WKFsuAHlslL6eHJfWFN4+t7PDVKvH02Kr6fdV0vKujOtFjlwc8/BwSZ96EMu0k3GPtOVcleOwHhvR1VWAv1gB6LLBulClaLAd6bM28nB6W1BfePLaGw1drxtNja+n31dbxno46RI/9OeDh5zo58yaU6YfCPdaecy2Cx3Y2pK9rAXvxfaDHAutGmaLFz0CPrZuX08OS+sKbx77v8NW68fTYevp9kTqidEQTPfaXuA8lfCxvQpl2Ee6x9pzrEebd1ZC+rgfsxRigxwLrRpmixS9Aj62fl9PDkvrCm8fGOHy1fjw9toF+X0MdjXQ0Jnqs/e01iQhe0024x9pzbkCY90eG9HUD5N8DAT0WWDfKFC1WAD22aV5OD0vqC28e28Thq03j6bHN9Pua62ihoyXRY+1vB0tM8JqPhXusPedmhHl3N6SvmyGfowR6LLBulClarAR6bOu8nB6W1BfePLaVw1dbx9Nj2+j3tdXRTkd7osfa376YhOA1nwj3WHvObQjz/tSQvm6D/P0z0GOBdaNM0WIV0GM75uX0sKS+8OaxHRy+2jGeHttJv+8DHR/q6Ez0WPvbbZMSvOYz4R5rz7kTYd49DOnrTsj7dkCPBdaNMkWL1UCP7ZqX08OS+sKbx3Zx+GrXeHpsN/2+j3R8rKM70WPtbw9PRvCaz4V7rD3nboR59zSkr7sh9ztAjwXWjTJFi1+BHvtpXk4PS+oLbx77icNXP42nx36m39dDx+c6ehI9dk3Aw+/Bc+ZNKNNewj3WnvNnhHn3NqSvPwP2Yi+gxwLrRpmixRqgx/bOy+lhSX3hzWN7OXy1dzw99gv9vj46vtTRl+ixawMefq+oM29CmX4h3GPtOX9BmHcfQ/r6C2AvfgX0WGDdKFO0WAv02H55OT0sqS+8eexXDl/tF0+P/Vq/r7+OAToGEj12XcDD72l25k0o0y+Fe6w9568J8+5rSF9/DezFb4AeC6wbZYoW64AeOygvp4cl9YU3j/3G4auD4umxg/X7hugYqmMY0WPXBzz83ntn3gTvbYR7rD3nwYR59zOkrwcDe3E40GOBdaNM0WI90GNH5OX0sKS+8Oaxwx2+OiKeHjtSv2+Ujm91jCZ67Aatb2qC13wt3GPtOY8kzLu/IX09EtiLY4AeC6wbZYoWG4AeOzYvp4cl9YU3jx3j8NWx8fTY7/T7xun4Xsd4osdu1PqmIXjNAOEea8/5O8K8BxrS198Be3EC0GOBdaNM0WIj0GMn5uX0sKS+8OaxExy+OjGeHvuDft8kHT/qmEz02E1a3ycIXvONcI+15/wDYd6DDOnrH4C9OAXoscC6UaZosQnosVPzcnpYUl9489gpDl+dGk+P/Um/b5qO6TpmED12s9Y3LcFrBgv3WHvOPxHmPcSQvv4J2IszgR4LrBtlihabgR47Ky+nhyX1hTePnenw1Vnx9NjZ+n1zdMzVMY/osVu0vukIXjNUuMfac55NmPcwQ/p6NrAX5wM9Flg3yhQttgA9dkFeTg9L6gtvHjvf4asL4umxC/X7FulYrGMJ0WO3an3TE7xmuHCPtee8kDDvEYb09UJgLy4FeiywbpQpWmwFeuyyvJweltQX3jx2qcNXl8XTY5fr9/2s4xcdK4geu03rm4HgNSOFe6w95+WEeY8ypK+XA3txJdBjgXWjTNFiG9BjV+Xl9LCkvvDmsSsdvroqnh67Wr/vVx1rdKwleux2rW9Ggtd8K9xj7TmvJsx7tCF9vRrYi+uAHgusG2WKFtuBHrs+L6eHJfWFN49d5/DV9fH02A36fRt1bNKxmeixO7S+mQheM0a4x9pz3kCY91hD+noDsBe3AD0WWDfKFC12AD12a15OD0vqC28eu8Xhq1vj6bHb9Pu269ihYyfRY3dqfTMTvOY74R5rz3kbYd7jTLk+BfbiLqDHAutGmaLFTqDH7s7L6WFJfeHNY3c5fHV3PD12j37fXh37dOwneuwurW8Wgtd8L9xj7TnvIcx7vCF9vQfYiweAHgusG2WKFruAHnswL6eHJfWFN4894PDVg/H02EP6fYd1/KbjCNFjd2t9sxK8ZoJwj7XnfIgw74mG9PUhYC8eBXossG6UKVrsBnrssbycHpbUF9489qjDV4/F02OP6/ed0HFSxymix+7R+mYjeM0Pwj3WnvNxwrwnGdLXx4G9+DvQY4F1o0zRYg/QY0/n5fSwpL7w5rG/O3z1dDw99ox+31kd53ScJ3rsXq1vdoLX/CjcY+05nyHMe7IhfX0G2IsXgB4LrBtlihZ7gR57MS+nhyX1hTePveDw1Yvx9NhL+n2XdVzRcZXosfu0vjkIXjNFuMfac75EmPdUQ/r6ErAXrwE9Flg3yhQt9gE99npeTg9L6gtvHnvN4avX4+mxN/T7buq4peM20WP3a31zErzmJ+Eea8/5BmHe0wzp6xvAXrwD9Fhg3ShTtNgP9Ni7eTk9LKkvvHnsHYev3o2nx97T77uvw8+j/3MPz2MPaH1zEbxmunCPted8jzDvGYb09T1gLyb24MYFrBtlihYHgB6bxMPpYUl94c1j7RqM89Iknvh5bFL9vmQ6kutI4eF57EGtrz/Ba2YK91h7zjZjdN5ZhvS1PXfUnFN6cOMC1o0yRYuDQI9N5eH0sKS+8Oaxdg3GeWkqT/w8NrV+XxodT+hI63l4Pu6VGKxzBj8cz9QeTm0nAc95KrC2ZwJzpQPys+smi9/DtcT5Qq/XyHE7x5veQxywnRydN4MHVwyseWfwPAQMyvtHsdmR2I9fbM7mtRL4Yo5zZgCnKTJ6HE0N/zQXDw7AH1cWsWOMG7RdJMn8fONKSAGchZ3J8+BnZntODAGcCqNgZPRgu4Y178TEeSf4T2vIDK2EvZRdmFk8hMfdPVgnizMFO2+32LxoFplJLLKRWGT7NywS/NEGJBZz/ru3UyL/Yny0GphbVLYP2AufPW+0lwL1VkiG9qYiuZ/33aff32TwVzXlzMnwbxQT5wYru+ff7BithL0UclF0GqJz0H9zzOqv/nfsMTvzx+VNqDHMAxtD3Ovv3tv7OxuZBD/f5pFpMEgtnHVpz7eb36Ovv6vPXzFH6pPTkUsFBeneiApTMVExQSFhEYH1VGhQaGhMcExYaHhwVExIcN2osGgVXDcoMCI6zIpR4dHRYSFBkWGhMRFRkaExTtNWUUFBwVER9SJVSGBo3XpWeFRQXSsmOCwo0KobFRQWFRUUHhpaNygoKjQ8JjwiPDCwbkxQuBUSFhZhhQYGRQSy9MkZq48vrzSnkq40c3ke/PT3GGLgrPHl8uDNOreHU4C5PbyrGpuFP4FFHhKLPB7eVQ2rLhYIv6ph1cBC4Vc1U0lXNUC9FZLhP+Wqxu5RFBPnYh7gMfCqxjloxlWNM39c3oQaw6L/wauavB6ZBoPUwlmX9ny7+T36knxV4/HgrmoWAq9qWPp4PA+vav5sUZB8O4o5TtYC86THwAXGOWjGAuPMH5c3oc28mLTAJAOPE2lgTwFzIW+bIRerxSQztNl183v0lRSs9dMe3KLwyG0zQYsVS5+nPf+cW3DPeB78fNbj5WEPK2Ev9WcPPSCf4knwd494cPNlCB/HMIkhDBOa6znhetgNY48RvUl43sMxKztvt9i8aBbPkljkI7HI5+HdrmXVxTLht2tZNbDcgNu19rzRt2uBeiskw3/K7Vq7T1FMnBu//B7i1TRwUXzEEJ2DRl9N22N25o/Lm1Bj+Jl0NY2+XevULKFzLuCRaTBILZx1ac+3m9+jL/TtWqQ+BT24K+DlwCtglj4FPb6/Amb9uUMhz4OfL3gMMXDW+Ap58Gb9oodTgC96eFc1NosXCCwKk1gU9vCualh1sUL4VQ2rBlYKv6qZSbqqAeqtkAz/KVc1do+imDgXc8tj4FWNc9CMqxpn/ri8CTWGVf+DVzXKI9NgkFo469Kebze/R1+Sr2oCPbirmpXAqxqWPoEe3z+EgrwdxRwna4EJ8hi4wDgHzVhgnPnj8ia0mVeTFhj0QyhIAwsG5kLeNkMuVqtJZmiz6+b36Av9EEqIB7coPHLbTNBixdInxIs+6GcEgA+dqNnAz5EK9WCvAH31OVLIcTvHG+YhDthOjs4b7sEVA2ve4Z6HgEF5ffo5UrMN+RypqaTPkYrw+PE+R8pZwFbCXo98jlTcoP8Jjxa+5Hnw82UP4XOkbAGcCqNgRHiwXcOad2LivBM6xlfIDK2EvZRdmK948Nq86vGjbPXsvN1i86JZvExi8RqJxWse3i+7WHWxVvgvu1g1sE74L7vshc+eN9pLgXorJMN/yi+77D5FMXFusF73EO9FIhdFpyE6B42+F2mP2Zk/Lm9CjWE92BjiXuhfdjk1S+ic3/DINBikFs66tOfbze/RF/qXXUh9inhw9w/XAe8fsvQp4vH9I3yzSVeaRT0PfhbzGGLgrPEV9eDNuriHU4DFPbyrGptFMQKLN0ks7Lzd/B680GNm1cVG4Vc1rBrYJPyqZjbpqgaot0Iy/Kdc1dg9imLiXMxLeAy8qnEOmnFV48wflzehxrD5f/CqpqRHpsEgtXDWpT3fbn6PviRf1ZTy4K5qNgGvalj6lPL4/hE+5O0o5jhZC0xpj4ELjHPQjAXGmT8ub0KbeQtpgUE/woc0sLeAuZC3zZCL1RaSGdrsuvk9+kI/wlfGg1sUHrltJmixYulTxvPPuQX3tufBz7IewudI/dlDD8ineBKaC/jgCOVzi+IYop8RZTFMaK5ywvWwG8YeI3qTUN7DMSs7b7fYvGgWZUksKpBYVPDwbtey6mK78Nu1rBrYYcDtWnve6Nu1QL0VkuE/5Xat3acoJs6NX0UP8WoauCg+YojOQaOvpu0xO/PH5U2oMewkXU2jb9c6NUvonN/xyDQYpBbOurTn283v0Rf6di1Sn0oe3BXwDuAVMEufSp5/zicpV/Y8+FnFY4iBs8ZX2YM366oeTgFW9fCuamwWVQgsqpFYVPPwrmpYdbFb+FUNqwb2CL+qmUq6qgHqrZAM/ylXNXaPopg4F/N3PQZe1TgHzbiqceaPy5tQY9j7P3hVU90j02CQWjjr0p5vN79HX5Kvamp4cFc1e4BXNSx9anh8/xAK8nYUc5ysBaamx8AFxjloxgLjzB+XN6HNvI+0wKAfQkEaWC1gLuRtM+RitY9khja7bn6PvtAPodT24BaFR26bCVqsWPrU9vDugBzTV4EnA/Ae9J7nv3rVHy/vsceYBMwT+UyDk2FC51tHuB72ZwraY0TnfR+oh50jMXh89l0Y5Bhnxubzw9Y15Q7UrNixojWvi+Pp08+eQ47bOd56HuKA63nweSM9uGJgzTvS8xAwKK9RTRbl4VxkoA0WWUvRHtmLySStNXKMtsZ2PhPq/IcATk/aC0B6h1b2uNP5eX9h/jeDIzl5gxQnb6DFyRtCyhsaw8kbFkjKG0ziQKqHUFb91uXkZdVvWD0SB9Z4o2xve3yjy/BpUK6HHGyTtk05id//f6EnkMiPMAG4mNzfQd9OwrlSifHEDjaT38NbkIli/4N7sceXk3g/TpT0wXHcf6++/u800NFQRyPPg/NJY4sksR+/UJCQmONEPm2X3DHOxp4HP5vE/mwa+7NZ7M/mngdzyRf7/hb63y11tNLRWkcbHW11tNPRXkcHHR11dNLxgY4PdXTW0UVHVx3ddHyk42Md3XV8ouNTHZ/p6KHjcx09dfTS0VvHFzr66PhSR18dX+nop+NrHf11DNAxUMc3OgZ5YsHH3ZO1B2+f8+X9ARskKNcjXTfYQxzwYA8+7xCP7PsD9ryHeB4CBuX16c2opqRiG+ohDngoodiGeWQXmz3vYR4/o4utGanYhnuIAx5OKLYRHtnFZs97hMcPXmyMsdoOPMyDv/M50mNmkzX3cJpslIc44FEefN5vPbKbzJ73t56HgEF5KWO1zWCkB99koz3YYn38gtLeosVdODZ1HDd3HBd/7IJyjP7Pxur4Tsc4z8PzcS/0swTAVVGN8eC0+d7D1eZ7hwZjHcffOY7HeR7VZrz+9wQdE3X84Hk0H7Iu7b60axOddxJQa3vu2fx8czessQfrT4+/MLkDw3m5rUDn86FxNzN+9Pj5TdYxRcdUHT/pmKZjuo4ZOmbqmKVjto45OubqmKdjvo4FOhbqWKRjsY4lOpbqWKZjuY7/Y+86wKQouu2SzAETKipsDuwCXbOzOzPkLGBCUTGAurOzC0jOOUkO5pxzIooIklTEHDDnnAMgQZJEX5XMSs9Q0+zS5/ar+579ffdn/+rp8txb9566Z6an5yVpL0t7Rdqr0l6T9rq0N6S9Ke0taW9LWyXtHWnvSntP2vvSPpD2YXJS7JsZCmyluLE5mrG5mrF5mrGnNGPzNWNPa8YWaMae0Ywt1Iwt0ow9qxlbrBlbohlbqhlbphlbrhl7TjP2vGbsBc3YCs3Yi5qxlZqxlzRjL2vGXtGMvaoZe00z9rpm7A3N2Juasbc0Y29rxlZpxt7RjL2rGXtPM/a+ZuwDzdiHyftIsuzIif7bLPqv5e6IIU23G8dswFwlpXuPObi5InNxc4Xm4eYST8HmKhHzYXMVi6dhcwXFAthclngGNVeJJRai5iq2xCLUXEFLPIuaS9b2YtBcJXKuJaC5iuVcS0FzBeVcy0BzKS5cjpmrRM31HGauYjXX85i5gmquFzBz/bN3rIDMVfLPXC9C5ir+Z66VkLmC/8z1EmSuvXvty4i5SvbO9QpiruK9c72KmCu4d67XEHNFe5PXAXNFonO9AZgrHJ3rTcBcgehcb7mfy1f2Vf+33c8lyuZa5XquYGnZXO+4nytcNte77uf699EI77meK/DvXO+7nqvg37k+cD2X+HeuD5N53BuN0A5lc32E85nkYa7qDUL1JlslcAw/Bq91ZbDf6q6a2cC1Uev8MUEcP2EQR2SOzyaK46fAOCps8W/Oq3UqexP+02T9nXibq8S+Of+ZfN3n0r6Q9mVy4jfnLXeHUHePzSGI6fYWtB/CucWnfP6MwO8dLWj2sYo+CeUAh/gsGefzV8k4XMC8EVzWoh9wLb5Opqlhk+pCx7EqB8u49Ovk8nHsN/J130r7Ttr3yXQcq+7OLfscyD6v25juNJxjlc/fEPi9i0ldK99RPv+QjMMFzBvBZS36A9fix2SaGjapLnQcq3KwjEt/TC4fx/4kX/eztF+k/ZpMx7Hq2w9ln6vb53Ub092Gc6zy+ScCv/cwqWvlO8rn35JxuIB5I7isxQDgWvyeTFPDJtWFjmNVDpZx6e/J5ePY1fJ1a6StlfZHMh3Hqm+Xld2nZJ/XbUz/Npxjlc+rCfxOasmjrpXvKJ/XJeNwAfNGcFmLgcC1WJ9MU8Mm1YWOY1UOlnHp+uTycewG+bqN0v6UtimZjmPVt3fL7vu0z+s2ppVams2xyucNBH5XZlLXyneUz5uTcbiAeSO4rMUg4FpsSaapYZPqQsexKgfLuHRLcvk4dqt83TZpf0nbnkzHserpCGX30dvndRvTKoZzrPJ5K4HfVZnUtfId5fOOZBwuYN4ILmsxGLgWO5NpatikutBxrMrBMi7dmVw+jt0lX7dbvVba38l0HKuePlP2vST7vG5jWs1wjlU+7yLw+xAmda18R/mclILDBcwbwWUthgDXolIKTQ2bVBc6jlU5+O/T0lLKx7GV5euqSKsqrVoKHceqp3uVfc/TPq/bmB5qOMcqn1WM0fMexqSuKwNr8RAgxwLzRnBZC1WDsLpLoalhk+pCx7GH2Hj10HJy7GHydYdLO0LakYQcq56eWPa9efu8bmN6uOEcq3w+jIBjj2BS14cBa/EoIMcC80ZwWQtVg6i1ODqFpoZNqgsdxx5l49Wjy8mxx8jXHSuturTjCDlWPZ227Dkk9nndxvRIwzlW+XwMAccexaSujwHW4vFAjgXmjeCyFqoGUWtxQgpNDZtUFzqOPd7GqyeUk2NPlK87SVoNaScTcqx6+nfZc53s87reTw3nWOXziQQcewyTuj4RWIunADkWmDeCy1qoGkStxakpNDVsUl3oOPYUG6+eWk6OrSlfd5q006WdQcix6tcVyp6TZ5/XbUyPNZxjlc81CTi2OpO6rgmsxVpAjgXmjeCyFqoGUWtRO4Wmhk2qCx3H1rLxau1ycmyyfF2KtFRpaYQcq369puy5o/Z53cb0OMM5VvmcTMCxxzOp62RgLaYDORaYN4LLWqgaRK1FRgpNDZtUFzqOTbfxakY5OTZTvi5LWra0HEKOVb8OVvYcZ/u8rt8XMpxjlc+ZBBx7IpO6zgTWYh0gxwLzRnBZC1WDqLXITaGpYZPqQsexdWy8mltOjs2Tr6srrZ60+oQcq359sey5+PZ53cb0JMM5VvmcR8CxNZjUdR6wFi0gxwLzRnBZC1WDqLUQKTQ1bFJd6DjWsvGqKCfH+uTr8qX5pRUQcuzY5H2/M2Kf121MTzacY5XPPgKOPYVJXfuAtVgI5Fhg3ggua6FqELUWgRSaGjapLnQcW2jj1UA5OTYoXxeS1kBaQ0KOHZe873eb7PO6/nzTcI5VPgcJOLYmk7oOAmuxEZBjgXkjuKyFqkHUWjROoalhk+pCx7GNbLzauJwc20S+rqmKl7TmhBx7TfK+38Gzz+s2pqcZzrHK5yYEHHs6k7puAqzFFkCOBeaN4LIWqgZRa9EyhaaGTaoLHce2sPFqy3JybCv5utbS2kg7k5Bjxyfv+11R+7xuY3qG4RyrfG5FwLG1mNR1K2AttgVyLDBvBJe1UDWIWot2KTQ1bFJd6Di2rY1X25WTY9vL150l7Wxp5xBy7ITkfb/TbJ/X9X16hnOs8rk9AccmM6nr9sBaPBfIscC8EVzWQtUgai3OS6GpYZPqQsex59p49bxycmwH+brzpV0grSMhx05M3ve79/Z53cY0xXCOVT53IODYVCZ13QFYixcCORaYN4LLWqgaRK3FRSk0NWxSXeg49kIbr15UTo69WL6uk7RLpF1KyLGTkpOSVibjuSbNcI5VPl9MwLHpTOr6YmAtXgbkWGDeCC5roWoQtRaXp9DUsEl1oePYy2y8enk5ObazfF0XaVdIu5KQYycnJyW9lIznmgzDOVb53JmAYzOZ1HVnYC1eBeRYYN4ILmuhahC1FkUpNDVsUl3oOPYqG68WlZNjw/J1xdIi0koIOXZKclLSy8l4rskynGOVz2ECjs1mUtdhYC2WAjkWmDeCy1qoGkStRdcUmho2qS50HFtq49Wu5eTYbvJ13aVdLa0HIcdOTU5KeiUZzzU5hnOs8rkbAcfWYVLX3YC12BPIscC8EVzWQtUgai16pdDUsEl1oePYnjZe7VVOju0tX9dHWl9p/Qg5dlpyUtKryXiuyTWcY5XPvQk4No9JXfcG1mJ/IMcC80ZwWQtVg6i1GJBCU8Mm1YWOY/vbeHVAOTl2oHzdIGmDpQ0h5NjpyUlJryXjuaau4RyrfB5IwLH1mNT1QGAtDgVyLDBvBJe1UDWIWothKTQ1bFJd6Dh2qI1Xh5WTY4fL142QNlLaKEKOnZGclPR6Mp5r6hvOscrn4QQcazGp6+HAWhwN5Fhg3ggua6FqELUWY1JoatikutBx7Ggbr44pJ8eOla8bJ+0aaeMJOfba5KSkN5LxXCMM51jl81gCjvVxeQ4JsBYnADkWmDeCy1qoGkStxcQUmho2qS50HDvBxqsTy8mxk+TrJkubIm0qIcdel5yU9GYynmvyDedY5fMkAo71c7knE1iL04AcC8wbwWUtVA2i1mJ6Ck0Nm1QXOo6dZuPV6eXk2BnydddKu07a9YQce31yUtJbyXiuKTCcY5XPMwg4tpCLPgXW4g1AjgXmjeCyFqoGUWtxYwpNDZtUFzqOvcHGqzeWk2Nvkq+7Wdot0m4l5NgbkpOS3k7Gc03AcI5VPt9EwLFBJnV9E7AWbwNyLDBvBJe1UDWIWovbU2hq2KS60HHsbTZevb2cHHuHfN2d0u6Sdjchx96YnJS0KhnPNSHDOVb5fAcBxzZgUtd3AGvxHiDHAvNGcFkLVYOotbg3haaGTaoLHcfeY+PVe8vJsffJ190v7QFpDxJy7E3JSUnvJOO5pqHhHKt8vo+AYxsxqev7gLX4EJBjgXkjuKyFqkHUWjycQlPDJtWFjmMfsvHqw+Xk2Efk6x6V9pi0xwk59ubkpKR3k/Fc09hwjlU+P0LAsU2Y1PUjwFp8AsixwLwRXNZC1SBqLZ5Moalhk+pCx7FP2Hj1yXJy7Ez5ulnSZkubQ8ixtyQnJb2XjOeapoZzrPJ5JgHHNmNS1zOBtTgXyLHAvBFc1kLVIGot5qXQ1LBJdaHj2Lk2Xp1XTo59Sr5uvrSnpS0g5Nhbk5OS3k/Gc01zwzlW+fwUAce2YFLXTwFr8RkgxwLzRnBZC1WDqLVYmEJTwybVhY5jn7Hx6sJycuwi+bpnpS2WtoSQY29LTkr6IBnPNS0N51jl8yICjm3FpK4XAWtxKZBjgXkjuKyFqkHUWixLoalhk+pCx7FLbby6rJwcu1y+7jlpz0t7gZBjb09OSvowGc81rQ3nWOXzcgKObcOkrpcDa3EFkGOBeSO4rIWqQdRavJhCU8Mm1YWOY1fYePXFcnLsSvm6l6S9LO0VG8eWHZXB61w9CRfPlSk0uV0F7PO8Wjifeybj5noVGD+VNycm7dtL7Ad6v0bituN9LYUQ8Gsp+HlfBxIdld+vp+wLMGjef5JNWeUk+mSzF6/l8qDEaScGy+VhL4o3bHmLf5oLsGtS2KpEMZaBVklSLckbVkIugD2x34wW0FvKJ4oFeIOAmd4Ab81Uflcm9Nv1V2uIY2i5O4RKzLcJ5OMq8PZeRgpq3rHRedGxeIsoFu8QxeIdh1i4frQBUSza/u++nVJ8AHxkOdCupdk8oDa+twm4FLjeAhlD1VQckqTvPpMqGIMD5ZR9Tgr+RsXE3mC969QxWu4O8TYRIdpBVxCzONB/R2F+l4AY2hvy3l5FGhnX97elmEkw7VvS5OV7to36YNfnQDFHrs/7trlEfr6sjUhAlEZK8wsCIV9YFOYXFpb6SwOFQX+ktMBfFAmUCH9Rvi9UErBKRbCkJFCQXxwoLA1FigtL7aQtIvn5/kgoXCwKfIVFYSsYyS+ySv2BfJ9VFMkPRCL5wcLCovz8SGGwNBgK+nxFpflBqyAQCFmFvvyQj2p93o+uj5dKE/mWhH0T+yCqND/kQuBU+D4gIOuPiDaujwhVjYrFhwSx+JgoFh8TqhqqvDjbcFVDlQPnGK5qFMlSqBrgeotz/lM18Yf4gEjVfMJR1XxCrGo+ISCGc/8fqppPU8wkmHOJuuZPmamaz4Cq5hygqqFan89sqibRpmDy21GUOKk2mM85bjCfE28wnxNsMOcRbTDVwDiRBPYFcC7k22bIzeo8IjL8ohyblduYfpmC2xRi3jYzaLOiWp8v/w+9BfdVyt5/v07R3OxhuTtEopsekHfxuP7tEWAnTLHwZTGswiSGbuf6xvD1UAXzDUGT8C1Rw/Qt4du1XxPF4juiWHxH+HYtVV5cYPjbtVQ50JHB27XfELxdC1xv0fG/t2vjj3/4GxUTe+P3PaWa/oaIEL8nVNMK8/cExHAhk7drvwE2RT+kmEkwFxIprB88eLsWuT4/At+u7QhUwFTr8+P/ggKm+rrDT1EF/DMXAqfC9xMBWf9CtHH9QqhqVCx+JojFr0Sx+JVQ1VDlxcWGqxqqHOjE4NZ6ClUDXG/R6T9VE3+In4hUzW8cVc1vxKrmNwJiuOT/oar5PcVMgrmEqGv+nZmqWQ1UNZ2AqoZqfVaneH8TCvLtKEqcVBvMGo4bzBriDWYNwQZzKZObUJAEthY4F/JtM+RmdSkRGa5Nob8J5Y8U3KbQsaWZmxXV+vyhWR/0PQLAm05E72QcrnVAXvfyOVLriDbR9SmEgNen4OfdACRmKr83pOwLMGheT58jZS84y+VBiRN5Z5u9KDamED5HagNQutpZvQz0/4VbC/+MFtCmFILnSKkF2EjATBvBeozK78qEfrvFuNnwD7tUYm4mkFhbiOTmFsIPuzYRxWIrUSy2En7YRZUXnQ3/sIsqB7owuIVvMwGXAtdbdPnvw6744x/+RsXE3mBtSyF8L3IzESFuI3wvUmHeRkAMVzD5sGszsCn6K8VMgrmC6P2pv1LoP+xCrs924IddXYDvH1Ktz/YU72/hQ74lYd/EdkSV5k4uBE6FbwcBWe8i2rh2EaoaFYudBLHYTRSL3YSqhiovrjJc1VDlQJHhqkaRLIWqAa63KPpP1cQfYgeRqtnDUdXsIVY1ewiIIfz/UNX8nWImwYSJuua/mamapFScqikCqhqq9VH+jk3y9hY+5NtRlDipNphKqQw3GDtoig3GPn/ZvG6LuZjJLXxIAqucauTnMNDNqpiIDCun0t/CVyUVtyl0aWnmZkW1PlVS/++8BVc1de+/1VKT8M+RSnTTA/IuHrdzAW8cIXluUVkM0feIUsXQ7VyHpJq9HqpgDiFoEg5NpSGrQ1Pp3q6tRhSLw4hicVgq3du1VHlRavjbtVQ50JXB27XKb/TbtcD1Fl3/e7s2/viHv1ExsTd+h1Oq6UOICPFwQjWtMB9OQAzdmLxdewhQAR+RaibBdCNSWEek0r9di1yfI4Fv13YFKmCq9Tnyf0EBU33d4ajUvf8ezYXAqfAdRUDWxxBtXMcQqhoVi6MJYnEsUSyOJVQ1VHlxteGqhioHejC4tZ5C1QDXW/T4T9XEH+IoIlVTnaOqqU6saqoTEEPP/4eq5rhUMwmmJ1HXfBwzVXM8UNX0AKoaqvU5PtX7m1CQb0dR4qTaYE7guMGcQLzBnECwwfRichMKksBOBM6FfNsMuVn1IiLDE1Ppb0I5KRW3KXRtaeZmRbU+JxG+A3JvclLSA8l4DqpB/C4YgnsUxirgeCLvaagB5LSTDV8P9UzBkwn2wlOA66HmqAzGp96FQWJUTwdX8yVh85rkHaheUazoNT8VmOtePnsOiduOt2YqIeCaqfh5TwMSH5Xfp/0/L7LTidQsmmCRuXSG4ZtJ1+SkJCRGtcZnMMnz0mSamlQbQI2kfY2i/aDwARnj+AMzt49ubrFv41L/Jkf/riXXtba0ZGkp0lKlpUlLl5YhLVNalrRsaTnS6kjLlZYnra60etLqS7OkCWk+afnS/NIKpBVKC0gLSgtJayCtobRG0hqnRsGUqTEF5rC4sdqasWTNWIpmLFUzlqYZS9eMZWjGMjVjWZqxbM1YjmasjmYsVzOWpxmrqxmrpxmrrxmzNGNCM+bTjOVrxvyasQLNWKFmLKAZC2rGQpqxBpqxhpqxRpqxxtEx+5ES/bdZ9F/L3RFDOm43oFqAzbakVB2WqA2aS/mYDJlrb7xS3M/lK/ucONXtXP59nzmnuZvLsn9+ne5mLl/sZ+EZBz+XFf+5euZBziXf7NvvM/qsg5srqPu8P/tg5grq7x3IqfhcgUT3IdSp6FyBxPc05FZsLp/T/RF5FZkr4HyvRd3yz3XAe4HqlXeuwAG5UNQv31xWOXhVWOWZyyoXRwtx4LkKysn3wnegufzl3jtEvuNc/tIK7EPC7zRXoEJ7mihIPFewgvujKEwwV6i0wnutCOjnsg5i3xZB3VzWQfUAIrT/XOIg+wnRIH6uyEH3JqJh7Fz5Lvoc0cg2l6/UVc8kGqfyfLeyMazXiwg73iaphIDV5JXj5nULvgluAUVTQFAp3/lUMVQYUe8mlsWwKbgITkry5p4eXPFGSN9VsceiWbTAmse/s9EsurD2seYaBYr+zBTHJJZoBiyg5uDFRSffP0UDLMYyv5sx3ZEawfIoFLHjbZFKCLgFfEcKRVoAd6SWhu9IKoYt4TtSKNKS6Y7UCIY7VKyBS7IjtYoWWOv4HamVZkdq7cGOhGMSS7QCFlBrosVFEVAZTqTPbYBklpSE3y2bRgmoMjgHkVLgTCCZ6WJouTuEWuMzCToZpN9edjINYfwTzrfjbZtKCLgtvJMJ57cFFn87wzsZFcN28E4mnN+OuPgRBHqm4QTaHhzDsgO98SJz/Cxg7XnZATeE4Q77NHBJOuCzo8R8TnwHfLamAz7Hgw4YtwNZ4mxgUp5DtLjoQkT6fC5xB2y5O4Qix7MIurfzDO9a1bqcx8Bvqhw/D5jjHQzP8URNCqL5Qc11PnjD9krtNIDtNcFSO94LUgkBXwBXO8HSC4AL2NFwtaNi2BGudoKlHQ1XO4rozk81m4wvBJNx2YH2GZnjFzFVOw1guIMlGrgkaufiKDF3ilc7F2vUTicP1A5uB7LExcCk7ES0uOhCRPp8ieGdoCLHiwi6/ksNVztqXS5l4DdVjl8KzPHLDM/xRE2K5e4QyCblcmDeeKl2QrC9xhfzLe/OqYSAO8PVjs/qDCyCLoarHRXDLnC147O6GK52FNFdnmo2GV/BRO0gc/xKpmonBMMtSjVwSdTOVVFiLopXO1dp1E6RB2oHtwNZ4ipgUhYRLS66EJE+hw3vBBU5XknQ9RcbrnbUuhQz8Jsqx4uBOR4xPMcTNSmWu0Mgm5QSpmonCNtrIjFqpzSVEHApXO1ErFJgEXQ1XO2oGHaFq52I1dVwtaOIriTVbDLuxkTtIHO8O1O1E4ThLvZM7VwdJeYe8Wrnao3a6eGB2sHtQJa4GpiUPYgWF12ISJ97Gt4JKnLsTtD19zJc7ah16cXAb6oc7wXM8d6G53iiJsVydwhkk9KHqdoJwPaawphnYvRNJQTcF652CkVfYBH0M1ztqBj2g6udwhi/LZeHzm8E0fVJNZuM+zNRO8gcH8BU7QRguAs9e5bKwCgxD4pXOwM1ameQB2oHtwNZYiAwKQcRLS66EJE+Dza8E1TkOICg6x9iuNpR6zKEgd9UOT4EmONDDc/xRE2K5e4QyCZlGFO1UwjbayJBO97hqYSAh8PVTiQ4HFgEIwxXOyqGI+BqJxIcYbjaUUQ3LNVsMh7JRO0gc3wUU7VTCMMdCWjgkqid0VFiHhOvdkZr1M4YD9QObgeyxGhgUo4hWlx0ISJ9Hmt4J6jIcRRB1z/OcLWj1mUcA7+pcnwcMMevMTzHEzUplrtDIJuU8UzVTgFsr/GH7HgnpBICngBXO/7QBGARTDRc7agYToSrHX9oouFqRxHd+FSzyXgSE7WDzPHJTNVOAQy3P6iBS6J2pkSJeWq82pmiUTtTPVA7uB3IElOASTmVaHHRhYj0eZrhnaAix8kEXf90w9WOWpfpDPymyvHpwByfYXiOJ2pSLHeHQDYp1zJVO37YXhOOuZPtulRCwNfB1U5YXAcsgusNVzsqhtfD1U44xm/L5aHzG0F016aaTcY3MFE7yBy/kana8cNwhz27k+2mKDHfHK92btKonZs9UDu4HcgSNwGT8maixUUXItLnWwzvBBU53kjQ9d9quNpR63IrA7+pcvxWYI7fZniOJ2pSLHeHQDYptzNVO/k4tVNsx3tHKiHgO/Bqp/gOYBHcabjaUTG8E692iu80XO0oors91WwyvouJ2kHm+N1M1U4+riEOa+CSqJ17osR8b7zauUejdu71QO3gdiBL3ANMynuJFhddiEif7zO8E1TkeHcqfmO433C1o9blfgZ+U+X4/cAcf8DwHE/UpFjuDoFsUh5kqnZ8sL3GH7bjfSiVEPBDcLXjDz8ELIKHDVc7KoYPw9WOP/yw4WpHEd2DqWaT8SNM1A4yxx9lqnZ8MNz+Ig1cErXzWJSYH49XO49p1M7jHqgd3A5kiceASfk40eKiCxHp8xOGd4KKHB8l6PqfNFztqHV5koHfVDn+JDDHZxqe44maFMvdIZBNyiymakfA9ppgzBOoZ6cSAp4NVztBazawCOYYrnZUDOfA1U7QmmO42lFENyvVbDKey0TtIHN8HlO1I2C4A549gfqpKDHPj1c7T2nUznwP1A5uB7LEU8CknE+0uOhCRPr8tOGdoCLHeQRd/wLD1Y5alwUM/KbK8QXAHH/G8BxP1KRY7g6BbFIWMlU7FpHaWZRKCHgRgdpZBCyCZw1XOyqGzxKonWcNVzuK6Bammk3Gi5moHWSOL2GqdiyGamdplJiXxaudpRq1s8wDtYPbgSyxFJiUy5ioHaTPyw3vBBU5LiHo+p8zXO2odXmOgd9UOf4cMMefNzzHEzUplrtDIJuUF5iqnfqwvaYo5plsK1IJAa+Aq52i0ApgEbxouNpRMXwRrnaKQi8arnYU0b2QajYZr2SidpA5/hJTtVMfhrvIs2eyvRwl5lfi1c7LGrXzigdqB7cDWeJlYFK+QrS46EJE+vyq4Z2gIseXCLr+1wxXO2pdXmPgN1WOvwbM8dcNz/FETYrl7hDIJuUNpmqnHk7t+O1430wlBPwmXu343wQWwVuGqx0Vw7fwasf/luFqRxHdG6lmk/HbTNQOMsdXMVU79XANcb4GLonaeSdKzO/Gq513NGrnXQ/UDm4HssQ7wKR8l2hx0YWI9Pk9wztBRY6rCLr+9w1XO2pd3mfgN1WOvw/M8Q8Mz/FETYrl7hDIJuVDpmqnLmyvicR8tvNRKiHgj+BqJxL6CFgEHxuudlQMP4arnUjoY8PVjiK6D1PNJuNPmKgdZI5/ylTt1IXhjnj22c5nUWL+PF7tfKZRO597oHZwO5AlPgMm5edEi4suRKTPXxjeCSpy/JSg6//ScLWj1uVLBn5T5fiXwBz/yvAcT9SkWO4OgWxSvmaqdvJge01xiR3vN6mEgL+Bq53ikm+ARfCt4WpHxfBbuNopLvnWcLWjiO7rVLPJ+DsmageZ498zVTt5MNzFEQ1cErXzQ5SYf4xXOz9o1M6PHqgd3A5kiR+ASfkj0eKiCxHp80+Gd4KKHL8n6Pp/NlztqHX5mYHfVDn+MzDHfzE8xxM1KZa7QyCblF+Zqp1c2F4jYj7b+S2VEPBvcLUjQr8Bi+B3w9WOiuHvcLUjQr8brnYU0f2aajYZr2aidpA5voap2smF4RaefbazNkrMf8SrnbUatfOHB2oHtwNZYi0wKf8gWlx0ISJ9Xmd4J6jIcQ1B17/ecLWj1mU9A7+pcnw9MMc3GJ7jiZoUy90hkE3KRqZqpw5srwnHqJ0/UwkB/wlXO+HQn8Ai2GS42lEx3ARXO+HQJsPVjiK6jalmk/FmJmoHmeNbmKqdOjDcYc/UztYoMW+LVztbNWpnmwdqB7cDWWIrMCm3ES0uuhCRPv9leCeoyHELQde/3XC1o9ZlOwO/qXJ8OzDHdxie44maFMvdIZBNyk6maicHttcEg3a8u1IJAe+Cq51gcBewCHYbrnZUDHfD1U4wuNtwtaOIbmeq2WS8h4naQeb430zVTg4MdzCggUuidpLSorFIS4pVNupEvNpRL6JWO7gdSCZ8Gi4pK6XRLC66EJE+V07Dkg+64BQ5/k3Q9VdJo924LHeHUOtSJc18v6lyvAowx6sanuOJmhTL3SGQTUo1YN54qXayYXuNP0btHJJGCFhNjlU7/uAhwCI4FFicVDE8NA2tdvzBQ4k3DQTRVUszm4wPA5Nx2YH2GZnjhwN99lLtZMPUjt8ztXNElJiPjFc7R2jUzpEeqB3cDmSJI4BJeWQazeKiCxHp81GGd4KKHA8n6PqPNlztqHU5moHfVDl+NDDHjzE8xxM1KZa7QyCblGOZqp0s2F4TEna81dMIAVeHq52QqA4sguMMVzsqhsfB1U4oxm/L5aHzG0F0x6aZTcbHM1E7yBw/ganayYKpnZClgUuidk6MEvNJ8WrnRI3aOckDtYPbgSxxIjApT0qjWVx0ISJ9rmF4J6jI8QSCrv9kw9WOWpeTGfhNleMnA3P8FMNzPFGTYrk7BLJJOZWp2smE7TUBy463Zhoh4JpwtROwagKL4DTD1Y6K4WlwtROwTjNc7SiiOzXNbDI+nYnaQeb4GUzVTiZM7RSWauCSqJ1aUWKuHa92amnUTm0P1A5uB7JELWBS1k6jWVx0ISJ9Tja8E1TkeAZB159iuNpR65LCwG+qHE8B5niq4TmeqEmx3B0C2aSkMVU7GbC9JhzzBOr0NELA6XC1Ey5JBxZBhuFqR8UwA652wiUZhqsdRXRpaWaTcSYTtYPM8SymaicDpnbCnj2BOjtKzDnxaidbo3ZyPFA7uB3IEtnApMxJo1lcdCEifa5jeCeoyDGLoOvPNVztqHXJZeA3VY7nAnM8z/AcT9SkWO4OgWxS6jJVO+mwvcYX89lOvTRCwPXgasdn1QMWQX3D1Y6KYX242vFZ9Q1XO4ro6qaZTcYWE7WDzHHBVO2kw9SO8OyzHV+UmPPj1Y5Po3byPVA7uB3IEj5gUuan0SwuuhCRPvsN7wQVOQqCrr/AcLWj1qWAgd9UOV4AzPFCw3M8UZNiuTsEskkJMFU7abi9ptiON5hGCDgIVztWcRBYBCHD1Y6KYQiudqzikOFqRxFdIM1sMm7ARO0gc7whU7WTBlM7VlgDl0TtNIoSc+N4tdNIo3Yae6B2gDuQaARMysZpNIuLLkSkz00M7wQVOTYk6PqbGq521Lo0ZeA3VY43BeZ4M8NzPFGTYrk7BLJJac5U7aTC9prCmDvZWqQRAm4BVzuFJS2ARdDScLWjYtgSrnYKS1oarnYU0TVPM5uMWzFRO8gcb81U7aTC1E6hZ3eytYkS85nxaqeNRu2c6YHawe1AlmgDTMoz02gWF12ISJ/bGt4JKnJsTdD1tzNc7ah1acfAb6ocbwfM8faG53iiJsVydwhkk3IWU7WTAttrRMwz2c5OIwR8NlztCHE2sAjOMVztqBieA1c7IsZvy+Wh8xtBdGelmU3G5zJRO8gcP4+p2kmBqR3h2TPZOkSJ+fx4tdNBo3bO90Dt4HYgS3QAJuX5aTSLiy5EpM8XGN4JKnI8j6Dr72i42lHr0pGB31Q53hGY4xcanuOJmhTL3SGQTcpFTNVOcioOtx3vxWmEgC9Ow8/byXCFovzulLYvwKB5SVSFIpSL0swmvUuYqApkXl5KTPSINbmUIMe9JNTaRIR6WRoh4MsICPVywwlV+X25R4RquTuEKozL02gKDuW3l0VWKxUXAzvezmmEgDsT7IidgYzexfCCVTHsQlAEXQx/j1YVaRcC+XMJcL2vMPztApU7VxCRfdmBru0rgOtzpeESP5FisNwdAqkYrjI8x9UaX0XQyCHzUDUJNZL2vWVuP9C4z0iiqfMkKE4f6ecclWyxTY7+XSTXMyytWFpEWom0UmldpXWT1l3a1dJ6SOsprZe03tL6SOsrrZ+0/tIGSBsobZC0wdKGSBsqbZi04dJGSBspbZS00dLGSBsb/xlLUfTzFPtYWDNWrBmLaMZKNGOlmrGumrFumrHumrGrNWM9NGM9NWO9NGO9NWN9NGN9NWP9NGP9NWMDNGMDNWODNGODNWNDNGNDNWPDNGPDNWMjNGMjNWOjNGOjNWNjNGNj0/b/7C4l+m+z6L+WuyOGdNySZRGAeMs+BwyD5lI+FkPm2huviPu5fNF4iRK3c/n/jb0odTeXZVtH0dXNXL6YnBDdDn4uKy6/RPeDnKuwdL9cFVcf3FxBTd6LHgczV1BbQ6JnxecKJKhH0auicwUS1rboXbG5fA48IfpUZK6AI+eIvuWfq/gA/CX6lXeuwAG5UPQv31xWOXhVDCjPXFa5OFoMPPBcBeXkezHoQHP5y713iMGOc/lLK7APiSFOcwUqtKeJoYnnClZwfxTDEswVKq3wXiuG6+eyDmLfFiN0c1kH1QOIkfvPJQ6ynxCj4ueKHHRvIkbHzpXvos8RY2xz+Upd9UxibBrPd7THwnq9SMxdx+PSCAGryVHvepWBH4dbQHENIKiU72irGCqM2LuOIzF+Wy4PL+8exRVvxLO7R8dHC2xCWlKs2hyftv/doxPS6O8exTGJJcYDC2gCeHHRyaeKZjywGMv8Hs90RxoDy6NQxI53Yhoh4InwHSkUmQjckSYZviOpGE6C70ihyCSmO9IYGO5QsQYuyY40OVpgU+J3pMmaHWmKBzvSGOCONBlYQFOIFhf9QTDS56lAMktKwu+W10QJCP1BMFIKTAOSmS6GlrtDqDWeRtDJTGPayYyG8U843453ehoh4OnwTiacPx1Y/DMM72RUDGfAO5lw/gzi4kcQ6DTDCfRacAzLDvTGi8zx64C152UHPBqGO+zTwCXpgK+PEvMN8R3w9ZoO+AYPOmDcDmSJ64FJeQPR4qILEenzjcQdsOXuEIocryPo3m4yvGtV63ITA7+pcvwmYI7fbHiOJ2pSEM0Paq5bwBu2V2pnFGyvCZba8d6aRgj4VrjaCZbeClzA2wxXOyqGt8HVTrD0NsPVjiK6W9LMJuPbwWRcdqB9Rub4HUzVzigY7mCJBi6J2rkzSsx3xaudOzVq5y4P1A5uB7LEncCkvItocdGFiPT5bsM7QUWOdxB0/fcYrnbUutzDwG+qHL8HmOP3Gp7jiZoUy90hkE3KfUw/2xkJ22tif3f8/jRCwPfD1Y7Puh9YBA8YrnZUDB+Aqx2f9YDhakcR3X1pZpPxg0zUDjLHH2KqdkbCcHv3u+MPR4n5kXi187BG7TzigdrB7UCWeBiYlI8QLS66EJE+P2p4J6jI8SGCrv8xw9WOWpfHGPhNleOPAXP8ccNzPFGTYrk7BLJJeYKp2hkB22siMWrnyTRCwE/C1U7EehJYBDMNVzsqhjPhaidizTRc7SiieyLNbDKexUTtIHN8NlO1MwKGu9gztTMnSsxz49XOHI3ameuB2sHtQJaYA0zKuUSLiy5EpM/zDO8EFTnOJuj6nzJc7ah1eYqB31Q5/hQwx+cbnuOJmhTL3SGQTcrTTNXOcNheUxjzTIwFaYSAF8DVTqFYACyCZwxXOyqGz8DVTmGM35bLQ+c3guieTjObjBcyUTvIHF/EVO0Mh+Eu9OxZKs9GiXlxvNp5VqN2FnugdnA7kCWeBSblYqLFRRci0uclhneCihwXEXT9Sw1XO2pdljLwmyrHlwJzfJnhOZ6oSbHcHQLZpCxnqnaG4T7bCdrxPpdGCPg5/Gc7weeARfC84WpHxfB5/Gc7wecNVzuK6JanmU3GLzBRO8gcX8FU7QyD4Y4ENHBJ1M6LUWJeGa92XtSonZUeqB3cDmSJF4FJuZJocdGFiPT5JcM7QUWOKwi6/pcNVztqXV5m4DdVjr8MzPFXDM/xRE2K5e4QyCblVaZqZyhsr/GH7HhfSyME/Bpc7fhDrwGL4HXD1Y6K4etwteMPvW642lFE92qa2WT8BhO1g8zxN5mqnaEw3P6gBi6J2nkrSsxvx6udtzRq520P1A5uB7LEW8CkfJtocdGFiPR5leGdoCLHNwm6/ncMVztqXd5h4DdVjr8DzPF3Dc/xRE2K5e4QyCblPaZqZwhsrwnH3Mn2fhoh4Pfhaics3gcWwQeGqx0Vww/gaicc47fl8tD5jSC699LMJuMPmagdZI5/xFTtDIHhDnt2J9vHUWL+JF7tfKxRO594oHZwO5AlPgYm5SdEi4suRKTPnxreCSpy/Iig6//McLWj1uUzBn5T5fhnwBz/3PAcT9SkWO4OgWxSvmCqdgbj1E6xHe+XaYSAv8SrneIvgUXwleFqR8XwK7zaKf7KcLWjiO6LNLPJ+GsmageZ498wVTuDcQ1xWAOXRO18GyXm7+LVzrcatfOdB2oHtwNZ4ltgUn5HtLjoQkT6/L3hnaAix28Iuv4fDFc7al1+YOA3VY7/AMzxHw3P8URNiuXuEMgm5SemamcQ7k62sB3vz2mEgNXkWLXjD6s5URh/STNb7agYKozgO9nCv6TRbhoIovspzWwy/jUNS8ZlB9pnZI7/BvTZS7UzCIbbX6SBS6J2fk/b++/qtKRYZfN72v5qR72IWu3gdiBL/A5MytVEi4suRKTPa8Dkgy44RY6/peE3hrXEG5fl7hBqXdYy8Jsqx9cCc/wPw3M8UZNiuTsEsklZB8wbL9XOQNheE4x5AvX6NELA6+FqJ2itBxbBBsPVjorhBrjaCVobDFc7iujWpZlNxhuZqB1kjv/JVO0MhOEOePYE6k1RYt4cr3Y2adTOZg/UDm4HssQmYFJuJlpcdCEifd5ieCeoyPFPgq5/q+FqR63LVgZ+U+X4VmCObzM8xxM1KZa7QyCblL+Yqp0BRGpnexoh4O0Eamc7sAh2GK52VAx3EKidHYarHUV0f6WZTcY7magdZI7vYqp2BjBUO7ujxLwnXu3s1qidPR6oHdwOZIndwKTcw0TtIH3+2/BOUJHjLoKuPyndbLWj1kVhNN1vqhy343Q7V6V0s3M8UZNiuTsEskmpDMwbL9VOf9heUxTzTLYq6YSA1eRYtVMUqgIsgqrA4qSKYdV0tNopClUl3jQQRFc53WwyrgYm47ID7TMyxw9B1l6Sd2qnP6w5LPLsmWyHRon5sPSkWGVzaPr+ake9iFrt9AeqnUOBSXlYOs3iogsR6fPhhneCihwPIej6jzBc7ah1OYKB31Q5fgQwx480PMcTNSmWu0Mgm5SjmKqdfji147fjPTqdEPDReLXjPxpYBMcYrnZUDI/Bqx3/MYarHUV0R6WbTcbHMlE7yByvzlTt9MOpnXwNXBK1c1yUmI+PVzvHadTO8R6onX5AtXMcMCmPT6dZXHQhIn0+wfBOUJFjdYKu/0TD1Y5alxMZ+E2V4ycCc/wkw3M8UZNiuTsEskmpwVTt9IXtNZGYz3ZOTicEfDJc7URCJwOL4BTD1Y6K4SlwtRMJnWK42lFEVyPdbDI+lYnaQeZ4TaZqpy9M7UQ8+2zntCgxnx6vdk7TqJ3TPVA7fYFq5zRgUp6eTrO46EJE+nyG4Z2gIseaBF1/LcPVjlqXWgz8psrxWsAcr214jidqUix3h0A2KclM1U4f2F5TXGLHm5JOCDgFrnaKS1KARZBquNpRMUyFq53iklTD1Y4iuuR0s8k4jYnaQeZ4OlO10wemdoojGrgkaicjSsyZ8WonQ6N2Mj1QO32AaicDmJSZ6TSLiy5EpM9ZhneCihzTCbr+bMPVjlqXbAZ+U+V4NjDHcwzP8URNiuXuEMgmpQ5TtdMbtteImM92ctMJAefC1Y4I5QKLIM9wtaNimAdXOyKUZ7jaUURXJ91sMq7LRO0gc7weU7XTG6Z2hGef7dSPErMVr3bqa9SO5YHa6Q1UO/WBSWml0ywuuhCRPgvDO0FFjvUIun6f4WpHrYuPgd9UOe4D5ni+4TmeqEmx3B0C2aT4maqdXrC9JhyjdgrSCQEXwNVOOFQALIJCw9WOimEhXO2EQ4WGqx1FdP50s8k4wETtIHM8yFTt9IKpnbBnaicUJeYG8WonpFE7DTxQO72AaicETMoG6TSLiy5EpM8NDe8EFTkGCbr+RoarHbUujRj4TZXjjYA53tjwHE/UpFjuDoFsUpowVTs9cU+gDtrxNk0nBNwUrnaCwabAImhmuNr5Z9HhaicYbGa42lFE1yTdbDJuzkTtIHO8BVO10xOmdoIBDVwStdMySsyt4tVOS43aaeWB2ukJVDstgUnZKp1mcdGFiPS5teGdoCLHFgRdfxvD1Y5alzYM/KbK8TbAHD/T8BxP1KRY7g6BbFLaMlU7PWB7jT9G7bRLJwTcDq52/MF2wCJob7jaUTFsD1c7/mB7w9WOIrq26WaT8VlM1A4yx89mqnZ6wNSO3zO1c06UmM+NVzvnaNTOuR6onR5AtXMOMCnPTadZXHQhIn0+z/BOUJHj2QRdfwfD1Y5alw4M/KbK8Q7AHD/f8BxP1KRY7g6BbFIuYKp2robtNSFhx9sxnRBwR7jaCYmOwCK40HC1o2J4IVzthGL8tlweOr8RRHdButlkfBETtYPM8YuZqp2rYWonZGngkqidTlFiviRe7XTSqJ1LPFA7VwPVTidgUl6STrO46EJE+nyp4Z2gIseLCbr+ywxXO2pdLmPgN1WOXwbM8csNz/FETYrl7hDIJqUzU7XTHbbXBCw73i7phIC7wNVOwOoCLIIrDFc7KoZXwNVOwLrCcLWjiK5zutlkfCUTtYPM8auYqp3uMLVTWKqBS6J2iqLEHI5XO0UatRP2QO10B6qdImBShtNpFhddiEifiw3vBBU5XkXQ9UcMVztqXSIM/KbK8Qgwx0sMz/FETYrl7hDIJqWUqdrphntKQcwTqLumEwLuClc74ZKuwCLoZrjaUTHsBlc74ZJuhqsdRXSl6WaTcXcmageZ41czVTvdcE8piGjgkqidHlFi7hmvdnpo1E5PD9RON6Da6QFMyp7pNIuLLkSkz70M7wQVOV5N0PX3NlztqHXpzcBvqhzvDczxPobneKImxXJ3CGST0pep2ukK22t8MZ/t9EsnBNwPrnZ8Vj9gEfQ3XO2oGPaHqx2f1d9wtaOIrm+62WQ8gInaQeb4QKZqpyvuCdSefbYzKErMg+PVziCN2hnsgdrpClQ7g4BJOTidZnHRhYj0eYjhnaAix4EEXf9Qw9WOWpehDPymyvGhwBwfZniOJ2pSLHeHQDYpw5mqnVLcXlNsxzsinRDwCLjasYpHAItgpOFqR8VwJFztWMUjDVc7iuiGp5tNxqOYqB1kjo9mqnZKYWrHCmvgkqidMVFiHhuvdsZo1M5YD9QOcAcSY4BJOTadZnHRhYj0eZzhnaAix9EEXf81hqsdtS7XMPCbKsevAeb4eMNzPFGTYrk7BLJJmcBU7ZTA9prCmDvZJqYTAp4IVzuFJROBRTDJcLWjYjgJrnYKSyYZrnYU0U1IN5uMJzNRO8gcn8JU7ZTgvrcT0cAlUTtTo8Q8LV7tTNWonWkeqJ0SoNqZCkzKaek0i4suRKTP0w3vBBU5TiHo+mcYrnbUusxg4DdVjs8A5vi1hud4oibFcncIZJNyHVO1E4HtNSLmmWzXpxMCvh6udoS4HlgENxiudlQMb4CrHRHjt+Xy0PmNILrr0s0m4xuZqB1kjt/EVO1EcHeyefZMtpujxHxLvNq5WaN2bvFA7USAaudmYFLekk6zuOhCRPp8q+GdoCLHmwi6/tsMVztqXW5j4DdVjt8GzPHbDc/xRE2K5e4QyCblDqZqpxh3M0bM93buTCcEfGc6ft67DFcoyu+70vcFGDQviapQhHJHutmkdzcTVYHMy3uIiR6xJvcQ5LiXhBomItR70wkB30tAqPcZTqjK7/s8IlTL3SFUYdyXTlNwKL+9LLKiNFwM7HjvTycEfD/Bjng/kNEfMLxgVQwfICiCBwx/j1YV6QME8udu4Ho/aPjbBSp3HiQi+7IDXdsPAtfnIcMlfiLFYLk7BFIxPGx4jqs1fpigkUPmoWoSaiTte8vcfqBxV0qiqfMkKE4f6ecclWyxTY7+/Yhcz0elPSbtcWlPSHtS2kxps6TNljZH2lxp86Q9JW2+tKelLZD2jLSF0hZJe1baYmlLpC2VtkzacmnPSXte2gvSVkh7UdpKaS/Ff8bySPTzFPvYo5qxxzRjj2vGntCMPakZm6kZm6UZm60Zm6MZm6sZm6cZe0ozNl8z9rRmbIFm7BnN2ELN2CLN2LOascWasSWasaWasWWaseWasec0Y89rxl7QjK3QjL2oGVupGXspff/P7lKi/zaL/mu5O2JIxy1ZPgIg3rLPAR8FzaV8fAwy1954Pe5+Ll80XuIJt3P5/429eNLdXJZtHcVMN3P5YnJCzDr4uay4/BKzD3KuwtL9clXMObi5gpq8F3MPZq6gtobEvIrPFUhQj+Kpis4VSFjbYn7F5vI58IR4uiJzBRw5Rywo/1zFB+Av8Ux55wockAvFwvLNZZWDV8Wi8sxllYujxbMHnqugnHwvFh9oLn+59w6xxHEuf2kF9iGx1GmuQIX2NLEs8VzBCu6PYnmCuUKlFd5rxXP6uayD2LfF87q5rIPqAcQL+88lDrKfECvi54ocdG8iXoydK99FnyNW2ubylbrqmcRLTN/RfgnW60Vi7jp+OZ0Q8Mvp6LuOI+Jl3AKKVwBBpXxHW8XwFeA72mUxfAVcBF7dPYor3ohnd4++Gi2w1+Lf2Xg1ff+7R19Lp797FMcklngVWECvgRcXnXyqaF4FFmOZ368y3ZFWwvIoFLHjfT2dEPDr8B0pFHkduCO9YfiOpGL4BnxHCkXeYLojrYThDhVr4JLsSG9GC+yt+B3pTc2O9JYHO9JK4I70JrCA3iJaXPQHwUif3waSWVISfrd8JUpA6A+CkVJgFZDMdDG03B1CrfEqgk5mFdNO5kUY/4Tz7XjfSScE/A68kwnnvwMs/ncN72RUDN+FdzLh/HeJix9BoKsMJ9D3wDEsO9AbLzLH3wfWnpcd8Isw3GGfBi5JB/xBlJg/jO+AP9B0wB960AHjdiBLfABMyg+JFhddiEifPyLugC13h1Dk+D5B9/ax4V2rWpePGfhNleMfA3P8E8NzPFGTgmh+UHN9Ct6wvVI7K2B7TbDUjvezdELAn8HVTrD0M+ACfm642lEx/ByudoKlnxuudhTRfZpuNhl/ASbjsgPtMzLHv2SqdlbAcAdLNHBJ1M5XUWL+Ol7tfKVRO197oHZwO5AlvgIm5ddEi4suRKTP3xjeCSpy/JKg6//WcLWj1uVbBn5T5fi3wBz/zvAcT9SkWO4OgWxSvmf62c4LsL0m9nfHf0gnBPwDXO34rB+ARfCj4WpHxfBHuNrxWT8arnYU0X2fbjYZ/8RE7SBz/GemaucFGG7vfnf8lygx/xqvdn7RqJ1fPVA7uB3IEr8Ak/JXosVFFyLS598M7wQVOf5M0PX/brjaUevyOwO/qXL8d2COrzY8xxM1KZa7QyCblDVM1c7zsL0mEqN21qYTAl4LVzsRay2wCP4wXO2oGP4BVzsR6w/D1Y4iujXpZpPxOiZqB5nj65mqnedhuIs9UzsbosS8MV7tbNConY0eqB3cDmSJDcCk3Ei0uOhCRPr8p+GdoCLH9QRd/ybD1Y5al00M/KbK8U3AHN9seI4nalIsd4dANilbmKqd52B7TWHMMzG2phMC3gpXO4ViK7AIthmudlQMt8HVTmGM35bLQ+c3gui2pJtNxn8xUTvIHN/OVO08B8Nd6NmzVHZEiXlnvNrZoVE7Oz1QO7gdyBI7gEm5k2hx0YWI9HmX4Z2gIsftBF3/bsPVjlqX3Qz8psrx3cAc32N4jidqUix3h0A2KX8zVTvLcZ/tBGPwZhACVpODP9sJqjlRGCtlmK12VAwVRvBnO8FKGbSbBoLo/k43m4wrZ2DJuOxA+4zM8SpAn71UO8thpB8JaOCSqJ2qUWKulpEUq2yqZuyvdtSLqNXOcqDaqQpMymoZNIuLLkSkz4eAyQddcIocq2TgN4ZDiTcuy90h1LocysBvqhw/FJjjhxme44maFMvdIZBNyuHAvPFS7SyD7TX+kB3vERmEgI+Aqx1/6AhgERxpuNpRMTwSrnb8oSMNVzuK6A7PMJuMj2KidpA5fjRTtbMMpnb8QQ1cErVzTJSYj41XO8do1M6xHqidZUC1cwwwKY/NoFlcdCEifa5ueCeoyPFogq7/OMPVjlqX4xj4TZXjxwFz/HjDczxRk2K5OwSySTmBqdpZCttrwjF3sp2YQQj4RLjaCYsTgUVwkuFqR8XwJLjaCcf4bbk8dH4jiO6EDLPJuAYTtYPM8ZOZqp2lMLUT9uxOtlOixHxqvNo5RaN2TvVA7SwFqp1TgEl5agbN4qILEelzTcM7QUWOJxN0/acZrnbUupzGwG+qHD8NmOOnG57jiZoUy90hkE3KGUzVzhKc2im2462VQQi4Fl7tFNcCFkFtw9WOimFtvNoprm242lFEd0aG2WSczETtIHM8hanaWYJTO2ENXBK1kxol5rR4tZOqUTtpHqidJUC1kwpMyrQMmsVFFyLS53TDO0FFjikEXX+G4WpHrUsGA7+pcjwDmOOZhud4oibFcncIZJOSxVTtLMbdyRa2483OIAScjb+TLZwNLIIcw9WOimEO/k62cI7hakcRXVaG2WRch4naQeZ4LlO1sxh3J1uRBi6J2smLEnPdeLWTp1E7dT1QO4uBaicPmJR1M2gWF12ISJ/rGd4JKnLMJej66xuudtS61GfgN1WO1wfmuGV4jidqUix3h0A2KYKp2nkWttcEY55A7csgBOyDq52g5QMWQb7hakfFMB+udoJWvuFqRxGdyDCbjP1M1A4yxwuYqp1nYWon4NkTqAujxByIVzuFGrUT8EDtPAtUO4XApAxk0CwuuhCRPgcN7wQVORYQdP0hw9WOWpcQA7+pcjwEzPEGhud4oibFcncIZJPSkKnaWUSkdhplEAJuRKB2GgGLoLHhakfFsDGB2mlsuNpRRNcww2wybsJE7SBzvClTtbOIodppFiXm5vFqp5lG7TT3QO0sAqqdZsCkbM5E7SB9bmF4J6jIsSlB19/ScLWj1qUlA7+pcrwlMMdbGZ7jiZoUy90hkE1Ka6ZqZyFsrymKeSZbmwxCwG3gaqco1AZYBGcarnZUDM+Eq52i0JmGqx1FdK0zzCbjtkzUDjLH2zFVOwthaqfIs2eytY8S81nxaqe9Ru2c5YHaWQhUO+2BSXlWBs3iogsR6fPZhneCihzbEXT95xiudtS6nMPAb6ocPweY4+canuOJmhTL3SGQTcp5TNXOMzi147fj7ZBBCLgDXu34OwCL4HzD1Y6K4fl4teM/33C1o4juvAyzyfgCJmoHmeMdmaqdZ3BqJ18Dl0TtXBgl5ovi1c6FGrVzkQdq5xmg2rkQmJQXZdAsLroQkT5fbHgnqMixI0HX38lwtaPWpRMDv6lyvBMwxy8xPMcTNSmWu0Mgm5RLmaqdBbhfF435bOeyDELAl8HVTiR0GbAILjdc7agYXg5XO5HQ5YarHUV0l2aYTcadmagdZI53Yap2FuB+XdSzz3auiBLzlfFq5wqN2rnSA7WzAKh2rgAm5ZUZNIuLLkSkz1cZ3gkqcuxC0PUXGa521LoUMfCbKseLgDkeNjzHEzUplrtDIJuUYqZq52nYXlNcYscbySAEHIGrneKSCLAISgxXOyqGJXC1U1xSYrjaUURXnGE2GZcyUTvIHO/KVO08DVM7xRENXBK10y1KzN3j1U43jdrp7oHaeRqodroBk7J7Bs3iogsR6fPVhneCihy7EnT9PQxXO2pdejDwmyrHewBzvKfhOZ6oSbHcHQLZpPRiqnbmw/YaEfPZTu8MQsC94WpHhHoDi6CP4WpHxbAPXO2IUB/D1Y4iul4ZZpNxXyZqB5nj/ZiqnfkwtSM8+2ynf5SYB8Srnf4atTPAA7UzH6h2+gOTckAGzeKiCxHp80DDO0FFjv0Iuv5BhqsdtS6DGPhNleODgDk+2PAcT9SkWO4OgWxShjBVO0/hfl00Ru0MzSAEPBSudsKhocAiGGa42lExHAZXO+HQMMPVjiK6IRlmk/FwJmoHmeMjmKqdp3C/LuqZ2hkZJeZR8WpnpEbtjPJA7TwFVDsjgUk5KoNmcdGFiPR5tOGdoCLHEQRd/xjD1Y5alzEM/KbK8THAHB9reI4nalIsd4dANinjmKqdebgnUAfteK/JIAR8DVztBIPXAItgvOFqR8VwPFztBIPjDVc7iujGZZhNxhOYqB1kjk9kqnbmwdROMKCBS6J2JkWJeXK82pmkUTuTPVA784BqZxIwKSdn0CwuuhCRPk8xvBNU5DiRoOufarjaUesylYHfVDk+FZjj0wzP8URNiuXuEMgmZTpTtTMXttf4Y9TOjAxCwDPgascfnAEsgmsNVzsqhtfC1Y4/eK3hakcR3fQMs8n4OiZqB5nj1zNVO3Nhasfvmdq5IUrMN8arnRs0audGD9TOXKDauQGYlDdm0CwuuhCRPt9keCeoyPF6gq7/ZsPVjlqXmxn4TZXjNwNz/BbDczxRk2K5OwSySbmVqdqZA9trQsKO97YMQsC3wdVOSNwGLILbDVc7Koa3w9VOKMZvy+Wh8xtBdLdmmE3GdzBRO8gcv5Op2pkDUzshSwOXRO3cFSXmu+PVzl0atXO3B2pnDlDt3AVMyrszaBYXXYhIn+8xvBNU5HgnQdd/r+FqR63LvQz8psrxe4E5fp/hOZ6oSbHcHQLZpNzPVO3Mhu01AcuO94EMQsAPwNVOwHoAWAQPGq52VAwfhKudgPWg4WpHEd39GWaT8UNM1A4yxx9mqnZmw9ROYakGLonaeSRKzI/Gq51HNGrnUQ/Uzmyg2nkEmJSPZtAsLroQkT4/ZngnqMjxYYKu/3HD1Y5al8cZ+E2V448Dc/wJw3M8UZNiuTsEskl5kqnamYV7SkHME6hnZhACnglXO+GSmcAimGW42lExnAVXO+GSWYarHUV0T2aYTcazmagdZI7PYap2ZuGeUhDRwCVRO3OjxDwvXu3M1aideR6onVlAtTMXmJTzMmgWF12ISJ+fMrwTVOQ4h6Drn2+42lHrMp+B31Q5Ph+Y408bnuOJmhTL3SGQTcoCpmpnJmyv8cV8tvNMBiHgZ+Bqx2c9AyyChYarHRXDhXC147MWGq52FNEtyDCbjBcxUTvIHH+WqdqZiXsCtWef7SyOEvOSeLWzWKN2lnigdmYC1c5iYFIuyaBZXHQhIn1eangnqMjxWYKuf5nhaketyzIGflPl+DJgji83PMcTNSmWu0Mgm5TnmKqdJ3F7TbEd7/MZhICfh6sdq/h5YBG8YLjaUTF8Aa52rOIXDFc7iuieyzCbjFcwUTvIHH+Rqdp5EqZ2rLAGLonaWRkl5pfi1c5Kjdp5yQO1A9yBxEpgUr6UQbO46EJE+vyy4Z2gIscXCbr+VwxXO2pdXmHgN1WOvwLM8VcNz/FETYrl7hDIJuU1pmrnCdheUxhzJ9vrGYSAX4erncKS14FF8IbhakfF8A242iksecNwtaOI7rUMs8n4TSZqB5njbzFVO0/gvrfj2Z1sb0eJeVW82nlbo3ZWeaB2ngCqnbeBSbkqg2Zx0YWI9PkdwztBRY5vEXT97xqudtS6vMvAb6ocfxeY4+8ZnuOJmhTL3SGQTcr7TNXO47C9RsQ8k+2DDELAH8DVjhAfAIvgQ8PVjorhh3C1I2L8tlweOr8RRPd+htlk/BETtYPM8Y+Zqp3HcXeyefZMtk+ixPxpvNr5RKN2PvVA7TwOVDufAJPy0wyaxUUXItLnzwzvBBU5fkzQ9X9uuNpR6/I5A7+pcvxzYI5/YXiOJ2pSLHeHQDYpXzJVO4/hbsaI+d7OVxmEgL/KwM/7teEKRfn9dca+AIPmJVEVilC+zDCb9L5hoiqQefktMdEj1uRbghz3klAfJSLU7zIIAX9HQKjfG06oyu/vPSJUy90hVGF8n0FTcCi/vSyyR9JxMbDj/SGDEPAPBDviD0BG/9HwglUx/JGgCH40/D1aVaQ/Esifb4Dr/ZPhbxeo3PmJiOzLDnRt/wRcn58Nl/iJFIPl7hBIxfCL4Tmu1vgXgkYOmYeqSaiRtO8tc/uBxl0riabOk6A4faSfc1SyxTY5+vevcj1/k/a7tNXS1khbK+0PaeukrZe2QdpGaX9K2yRts7Qt0rZK2ybtL2nbpe2QtlPaLmm7pe2R9rfi2Uz535RWWVoVaVWlVZN2SGZS7Ocpv0Y/T7GP/aYZ+10ztloztkYztlYz9odmbJ1mbL1mbINmbKNm7E/N2CbN2GbN2BbN2FbN2DbN2F+ase2asR2asZ2asV2asd2asT2asb81Yyo54scqacYqa8aqaMaqasaqacYOydz/s7uU6L/Nov9a7o4Y0nFLlr8CiLfsc8DfQHMpH3+HzLU3Xqvdz+WLxkuscTuX/9/Yi7Xu5rJs6yj+cDOXLyYnxLqDn8uKyy+x/iDnKizdL1fFhoObK6jJe7HxYOYKamtI/FnxuQIJ6lFsquhcgYS1LTZXbC6fA0+ILRWZK+DIOWJr+ecqPgB/iW3lnStwQC4Uf5VvLqscvCq2l2cuq1wcLXYceK6CcvK92Hmgufzl3jvELse5/KUV2IfEbqe5AhXa08SexHMFK7g/ir8TzBUqrfBeK1RPopnLOoh9W1TSzWUdVA8gKu8/lzjIfkJUiZ8rctC9iagaO1e+iz5HVLPN5St11TOJQzJ5vqN9SCaq14vE3HV8aCYhYDU56l2vMvCH4hZQHAYIKuU72v8Ikkz0XceRGL8tl4eXd4/iijfi2d2jh0cL7Ij4dzYOz9z/7tEjMunvHsUxiSUOBxbQEeDFRSefKprDgcVY5vfhTHekarA8CkXseI/MJAR8JHxHCkWOBO5IRxm+I6kYHgXfkUKRo5juSNVguEPFGrgkO9LR0QI7Jn5HOlqzIx3jwY5UDbgjHQ0soGOIFhf9QTDS52OBZJaUhN8tD4sSEPqDYKQUqA4kM10MLXeHUGtcnaCTqc60k6kK459wvh3vcZmEgI+DdzLh/OOAxX+84Z2MiuHx8E4mnH88cfEjCLS64QR6AjiGZQd640Xm+InA2vOyA64Kwx32aeCSdMAnRYm5RnwHfJKmA67hQQeM24EscRIwKWsQLS66EJE+n0zcAVvuDqHI8USC7u0Uw7tWtS6nMPCbKsdPAeb4qYbneKImBdH8oOaqCd6wvVI7VWB7TbDUjve0TELAp8HVTrD0NOACnm642lExPB2udoKlpxuudhTR1cw0m4zPAJNx2YH2GZnjtZiqnSow3MESDVwStVM7SszJ8WqntkbtJHugdnA7kCVqA5MymWhx0YWI9DnF8E5QkWMtgq4/1XC1o9YllYHfVDmeCszxNMNzPFGTYrk7BLJJSWf62U5l2F4T+7vjGZmEgDPgasdnZQCLINNwtaNimAlXOz4r03C1o4guPdNsMs5ionaQOZ7NVO1UhuH27nfHc6LEXCde7eRo1E4dD9QObgeyRA4wKesQLS66EJE+5xreCSpyzCbo+vMMVztqXfIY+E2V43nAHK9reI4nalIsd4dANin1mKqdSrC9JhKjdupnEgKuD1c7Eas+sAgsw9WOiqEFVzsRyzJc7Siiq5dpNhkLJmoHmeM+pmqnEgx3sWdqJz9KzP54tZOvUTt+D9QObgeyRD4wKf1Ei4suRKTPBYZ3goocfQRdf6HhaketSyEDv6lyvBCY4wHDczxRk2K5OwSySQkyVTtJsL2mMOaZGKFMQsAhuNopFCFgETQwXO2oGDaAq53CGL8tl4fObwTRBTPNJuOGTNQOMscbMVU7STDchZ49S6VxlJibxKudxhq108QDtYPbgSzRGJiUTYgWF12ISJ+bGt4JKnJsRND1NzNc7fyzLgz8psrxZsAcb254jidqUix3h0A2KS2Yqp2/YU97jgTteFtmEgJuif9sJ9gSWAStDFc7Koat8J/tBFsZrnYU0bXINJuMWzNRO8gcb8NU7fwN+22WSEADl0TtnBkl5rbxaudMjdpp64Hawe1AljgTmJRtM2kWF12ISJ/bGd4JKnJsQ9D1tzdc7ah1ac/Ab6ocbw/M8bMMz/FETYrl7hDIJuVspmpnD2yv8YfseM/JJAR8Dlzt+EPnAIvgXMPVjorhuXC14w+da7jaUUR3dqbZZHweE7WDzPEOTNXOHpja8Qc1cEnUzvlRYr4gXu2cr1E7F3igdvYA1c75wKS8IJNmcdGFiPS5o+GdoCLHDgRd/4WGqx21Lhcy8Jsqxy8E5vhFhud4oibFcncIZJNyMVO1sxu214Rj7mTrlEkIuBNc7YRFJ2ARXGK42lExvASudsIxflsuD53fCKK7ONNsMr6UidpB5vhlTNXObpjaCXt2J9vlUWLuHK92Lteonc4eqJ3dQLVzOTApO2fSLC66EJE+dzG8E1TkeBlB13+F4WpHrcsVDPymyvErgDl+peE5nqhJsdwdAtmkXMVU7ezCqZ1iO96iTELARXi1U1wELIKw4WpHxTCMVzvFYcPVjiK6qzLNJuNiJmoHmeMRpmpnF07thDVwSdROSZSYS+PVTolG7ZR6oHZ2AdVOCTApSzNpFhddiEifuxreCSpyjBB0/d0MVztqXbox8Jsqx7sBc7y74TmeqEmx3B0C2aRczVTt7MTdyRa24+2RSQi4B/5OtnAPYBH0NFztqBj2xN/JFu5puNpRRHd1ptlk3IuJ2kHmeG+mamcn7k62Ig1cErXTJ0rMfePVTh+N2unrgdrZCVQ7fYBJ2TeTZnHRhYj0uZ/hnaAix94EXX9/w9WOWpf+DPymyvH+wBwfYHiOJ2pSLHeHQDYpA5mqnR2wvSYY8wTqQZmEgAfB1U7QGgQsgsGGqx0Vw8FwtRO0BhuudhTRDcw0m4yHMFE7yBwfylTt7ICpnUCpBi6J2hkWJebh8WpnmEbtDPdA7ewAqp1hwKQcnkmzuOhCRPo8wvBOUJHjUIKuf6Thakety0gGflPl+Ehgjo8yPMcTNSmWu0Mgm5TRTNXOdiK1MyaTEPAYArUzBlgEYw1XOyqGYwnUzljD1Y4iutGZZpPxOCZqB5nj1zBVO9sZqp3xUWKeEK92xmvUzgQP1M52oNoZD0zKCUzUDtLniYZ3goocryHo+icZrnbUukxi4DdVjk8C5vhkw3M8UZNiuTsEskmZwlTt/AXba4pinsk2NZMQ8FS42ikKTQUWwTTD1Y6K4TS42ikKTTNc7Siim5JpNhlPZ6J2kDk+g6na+Qumdoo8eybbtVFivi5e7VyrUTvXeaB2/gKqnWuBSXldJs3iogsR6fP1hneCihxnEHT9NxiudtS63MDAb6ocvwGY4zcanuOJmhTL3SGQTcpNTNXONpza8dvx3pxJCPhmvNrx3wwsglsMVzsqhrfg1Y7/FsPVjiK6mzLNJuNbmagdZI7fxlTtbMOpnXwNXBK1c3uUmO+IVzu3a9TOHR6onW1AtXM7MCnvyKRZXHQhIn2+0/BOUJHjbQRd/12Gqx21Lncx8Jsqx+8C5vjdhud4oibFcncIZJNyD1O1sxX366Ixn+3cm0kI+F642omE7gUWwX2Gqx0Vw/vgaicSus9wtaOI7p5Ms8n4fiZqB5njDzBVO1txvy7q2Wc7D0aJ+aF4tfOgRu085IHa2QpUOw8Ck/KhTJrFRRci0ueHDe8EFTk+QND1P2K42lHr8ggDv6ly/BFgjj9qeI4nalIsd4dANimPMVU7W2B7TXGJHe/jmYSAH4erneKSx4FF8IThakfF8Am42ikuecJwtaOI7rFMs8n4SSZqB5njM5mqnS0wtVMc0cAlUTuzosQ8O17tzNKondkeqJ0tQLUzC5iUszNpFhddiEif5xjeCSpynEnQ9c81XO2odZnLwG+qHJ8LzPF5hud4oibFcncIZJPyFFO1sxm214iYz3bmZxICng9XOyI0H1gETxuudlQMn4arHRF62nC1o4juqUyzyXgBE7WDzPFnmKqdzTC1Izz7bGdhlJgXxaudhRq1s8gDtbMZqHYWApNyUSbN4qILEenzs4Z3goocnyHo+hcbrnbUuixm4DdVji8G5vgSw3M8UZNiuTsEsklZylTtbML9umiM2lmWSQh4GVzthEPLgEWw3HC1o2K4HK52wqHlhqsdRXRLM80m4+eYqB1kjj/PVO1swv26qGdq54UoMa+IVzsvaNTOCg/Uziag2nkBmJQrMmkWF12ISJ9fNLwTVOT4PEHXv9JwtaPWZSUDv6lyfCUwx18yPMcTNSmWu0Mgm5SXmaqdP3FPoA7a8b6SSQj4FbjaCQZfARbBq4arHRXDV+FqJxh81XC1o4ju5Uyzyfg1JmoHmeOvM1U7f8LUTjCggUuidt6IEvOb8WrnDY3aedMDtfMnUO28AUzKNzNpFhddiEif3zK8E1Tk+DpB1/+24WpHrcvbDPymyvG3gTm+yvAcT9SkWO4OgWxS3mGqdjbC9hp/jNp5N5MQ8LtwteMPvgssgvcMVzsqhu/B1Y4/+J7hakcR3TuZZpPx+0zUDjLHP2CqdjbC1I7fM7XzYZSYP4pXOx9q1M5HHqidjUC18yEwKT/KpFlcdCEiff7Y8E5QkeMHBF3/J4arHbUunzDwmyrHPwHm+KeG53iiJsVydwhkk/IZU7WzAbbXhIQd7+eZhIA/h6udkPgcWARfGK52VAy/gKudUIzflstD5zeC6D7LNJuMv2SidpA5/hVTtbMBpnZClgYuidr5OkrM38Srna81aucbD9TOBqDa+RqYlN9k0iwuuhCRPn9reCeoyPErgq7/O8PVjlqX7xj4TZXj3wFz/HvDczxRk2K5OwSySfmBqdpZD9trApYd74+ZhIB/hKudgPUjsAh+MlztqBj+BFc7Aesnw9WOIrofMs0m45+ZqB1kjv/CVO2sh6mdwlINXBK182uUmH+LVzu/atTObx6onfVAtfMrMCl/y6RZXHQhIn3+3fBOUJHjLwRd/2rD1Y5al9UM/KbK8dXAHF9jeI4nalIsd4dANilrmaqddbinFMQ8gfqPTELAf8DVTrjkD2ARrDNc7agYroOrnXDJOsPVjiK6tZlmk/F6JmoHmeMbmKqddbinFHj2BOqNUWL+M17tbNSonT89UDvrgGpnIzAp/8ykWVx0ISJ93mR4J6jIcQNB17/ZcLWj1mUzA7+pcnwzMMe3GJ7jiZoUy90hkE3KVqZq5w/YXuOL+WxnWyYh4G1wteOztgGL4C/D1Y6K4V9wteOz/jJc7Sii25ppNhlvZ6J2kDm+g6na+QP3BOpSDVwStbMzSsy74tXOTo3a2eWB2vkDqHZ2ApNyVybN4qILEenzbsM7QUWOOwi6/j2Gqx21LnsY+E2V43uAOf634TmeqEmx3B0C2aQkZfFUO2txe02xHW+lLELAanKs2pHgcQsoKmeZrXZUDBVGrNqxiitn0W4aCKJLyjKbjKtkYcm47ED7jMzxqkCfvVQ7a2Fqxwpr4JKonWpRYj4kKylW2VTL2l/tqBdRqx3gDiSqAZPykCyaxUUXItLnQ8Hkgy44RY5Vs/Abw2HEG5fl7hBqXQ5j4DdVjh8GzPHDDc/xRE2K5e4QyCblCKZqZw1srymMuZPtyCxCwEfC1U5hyZHAIjjKcLWjYngUXO0UlhxluNpRRHdEltlkfDQTtYPM8WOYqp01uO/teHYn27FRYq4er3aO1aid6h6onTVAtXMsMCmrZ9EsLroQkT4fZ3gnqMjxGIKu/3jD1Y5al+MZ+E2V48cDc/wEw3M8UZNiuTsEskk5kanaWQ3ba0TMM9lOyiIEfBJc7QhxErAIahiudlQMa8DVjojx23J56PxGEN2JWWaT8clM1A4yx09hqnZW4+5k8+yZbKdGiblmvNo5VaN2anqgdlYD1c6pwKSsmUWzuOhCRPp8muGdoCLHUwi6/tMNVztqXU5n4DdVjp8OzPEzDM/xRE2K5e4QyCalFlO18zvuZoyY7+3UziIEXDsLP2+y4QpF+Z2ctS/AoHlJVIUilFpZZpNeChNVgczLVGKiR6xJKkGOe0movxERaloWIeA0AkJNN5xQld/pHhGq5e4QqjDSs2gKDuW3l0X2awYuBna8GVmEgDMIdsQMIKNnGl6wKoaZBEWQafh7tKpIMwnkTwpwvbMMf7tA5U4WEdmXHejazgKuT7bhEj+RYrDcHQKpGHIMz3G1xjkEjRwyD1WTUCNp31vm9qN2ItzCOqjjzJr7zXWQM1lW2/i5Dnomy2oXO5eLmSyrfU2Hda7gzGclnqvCGM9ONNdBeHuOfq6Ditu5NctRF+Wc+bwDz1VujB0ONFcFvD3fea4Kxe2C8sSrnDN3LP9cB8R4YXnnKoe3F5VvrnLF7eKKxOsAM3eq+FwJMV5S0bkcvL20YnM5xu2yg4lXgpkvP/i59sPY+WDn0njb5eDm0sbtCjfxipv5Svdz/YvxKrdz2bwtcjdXTNzCiHhF542g5pIISzBz/eNrKc5HunsuLB/p/RxlPa/6Nzn6dx3Zt+ZKy5NWV1o9afWlWdKENJ+0fGl+aQXSCqUFpAWlhaQ1kNZQWiNpjaU1kdZU9cLSmktrIa2ltFbSWktrI+1MaW2ltYu/l6RO9L4R+1iuZixPM1ZXM1ZPM1ZfM2ZpxoRmzKcZy9eM+TVjBZqxQs1YQDMW1IyFNGMNNGMNNWONNGONNWNNNGNNNWPNNGPNNWMtNGMtNWOtNGOtNWNtNGNnasbaasbaZe1/j1LT6L/Nov/ai+dgjv/ElVWh4z9xVbGZ/xNXFZv5P3FVsZn/E1cVm/k/cVWxmf8TVxWbl4O4cvvmdx3AG+ll93XnguZSfuZB5tobs7ru5/JF4yXquZ3L/2/sRX13c1m2dRSWm7l8MTkhxMHPZcXll/Ad5FyFpfvlqsg/uLmCmrwX/oOZK6itIVFQ8bkCCepRFFZ0rkDC2haBis3lc+AJEazIXAFHzhGh8s9VfAD+Eg3KO1fggFwoGpZvLqscvCoalWcuq1wcLRofeK6CcvK9aHKgufzl3jtEU8e5/KUV2IdEM6e5AhXa00TzxHMFK7g/ihYJ5gqVVnivFS31c1kHsW+LVrq5rIPqAUTr/ecSB9lPiDbxc0UOujcRZ8bOle+izxFtbXP5Sl31TKId0zsU28F6vUjMt8jbZxECbp+F/hZ5RLTHLaA4CxBUyjsUVQzPAt6hWBbDs8BF4NW3gXHFG/Hs28BnRwvsnPhPcM7O2v/bwOdk0X8bGMckljgbWEDngBcXnXyqaM4GFmOZ32cz3ZHawvIoFLHjPTeLEPC58B0pFDkXuCOdZ/iOpGJ4HnxHCkXOY7ojtYXhDhVr4JLsSB2iBXZ+/I7UQbMjne/BjtQWuCN1ABbQ+USLiyKgMpxIny8AkllSEn63PCtKQJXBOYiUAh2BZKaLoeXuEGqNOxJ0Mh2ZdjJnwvgnnG/He2EWIeAL4Z1MOP9CYPFfZHgno2J4EbyTCedfRFz8CALtaDiBXgyOYdmB3niROd4JWHtedsBnwnCHfRq4JB3wJVFivjS+A75E0wFf6kEHjNuBLHEJMCkvJVpcdCEifb6MuAO23B1CkWMngu7tcsO7VrUulzPwmyrHLwfmeGfDczxRk4JoflBzdQFv2F6pnTawvSZYasd7RRYh4CvgaidYegVwAa80XO2oGF4JVzvB0isNVzuK6LpkmU3GV4HJuOxA+4zM8SKmaqcNDHewRAOXRO2Eo8RcHK92whq1U+yB2sHtQJYIA5OymGhx0YWI9DlieCeoyLGIoOsvMVztqHUpYeA3VY6XAHO81PAcT9SkWO4OgWxSujL9bKc1bK/xxTzZsVsWIeBucLXjs7oBi6C74WpHxbA7XO34rO6Gqx1FdF2zzCbjq5moHWSO92CqdlrDcItSDVwStdMzSsy94tVOT43a6eWB2sHtQJboCUzKXkSLiy5EpM+9De8EFTn2IOj6+xiudtS69GHgN1WO9wHmeF/DczxRk2K5OwSySenHVO20gu01kRi10z+LEHB/uNqJWP2BRTDAcLWjYjgArnYi1gDD1Y4iun5ZZpPxQCZqB5njg5iqnVYw3MWeqZ3BUWIeEq92BmvUzhAP1A5uB7LEYGBSDiFaXHQhIn0eangnqMhxEEHXP8xwtaPWZRgDv6lyfBgwx4cbnuOJmhTL3SGQTcoIpmqnJWyvKYx5JsbILELAI+Fqp1CMBBbBKMPVjorhKLjaKYzx23J56PxGEN2ILLPJeDQTtYPM8TFM1U5LGO5Cz56lMjZKzOPi1c5YjdoZ54Hawe1AlhgLTMpxRIuLLkSkz9cY3gkqchxD0PWPN1ztqHUZz8BvqhwfD8zxCYbneKImxXJ3CGSTMpGp2mmB+2wnaMc7KYsQ8CT8ZzvBScAimGy42lExnIz/bCc42XC1o4huYpbZZDyFidpB5vhUpmqnBQx3JKCBS6J2pkWJeXq82pmmUTvTPVA7uB3IEtOASTmdaHHRhYj0eYbhnaAix6kEXf+1hqsdtS7XMvCbKsevBeb4dYbneKImxXJ3CGSTcj1TtdMcttf4Q3a8N2QRAr4Brnb8oRuARXCj4WpHxfBGuNrxh240XO0oors+y2wyvomJ2kHm+M1M1U5zGG5/UAOXRO3cEiXmW+PVzi0atXOrB2oHtwNZ4hZgUt5KtLjoQkT6fJvhnaAix5sJuv7bDVc7al1uZ+A3VY7fDszxOwzP8URNiuXuEMgm5U6maqcZbK8Jx9zJdlcWIeC74GonLO4CFsHdhqsdFcO74WonHOO35fLQ+Y0gujuzzCbje5ioHWSO38tU7TSD4Q57difbfVFivj9e7dynUTv3e6B2cDuQJe4DJuX9RIuLLkSkzw8Y3gkqcryXoOt/0HC1o9blQQZ+U+X4g8Acf8jwHE/UpFjuDoFsUh5mqnaa4tROsR3vI1mEgB/Bq53iR4BF8KjhakfF8FG82il+1HC1o4ju4SyzyfgxJmoHmeOPM1U7TXENcVgDl0TtPBEl5ifj1c4TGrXzpAdqB7cDWeIJYFI+SbS46EJE+jzT8E5QkePjBF3/LMPVjlqXWQz8psrxWcAcn214jidqUix3h0A2KXOYqp0muDvZwna8c7MIAc/F38kWngssgnmGqx0Vw3n4O9nC8wxXO4ro5mSZTcZPMVE7yByfz1TtNMHd7FSkgUuidp6OEvOCeLXztEbtLPBA7eB2IEs8DUzKBUSLiy5EpM/PGN4JKnKcT9D1LzRc7ah1WcjAb6ocXwjM8UWG53iiJsVydwhkk/IsU7XTGLbXBGOeQL04ixDwYrjaCVqLgUWwxHC1o2K4BK52gtYSw9WOIrpns8wm46VM1A4yx5cxVTuNYbgDnj2BenmUmJ+LVzvLNWrnOQ/UDm4HssRyYFI+R7S46EJE+vy84Z2gIsdlBF3/C4arHbUuLzDwmyrHXwDm+ArDczxRk2K5OwSySXmRqdppRKR2VmYRAl5JoHZWAovgJcPVjorhSwRq5yXD1Y4iuhezzCbjl5moHWSOv8JU7TRiqHZejRLza/Fq51WN2nnNA7WD24Es8SowKV9jonaQPr9ueCeoyPEVgq7/DcPVjlqXNxj4TZXjbwBz/E3DczxRk2K5OwSySXmLqdppCNtrimKeyfZ2FiHgt+Fqpyj0NrAIVhmudlQMV8HVTlFoleFqRxHdW1lmk/E7TNQOMsffZap2GsJwF3n2TLb3osT8frzaeU+jdt73QO3gdiBLvAdMyveJFhddiEifPzC8E1Tk+C5B1/+h4WpHrcuHDPymyvEPgTn+keE5nqhJsdwdAtmkfMxU7TTAqR2/He8nWYSAP8GrHf8nwCL41HC1o2L4KV7t+D81XO0oovs4y2wy/oyJ2kHm+OdM1U4DXEOcr4FLona+iBLzl/Fq5wuN2vnSA7WD24Es8QUwKb8kWlx0ISJ9/srwTlCR4+cEXf/XhqsdtS5fM/CbKse/Bub4N4bneKImxXJ3CGST8i1TtROC7TWRmM92vssiBPwdXO1EQt8Bi+B7w9WOiuH3cLUTCX1vuNpRRPdtltlk/AMTtYPM8R+Zqp0QDHfEs892fooS88/xaucnjdr52QO1g9uBLPETMCl/JlpcdCEiff7F8E5QkeOPBF3/r4arHbUuvzLwmyrHfwXm+G+G53iiJsVydwhkk/I7U7UThO01xSV2vKuzCAGvhqud4pLVwCJYY7jaUTFcA1c7xSVrDFc7iuh+zzKbjNcyUTvIHP+DqdoJwnAXRzRwSdTOuigxr49XO+s0ame9B2oHtwNZYh0wKdcTLS66EJE+bzC8E1Tk+AdB17/RcLWj1mUjA7+pcnwjMMf/NDzHEzUplrtDIJuUTUzVTgC214iYz3Y2ZxEC3gxXOyK0GVgEWwxXOyqGW+BqR4S2GK52FNFtyjKbjLcyUTvIHN/GVO0EYLiFZ5/t/BUl5u3xaucvjdrZ7oHawe1AlvgLmJTbiRYXXYhIn3cY3gkqctxG0PXvNFztqHXZycBvqhzfCczxXYbneKImxXJ3CGSTspup2imE7TXhGLWzJ4sQ8B642gmH9gCL4G/D1Y6K4d9wtRMO/W242lFEtzvLbDJOyuahdpA5Xgnos5dqpxCW72HP1E7l7L3/VslOilU26kS82lEvolY7uB3IEpWzcUlZJZtmcdGFiPS5Kph80AWnyLFSNn5jqJZNu3FZ7g6h1qUaA7+pcrwaMMcPMTzHEzUplrtDIJuUQ4F546XaKYDtNcGgHe9h2YSA1eRYtRMMHgYsgsOBxUkVw8Oz0WonGDyceNNAEN2h2WaT8RFM1A4yx49kqnYKYGonGNDAJVE7R0WJ+eh4tXOURu0c7YHaKQCqnaOASXl0Ns3iogsR6fMxhneCihyPJOj6jzVc7ah1OZaB31Q5fiwwx6sbnuOJmhTL3SGQTcpxTNWOH7bX+GPUzvHZhICPh6sdf/B4YBGcYLjaUTE8Aa52/METDFc7iuiOyzabjE9konaQOX4SU7Xjh6kdv2dqp0aUmE+OVzs1NGrnZA/Ujh+odmoAk/LkbJrFRRci0udTDO8EFTmeRND1n2q42lHrcioDv6ly/FRgjtc0PMcTNSmWu0Mgm5TTmKqdfNheExJ2vKdnEwI+Ha52QuJ0YBGcYbjaUTE8A652QjF+Wy4Pnd8Iojst22wyrsVE7SBzvDZTtZMPUzshSwOXRO0kR4k5JV7tJGvUTooHaicfqHaSgUmZkk2zuOhCRPqcangnqMixNkHXn2a42lHrksbAb6ocTwPmeLrhOZ6oSbHcHQLZpGQwVTs+2F4TsOx4M7MJAWfC1U7AygQWQZbhakfFMAuudgJWluFqRxFdRrbZZJzNRO0gczyHqdrxwdROYakGLonaqRMl5tx4tVNHo3ZyPVA7PqDaqQNMytxsmsVFFyLS5zzDO0FFjjkEXX9dw9WOWpe6DPymyvG6wByvZ3iOJ2pSLHeHQDYp9ZmqHYF7SkHME6itbELAFlzthEssYBEIw9WOiqGAq51wiTBc7Siiq59tNhn7mKgdZI7nM1U7AveUAs+eQO2PEnNBvNrxa9ROgQdqRwDVjh+YlAXZNIuLLkSkz4WGd4KKHPMJuv6A4WpHrUuAgd9UOR4A5njQ8BxP1KRY7g6BbFJCTNWOBdtrfDGf7TTIJgTcAK52fFYDYBE0NFztqBg2hKsdn9XQcLWjiC6UbTYZN2KidpA53pip2rFwDyn27LOdJlFibhqvdppo1E5TD9SOBVQ7TYBJ2TSbZnHRhYj0uZnhnaAix8YEXX9zw9WOWpfmDPymyvHmwBxvYXiOJ2pSLHeHQDYpLZmqnfq4vabYjrdVNiHgVnC1YxW3AhZBa8PVjopha7jasYpbG652FNG1zDabjNswUTvIHD+Tqdqpj3vielgDl0TttI0Sc7t4tdNWo3baeaB2gDuQaAtMynbZNIuLLkSkz+0N7wQVOZ5J0PWfZbjaUetyFgO/qXL8LGCOn214jidqUix3h0A2KecwVTv1YHtNYcydbOdmEwI+F652CkvOBRbBeYarHRXD8+Bqp7DkPMPVjiK6c7LNJuMOTNQOMsfPZ6p26uG+t+PZnWwXRIm5Y7zauUCjdjp6oHbqAdXOBcCk7JhNs7joQkT6fKHhnaAix/MJuv6LDFc7al0uYuA3VY5fBMzxiw3P8URNiuXuEMgmpRNTtVMXtteImGeyXZJNCPgSuNoR4hJgEVxquNpRMbwUrnZEjN+Wy0PnN4LoOmWbTcaXMVE7yBy/nKnaqYu7k82zZ7J1jhJzl3i101mjdrp4oHbqAtVOZ2BSdsmmWVx0ISJ9vsLwTlCR4+UEXf+VhqsdtS5XMvCbKsevBOb4VYbneKImxXJ3CGSTUsRU7eThbsaI+d5OOJsQcDgbP2+x4QpF+V2cvS/AoHlJVIUilKJss0kvwkRVIPOyhJjoEWtSQpDjXhJqLhGhlmYTAi4lINSuhhOq8rurR4RquTuEKoyu2TQFh/LbyyKrA/xdeDvebtmEgLsR7IjdgIze3fCCVTHsTlAE3Q1/j1YVaXcC+RMBrvfVhr9doHLnaiKyLzvQtX01cH16GC7xEykGy90hkIqhp+E5rta4J0Ejh8xD1STUSNr3lrn9gMcjiabOk6A4faSfc1SyxTY5+ncvuZ69pfWR1ldaP2n9pQ2QNlDaIGmDpQ2RNlTaMGnDpY2QNlLaKGmjpY2RNlbaOGnXSBsvbYK0idImSZssbYq0qdKmSZsubUb8Zyy9op+n2Md6a8b6aMb6asb6acb6a8YGaMYGasYGacYGa8aGaMaGasaGacaGa8ZGaMZGasZGacZGa8bGaMbGasbGacau0YyN14xN0IxN1IxN0oxN1oxN0YxN1YxN04xN14zNyN7/s7uU6L/Nov9a7o4Y0nFLlr0AxFv2OWBv0FzKxz6QufbGq6/7uXzReIl+bufy/xt70d/dXJZtHcUAN3P5YnJCDDz4uay4/BKDDnKuwtL9clUMPri5gpq8F0MOZq6gtobE0IrPFUhQj2JYRecKJKxtMbxic/kceEKMqMhcAUfOESPLP1fxAfhLjCrvXIEDcqEYXb65rHLwqhhTnrmscnG0GHvguQrKyfdi3IHm8pd77xDXOM7lL63APiTGO80VqNCeJiYknitYwf1RTEwwV6i0wnutmKSfyzqIfVtM1s1lHVQPIKbsP5c4yH5CTI2fK3LQvYmYFjtXvos+R0y3zeUrddUziRnZPN/RngHr9SIxdx1fm00IWE2OeterDPy1uAUU1wGCSvmOtoqhwoi96zgS47fl8vDy7lFc8UY8u3v0+miB3ZCdFKs2r8/e/+7RG7Lp7x7FMYklrgcW0A3gxUUnnyqa64HFWOb39Ux3pOmwPApF7HhvzCYEfCN8RwpFbgTuSDcZviOpGN4E35FCkZuY7kjTYbhDxRq4JDvSzdECuyV+R7pZsyPd4sGONB24I90MLKBbiBYX/UEw0udbgWSWlITfLa+LEhD6g2CkFLgNSGa6GFruDqHW+DaCTuY2pp3MNBj/hPPteG/PJgR8O7yTCeffDiz+OwzvZFQM74B3MuH8O4iLH0GgtxlOoHeCY1h2oDdeZI7fBaw9LzvgaTDcYZ8GLkkHfHeUmO+J74Dv1nTA93jQAeN2IEvcDUzKe4gWF12ISJ/vJe6ALXeHUOR4F0H3dp/hXatal/sY+E2V4/cBc/x+w3M8UZOCaH5Qcz0A3rC9UjtTYXtNsNSO98FsQsAPwtVOsPRB4AI+ZLjaUTF8CK52gqUPGa52FNE9kG02GT8MJuOyA+0zMscfYap2psJwB0s0cEnUzqNRYn4sXu08qlE7j3mgdnA7kCUeBSblY0SLiy5EpM+PG94JKnJ8hKDrf8JwtaPW5QkGflPl+BPAHH/S8BxP1KRY7g6BbFJmMv1sZwpsr4n93fFZ2YSAZ8HVjs+aBSyC2YarHRXD2XC147NmG652FNHNzDabjOcwUTvIHJ/LVO1MgeH27nfH50WJ+al4tTNPo3ae8kDt4HYgS8wDJuVTRIuLLkSkz/MN7wQVOc4l6PqfNlztqHV5moHfVDn+NDDHFxie44maFMvdIZBNyjNM1c5k2F4TiVE7C7MJAS+Eq52ItRBYBIsMVzsqhovgaidiLTJc7SiieybbbDJ+lonaQeb4YqZqZzIMd7FnamdJlJiXxqudJRq1s9QDtYPbgSyxBJiUS4kWF12ISJ+XGd4JKnJcTND1Lzdc7ah1Wc7Ab6ocXw7M8ecMz/FETYrl7hDIJuV5pmpnEmyvKYx5JsYL2YSAX4CrnULxArAIVhiudlQMV8DVTmGM35bLQ+c3guiezzabjF9konaQOb6SqdqZBMNd6NmzVF6KEvPL8WrnJY3aedkDtYPbgSzxEjApXyZaXHQhIn1+xfBOUJHjSoKu/1XD1Y5al1cZ+E2V468Cc/w1w3M8UZNiuTsEskl5nanamYj7bCdox/tGNiHgN/Cf7QTfABbBm4arHRXDN/Gf7QTfNFztKKJ7PdtsMn6LidpB5vjbTNXORBjuSEADl0TtrIoS8zvxameVRu2844Hawe1AllgFTMp3iBYXXYhIn981vBNU5Pg2Qdf/nuFqR63Lewz8psrx94A5/r7hOZ6oSbHcHQLZpHzAVO1MgO01/pAd74fZhIA/hKsdf+hDYBF8ZLjaUTH8CK52/KGPDFc7iug+yDabjD9monaQOf4JU7UzAYbbH9TAJVE7n0aJ+bN4tfOpRu185oHawe1AlvgUmJSfES0uuhCRPn9ueCeoyPETgq7/C8PVjlqXLxj4TZXjXwBz/EvDczxRk2K5OwSySfmKqdoZD9trwjF3sn2dTQj4a7jaCYuvgUXwjeFqR8XwG7jaCcf4bbk8dH4jiO6rbLPJ+FsmageZ498xVTvjYbjDnt3J9n2UmH+IVzvfa9TODx6oHdwOZInvgUn5A9HiogsR6fOPhneCihy/I+j6fzJc7ah1+YmB31Q5/hMwx382PMcTNSmWu0Mgm5RfmKqda3Bqp9iO99dsQsC/4tVO8a/AIvjNcLWjYvgbXu0U/2a42lFE90u22WT8OxO1g8zx1UzVzjW4hjisgUuidtZEiXltvNpZo1E7az1QO7gdyBJrgEm5lmhx0YWI9PkPwztBRY6rCbr+dYarHbUu6xj4TZXj64A5vt7wHE/UpFjuDoFsUjYwVTvjcHeyhe14N2YTAt6Iv5MtvBFYBH8arnZUDP/E38kW/tNwtaOIbkO22WS8iYnaQeb4ZqZqZxzuZqciDVwStbMlSsxb49XOFo3a2eqB2sHtQJbYAkzKrUSLiy5EpM/bDO8EFTluJuj6/zJc7ah1+YuB31Q5/hcwx7cbnuOJmhTL3SGQTcoOpmpnLGyvCcY8gXpnNiHgnXC1E7R2Aotgl+FqR8VwF1ztBK1dhqsdRXQ7ss0m491M1A4yx/cwVTtjYbgDnj2B+u8yYs5JilU2f2vUjnoRtdrB7UCW+BtJvDk0i4suRKTPlXKw5IMuOEWOewi6/so5tBuX5e4Qal0URtP9pspxO063c1UxPMcTNSmWu0Mgm5SqwLzxUu2MIVI71XIIAavJ0WqnGrAIDgEWJ1UMD8nBq51DiDcNBNFVzTGbjA8Fk3HZgfYZmeOHAX32Uu2MYah2Do8S8xHxaufwnP3VzhEeqJ0xQLVzODApj2CidpA+H2l4J6jI8TCCrv8ow9WOWpejGPhNleNHAXP8aMNzPFGTYrk7BLJJOYap2hkN22uKYp7JdmwOIeBj4WqnKHQssAiqG652VAyrw9VOUai64WpHEd0xOWaT8XFM1A4yx49nqnZGw9ROkWfPZDshSswnxqudEzRq50QP1M5ooNo5AZiUJ+bQLC66EJE+n2R4J6jI8XiCrr+G4WpHrUsNBn5T5XgNYI6fbHiOJ2pSLHeHQDYppzBVO6Nwasdvx3tqDiHgU/Fqx38qsAhqGq52VAxr4tWOv6bhakcR3Sk5ZpPxaUzUDjLHT2eqdkbh1E6+Bi6J2jkjSsy14tXOGRq1U8sDtTMKqHbOACZlrRyaxUUXItLn2oZ3goocTyfo+pMNVztqXZIZ+E2V48nAHE8xPMcTNSmWu0Mgm5RUpmpnJGyvicR8tpOWQwg4Da52IqE0YBGkG652VAzT4WonEko3XO0ookvNMZuMM5ioHWSOZzJVOyNhaifi2Wc7WVFizo5XO1katZPtgdoZCVQ7WcCkzM6hWVx0ISJ9zjG8E1TkmEnQ9dcxXO2odanDwG+qHK8DzPFcw3M8UZNiuTsEsknJY6p2RsD2muISO966OYSA68LVTnFJXWAR1DNc7agY1oOrneKSeoarHUV0eTlmk3F9JmoHmeMWU7UzAqZ2iiMauCRqR0SJ2RevdoRG7fg8UDsjgGpHAJPSl0OzuOhCRPqcb3gnqMjRIuj6/YarHbUufgZ+U+W4H5jjBYbneKImxXJ3CGSTUshU7QyH7TUi5rOdQA4h4ABc7YhQAFgEQcPVjophEK52RChouNpRRFeYYzYZh5ioHWSON2CqdobD1I7w7LOdhlFibhSvdhpq1E4jD9TOcKDaaQhMykY5NIuLLkSkz40N7wQVOTYg6PqbGK521Lo0YeA3VY43AeZ4U8NzPFGTYrk7BLJJacZU7QyD7TXhGLXTPIcQcHO42gmHmgOLoIXhakfFsAVc7YRDLQxXO/8QXY7ZZNySidpB5ngrpmpnGO4HKD1TO62jxNwmXu201qidNh6onWFAtdMamJRtcmgWF12ISJ/PNLwTVOTYiqDrb2u42lHr0paB31Q53haY4+0Mz/FETYrl7hDIJqU9U7UzFPcE6qAd71k5hIDPgqudYPAsYBGcbbjaUTE8G652gsGzDVc7iuja55hNxucwUTvIHD+XqdoZClM7wYAGLonaOS9KzB3i1c55GrXTwQO1MxSods4DJmWHHJrFRRci0ufzDe8EFTmeS9D1X2C42lHrcgEDv6ly/AJgjnc0PMcTNSmWu0Mgm5QLmaqdIbC9xh+jdi7KIQR8EVzt+IMXAYvgYsPVjorhxXC14w9ebLjaUUR3YY7ZZNyJidpB5vglTNXOEJja8Xumdi6NEvNl8WrnUo3aucwDtTMEqHYuBSblZTk0i4suRKTPlxveCSpyvISg6+9suNpR69KZgd9UOd4ZmONdDM/xRE2K5e4QyCblCqZqZzBsrwkJO94rcwgBXwlXOyFxJbAIrjJc7agYXgVXO6EYvy2Xh85vBNFdkWM2GRcxUTvIHA8zVTuDYWonZGngkqid4igxR+LVTrFG7UQ8UDuDgWqnGJiUkRyaxUUXItLnEsM7QUWOYYKuv9RwtaPWpZSB31Q5XgrM8a6G53iiJsVydwhkk9KNqdoZBNtrApYdb/ccQsDd4WonYHUHFsHVhqsdFcOr4WonYF1tuNpRRNctx2wy7sFE7SBzvCdTtTMIpnYKSzVwSdROrygx945XO700aqe3B2pnEFDt9AImZe8cmsVFFyLS5z6Gd4KKHHsSdP19DVc7al36MvCbKsf7AnO8n+E5nqhJsdwdAtmk9GeqdgbinlIQ8wTqATmEgAfA1U64ZACwCAYarnZUDAfC1U64ZKDhakcRXf8cs8l4EBO1g8zxwUzVzkDcUwo8ewL1kCgxD41XO0M0ameoB2pnIFDtDAEm5dAcmsVFFyLS52GGd4KKHAcTdP3DDVc7al2GM/CbKseHA3N8hOE5nqhJsdwdAtmkjGSqdgbA9hpfzGc7o3IIAY+Cqx2fNQpYBKMNVzsqhqPhasdnjTZc7SiiG5ljNhmPYaJ2kDk+lqnaGYB7ArVnn+2MixLzNfFqZ5xG7VzjgdoZAFQ744BJeU0OzeKiCxHp83jDO0FFjmMJuv4JhqsdtS4TGPhNleMTgDk+0fAcT9SkWO4OgWxSJjFVO/1xe02xHe/kHELAk+FqxyqeDCyCKYarHRXDKXC1YxVPMVztKKKblGM2GU9lonaQOT6NqdrpD1M7VlgDl0TtTI8S84x4tTNdo3ZmeKB2gDuQmA5Myhk5NIuLLkSkz9ca3gkqcpxG0PVfZ7jaUetyHQO/qXL8OmCOX294jidqUix3h0A2KTcwVTv9YHtNYcydbDfmEAK+Ea52CktuBBbBTYarHRXDm+Bqp7DkJsPVjiK6G3LMJuObmagdZI7fwlTt9MN9b8ezO9lujRLzbfFq51aN2rnNA7XTD6h2bgUm5W05NIuLLkSkz7cb3gkqcryFoOu/w3C1o9blDgZ+U+X4HcAcv9PwHE/UpFjuDoFsUu5iqnb6wvYaEfNMtrtzCAHfDVc7QtwNLIJ7DFc7Kob3wNWOiPHbcnno/EYQ3V05ZpPxvUzUDjLH72Oqdvri7mTz7Jls90eJ+YF4tXO/Ru084IHa6QtUO/cDk/KBHJrFRRci0ucHDe8EFTneR9D1P2S42lHr8hADv6ly/CFgjj9seI4nalIsd4dANimPMFU7fXA3Y8R8b+fRHELAj+bg533McIWi/H4sZ1+AQfOSqApFKI/kmE16jzNRFci8fIKY6BFr8gRBjntJqL2JCPXJHELATxIQ6kzDCVX5PdMjQrXcHUIVxswcmoJD+e1lkfXKxsXAjndWDiHgWQQ74iwgo882vGBVDGcTFMFsw9+jVUU6m0D+PA5c7zmGv12gcmcOEdmXHejangNcn7mGS/xEisFydwikYphneI6rNZ5H0Mgh81A1CdWT9r1lrrB+lxR7oPE3TsXXOxpjIwYYGzLA2IABxhADjEEGGAMMMBYywFjAAKOfAcZ8Bhh9DDAKBhgtBhjrM8BYjwHGugww5jHAmMsAYx0GGHMYYMxmgDGLAcZMBhgzGGBMZ4AxjQHGVAYYUxhgTGaAsTYDjLUYYBybZj7GMQwwjmaAcRQDjCMZYBzBAONwBhiHMcA4lAHGIQwwDmaAcRADjAMZYBzAAGN/Bhj7McDYlwHGPgww9maAsRcDjD0ZYOzBAOPVDDB2Z4CxGwOMXRlgLGWAsYQBxggDjMUMMIYZYCxigPGldPMxrmSA8UUGGFcwwPgCA4zPM8D4HAOMyxlgXMYA41IGGJcwwLiYAcZnGWBcxADjQgYYn2GAcQEDjE8zwDifAcanGGCcxwDjXAYY5zDAOJsBxlkMMM5kgPFJBhifYIDxcQYYH2OA8VEGGB9hgPGQTPMxVmOAsSoDjFUYYKzMAGMlBhiTGGD8O8N8jHsYYNzNAOMuBhh3MsC4gwHG7Qww/sUA4zYGGLcywLiFAcbNDDBuYoDxTwYYNzLAuIEBxvUMMK5jgPEPBhjXMsC4hgHG1Qww/s4A428MMP7KAGO7LPMxtmWA8UwGGNswwNiaAcZWDDC2ZICxBQOMzRlgbMYAY1MGGJswwNiYAcZGDDA2ZICxAQOMIQYYgwwwBhhgLGSAsYABRj8DjPkMMPoYYBQMMFoMMNZngLEeA4x1GWDMY4AxlwHGOgQYk7AYgzTzFodo5i0ooZk3mE8zb34hzbyWjygOROtmEcW3iCh/w0Tx9RfRzFtKlGeCaN6woJk3nyi+RaU08xYS8VmYaN4iKj4rppk3QpRngTDNvH4i/vUHaOYtKaCZV/iJ8BLtQ4VU/RkRnwWI8ixAFIfgv3WM7tFnAH8RnQrjdAYYpzHAOJUBxikMME5mgHESA4wTGWCcwADjeAYYr2GAcRwDjGMZYBzDAONoBhhHMcA4kgHGEQwwDmeAcRgDjEMZYBzCAONgBhgHMcA4kAHGAQww9meAsR8DjH0ZYOzDAGNvBhh7EWC0H5i5SwjntqzKtthWj/79VE5S0nxpT0tbIO0ZaQulLZL2rLTF0pZIWyptmbTl0p6T9ry0F3L2zrEiJzpplei/atLkuLH5mrGnNWMLNGPPaMYWasYWacae1Ywt1owt0Ywt1Ywt04wt14w9pxl7XjP2gmZsRXTMflTBJoNolAqaS1hWY9tc+Vah318S8JWIfFFk+ULhYIHlLwgXBkVQFAQLIr5gfn5J0B8MhMKhgBUS/vwSUVoQyi+NTvdiDi7h7TF9URPTysiYiljsbuOwkigOKz3IrYapuLlWAmP6ElFMX/Igt14CxuFloji87EFuNQDm1svAmL5CFNNXqHNLPUzZ0DhQ5lEQuP+FgPvfq0R59KoHHPUqMI9eI4rDax5wVADIUa8BY/o6UUxf9yC3XgfG4Q2iOLzhQW4VAnPrDWBM3ySK6Zse7H/zDY0DZR75gftfAXD/e4soj97ygKPeAubR20RxeNsDjsoHctTbwJiuIorpKg9yaxUwDu8QxeEdD3LLB8ytd4AxfZcopu96sP89bWgcKPPIAu5/Arj/vUeUR+95wFHvAfPofaI4vO8BR9UHctT7wJh+QBTTDzzIrQ+AcfiQKA4fepBb9YC59SEwph8RxfQjD/a/BYbGgTKP8oD7X13g/vcxUR597AFHfQzMo0+I4vCJBxyVC+SoT4Ax/ZQopp96kFufAuPwGVEcPvMgt+oAc+szYEw/J4rp5x7sf88YGgfKPMoG7n85wP3vC6I8+sIDjvoCmEdfEsXhSw84KgvIUV8CY/oVUUy/8iC3vgLG4WuiOHztQW5lAnPra2BMvyGK6Tce7H8LDY0DZR6lA/e/DOD+9y1RHn3rAUd9C8yj74ji8J0HHJUG5KjvgDH9niim33uQW98D4/ADURx+8CC3UoG59QMwpj8SxfRHD/a/RYbGgTKPkoH7Xwpw//uJKI9+8oCjfgLm0c9EcfjZA46qDeSon4Ex/YUopr94kFu/AOPwK1EcfvUgt2oBc+tXYEx/I4rpbx7sf88aGgfKPBqThqvNsWm4+P1OlEe/e8BRvwPzaDVRHFZ7wFGj03BzrQbGdA1RTNd4kFtrgHFYSxSHtR7k1ihgbq0FxvQPopj+4cH+t9jQOFDm0Qjg/jcSuP+tI8qjdR5w1DpgHq0nisN6DzhqOJCj1gNjuoEophs8yK0NwDhsJIrDRg9yaxgwtzYCY/onUUz/9GD/W2JoHCjzaAhw/xsK3P82EeXRJg84ahMwjzYTxWGzBxw1GMhRm4Ex3UIU0y0e5NYWYBy2EsVhqwe5NQiYW1uBMd1GFNNtHux/Sw2NA2UeDQDufwOB+99fRHn0lwcc9Rcwj7YTxWG7BxzVH8hR24Ex3UEU0x0e5NYOYBx2EsVhpwe51Q+YWzuBMd1FFNNdHux/ywyNA2Ue9QHuf32B+99uojza7QFH7Qbm0R6iOOzxgKN6AzlqDzCmfxPF9G8PcutvYByS6tDEQc2bTJxbvYC5ZY+D25hWIopppTr0+9/yHDPjQJlHPYD7X0/g/leZKI8q16HnqMrAeqpCFIcqHnDU1UCOqgKMaVWimFb1ILeqAuNQjSgO1TzIre7A3KoGjOkhRDE9xIP977kcM+NAmUddgftfN+D+dyhRHh3qAUcdCqynw4jicJgHHFUK5KjDgDE9nCimh3uQW4cD43AEURyO8CC3SoC5dQQwpkcSxfRID/a/53PMjANlHhUD978IcP87iiiPjvKAo44C1tPRRHE42gOOCgM56mhgTI8hiukxHuTWMcA4HEsUh2M9yK0iYG4dC4xpdaKYVvdg/3shx9w4nJC0/28q2n9L0f4bivbfTrT/ZqL9txLtv5Fo/21E+28i2n8L0f4biPbfPrT/5qH9tw7tv3Fo/23DN07Z9/ebtr/fsv39tu3vVba/37H9/a7t7/eifx8nY368tBOknSjtJGk1pJ0s7RRpVZP2/uBlWS2qa79Lij0qgXPK/puIlsuDCmMjBhgbMsDYgAHGEAOMQQYYAwwwFjLAWMAAo58BxnwGGH0MMAoGGC0GGOszwFiPAca6DDDmMcCYywBjHQYYcxhgzGaAMYsBxkwGGDMYYExngDGNAcZUBhhTGGBMZoCxNgOMtRhgHJtmPsYxDDCOZoBxFAOMIxlgHMEA43AGGIcxwDiUAcYhDDAOZoBxEAOMAxlgHMAAY38GGPsxwNiXAcY+DDD2ZoCxFwOMPRlg7MEA49UMMHZngLEbA4xdGWAsZYCxhAHGCAOMxQwwhhlgLGKA8aV08zGuZIDxRQYYVzDA+AIDjM8zwPgcA4zLGWBcxgDjUgYYlzDAuJgBxmcZYFzEAONCBhifYYBxAQOMTzPAOJ8BxqcYYJzHAONcBhjnMMA4mwHGWQwwzmSA8UkGGJ9ggPFxBhgfY4DxUQYYH2GA8ZBM8zFWY4CxKgOMVRhgrMwAYyUGGJMYYPw7w3yMexhg3M0A4y4GGHcywLiDAcbtDDD+xQDjNgYYtzLAuIUBxs0MMG5igPFPBhg3MsC4gQHG9QwwrmOA8Q8GGNcywLiGAcbVDDD+zgDjbwww/soAY7ss8zG2ZYDxTAYY2zDA2JoBxlYMMLZkgLEFA4zNGWBsxgBjUwYYmzDA2JgBxkYMMDZkgLEBA4whBhiDDDAGGGAsZICxgAFGPwOM+Qww+hhgFAwwWgww1meAsR4DjHUZYMxjgDGXAcY6BBiTsBiDNPMWh2jmLSihmTeYTzNvfiHNvJaPKA5E62YRxbeIKH/DRPH1F9HMW0qUZ4Jo3rCgmTefKL5FpTTzFhLxWZho3iIqPiummTdClGeBMM28fiL+9Qdo5i0poJlX+InwEu1DhVT9GRGfBYjyLEAUh+C/dYzu0Wdkm68jpjPAOI0BxqkMME5hgHEyA4yTGGCcyADjBAYYxzPAeA0DjOMYYBzLAOMYBhhHM8A4igHGkQwwjmCAcTgDjMMYYBzKAOMQBhgHM8A4iAHGgQwwDmCAsT8DjP0YYOzLAGMfBhh7M8DYiwCj/cDMXUI4t9+qbItt9ejfp9ZJSqop7TRpp0s7Q1otabWlJUtLkZYqLU1aurQMaZnSsqRl19k7R06d6KRVov+qSZPjxmpqxk7TjJ2uGTtDM1ZLM1ZbM5asGUvRjKVqxtI0Y+masQzNWKZmLEszlq0Zy4mO2Y8q0GQAPsheWJb9wf35VqHfXxLwlYh8UWT5QuFggeUvCBcGRVAUBAsivmB+fknQHwyEwqGAFRL+/BJRWhDKL41OV6cOrlDtMa2jiWllZExFLHa3ccglikOuB7kF/AECkQuMaR5RTPM8yK08YBzqEsWhrge5BfzhCFEXGNN6RDGtR51bMg6nGhoHyjx6Hrj/vQDc/+oT5VF9DziqPjCPLKI4WB5wFPAHT4QFjKkgiqnwILcEMA4+ojj4PMgt4A/VCB8wpvlEMc33YP+raWgcKPNoKXD/Wwbc//xEeeT3gKP8wDwqIIpDgQccBfyBJVEAjGkhUUwLPcitQmAcAkRxCHiQW8AfxhIBYEyDRDENerD/nWZoHCjzaBFw/3sWuP+FiPIo5AFHhYB51IAoDg084CjgD7qJBsCYNiSKaUMPcqshMA6NiOLQyIPcAv4Qn2gEjGljopg29mD/O93QOFDm0dPA/W8BcP9rQpRHTTzgqCbAPGpKFIemHnAU8AckRVNgTJsRxbSZB7nVDBiH5kRxaO5BbgF/+FM0B8a0BVFMW3iw/51haBwo82gucP+bB9z/WhLlUUsPOKolMI9aEcWhlQccBfzBWtEKGNPWRDFt7UFutQbGoQ1RHNp4kFvAHxoWbYAxPZMopmd6sP/VMjQOlHk0E7j/zQLuf22J8qitBxzVFphH7Yji0M4DjgL+QLZoB4xpe6KYtvcgt9oD43AWURzO8iC3gD9sLs4CxvRsopie7cH+V9vQOFDm0WPA/e9x4P53DlEeneMBR50DzKNzieJwrgcc9SiQo84FxvQ8opie50FunQeMQweiOHTwILceAeZWB2BMzyeK6fke7H/JhsaBMo+qZeJq85BMXPwuIMqjCzzgqAuAedSRKA4dPeCoqpm4uToCY3ohUUwv9CC3LgTG4SKiOFzkQW5VAebWRcCYXkwU04s92P9SDI0DZR5VAu5/lYH7XyeiPOrkAUd1AubRJURxuMQDjkoCctQlwJheShTTSz3IrUuBcbiMKA6XeZBbf+N+yFpcBozp5UQxvdyD/S/V0DhQ5tHuDFxt7snAxa8zUR519oCjOgPzqAtRHLp4wFG7gBzVBRjTK4hieoUHuXUFMA5XEsXhSg9yaycwt64ExvQqophe5cH+l2ZoHCjzaDtw/9sB3P+KiPKoyAOOKgLmUZgoDmEPOOovIEeFgTEtJoppsQe5VQyMQ4QoDhEPcmsbMLciwJiWEMW0xIP9L93QOFDm0Rbg/rcVuP+VEuVRqQccVQrMo65EcejqAUdtBnJUV2BMuxHFtJsHudUNGIfuRHHo7kFubQLmVndgTK8miunVHux/GYbGgTKPNgL3vz+B+18Pojzq4QFH9QDmUU+iOPT0gKM2ADmqJzCmvYhi2suD3OoFjENvojj09iC31gNzqzcwpn2IYtrHg/0v09A4UObRH8D9bx1w/+tLlEd9PeCovsA86kcUh34ecNRaIEf1A8a0P1FM+3uQW/2BcRhAFIcBHuTWGmBuDQDGdCBRTAd6sP9lGRoHyjz6Hbj/rQbuf4OI8miQBxw1CJhHg4niMNgDjvoNyFGDgTEdQhTTIR7k1hBgHIYSxWGoB7n1KzC3hgJjOowopsM82P+yDY7DCUn7/6ai/bcU7b+haP/tRPtvJtp/K9H+G4n230a0/yai/bcQ7b+BaP/tQ/tvHtp/69D+G4f23zY8zvb38ba/T7D9faLt75Nsf9ew/X2y7e9Ton8Pl/+OkDZS2ihpo6WNkTZW2jhpVZP2/uBlWS2qa79Lij0qgXOqcSq+D0JjbMQAY0MGGBswwBhigDHIAGOAAcZCBhgLGGD0M8CYzwCjjwFGwQCjxQBjfQYY6zHAWJcBxjwGGHMZYKzDAGMOA4zZDDBmMcCYyQBjBgOM6QwwpjHAmMoAYwoDjMkMMNZmgLEWA4xj08zHOIYBxtEMMI5igHEkA4wjGGAczgDjMAYYhzLAOIQBxsEMMA5igHEgA4wDGGDszwBjPwYY+zLA2IcBxt4MMPZigLEnA4w9GGC8mgHG7gwwdmOAsSsDjKUMMJYwwBhhgLGYAcYwA4xFDDC+lG4+xpUMML7IAOMKBhhfYIDxeQYYn2OAcTkDjMsYYFzKAOMSBhgXM8D4LAOMixhgXMgA4zMMMC5ggPFpBhjnM8D4FAOM8xhgnMsA4xwGGGczwDiLAcaZDDA+yQDjEwwwPs4A42MMMD7KAOMjDDAekmk+xmoMMFZlgLEKA4yVGWCsxABjEgOMwN/oI8O4hwHG3Qww7mKAcScDjDsYYNzOAONfDDBuY4BxKwOMWxhg3MwA4yYGGP9kgHEjA4wbGGBczwDjOgYY/2CAcS0DjGsYYFzNAOPvDDD+xgDjrwwwtssyH2NbBhjPZICxDQOMrRlgbMUAY0sGGFswwNicAcZmDDA2ZYCxCQOMjRlgbMQAY0MGGBswwBhigDHIAGOAAcZCBhgLGGD0M8CYzwCjjwFGwQCjxQBjfQYY6zHAWJcBxjwGGHMZYKxDgDEJizFIM29xiGbeghKaeYP5NPPmF9LMa/mI4kC0bhZRfIuI8jdMFF9/Ec28pUR5JojmDQuaefOJ4ltUSjNvIRGfhYnmLaLis2KaeSNEeRYI08zrJ+Jff4Bm3pICmnmFnwgv0T5USNWfEfFZgCjPAkRxCP5bx+gefUa2+TpiOgOM0xhgnMoA4xQGGCczwDiJAcaJDDBOYIBxPAOM1zDAOI4BxrEMMI5hgHE0A4yjGGAcyQDjCAYYhzPAOIwBxqEMMA5hgHEwA4yDGGAcyADjAAYY+zPA2I8Bxr4MMPZhgLE3A4y9CDDaD8zcJYRzB63KtthWj/59TZ2kpPHSJkibKG2StMnSpkibKm2atOnSZki7Vtp10q6XdoO0G+vsneOmOtFJq0T/VZMmx42N14xN0IxN1IxN0oxN1oxN0YxN1YzdFB2zH1WgwQZ+UUpYlv2LYflWod9fEvCViHxRZPlC4WCB5S8IFwZFUBQECyK+YH5+SdAfDITCoYAVEv78ElFaEMovjU53cx1cIdhjerMmppWRMRWx2N3G4RaiONziQW4Bv+AmbgHG9FaimN7qQW7dCozDbURxuM2D3AJ+MVHcBozp7UQxvZ06t9QbvobGgTKPWgH3v9bA/e8Oojy6wwOOugOYR3cSxeFODzgK+IVacScwpncRxfQuD3LrLmAc7iaKw90e5Bbwi9DibmBM7yGK6T0e7H/jDY0DZR41A+5/zYH7371EeXSvBxx1LzCP7iOKw30ecBTwC/ziPmBM7yeK6f0e5Nb9wDg8QBSHBzzILeCDF8QDwJg+SBTTBz3Y/yYYGgfKPGoE3P8aA/e/h4jy6CEPOOohYB49TBSHhz3gKOADQ8TDwJg+QhTTRzzIrUeAcXiUKA6PepBbwAe9iEeBMX2MKKaPebD/TTQ0DpR5FATufyHg/vc4UR497gFHPQ7MoyeI4vCEBxwFfECReAIY0yeJYvqkB7n1JDAOM4niMNOD3AI+WErMBMZ0FlFMZ3mw/00yNA6UeeQH7n8FwP1vNlEezfaAo2YD82gOURzmeMBRwAeiiTnAmM4liulcD3JrLjAO84jiMM+D3AI+yE7MA8b0KaKYPuXB/jfZ0DhQ5pEF3P8EcP+bT5RH8z3gqPnAPHqaKA5Pe8BRwAcwiqeBMV1AFNMFHuTWAmAcniGKwzMe5BbwwZniGWBMFxLFdKEH+98UQ+NAmUd5wP2vLnD/W0SUR4s84KhFwDx6ligOz3rAUcAHvopngTFdTBTTxR7k1mJgHJYQxWGJB7kFfFCvWAKM6VKimC71YP+bamgc7D5XAvs8DeBzSSC/sEgESihxTgfgDIdKI4HCUlKcMwA4/QF/JFxghSlxXgvAGQn5S4oLCnyUOK8D4AwKvygIlRZQ4rwegFPIwXBhuIgS5w0AnFZRSVgUFwlKnDcieKkgWBgsDTryp1ueX4bg+WBxqKAk9oHuaJzLATjzCy1fMGSR4nwOgLMoGPb5i2IfMI7G+TwApygMi/yi2Ad1o3G+AMBZWBIuKSqMfeA1GucKAM6ICIT9odgHR6NxvgjAWVIg/CX5haS8tBLBS0UBOXdQKGwnJO3/zAz7szLsz8iwPxvD/kwM+7Mw7M/AsD/7Ypnt7+W2v5+z/f287e8XbH+vsP39ou3vlba/h9v+HmH7e6Tt71G2v0fb/h5j+3us7e9x0b9fkv++LO0Vaa9Ke03a69LekPamtKpJex9oUsW25t8lxR7ofbRxKl6HoDE2YoCxIQOMDRhgDDHAGGSAMcAAYyEDjAUMMPoZYMxngNHHAKNggNFigLE+A4z1GGCsywBjHgOMuQww1mGAMYcBxmwGGLMYYMxkgDGDAcZ0BhjTGGBMZYAxhQHGZAYYazPAWIsBxrFp5mMcwwDjaAYYRzHAOJIBxhEMMA5ngHEYA4xDGWAcwgDjYAYYBzHAOJABxgEMMPZngLEfA4x9GWDswwBjbwYYezHA2JMBxh4MMF7NAGN3Bhi7McDYlQHGUgYYSxhgjDDAWMwAY5gBxiIGGF9KNx/jSgYYX2SAcQUDjC8wwPg8A4zPMcC4nAHGZQwwLmWAcQkDjIsZYHyWAcZFDDAuZIDxGQYYFzDA+DQDjPMZYHyKAcZ5DDDOZYBxDgOMsxlgnMUA40wGGJ9kgPEJBhgfZ4DxMQYYH2WA8REGGA/JNB9jNQYYqzLAWIUBxsoMMFZigDGJAca/M8zHuIcBxt0MMO5igHEnA4w7GGDczgDjXwwwbmOAcSsDjFsYYNzMAOMmBhj/ZIBxIwOMGxhgXM8A4zoGGP9ggHEtA4xrGGBczQDj7www/sYA468MMLbLMh9jWwYYz2SAsQ0DjK0ZYGzFAGNLBhhbMMDYnAHGZgwwNmWAsQkDjI0ZYGzEAGNDBhgbMMAYYoAxyABjgAHGQgYYCxhg9DPAmM8Ao48BRsEAo8UAY30GGOsxwFiXAcY8BhhzGWCsQ4AxCYsxSDNvcYhm3oISmnljf9sNN29+IdG6+YjiQLRuFlF8i4jyN0wUX38RzbylRHkmiOYNC5p584niG/sbgLh5C4n4LEw0bxEVnxXTzBshyrNAmGZePxH/xv7mIm7ekgKaeYWfCC/RPlRI1Z8R8VmAKM8CRHEI/lvH6B59Rrb5OmI6A4zTGGCcygDjFAYYJzPAOIkBxokMME5ggHE8A4zXMMA4jgHGsQwwjmGAcTQDjKMYYBzJAOMIBhiHM8A4jAHGoQwwDmGAcTADjIMYYBzIAOMABhj7M8DYjwHGvgww9mGAsTcDjL0IMNoPzNwlhHMXW5Vtsa0e/futOklJb0tbJe0dae9Ke0/a+9I+kPahtI+kfSztE2mfSvtM2ufSvqizd44v60QnrRL9V02aHDf2tmZslWbsHc3Yu5qx9zRj72vGPtCMfRkdsx9VoMEGvlErLMv+xnS+Vej3lwR8JSJfFFm+UDhYYPkLwoVBERQFwYKIL5ifXxL0BwOhcChghYQ/v0SUFoTyS6PTfVUHVwj2mH6liWllZExFLHa3cfiaKA5fe5BbwDfYxdfAmH5DFNNvPMitb4Bx+JYoDt96kFvAD0bEt8CYfkcU0++oc0vG4S1D40CZR5OB+98U4P73PVEefe8BR30PzKMfiOLwgwccBfxAT/wAjOmPRDH90YPc+hEYh5+I4vCTB7kF/CBW/ASM6c9EMf3Zg/3vbUPjQJlH44H73wTg/vcLUR794gFH/QLMo1+J4vCrBxwFvIFA/AqM6W9EMf3Ng9z6DRiH34ni8LsHuQW88UP8DozpaqKYrvZg/1tlaBwo82gMcP8bC9z/1hDl0RoPOGoNMI/WEsVhrQccBbxhSawFxvQPopj+4UFu/QGMwzqiOKzzILeAN5qJdcCYrieK6XoP9r93DI0DZR6NAO5/I4H73waiPNrgAUdtAObRRqI4bPSAo4A3SIqNwJj+SRTTPz3IrT+BcdhEFIdNHuQW8MZWsQkY081EMd3swf73rqFxoMyjIcD9byhw/9tClEdbPOCoLcA82koUh60ecBTwhmyxFRjTbUQx3eZBbm0DxuEvojj85UFuAW+kF38BY7qdKKbbPdj/3jM0DpR5NAC4/w0E7n87iPJohwcctQOYRzuJ4rDTA44CfgFE7ATGdBdRTHd5kFu7gHHYTRSH3R7kFvCLO2I3MKZ7iGK6x4P9731D40CZR32A+19f4P73N1Ee/e0BR/0NzKOkXJo4qHnj44DOLeAXzoQ9Dm5jWokoppVy6XOrEjAOlYniUNmD3AJ+UVBUBsa0ClFMq+TS738f1DEzDnafK4F9/rAOD5wfMcH5MROcnzDB+SkTnJ8xwfk5E5xfAHFWlXMclrRvD1ZYqyfFHmj8bxHEGY3xbQYYVzHA+A4DjO8ywPgeA4zvM8D4ARHHIzAGiealwvvfvP+35sXN7RN0c5dYZZxg71WqSk1ZTdoh0g6Vdpi0w6UdIe1IaUdJO1raMdKOlVZd2nHSjpd2Qm5S7MNlqubu/8CZapqxQzRjh2rGDtOMHa4ZO0IzdqRm7HjN2AnRMdXQnZS07w0A+4Em06NyDU9GsfcfeyxOzN3770nxi65OHBYHAP3O1FGAd5NK9r6NIk4EvjN1EpN3ZLjgPJoJzmOY4DyWCc7qTHAexwQngi8D0bnsOOPfHXfLn8B3NERVorVB+wx8h0RUY+Iz8B0XcQgTn4Hv4IhDmfgMfEdIHMbEZ+A7TOJwJj4D37ESRzDxGfgOmDjSI5+tgztE2R/HA7VSDaJP8e3zguNQdogTcNhFDYiWlUfIEv+8gZG0/5OH7U8ctj9p2P6EYfuThe1PFLY/Sdj+BOEmNff9vanKwf9tfxPmBNvfL9n+Wy/b/n7F9vertr9fs/39uu3vN2x/vxn9+xT53zlVWk1pp0k7XdoZ0mpJq527982fGkn73rewH+je/BTT3/zZe/jJ5hZWzDuRVaN/J8u4pEhLlZYW/yZTcvRNJvtYimYsVTOWpnmDqho2WDGL6pYok1EEUWqJFNBcysdU4JtwacAi8LJ4T/2veLXFmy7jkiEtU1pWfPGma4oyQzOWqRnL8qB4TwUWbzqweDOAxZsJLN4spsVb87/i1RZvtoxLjrQ60nLjizdbU5Q5mrE6mrFcD4q3JrB4s4HFmwMs3jrA4s1lWryn/Ve82uLNk3GpK62etPrxxZunKcq6mrF6mrH6HhTvacDizQMWb11g8dYDFm99psV7+n/Fqy1eS8ZFSPNJy48vXktTlEIz5tOM5XtQvKcDi9cCFq8AFq8PWLz5TIv3jP+KV1u8fhmXAmmF0gLxxevXFGWBZqxQMxbwoHjPABavH1i8BcDiLQQWb4Bp8db6r3i1xRuUcQlJayCtYXzxBjVFGdKMNdCMNfSgeGsBizcILN4QsHgbAIu3IdPirf1f8WqLt5GMS2NpTaQ1jS/eRpqibKwZa6IZa+pB8dYGFm8jYPE2BhZvE2DxNgUX73FJ3hRvpSSa4q2dCKewDupI3j++BzmTZaXEz3XQM1lWauxcLmayLMePGys4c3riuSqMMSPRXAfhbaZ+roOKW7k+4SnnzNkHnqvcGHMONFcFvK3jPFeF4lahN9UPMHNe+ec6IMa65Z2rHN7WK99c5YrbQb2PmWjmis+VEKOo6FwO3voqNpdj3Fy9dRQ3s//g59oPY8HBzqXxtvDg5tLGDaLWozMH3c/1L8aQ27ls3jZwN1dM3IACKaaPtNwcEmETzFz/+IrsI5M0h5u5A1agoNBXWFwYKsyvbJ8zN3oXTPT/N5f/v4W0ltJaSWstrY20M6W1ldZOWntpZ0k7W9o50s6Vdp60DtLOl3aBtI7SLpR2kbSLpXWSdom0S6VdJu1yaZ2ldZF2hbQrpV0lrUhaWFqxtIi0Emml0roqEealMu6RZO5i7jt8Abq5LZ9dGZclSDe5EN2lXS2th7Se0npJ6y2tj7S+0vpJ6y9tgLSB0gZJGyxtiLSh0oZJGy5thLSR0kZJGy1tjLSx0sZJu0baeGkTpE2UNknaZGlTpE2VNk3adGkzpF0r7bp4ld4tmtn2se6asas1Yz00Yz01Y700Y701Y300Y301Y/00Y/01YwM0YwM1Y4M0Y4M1Y0M0Y0M1Y8M0Y8M1YyM0YyM1Y6M0Y6M1Y2M0Y2M1Y+M0Y9doxsZrxiZoxiZqxiZpxiZrxqZoxqZqxqZpxqZrxmZoxq7VjF2Xu48My47s6L/Nov9a7o4YcnT7DlO3XNQ7TKWl3XFzRa7GzRXqgZtL9ITNVSJ6weYqFr1hcwVFH9hcluiLmqvEEv1QcxVboj9qrqAlBqDmkrU9EDRXiZxrEGiuYjnXYNBcQTnXENBciguHYuYqUXMNw8xVrOYajplLPfpKjMDM9c/eMRIyV8k/c42CzFX8z1yjIXP986QwMQYy1969dixirpK9c41DzFW8d65rEHPtfbCaGI+YK9qbTADMFYnONREwVzg61yTAXGVPzJjsfi5ftP8SU9zPJcrmmup6rmBp2VzT3M8VLptruvu5yvpVMcP1XIF/57rW9VwF/851XS72DYv4N1T+xWcdVJ8v1KeA3XId5j3Y39pr6Ynf4iDx/fMFSQq/t4H9LjuqxuH890X/hz/9df3kgVaercX/+U+p3a7Fya08rouD8pjHp+lu1+KU/421qLDHPD71d7sWp/7vrsW+4//A3Qlu16Lm//5a/J+5i8LtWpxmSl04eszjbg+3a3G6SWuR0GMed6W4XYszzFyLfQeju2fcrkUtc9eC3V0+bteiNngt4p9k/g++yEHj++chSnGfqea78PefByk5fkYbqNh86UTvh6R4sS778AUrGscMhziGSiu+LpmJ57MOZp2ziNYl1dt12YfPKp/f2QfK773zFZQ3jjnlmc9f/nWpQ7QuaZ6vi7+0IvmYW7512TdfwHm+vIrNV3wgfHWJ1iX9f6teFL7AgdelXvnjaJVnnetXdJ3L5gvq57OI1iXjf3Nd9uELJIqjOJg4BhKvi6/i8/mc1jmfaF0yzViXffh8sX77Dza/985nxcexwMV8haX7r0sh0bpkmbMuQV0+Btyty373aQQx8/37uXyIaF2yTasXhc+/b10auI+jZV/nhqB1LotfY6J1yTFxXWz3UTaB1cve++aaxs1nuTtEc6J1qUP03sspcTitgz/2+/aRW5+vB64L8P4MAbznQQA/sxfAz5wF8DNTAfzMTwA/sxLAz1wE8DMDAXzPWwDfsxXA9xwF8H0yAXxvRwDfjxBADS2Auk8AtYoA9tcC2BMKYB8jqPbeY6L/onA2B+69NwDnsu+9yPsNke/VI99fRr4ninwfD/neE/L9EqTGR+pSpJYyqf9X2uT4pH2fu6r/r3rtPdG/b7D9rX7RqOzvzdG/y667Ub7uJmk3S7slN3Y+JK+pJwF0J9BUITCvo/Epn28k8LuB6fdU7D3EjcA96FaglgTmjeCyFi2Aa3FbLk0Nm1QXOo691cart5WTY2+Xr7tD2p3S7iLkWPWklasJuKah4RyrfL6dwO9GTOr6dmAt3g3kWGDeCC5r0RK4Fvfk0tSwSXWh49i7bbx6Tzk59l75uvuk3S/tAUKOVU+y6kHANY0N51jl870EfjdhUtf3AmvxQeS9rUCO5bIWrYBr8VAuTQ2bVBc6jn3QxqsPlZNjH5ave0Tao9IeI+RY9aTAngRc09RwjlU+P0zgdzMmdf0wsBYfB3IsMG8El7VoDVyLJ3JpatikutBx7OM2Xn2inBz7pHzdTGmzpM0m5Fj1JNZeBFzT3HCOVT4/SeB3CyZ1/SSwFucg77kCciyXtWgDXIu5uTQ1bFJd6Dh2jo1X55aTY+fJ1z0lbb60pwk5Vj3pujcB17Q0nGOVz/MI/G7FpK7nAWtxAZBjgXkjuKzFmcC1eCaXpoZNqgsdxy6w8eoz5eTYhfJ1i6Q9K20xIceqXxLoQ8A1rQ3nWOXzQgK/2zCp64XAWlwC5Fhg3ggua9EWuBZLc2lq2KS60HHsEhuvLi0nxy6Tr1su7TlpzxNyrPqllr4EXHOm4RyrfF5G4HdbJnW9DFiLLwA5Fpg3gstatAOuxYpcmho2qS50HPuCjVdXlJNjX5SvWyntJWkvE3Ks+iWsfgRc085wjlU+v0jgd3smdf0isBZfAXIsMG8El7VoD1yLV3NpatikutBx7Cs2Xn21nBz7mnzd69LekPYmIceqXxrsT8A1ZxnOscrn1wj8PptJXb8GrMW3gBwLzBvBZS3OAq7F27k0NWxSXeg49i0br75dTo5dJV/3jrR3pb1HyLHql1wHEHDNOYZzrPJ5FYHf5zKp61XAWnwfyLHAvBFc1uJs4Fp8kEtTwybVhY5j37fx6gfl5NgP5es+kvaxtE8IOVb9UvZAAq45z3COVT5/SOB3ByZ1/SGwFj8FciwwbwSXtTgHuBaf5dLUsEl1oePYT228+lk5OfZz+bovpH0p7StCjj03d99vntvndRvT8w3nWOXz5wR+X8Ckrj8H1uLXQI4F5o3gshbnAtfim1yaGjapLnQc+7WNV78pJ8d+K1/3nbTvpf1AyLHnybkHE3BNR8M5Vvn8LYHfFzKp62+BtfgjkGOBeSO4rMV5wLX4KZemhk2qCx3H/mjj1Z/KybE/y9f9Iu1Xab8RcmwHOfcQAq65yHCOVT7/TOD3xUzq+mdgLf4O5Fhg3ggua9EBuBarc2lq2KS60HHs7zZeXV1Ojl0jX7dW2h/S1hFy7Ply7qEEXNPJcI5VPq8h8PsSJnW9BliL64EcC8wbwWUtzgeuxYZcmho2qS50HLvexqsbysmxG+Xr/pS2SdpmQo69QM49jIBrLjWcY5XPGwn8voxJXW8E1uIWIMcC80ZwWYsLgGuxNZemhk2qCx3HbrHx6tZycuw2+bq/pG2XtoOQYzvKuYcTcM3lhnOs8nkbgd+dmdT1NmAt7gRyLDBvBJe16Ahci125NDVsUl3oOHanjVd3lZNjd6vXSftbWlIeHcdeKOcfQcA1XQznWOXzbgK/r2BS17uBtVgpD4cLmDeCy1pcCFyLynk0NWxSXeg4VuVgGZdWzisfx1ZRvCqtmrRDCDn2Irm+Iwm45krDOVb5rGKMnvcqJnVdBViLhwI5Fpg3gstaXATk2MPyaGrYpLrQceyhNl49rJwce7h83RHSjpR2FCHHXizXdxQBxxYZzrHK58MJODbMpK4PB9bi0UCOBeaN4LIWFwM59pg8mho2qS50HHu0jVePKSfHHitfV13acdKOJ+TYTnJ9RxNwbLHhHKt8PpaAYyNM6vpYYC2eAORYYN4ILmvRCcixJ+bR1LBJdaHj2BNsvHpiOTn2JPm6GtJOlnYKIcdeItd3DAHHlhjOscrnkwg4tpRJXZ8ErMVTgRwLzBvBZS0uAXJszTyaGjapLnQce6qNV2uWk2NPk687XdoZ0moRcuylcn3HEnBsV8M5Vvl8GgHHdmNS16cBa7E2kGOBeSO4rMWlQI5NzqOpYZPqQsextW28mlxOjk2Rr0uVliYtnZBjL5PrO46AY7sbzrHK5xQCjr2aSV2nAGsxA8ixwLwRXNbiMiDHZubR1LBJdaHj2Awbr2aWk2Oz5OuypeVIq0PIsZfL9b2GgGN7GM6xyucsAo7tyaSus4C1mAvkWGDeCC5rcTmQY/PyaGrYpLrQcWyujVfzysmxdeXr6kmrL80i5NjOcn3HE3BsL8M5Vvlcl4BjezOp67rAWhRAjgXmjeCyFp2BHOvLo6lhk+pCx7HCxqu+cnJsvnydX1qBtEJCju0i13cCAcf2MZxjlc/5BBzbl0ld5wNrMQDkWGDeCC5r0QXIscE8mho2qS50HBuw8WqwnBwbkq9rIK2htEaEHHuFXN+JBBzbz3COVT6HCDi2P5O6DgFrsTGQY4F5I7isxRVAjm2SR1PDJtWFjmMb23i1STk5tqmKlbTm0loQcuyVcn0nEXDsAMM5VvnclIBjBzKp66bAWmwJ5Fhg3ggua3ElkGNb5dHUsEl1oePYljZebVVOjm0tX9dG2pnS2hJy7FVyfScTcOwgwzlW+dyagGMHM6nr1sBabAfkWGDeCC5rcRWQY9vn0dSwSXWh49h2Nl5tX06OPUu+7mxp50g7l5Bji+T6TiHg2CGGc6zy+SwCjh3KpK7PAtbieUCOBeaN4LIWRUCO7ZBHU8Mm1YWOY8+z8WqHcnLs+fJ1F0jrKO1CQo4Ny/WdSsCxwwznWOXz+QQcO5xJXZ8PrMWLgBwLzBvBZS3CQI69OI+mhk2qCx3HXmTj1YvLybGd5OsukXaptMsIObZYru80Ao4dYTjHKp87EXDsSCZ13QlYi5cDORaYN4LLWhQDObZzHk0Nm1QXOo693MarncvJsV3k666QdqW0qwg5NiLXdzoBx44ynGOVz10IOHY0l/uFgLVYBORYYN4ILmsRAXJsOI+mhk2qCx3HFtl4NVxOji2Wr4tIK5FWSsixJXJ9ZxBw7BjDOVb5XEzAsWO59E7I77UDORaYN4LLWpQAObZbHk0Nm1QXOo7tauPVbuXk2O7ydVdL6yGtJyHHlsr1vZaAY8cZzrHK5+4EHHsNk7rujvw+EJBjgXkjuKxFKZBje+fR1LBJdaHj2F42Xu1dTo7tI1/XV1o/af0JObarXN/rCDh2vOEcq3zuQ8CxE5jUdR/kfZRAjgXmjeCyFl2BHDswj6aGTaoLHccOsPHqwHJy7CD5usHShkgbauPYsqNy3Dq7jcERwJwZlEeT20fhcluo/2kKzO1hQJ6pAeSZk4FznQKc61TgXDWBc50GnOt04FxnAOeqBZyrNtE+Br/fx2V9BqxAQaGvsLgwVJiv4/hu1fdx+TAbxw+3/X1Y1ViOHyHPjZQ2StroKMdXjc5dKWn/A91fjyDi6X+PymDA2acD3wgDErZamCrRBVLzJh9g4Vy/8QbAXloaKRaB/GJdMs+zJfNYWwLnJNm+6BOXzOPk666RNl7aBE3DUgWdC8C5xgEb04nAotKtzUTbelxj+3u87e8JebFrM0n+/8nSpkibaiOaE2zrojuaYfzIr+Tw33H73yjL4yRbjIDYRU4SniTRGLOTkjzZhC13h5jEbcMZAySGaUQbzrTohqMK+sik/YmXYiErJf3/Tjg0zjFMcFZJ8riA3RYd0vmeRM6jfQYWp+jFxOfKQJ97M/EZWIyij0c+W+4O0RcYv7VVeJBuvyQeOPszwTmACc6BTHAOYoJzMBOcQ5jgHMoE5zAmOIczwTmCCc6RTHCOYoJzNBOcY5jgHMsE5zgmOK9hgnM8E5wTmOCcyATnJCY4JzPBOYUJzqlMcE5jgnM6E5wzmOC8lgnO65jgvJ4JzhuY4LyRCc6bmOC8mQnOW5jgvJUIp8mfC97mkc+Wu0PcDozfBiafF92RxAPnnUxw3sUE591McN7DBOe9THDexwTn/UxwPsAE54NMcD7EBOfDTHA+wgTno0xwPsYE5+NMcD7BBOeTTHDOZIJzFhOcs5ngnMME51wmOOcxwfkUE5zzmeB8mgnOBUxwPsME50ImOBcxwfksE5yLmeBcwgTnUiY4lzHBuZwJzueY4HyeCc4XmOBcwQTni0xwrmSC8yUmOF9mgvMVJjhfZYLzNSY4X2eC8w0mON9kgvMtJjjfZoJzFROc7zDB+S4TnO8xwfk+E5wfMMH5IROcHzHB+TETnJ8wwfkpE5yfMcH5OROcXzDB+SUTnF8xwfk1E5zfMMH5LROc3zHB+T0TnD8wwfkjE5w/McH5MxOcvzDB+SsTnL8xwfk7E5yrmeBcwwTnWiY4/2CCcx0TnOuZ4NzABOdGJjj/ZIJzExOcm5ng3MIE51YmOLcxwfkXE5zbmeDcwQTnTiY4dzHBuZsJzj1McP7NBKeakAPOSkxwVmaCswoTnFWZ4KzGBOchTHAeygTnYUxwHs4E5xFMcB7JBOdRTHAezQTnMUxwHssEZ3UmOI9jgvN4JjhPYILzRCY4T2KCswYTnCczwXkKE5ynMsFZkwnO05jgPJ0JzjOY4KzFBGdtJjiTmeBMYYIzlQnONCY405ngzCDCWRmMM9OG0+0z4kfk8fA5C+hz9uk88jGbSd3kMMFZhwnOXCY485jgrMsEZz0mOOszwWkxwSmY4PQxwZnPBKefCc4CJjgLmeAMMMEZZIIzxARnAyY4GzLB2YgJzsZMcDZhgrMpE5zNmOBszgRnCyY4WzLB2YoJztZMcLZhgvNMJjjbMsHZjgnO9kxwnsUE59lMcJ7DBOe5THCexwRnByY4z2eC8wImODsywXkhE5wXMcF5MROcnZjgvIQJzkuZ4LyMCc7LmeDszARnFyY4r2CC80omOK9igrOICc4wE5zFTHBGmOAsYYKzlAnOrkxwdmOCszsTnFczwdmDCc6eTHD2YoKzNxOcfZjg7MsEZz8mOPszwTmACc6BTHAOYoJzMBOcQ5jgHMoE5zAmOIczwTmCCc6RTHCOIsJZOQ6n2+9FVgL6PJqJzzlAn8cw8bkK0OexHvlsuTvEuEq4+KWfzsPna4A+b6zy/4/Dxv8/5O0J/w85bCITDpsErOdJTJ77MBno8xgin9H94hQmfe1UJjinMcE5nQnOGUxwXssE53VMcF7PBOcNTHDeyATnTUxw3swE5y1McN7KBOdtTHDezgTnHUxw3skE511McN7NBOc9THDeywTnfUxw3s8E5wNMcD7IBOdDTHA+zATnI0xwPsoE52NMcD7OBOcTTHA+yQTnTCY4ZzHBOZsJzjlMcM5lgnMeE5xPMcE5nwnOp5ngXMAE5zNMcC5kgnMRE5zPMsG5mAnOJUxwLmWCcxkTnMuZ4HyOCc7nmeB8gQnOFUxwvsgE50omOF9igvNlJjhfYYLzVSY4X2OC83UmON9ggvNNJjjfYoLzbSY4VzHB+Q4TnO8ywfkeE5zvM8H5AROcHzLB+RETnB8zwfkJE5yfMsH5GROcnzPB+QUTnF8ywfkVE5xfM8H5DROc3zLB+R0TnN8zwfkDE5w/MsH5ExOcPzPB+QsTnL8ywfkbE5y/M8G5mgnONUxwrmWC8w8mONcxwbmeCc4NTHBuZILzTyY4NzHBuZkJzi1McG5lgnMbE5x/McG5nQnOHUxw7mSCcxcTnLuZ4NzDBOffTHAmVeaBsxITnJWZ4KzCBGdVJjirMcF5CBOchzLBeRgTnIczwXkEE5xHMsF5FBOcRzPBeQwTnMcywVmdCc7jmOA8ngnOE5jgPJEJzpOY4KzBBOfJTHCewgTnqUxw1mSC8zQmOE9ngvMMJjhrMcFZmwnOZCY4U5jgTGWCM40JznQmODOY4MxkgjOLCc5sJjhzmOCswwRnLhOceUxw1mWCsx4TnPWZ4LSY4BRMcPqY4MxngtPPBGcBE5yFTHAGmOAMMsEZYoKzAROcDZngbMQEZ2MmOJswwdmUCc5mTHA2Z4KzBROcLZngbMUEZ2smONswwXkmE5xtmeBsxwRneyY4z2KC82wmOM9hgvNcJjjPY4KzAxOc5zPBeQETnB2Z4LyQCc6LmOC8mAnOTkxwXsIE56VMcF7GBOflTHB2ZoKzCxOcVzDBeSUTnFcxwVnEBGeYCc5iJjgjTHCWMMFZygRnVyY4uzHB2Z0JzquZ4OzBBGdPJjh7McHZmwnOPkxw9mWCsx8TnP2Z4BzABOdAJjgHMcE5mAnOIUxwDmWCcxgTnMOZ4BzBBOdIJjhHMcE5mgnOMUxwjmWCcxwTnNcwwTmeCc4JTHBOZIJzEhOck5ngnMIE51QmOKcxwTmdCc4ZTHBeywTndUxwXs8E5w1McN7IBOdNTHDezATnLUxw3soE521McN7OBOcdTHDeyQTnXUxw3s0E5z1McN7LBOd9THDezwTnA0xwPsgE50NMcD7MBOcjTHA+ygTnY0xwPs4E5xNMcD7JBOdMJjhnMcE5mwnOOUxwzmWCcx4TnE8xwTmfCc6nmeBcwATnM0xwLmSCcxETnM8ywbmYCc4lTHAuZYJzGROcy5ngfI4JzueZ4HyBCc4VTHC+yATnSiY4X2KC82UmOF9hgvNVJjhfY4LzdSY432CC800mON9igvNtJjhXMcH5DhOc7zLB+R4TnO8zwfkBE5wfMsH5EROcHzPB+QkTnJ8ywfkZE5yfM8H5BROcXzLB+RUTnF8zwfkNE5zfMsH5HROc3zPB+QMTnD8ywfkTE5w/M8H5CxOcvzLB+RsTnL8zwbmaCc41THCuZYLzDyY41zHBuZ4Jzg1McG5kgvNPJjg3McG5mQnOLUxwbmWCcxsTnH8xwbmdCc4dTHDuZIJzFxOcu5ng3MME599McCZV4YGzEhOclZngrMIEZ1UmOKsxwXkIE5yHMsF5GBOchzPBeQQTnEcywXkUE5xHM8F5DBOcxzLBWZ0JzuOY4DyeCc4TmOA8kQnOk5jgrMEE58lMcJ7CBOepTHDWZILzNCY4T2eC8wwmOGsxwVmbCc5kJjhTmOBMZYIzjQnOdCY4M5jgzGSCM4sJzmwmOHOY4KxDhLNyHM58q9DvLwn4SkS+KLJ8oXCwwPIXhAuDIigKggURXzA/vyToDwZC4VDACgl/fokoLQjll0bnzgL6nOuRz5a7Q+RVwcVvWh6Pda4KjF9dJrldDehzPSY+HwL0uT4Tnw8F+mwx8fkwoM+Cic+HA332MfH5CKDP+Ux8PhLos5+Jz0cBfS5g4vPRQJ8Lmfh8DNDnABOfj03C+Rxk4nN1oM8hJj4fB/S5AROfjwf63JCJzycAfW7ExOcTgT43ZuLzSUCfmzDxuQbQ56ZMfD4Z6HMzJj6fAvS5OROfTwX63IKJzzWBPrdk4vNpQJ9bMfH5dKDPrZn4fAbQ5zZMfK4F9PlMJj7XBvrclonPyUCf2zHxOQXoc3smPqcCfT6Lic9pQJ/PZuJzOtDnc5j4nAH0+VwmPmcCfT4P6LOcSn1FPumnqMM9pfWS1ltaH2l9pfWT1l/aAGkDpQ2SNljaEGlDpQ2TNlzaCGkjpY2SNlraGGljpY2Tdo208dImSJsobZK0ydKmSJsqbZq06dJmSLtW2nXSrpd2g7Qbpd0k7WZpt0i7Vdpt0m6Xdoe0O6XdJe1uafdIu1fafdLul/aAtAelPSTtYWmPSHtU2mPSHpf2hLQnpc2UNkvabGlzpM2VNk/aU9LmS3ta2gJpz0hbKG2RtGelLZa2RNpSacukLZf2nLTnpb0gbYW0F6WtlPaStJelvSLtVWmvSXtd2hvS3pT2lrS3pa2S9o60d6W9J+19aR9I+1DaR9I+lvaJtE+lfSbtc2lfSPtS2lfSvpb2jbRvpX0n7XtpP0j7UdpP0n6W9ou0X6X9Ju13aaulrZG2Vtof0tZJWy9tg7SN0v6UtknaZmlbpG2Vtk3aX9K2S9shbae0XdJ2S9sj7W9p6gayStIqS6siraq0atIOkXaotMOkHS7tCGlHSjtK2tHSjpF2rLTq0o6Tdry0E6SdKO0kaTWknSztFGmnSqsp7TRpp0s7Q1otabWlJUtLkZYqLU1aurQMaZnSsqRlS8uRVkdarrQ8aXWl1ZNWX5olTUjzScuX5pdWIK1QWkBaUFpIWgNpDaU1ktZYWhNpTaU1k9ZcWgtpLaW1ktZaWhtpZ0prK62dtPbSzpJ2trRzpJ0r7TxpHaSdL+0CaR2lXSjtImkXS+sk7RJpl0q7TNrl0jpL6yLtCmlXSrtKWpG0sLRiaRFpJdJKpXWV1k1ad2lXS+shrae0XtJ6S+sjra+0ftL6SxsgbaC0QdIGSxsibai0YdKGSxshbaS0UdJGSxsjbay0cdKukTZe2gRpE6VNkjZZ2hRpU6VNkzZd2gxp10q7Ttr10m6QdqO0m6TdLO0WabdKu03a7dLukHantLuk3S3tHmn3SrtP2v3SHpD2oLSHpD0s7RFpj0p7TNrj0p6Q9qS0mdJmSZstbY60udLmSXtK2nxpT0tbIO0ZaQulLZL2rLTF0pZIWyptmbTl0p6T9ry0F6StkPaitJXSXpL2srRXpL0q7TVpr0t7Q9qb0t6S9ra0VdLekfautPekvS/tA2kfSvtI2sfSPpH2qbTPpH0u7QtpX0r7StrX0r6R9q2076R9L+0HaT9K+0naz9J+kfartN+k/S5ttbQ10tZK+0PaOmnrpW2QtlHan9I2SdssbYu0rdK2SftL2nZpO6TtlLZL2m5pe6T9LU1tpJWkVZZWRVpVadWkHSLtUGmHSTtc2hHSjpR2lLSjpR0j7Vhp1aUdJ+14aSdIO1HaSdJqSDtZ2inSTpVWU9pp0k6Xdoa0WtJqS0uWliItVVqatHRpGdIypWVJy5aWI62OtFxpedLqSqsnrb40S5qQ5pOWL80vrUBaobSAtKC0kLQG0hpKayStsbQm0ppKayatubQW0lpKayWttbQ20s6U1lZaO2ntpZ0l7Wxp50g7V9p50jpIO1/aBdI6SrtQ2kXSLpbWSdol0i6Vdpm0y6V1ltZF2hXSrpR2lbQiaWFpxdIi0kqklUrrKq2btO7SrpbWQ1pPab2k9ZbWR1pfaf2k9Zc2QNpAaYOkDZY2RNpQacOkDZc2QtpIaaOkjZY2RtpYaeOkXSNtvLQJ0iZKmyRtsrQp0qZKmyZturQZ0q6Vdp2066XdIO1GaTdJu1naLdJulXabtNul3SHtTml3Sbtb2j3S7pV2n7T7pT0g7UFpD0l7WNoj0h6V9pi0x6U9Ie1JaTOlzZI2W5r6rXr1O/DqN9bV75er3wZXv7utftNa/V60+i1m9TvH6jeE1e/zqt++Vb8rq36zVf0eqvqtUfU7nuo3MldIU7/tqH43Uf0mofq9P/Vbeup36tRvwKnfV1O/XaZ+F0z95pb6PSv1W1Hqd5jUbxyp3w9Sv82jfvdG/aaM+r0W9Vso6ndG1G94qN/HUL89oX7XQf1mgvo9AvWsf/UcffWM+u+kqWerq+eWq2eCqz5PPctaPSdaPYNZPd9YPTtYPZdXPfNWPU9WPatVPQdVPWNUPb9TPRtTPXdSPdNRPS9RPYtQPedPPUNPPZ9OPftNPVdNPbNMPQ9MPWtLPcdKPSNKNZfq2UbquUHqmTzqeTfqWTLqOS3qGSjq+SLq2R3quRjqmRPqeQ7qWQnqOQTqO/7q+/Pqu+nqe9/qO9Xq+8rqu8Dqe7bqO6zq+6Hqu5fqe43qO4Pq+3jqu27qe2TqO1rq+0/qu0XqezvqOzHq+ybquxzqexLqOwjq/n5177y6L13dp63ugVb38ar7WtV9nqpBVvcBqvvi1H1i6r4pdR+Ruq9G3Wei7rtQ9yGoz+XV59Tqc1v1Oab6XO+fz7mkqc9B1OcC6n1y9b6xeh9Vva+o3mdT7zup92HU+xJKpyvdqnSc0jWqz6+8t4VKUvcpq6Nn0r4jSq//9O/qvLqvV93nqu77VPdBqvsC1X1y6r4xdR+Vuq9I3Wej7jtR92Go+xLU5/Tqc2v1Oa76XFN9zqc+91KfA6nPRdTnBOp9c/U+snpfVb3PqN53S5aWIi1VWpo0pWOVrlM6R907ny0tR1odabnS8qTVlVZPWn1pSmwJaT5p+dL80gqkFUoLSAtKC0lrIK2htEbSGktrIq1p0l7901xaC2ktpbWS1lpaG2lnSmsrrZ209tLOkna2tHOknSvtPGkdpJ0v7QJpHaVdKO0iaRdL6yTtEmmXSrtM2uXSOkvrIu0KaVdKu0pakbSwtGJpEWkl0kqldZXWTVp3aVdL65G0/6Fyr+yYFf33pJ+an9rvzcdb2183x+HcU9F/73+y1sLTfqp8mf3coui/9x4/eGxWb8UK+w7VU6hjRKvG+Td/NnOM/dwXlRLP+ZXDuZ8czv3icO53h3NrHM5tcji3xeHcDodzuxzOlb0hoDtX2eHcEQ7njnI4d6zDueMczp3qcO40h3PJDudSHc7lOZyr53Cu0OFc0OFcQ4dzjR3OtXY4d6bDubMdzp3rcO4Ch3MXOpzr7HDuCodzRQ7nih3O9XA418vhXH+HcwMdzg2Nnlv6yoidD36+IoYax0TPLQu+0v6zx4+tYT83Nnpu1QV3f3Tx8UOq28+Ni57b+eixI37YVHmX/VzdY/f+q+PPqccnPnfnSYnP3X/y3n8rJ1U/5rKXe7xiP/foyYmve8zhuqUO1y2PnnvrlndffWJKUcR+7nmH61Y4XLfS4bpXHM695jDnGw7XveVw3SqH695zOPeBw5wfOVz3icN1nzlc96XDua8d5vzW4brvHa770eG6XxzO/eYw52qH69Y6XLfO4bqNDuc2Ocy5xeG6bQ7XbXe4bpfDuT0Oc/7T8Ca4rvIpia+r6nDdoQ7nDneY80iH6452uO5Yh+uOdzh3osOcNRyuO8XhupoO153hcK62w5wpDtelOVyX4XBdtsO5Og5z5jlcV8/hOsvhunyHcwUOcwYcrgs5XNfQ4bomDueaOczZwuG6Vg7XtXG4rp3DubMc5jzH4brzHK473+G6Cx3OXeww5yUO113mcF1nh+uudDhX5DBnscN1JQ7XdXW4bqLDuckOc051uG66w3XXOlx3g8O5mxzmvMXhutscrrvD4bq7Hc7d6zDn/Q7XPehw3cMO1z3mcO4JhzlnOlw32+G6uQ7XzXc4t8BhzoUO1z3rcN0Sh+uWO5x73mHOFQ7XrXS47mWH615zOPeGw5xvOVy3yuG6dx2u+8Dh3EcOc37icN1nDtd94XDd1w7nvnWY83uH6350uO5nh+t+czi32mHOtQ7XrXO4boPDdZsczm1xmHObw3XbHa7b6XDdHodz/7yZnGDOyqcmvq6qw3WHOFx3uMO5Ix3mPNrhumMdrjvO4boTHc7VcJjzFIfrajpcd7rDdbUdzqU4zJnmcF2Gw3VZDtfVcTiX5zBnPYfrLIfrfA7XtXU4195hzrMdrjvX4boODtd1dDh3kcOcnRyuu9ThussdrrvC4dxVDnOGHa6LOFxX6nBdd4dzPRzm7OVwXR+H6/o5XDfQ4dxghzmHOlw33OG6kQ7XjXE4N85hzvEO1010uG6yw3XTHM7NcJjzOofrbnC47iaH6251OHe7w5x3Olx3t8N19zpc94DDuYcc5nzE4brHHK57wuG6WQ7n5jjMOc/huvkO1y1wuG6Rw7nFDnMudbhuucN1zztc96LDuZcc5nzF4brXHK57w+G6tx3OveMw53sO133gcN1HDtd96nDuc4c5v3S47muH6751uO4Hh3M/Ocz5i8N1vzlct9rhuj8czq13mHOjw3WbHK7b4tTT1kx87uiaiec81uG64xyuO8HhuhoO505xmLOmw3WnO1xXy+G6FIdzaQ5zZjhcl+VwXY7DdXkO5+o5zGk5XOdzuM7vcF3A4VzIYc6GDtc1driuqcN1LRzOtXKYs43DdW0drmvvcN05DufOc5jzfIfrOjpcd5HDdZc4nLvMYc7ODtdd4XDdVQ7XFTucK3GYs6vDdd0druvhcF1vh3N9Hebs73DdQIfrBjtcN8zh3AiHOUc5XDfG4bpxDtdNcDg3yWHOKQ7XTXO4bobDddc7nLvRYc6bHa671eG62x2uu8vh3D0Oc97ncN0DDtc95HDdow7nHneY80mH62Y5XDfH4bqnHM497TDnMw7XLXK4brHDdS84nHvRYc6XHK57xeG61xyuW+9wXd3T9/6ru3cyED2nu+8p5HCuucO5lg7n2jica+twroPDuQscznVyOHepw7kuDueudDjX1eFcd4dzPR3O9XY4N9jh3FCHc6Mczo1xODfV4dx0h3M3O5y71eHcHQ7n7nI495DDuUcczj3pcG6Ww7l5DufmO5xb4nBumcO55x3OrXA497rDuTcdzr3rcO59h3MfR8/p7p38KnpOd+/k19Fzunsnf4ie0/betfb+q+O6c2slxtnB4dwlDucuczjXxeHclQ7nujqc6+5wrrfDub4O5wY6nBvscG60w7mxDufGO5yb6HDuWodz1zucu8Xh3G0O5x5wOPeQw7mZDudmO5yb53BuvsO5JQ7nljmcW+FwbqXDuVcdzr3ucO49h3MfOJz72OHcpw7nvnU4973DuV8czv3mcG5t9JyO6zZFz+m4bnP0nI7rdjn893Y7nKtcO/G5qg7nToiem/JA02q9Zn070n6uVvLef3Xcmp2ceM46Dud8Duf8DucCDudCDueaO5xr6XCurcO59g7nznU418Hh3CUO5y5zONfF4dyVDue6Opzr7nCut8O5vg7nhjucG+lwboLDuUkO56Y6nJvucO5mh3O3Opy7y+HcPQ7nHnA495DDuZkO52Y7nJvncG6+w7klDueWOZxb4XBupcO5V6PndNy6KnpOx63vRM/puPWzlL3/6vjsh5TEWH5yOLfW4dw6h3MbHc5tcji30+HcbodzlVMTn6vqcO4wh3NHOJw73uHciQ7nTnY4d6rDuRSHc2kO57IdztVxOOd3OFfocK6Jw7lmDudaOpxr7XDuHIdz5zmcu9Dh3MUO5y5zONfZ4VzE4Vypw7nuDud6OJwb4HBukMO54Q7nRjqcGxs9p+OzydFzOj6bEj2n47PT6+79V6eLa0XP6d4fTHa4LtXhunSH67IczuU4zJnrcF1dh+vqO1znczjnd5iz0OG6oMN1DRyua+xwrqnDnM0drmvpcF1rh+vaOpxr7zDn2Q7XnetwXQeH6zo6nLvIYc5ODtdd6nDd5Q7XXeFw7iqHOcMO10Ucrit1uK67w7keDnP2criuj8N1/RyuG+hwbrDDnEMdrhvucN1Ih+vGOJwb5zDneIfrJjpcN9nhumkO52Y4zHmdw3U3OFx3k8N1tzqcu91hzjsdrvuf9r4ETo6jOr9He0i7q5VWkm3Zkg8ZX2Abe669OIIAX4jbxoCBALM7M0IgS7YOn7I9snX4vm2wue/D3BBuCPxDIPcFISEhgUASchEScpCEEP5qud/MN9++qunZebU7srZ+P2l7ur763qtXVa+qq6qr3+hJ92ZPurd54t7h4XyXJ917POne50n3iCfuQx7Oj3jSfcyT7hOedJ/yxH3Gw/k5T7oveNJ9yZPuK564X/Nw/ron3dc96X7Tk+67nri/8nD+wJPubzzpfuhJ9w+euH/ycP6zJ92/eNL9xJPuPzxxP/Vw/rcn3c886X7uSXfwMCRH3KKz3Jy9nnT9nnRLPOmGPHHDHs7lnnQrPOlWedId5Yk72sO5xpPuWE+64z3pTvTEneThPMWT7jRPuid40p3piTvLw5n1pMt70hU96cY9cZMezid70j3Vk+5pnnTP8MSd4+E8z5PuAk+6DZ50z/XEPd/D+UJPuos86S72pHupJ+5lHs5XeNK90pPu1Z500564iodzoyfdJk+613nSbfHEXebh3OZJt8OT7gpPuqs9cdd6OK/zpLvBk263J90eT9w+D+fNnnS3etLd7kn3sCfuTR7Ot3jSvc2T7h2edO/2xL3Xw/l+T7pHPOk+5En3UU/cxz2cn/Sk+5Qn3Wc86T7vifuih/NXPem+4kn3a550X/PE/YaH87c86X7Hk+73POn+0BP3DQ/nH3vS/Ykn3bc96b7jiftLD+f3POm+70n31550P/TE/b2H8x896X7kSfdj35j2bHfc8rPdnCs86VZ50h3pSXe0J26Nh/NYT7rjPenWedKd5Ik7xcN5mifdEzzpzvCkO8sTl/Vw5j3pip50Y550k564J3s4n+pJ9zRPuqd70p3jiTvPw3mBJ90GT7rneNI93xP3Qg/nRZ50F3vSvcST7mWeuFd4OF/pSfdqT7opT7pbPem+lHxp5srHP+Mz//v1f/wxxn016+b8bUdccqxdNHTco38Hkt/JsZgHz4mOjxten/zOdhZyA8BrzT+RnawMRM3BWP/CAHAG4M8Lf28Y/uzihOdNtWb+iOQOJ78zYEtJI3F4MPSbk7glSbxcX5tcDxBfiHJHnazttkrRfxHkLQ7PrIWQnZ8W/nOC8GfLwn9uGP6q8J+X8EdN3LnCxFghPzGWz5cr2VJ5bLw6WRjPFqZGC5PTU7lsYTQ/UR4vFbLZSqEyXcyWxyZHy5XS5GihOlWaHBPu81XuQmXqANVoaWxiKlctjVWzU8XxiUKpOj5eLpUni5Xx0Ww5Nz2Wm87nqhMTpdHR0vToZC5XrUyOVifq3BeEsUte+J8VhL8wKvwbgD9jxj9W9+XPDsI/XhL+5wSxT35K+J8bhD9X539emPItCv/zgb83svN5wv+CMPz1+vPCMPz19nVhEPs39L8o4Y8ie9u/KIjuuXHhvziMbQrC/+Iw+tfr/kvC6F/3nS8No3+9fC8Jo3/dPi8Dfjvf3Kj7Lw/DX68/rwjDX/cNv2xs/7HSgcHo2Fi9fb3SmH9qamy8VJmo189XGfMXpscq1cJ43T6vNuYvjRar1dFCvW8vGfOP5rKV0fx4fcw5Zcw/OZUdHZuYqI/Jp435D4xDC+XJUn3sULa2z1QlO13OTQp/xZj/0VCs+7dqEP7ChPBvTPgj4M5NFPL58UL8Ld2J8oG+ojydnzjwdDFVzE5nS9P5ymQxN1kt5ouF6fL01ERxopSrZqul6cnqxKPswv2aILpn63MUm4DfzrcV6s8trw2hf65hn9fVZto+21mo+7XNbu5ZF69wX6pw50uF6exk9YB/miiNH/CvB4ope+BiaqJSHcuXpg48eObLuVyuUjzwX75SLk5OlcdyU2OV8fzo1AFxdZtsCWHzbG5a5lS2gu4yFyGyLwsiOzuZIXlR1DxnFJH8QdLVetydIXmoD9pH5mfEdpfXZuo6osThmIDjepR7IkfjeqUh16sMuV5tyFUy5Joy5Jo25Con11pbi8P65G+2wzBAso3HvXX+bcDfE4B/exj71J87diT8Ibh3hrFNvV++Igx//ZnjyjD89THXVWH462PSq8Pw1585rgnDXx+zXxuGv/7MsQv47XxDvt52rwvCX6jzXx+Gv95+bwjCX6zz18Lw1+dsdofhr4+tbwzDX/dvN4Xhrz837QnCP1p/PtgbhH+sPqe1Lwx/vf7sD8Nfrz83h+Gv159bwvDX+8dbw/DX+8fbwvDX+8fbw/DX+687wvDX+687w/DX17HvCsNf9z93h+Gv+597gvCP1/vfe8Pw1+eM7wvDX/ef94fhr/vPB8Lw1/3ng2H46/7z9WH46/7tDWH46/7toTD8df/2cBj+uv95Y8IfzZ67wDeGokf3U/0o+e60tg/NcCyUlT1evY2sNM03xtd9cN9wrrOcZr4R5Q+SriHmG1Ge6MP2wfnGOK5f0XVEieMy7Ffk9CtyRpQ4Hvt1wnWvIdfNhlx3G3JZ5vFOQ67bDLnuMuS6xZBrlyGXpe0t29B9Xcq1wZDLsk5Y2t6yfu0z5LJs25Z1Yq8hl6WPftCQq1v7RxlThx1bZceGFdkSJG4xyMYxFYce+o16x2PVf1vZ4GWchKVRY71t+9Vbpl+wbdMVpR2Vi3Yc+C/ypIvDeTX9frfZMENxS1LkIYpa23fxqgYv41gfLMfFFNenpM0oXNqaP9dptHmvQwfkkLLi8fD65He2o5ArpMkHyp+rZwnNV2jPEmKfxWHsk88QP+qzWLEP12Euu0zUWCPvAy7EL4Y8Ih6vJT3e+7Pk70g0sx3JHuyMEtej3BP7xrp/k/KGZcP1NEw5FHNp66nIH4xCtptGPdXqhdanDUQzy9lyP2GactV824ASJ1yyTwnrKeKXQB4Rj9eSHu/9XfJ3JJpZp7meDij5wXtYT7+fXA848rM++Z3tKIyPa/0UtwO0k+U+t7TtQOQPRiHrXaMdaOWk+ROx3aCi64gSx3M/g4qcQUXOiBLH49FOuO425NpryLXfkOu+LuW6zZDrLkOuWwy5dhly3WHIZVnvu9Fevn6wXa44WNbV+w25bjXksqyrlnncYMjVrW37IUOu6wy5ZA2Rx5nCH0WNsRL39+uT39mOwqPPbihP8oH3UP4g6WqrT2OspNlVG9OKfYbC2Keuz5Ciz5BiHynLpUqccMlcCz4zIH4I8oh4vJb0eE8Kc4Q448DPDEuV/OA9fGY4M9OcNywbrqchywHlid54D+UPRiHbTdZbL7T2PxDNLGdD+2TTlCvqK2U5rMQJ17LkN9ZTxC+FPCIeryU93ltP9RTrNNfTYSU/eA/r6ZOonmLZcD0NUg65aup6KvIHo5DtplFPtXoxpNhxIJpZzob2yaYpV9RXynKZEidcy5PfWE8RPwx5RDxeS3q89zyqp1in+d2aZUp+8B7W0wsS3gFHftYnv7MdhdGiVpZ2/OO5YSWf3M7Q1nb1upC6nYn8wWhmvQjRzpaTPq56ILYbUXQdUeK4jowockYUOSNKHD/XdMK135BrlyHXXkOuOwy5Nhhy3WbIdachl2Wd2GfItceQ6z4jLs0/d6LXvUZ6xeF+Qy7Ltv2QIZelL7Rsj3cZclmW48OGXJZ1wtL2Vm07Ms6jZZ2425CrW/2EpV6Hw5hpoU+bP9tbtsebDbks8/j6LtXLcjxhmUdeH8Bny0zydyCa2fYMn7MrGZIn+cB7KH+QdLXVp/Gcrdl1uWJXsd0KRdcRJY6fs1coclYockaUOO4zOuHab8i1y5DLMo+3GXLdZch1vyGXpe0fMuRaKMf2uB425LKsE/sMue425LL0X/cZclna3rKuWtq+W/2XZV21rF93GnJZlqNl/bJsQ5b1615Drg2GXJZ57NaxnGUeLccT3VqO3TqWe70hV7eOcyzHmAvjicdGG7L0E5Z6WdWv+JrnVTvR64GaHZel7S3HANLX8n434Y9D2Dm0fOo9tjyHFmQPVos5NG1v3UA0sx4a2ieXppxRXynLlUqccCWvNTftCUP8Csgj4vFa0uO9ZyRGGSHOOPCesJVKfvCe2DfeE/aU5MeAIz/rk9/ZzsIEz4eKDJSNdjKsd6nOgEf5g1HIetdoB1o5af5FbLdK0XUkmll3uD6sUuSsUuQscHUX18uMuHw+TOLjMKCks/a3KE/ygfdQ/mAU1C/kfHbV/KXY54gw9qnvUT5C0ecIxT5SlkcqccJ1VPIb+yPEHwF5RDxeS3q8V6X+6EjAchs4UskP3sP+6NWLmvOGZcP1NEw5pH/nQ+QPRiHbTaOeavVCa/8D0cxyNrRPNk25or5SlkcpccIl33LGeor4IyGPiMdrSY/3dlA9xTrN9fQoJT94D+vpluTH8sjdPtO0Z+TV/DbbENNxewhS3rlKNm17EPmDUcj22WgPR6a0q9jnqCD2KVfT1B/UV8pytRInXEcnv7E9IP4oyCPi8VrS47291B6w7XB7WK3kB+9he7iB/DaWDdfTIOWQzVbT1lORPxiF9JONeqrVC63/G4hmlrOhPpU05Yr6SlkercQJ1zHJb6yniF8NeUQ8Xkt6vHcf1VOs0/yu3tFKfvAe1tM76HmX87M++Z3tKFRyWlna8ZeyA4qt7fjzkwNKednxT00I/5ow/GPCvzYI/0S9fI8Nwj9at89xYfjLwn98mPpT1/+EIPyFgvCvC8Jfqet/YhD+Yp3/cUH4p+rt96Qg/JP1+n9yGPvUy/eUIPzVUeE/NYx96vqfFkb/uv9/AvBbzkUI/xlB+LMFscfpUSP0KHkS+TIWeTzgM46/wsVxImuQuEKN+7S8of783Hc66IM2cHGd3ibXgBIXokyf4Mk3yh/26Mr5iAOfgTNbm8RhnyHXTYZc9xpxaWPbTvS63lCv1UZ6aePfTriOMeTqMeKKA39TrxO91hjpFV+v7VKuYw25jjPkOt6Q6wRDrnWGXCcaccWBv9XUiV6PM9TrHkO9TjLSK74+2ZDLqu+Ir08x5DrVkOs0I6448Nxpt3DJGnLY+a7iZNj5rkIp7HxXsRx2vmu0EHa+qzgedr6rOC1jdekPRQbWLezf7J4riqnfBRX5g6SrrT6N57vjSR+2D+/fOUHRdUSJ4zZ6giLnBEXOiBLHe3k74XrQkGuDIdcdhly3GXLtM+TaZch1pyHXfkOu+7qUy7Ku3mLIZWV7rd/ulrpq2R7vN+Tq1vb4gCGXZRvqVtvfashl6Scs+1pLH21pe0t7dWv9shybWJajpe0PBz/xkBFXfM3PsJ3otdtQr2OM9LLkisMNNTu91hjqZWX7OOwx5LKsEzyX3glXjxFXHKzqRBxuMuSqGXJZ1i9LvfYYcXWzL1xqqJdlXbUsR0u/2q322mPEFV/z3Gq3tG1L//WwIZfl+OtmQy7LOQXLMbnls4Ll3KOM72Ue+1iIyyR/w64BZGe9BnBsGH28awDHKnbV9sMa6lNOU86or5TlOiVOuE5MfuPefsSfAHlEPF5Lerz3rqTgRogzDry3f52SH7wn9o339r+lpzlvWDZcT8OUQ/pvwIr8wShou8n56sXxih21eiFpR5Q4HtOvU+SsU+RoZc973zrhutuQa2/Njmu/Idd9Xcp1myHXXYZctxhy7TLkuseQy7INWZbjg4ZcGwy57jfksmzblvXLsg1Z+tXDwfZ3GnJZ+mjxhdp7VIbjj6z2npMhf/2dgxM9tkD5vBdH4rW/wsVxImuQuIzzlvPlzffsdiLosw6uXVwntsmlvRsXokzXRe58o/yw7wKO5sO+Czg6FvZdwGJV6vxJYM8M2e6UIGU5kfosFZE/SLqGalOnkD5sH34eOlXRdUSJ4717pypyTlXkjChx3G93wvWgIdcGQ647DLluM+TaZ8i1y5DrHkOuew25LG3frXX1fkOu/YZclvXL0ufcbch1ONj+TkMuyzze16Vclm37FkMuK9vH17wvt1vqareOASy5FvrthX77UOk7FvrthX57od9+bNq+W+vqA4Zclvay9DmWtr/VkMuyDVn2293qo7t1PGGZR8uxr2U5Wtr+cPATDxlxZaKZ+3M64VpnyGU1Tx5fn2jEFQfee9yJXksN9dptpFcc9hhy3WTEFV8/LrLjeqzbPr7mdyc64TrGkGuNEVcc9tTs9DrZSC/LuhoHyzbUrfW+W/O4p2bH1Y2+0FKvOOwx5FroO+bP9jcaccXXlnserOwVX6811KtmqJdVXxuHPTU7vSzt1Y19RxweNuSyfOa72ZDLck3Hch7Acn7Ccn8Ov9+Ge8MyyV/tvPhYzvrkd7azUM6QPMkH3kP5g6SrsT45n11PUeyqnXdvqM90hvhRn9MU+0hZPkGJEy45JxPfb0P8aZBHxOO1pG+K73v07whxxoHfb9POSsd7Yt/+A/9+1tucNywbrqdhyiGf+v02kT8YBW03OV+90Nq/Vi8krVZe3O+nLS+N6zZDrvsMufYact1tyPWgIdd+Q657u1SvfYZcuwy5HjLkus6Q62FDLkt73WXIZdke7zfksqz3lr7QshxvNuSy9DmWdeJOQy5L22/oUr3uMeSyrBOWYxPLftuyHLvVf1nWL8v22K0+2pLLsn7dYsgltpfnFXy+ySR/ByhdJjJ91itmSJ7kA++h/EHS1VafxrOeZtfTFLu2830x0VWuMQ7lzPV3vOJwtyHXXkOu/YZc93Up122GXHcZct1iyLXLkMvq20hx2GDIZdke7zfksqxflva6w5DLsn5ZtiFLv2pZJyz9are2bcv2aNmGHjTksmyPh0P9utOQy3IMIH3t8iQOx9t4HgnGoRzfmB/TC25YSZdJ/g6QfpnIcow9mfq8DpE/qNgkxJj/9JR2Fdudoeg6osTx3pUzFDlnKHJGlDjumzrhetCQa4Mh1x2GXLcZcu0z5NplyHWPIde9hlyWtu/Wunq/Idd+Qy7L+mXpc+425DocbH+nIZdlHu/rUi7Ltn2LIZeV7eNrPq+jW+pqt44BLLm6td+2tL3lGMDSR1uOJ7q1ri702/PXpy2MydvjWhiTz1/9WhgXzl/96sZxYRws7dWtdfUBQy5Le1n6HEvb32rIZdmGLPuObvXR3dqnWebRcuxrWY6Wtj8c/MRDRlyZaOYep070usFQr3VGesXXSw25LNeHLO211lCvPTU7rpuMuOLrx0V2XFZ1Ig78bnM32N6ybVu3R6s2FF+faMQVB8v2eDjULz5vqBOuYwy51hhxxWFPzU6vk430svSFcbD00d1a77s1j3tqdlzd2Nda6hWHPYZcC2OT+bP9jUZcluOJOFjZK762HJPXDPWy6mvjsKdmp5elvbqx74jDw4ZclnMKNxtyWa5bWc4zWc5/7TPk4vOGlkJcJvkr+3zR18Vy1ie/s52F1Oe4iPzBaGZfZahPfZ/vUdFMuy5V7Cr2WR1Gn6kM8aM+qxX7SFkercQJl/hhPG8I8ashj+y3jwE9+ujeX/Q/+neEOOPA5w0dreQH74l9Y8o/6W/OG5YN19Mw5ZBLfS6WyB+MgrabnK9eHKXYUasXknZEieM5nLTlpZU9703ohOtuQ669hlz7Dbnu61Ku2wy57jLkusWQa5ch1z2GXJZtyLIcHzTk2mDIdb8hl2XbtqxflnpZlqOlXpZ+wrJOWJbjnYZclv5e/KqMrXhMsD75ne0ojI7K2ATHMjKmGoj0sYmN7NxEhuRFkT6uE/mDpKutPo1xnVZuaB8e1x2j6DqixHEZHqPIOUaRM6LEcdvshOt2Qy5Lve424oqvF0c2XNZ53GXIdach132GXLcYclna635DrjcYct1jyLXfkMvS9rcZcu0z5LLM40OGXNcZcsl8NI8t4rA++XugOyxMjBXyE2P5fLmSLZXHxquThfFsYWq0MDk9lcsWRvMT5fFSIZutFCrTxWx5bHK0XClNjhaqU6XJ8bBjh9HJgUjvX234cznhXxOGPy/8a8PwF4R/XRj+UeE/MQz/mPA/Lgz/RNgzNHL1+nlGGP6S8J8Zhr8s/E8Mw18R/rPC8FeF/+wg/Pms8GfD8Nf9Ty4Mf93/5MPw1/1PIQx/UfiLYfjr/m00DH/dv42F4a/3v+Nh+Ov+cyIMf91/Tobhr/vPJ4Xhr/vPJ4fhr/vPp4Thr/vPpwbhL9T95y+F4a/7z6eF4a/7z/Vh+Ov+8+lh+Ov+5xlh+Ov+55lh+Ov+4Zww/HX/cG4Y/inhPy8M/7Twnx+Gv+7fLgjDX/dvzwrDX/dvG4LwF+v+59lh+Ov+5zlh+Ov+57lh+Ovjt+eF4a+P354fhr/uP18Qhr/uP18Yhr8+frswDH/dP18Uhr/un18Uhr/uny8Ow1/3zy8Ow1/3zy8Jw1/3zy8Nw1/3z5cE4R+tjz9fFoa/7v9fHoa/7v9fEYa/7v9/OQx/3f+/Mgx/3f+/Kgx/3f+/Ogx/3f+XwvDX/f9U1AgN7kJl6sBU/2hpbGIqVy2NVbNTxfGJQqk6Pl4ulSeLlfHRbDk3PZabzueqExOl0dHS9OhkLletTI5WJ+q6T6vcnYTGvHw5hF1y1bpfqAB/xkz/iTp/NQh/tt6uNgaxT7nul1+jlG2+WB6bKmXHq+Ol0kT1QCeaLx/4M3ag1lRH86XJwnTpQC0qT1VKU4Xpyfx0OV8uVCYO+JpKYXKsUmn0WZus600uW7f7a4PYvbGe8Dpzu08c/D/ehv1QsolBziDfDLL6KF+XJr9ln3kcttUamM0Qj/jfH3z0byzvzYm8YchPBHLiIPnuNc/3QbtOZkheFOl7hET+IOlqq09jj1Av6cP24T1CfYquIxQXB14z7lPk9ClyNK6HDbl2GXLdY8i135DrLkOufYZctxlyWebxFkOubq1fGwy57jXkut+Qy7J+WdrrDkMuy/pl2YbuNuSyrBOWflX2Eg5EM/tCu755rCB9LT53SJA4fG7IUFwF8OfXGjgOPfQb87TkwL/Vqxq8jGN9cNxUBn7XmCEOYsd+iLcc4wj/QBj+gth+SdRsU87TgMNWEq/9FS6OE1mD0Uy7hxgfanlD/bm9LAF90AYuriVtcg0ocSHKtN+Tb5Q/7NFVywc/32j+SBt/C37AoxfilyuyJa3YcBDiDG2Y99kQ26LIXwp6litTOzc+Z+vGiEIP2UHsdjThLqw17MB1cImDK6LfR9O9HuDDEPaZcX77AclTu/0A2rZMcbP1e3Fg38A2j0Nc1j+juYUeJU9ch1xzCz0Q39RWlzTk/SKRNwQyhz0yl5HeiI/DhbVm/HLIW4+CGSYdBd+3pKHqaUn5abYTfQYo/WOpLkue2q3LWI6sW93OUaMcsWxd5bICyuX0VQ2dWd6yyJ0P+T2lyBPdVxA2DlLGK+G+4RxX6u/tifxB0tW4H6qPYVaSPmwf8S1xPzSUXG/eWio/s3TZ9p2bK4vIlCNwjfQjRCcYxGIYAZUiB46LPQ4vrc1Mx0FM2Uc6nwqua21yvTya2fT5GC/UoUe5x+55qaK/Nv16Wa05DodDF1FcvyduiSduQMmXxA1Cum2UbkjhjHXYvKTBh7aNIr16ibvW7OyqSy6uC4gL068krlUtuC4mLky/iriOaMF1CXFh+iOI68gWXC8hLkx/JHEd1YJrJ3Fhej7SZnULriuIC9Pzp7KObsF1JXFh+qOJ65gWXFcRF6bn49LWtOC6mrgwPR9NurYF1zXEhen5uLRjW3BdS1yY/ljiOq4F1znEhemPI67jW3C9hrgwvaQdVri4S8ZP5xp2gamPxhL5g6RrqC75hGimXdE+vOy0TtF1RIljv7VOkbNOkaNxHWHIdaQh11GGXKsNuY425DrGkGuNIddaQ65jDbnYb7Xqr8+tPfrX119LOqy7iOsBjNZHI4drPNATpR8XvJR01mRqY8ztteY4nILjsSlOF41QHE6lraQ4HGOy38dptlUUNwRxkh8cY/ZRfrYm98M+rmezOBZ02YqfW7S/UZRuOkebkhsmuRZy0F7cx4wYyuFxPcpZYSgHuWRaROSsUuRIveE2uD75ne0sVNPkA+UPRrpfWW+jT27+jnsspp4OmevjHrXnCawrvOSgPTNox0Pi9MnGyo4Dk/jPuPpFpY2LAYquk9VZRrgj6DcPoUSt9VEjoDnltwxLWA/kwsB6+KZnNPmaW5TrPuV+HLTHLR7KtntSBqY/xiPnqA7lHKXICXvqRGNl99gw/PVVQO0RF/Mk8vkELYnX/goXx4mswWhmGYVwA1refOWMQ980UwFr2+QKe5JIo0zXePKN8oc9umr5wNUk9HMrk7FhPKx705Jmbs1XhN1dUhhLWx9F/lztRE27Eq4N1SXtCMXFgb/WoK1K9ytyNK67DbkeMOS6y5BrnyHXLkMuyzxalqNlHvcaclnm8U5DrnsMue4w5NpvyHW/IddthlyWdcKyPVq2Ics6YWmvWwy57jPksrT9zYZclra/15DL0l6WvnCDIZelvbrVF1ray9LnHA5jJss6YdlvW9k+vuaTmrul3lva/lZDLst6b5lHSz9hOQawtNdDhlxp3tbUnusFr+1w1+alDpcd7qOEs9jhPkr3eiJ9h3vM/TN6e3otpY1D2PnYQj5D8jiPEckfJF2Ny78+Z6VtW9LmPcV2xym6jihx/LVlbUvTcYqcESWO++1OuO405LrHkOsOQ679hlz3G3LdZshlWSfuMuTaZchlWScs7XWLIZelvW425LK01wOGXJZ1dZ8h1+FQjvcaclnay7If2mDIZWmvbu2HLO1l6e8t65elz7Fsj5Z1wnLMZGX7+JrnYLql3lva/lZDLst6b5lHSz/RreOvhwy5ZA5Ge8WFt9Zrz7DHeuRg+mNTcGnPw4LXXgPxzfXgaymSNuwXghpzPVp54Gs7In82cz1itxzheK4HfdvxDq6Ifufonmuuh/ct7U0mssJ+oUrfas77FX2vJmqvTOI9rr+YfqWDy3UiwBGRbqvbElvF5f7EVc2crbbb8uuhqBPvJzzGIR/Lvo+wd4Nu2VVuWSHsqslZ2qGcpYqcYSVdxvFX5PA9lqPpLHJwD6HUj3iu9I0DjTRcXj1KWnlFksvsC3B65VsSTu01Slf9zYA83Ectrw8LXnxzf9SwCWK4vgv+nVCnTqP6fgTlGfOp6SyceCoF6iyviLMO7yP/FGgvsOqfRJb2KtJApNsjivQy4Xo3oNhBk3NKh3JOUeQMK+k6bUeazr61hNnKQS5pk2HrRvunmrCdKxDH+46rEMcniOGpyLjGxaGHfqMt4rZbSHEaSti1tLmz4RqKQxtyG8eg2VBskdaGy6OZNuS2vVLJh9bu+X2Ndtv9UR4dUM5yiuNXDTEO2+cg6dej6Nfj0W9QkRP23YD26+BRFId1cDXFYR08muKwDnK9fg3E8auXmyCun+LwZHA+pQ5P9R6kODyFu932IOUSy9todFoYjnMqFLdE4Q37amOhkKZfQvmDpKutPo01aK39a6cqiu1WK7qOUFwcarUGjuN6lHuLPFy3GXLdZ8i115DrbkOuBw259hty3duleu0z5NplyPWQIdd1hlwPG3JZ2usuQy7L9ni/IZdlvbf0hZbleLMhl2U5WvovS3vdY8i1wZDL0l6WbchyPGFprzsMuRb86vz5VSvbx9e8Bt0t9d7S9rcaclnWe8s8WvqJWwy5unW8er0hl4xXeX4rvsb1FJkDwKPoLNeC5/PcEcwTnzuCtso4/goXx/G5I6vD5M177oivHuCcHx8x2Mm5I8I1V+eOHO3JN8of9uiq5eMIQ5uk+TqFNrfUbtlqR9VK2sBtrL6f4wiPnVB+J+/u5Akna6uLoplld7SDK6Lfebrn2s+hnUmEa9VTg7rOuFatHf/LX0N4GNaqK8m1ti4wEjXHYV2TY+zCft2l/Xn+HorDeX7XWV5RpM+RS57a/QoBvt/FXyEQTtdXCPohHvHbBhu6/MEanTMDnPieG3+hQtYmcQ8BYlgHwV8BOvAeAsH0OvK1xMF5O9TFqwd1zkjh1PI1SPliHQZIB8FfB/n6BgxOECO/0b/uqDXrNqTIihz3kBvTcpxPbqu08TV+oYLjuK6wvTC9y6ZcVwS/z1NX+hUdML9crqwDYwYdOtyq6IBHHk5vvezq5IsREQX+8E0P/eai5CLoV3hcQfjjNLcP6jzy21f9cBvKEkXGEoeOmDY2j5ivXNlc2VFxGGiRkgFN2KJID9onIsSXBv5iWOp3U/nLbf1h9PF+uU17h1s7pljSamvyvL8prZylUWMf3fYdW7e56gKXPf/uc8jPKOkjSptR7kVR83vO2viE89zuVyQHFP01OYMdyhlMKWdVh3JWpZRzVIdyjlLkMJc2Xo1DpdaIR/z7wY9/a43OucjBKZ9MEbz2DKHtbRG8NgdyhJJH7WyD1VFr2WhL7veOblPXVnMQvHdIe5ZNq+sFc6xrX5u6Diqyse8/0LltuqKy7Xlbd1TQxbAaEV1zv88nnXN3tsSh6lLC8TZonh7qo99H0u8hRT8tiB4YWJeeqHWQJiq2+iw00W87mmgU6U1Uqj0//mJa7fFX26aPU4uurdMu9yNfhuFty1/2uB/t9RnfydzaKynaqz7aV3OOozi0E26rP8hdm8lZf0SDOMNhzHRsn++saejB9umrpbdFHNh22pd98PUaPuoXXz1aS3G4XY5fiWpVr7i+4rY3SYuvFkh5XQE47hqvhN89hEeZgr8K5GiPRJK2j/DfVB6JRhSdRJ8BSm9bZ8YnxYZXRzODxF0TNecd464F/Hm1Bo6DNr0jeYptsbiN6R0sR9ZNONHHYNm6yuV7UC78kUmUd2Xkzof87lHksS0lPg5SxtcSx/rkd7ajMFrKkLwo0h+3RP5gNNO2IR63riV92D7asMHzkcmr4RrpLyE6wSAWwyWgUuTAacV+tJKOg5iyj3T+GczC/QPNCGPT52/jog49yj1+OuhV9Nfk9Hcop1+Rw7um48Afs7w0mplXidsC6fjDk1sh7iKKuyyamS+Ju9zDuc3Dud0Tt8MTt1OJi3XavLShI7tjrWnwG5BYdq524OLiD2Ri+muJa1cLLv5AJqbfRVzXteC6hLgw/XXEdX0LLv5AJqa/nrhuaMHFH8jE9DcQV60FF38gE9PXiGt3Cy7+QCam301cN7bg4g9kYvobieumFlxXExemv4m49rTg4g9kYvo9xLW3BRd/IBPT7yWufS24ziEuTL+PuPa34OIPZGL6/cR1cwuuc4kL099MXLe04OKPyWH6W4jrVg9XfM2PWZj+VuK6rQXXGuLC9JJ2WOHKJH9l+HU73Lcb7uRSvwUj8gdJV1t9GsOv26OZdkX78Gz3HYquI0oc9kUYh3LuUORoXFcbcl1ryLXLkOs6Q67rDbluMOSqGXLtNuS60ZDrJkOuPYZcew259hly7TfkutmQ6xZDLu7LfOP6+JrfYtbG9ZIO/RlPD/VQGsQjh+u5oQd0bvX88OJas86zfX6Ir9dFzVyzfX6Ir08krk6eH15Ua+aa7fNDfP040mu2zw/x9enENdvnh/j6DOLC9OxzWz0/PLfWzIXp231+2EJcs31+iK/PjJq5Zvv8EF8/kbhm+/wQX59FXLN9foivzyau2T4/xNdZ4prt80N8nSOuTp4f8sTle364vQVXgbgw/e3EdUcLriJxYfo7iOvOFlyjxIXp7ySuu1pwjREXpr+LuO5uwTVOXJj+buK6pwXXBHFh+nuI694WXJPEhenvJa77PFxxeE6tmQvT30dc97fgeiZxYfr7ieuByJ/HJ0XNXJj+AeJ6sAXXk4kL0z9IXK9vwfUU4sL0ryeuN7TgeipxYfo3ENdDLbh+ibgw/UPE9XALrqcRF6Z/mLje2IJrPXFh+jcS15s8XHF4Xq2ZC9O/ibje3ILrWcSF6d9MXG+J/Hl8etTMhenfQlxvbcH1DOLC9G8lrrd5uOJQrTVzYfq3EdfbW+j1TNIL07+duN7Rgusc4sL07yCud7bgOpe4MP07ietdLbjOIy5M/y7iencLrvOJC9O/m7je04LrAuLC9O8hrve24HoWcWH69xLX+zxccajUmrkw/fuI6/0t9NpAemH69xPXB1pwPZu4MP0HiOuRFlzPIS5M/whxfbAF13OJC9N/kLg+1ILrecSF6T9EXB9uwfV84sL0Hyauj7TgegFxYfqPENdHW3C9kLgw/UeJ62MtuC4kLkz/MeL6eAuui4gL03+cuD7RgutFxIXpP0Fcn2zBdTFxYfpPEtevtOB6MXFh+l8hrk+14HoJcWH6TxHXp1twvZS4MP2nieszLbguIS5M/xni+mwLrpcRF6b/LHF9rgXXy4kL03+OuD7fgusVxIXpP09cX2jB9cvEhekl7bDClUn+yvrTF+G+3XpPMZcheZIPvIfyB0lXW30a609fjGbaFe3D609fUnQdUeJ4zvFLipwvKXI0rl2GXNcZcl1vyHWDIVfNkGu3IdeNhlw3GXLtMeTaa8i1z5BrvyHXzYZctxhy3WrIdbsh1x2GXHcact1lyHW3Idc9hlz3GnLdZ8h1vyHXA4ZcDxpyvd6Q6w2GXA8Zcj1syPVGQ643GXK92ZDrLYZcbzXkepsh19sNud5hyPVOQ653GXK925DrPYZc7zXkep8h1/sNuT5gyPWIIdcHDbk+ZMj1YUOujxhyfdSQ62OGXB835PqEIdcnDbl+xZDrU4Zcnzbk+owh12cNuT5nyMVzjq32yb0yufbtk5N0OO/Erxj2UBrEI4drH14P6NxqP96rSOfZ7seLr19NXJ3sxysRF6Zvdz/e0cSl7cfT3oPbXmuOuxTS8TsMWyCO363bCnFXU9xlEMfz0pdD3LUUtw3idlHcdoi7juJ2QNz1FLcT4sRG+B6cvB8pNtqa3B+gvEkdXJ/8znYYtC+XsR2x3DKOv1E0c449DuwD8AsyGZJztaEc5JLXtKWOYv3l4zKuITl8j+Vg+mscXK4vRW6BeMRfm5S99qVIbW/ypXDvQk9eJa3UKfZr65Pf2c5CTvivD8Nf8PlfzBO3QbRdO/ULZQ1GkdqvrDeynS9vqD/XQ+wP0uwbv65NrgElLkSZ7vLkW/O5mq5aPlxtE+X4Tq293qMX4n39s9gQ+0hDG+Z9NtT6+NmcWit2W0s4/gqxNtZhroh+85ceeyL91FrNtw049BS5rfw4phec7wiLNH5Dk6PpLHLwfAE8hfchelde6h0e+YHvtfAXgAX/5ysbnG9KOLX3blxtJQPy8GwCPipG5LmOitni0O/t0O/xCZ5blDwf49FZOPH8B9SZvxgr+PfQuCtQH6mOu0TWctKXy4fzopUJ17urFDu4bBsHHKfgOAbxH2xznIL1m8cpqJOk1Z712A6aHF8/eVVKOYMdyhlU5HQ6DtHkaDrzM1Uc0J98lvyJ1DtsW5hW3oPvI/xvgj/5gsef8P4UHjuxj2V/IvJc/oTrp+C/4vEn2tj8pTW3zsKJ/gR1Zn8i+K+RPwk0flL9icjS+suhSLdHFKXrL4cUO4TuL4dIzi5DOcglbUUby7H/aXdsjel5LOtqr99cqsvU2ivW3T7C3wPt9U+ovWJ9F5tr9Yb7qF2KXG4zUTTz+SwOPl+2y8GVto8S/Hc9fZTvWSMOvmdp35wj4hDjm//r8cjAeov3ZWyMfecWwl5H2F0erOu5Mb6eTq7DPtuPV6Ut4BymBImrKTpL3G7Ab6w1cBx66DfmKa4rP1nT4GUc64N2qjk4NX/Bp+pLnhcpvNcTL/oAtpecs8Xt/xdJW4jb/78v1fm4nsThdQlf2OfXiSyXLwYuX7YPB618Re+4fE9c2+BlHMvEMtxNceiz+Ww39PXCEdt+IBHarW1pNu2lHXtq7UWzJ68RaH0n2rOPOM4cbmCGhpt1Egz3F3GQ9iNtVuzXq6SPA4/9BL88kRnb59K1unxfe4si3S+gHfhMxlqk66LlWbBPoPqIbcyuPhZzUo43ks4o+6ZAsjMkL4r0eV6RP6zoI3oPKnG9Heg6mhsfz48Vy6PVqbGJ0dFKhvhFV77Hc5TaWRDLFbzYem8QWxfK0tTwSOg9YNc49ELcTRTXB3GiY9yGLlvbrP+eQPqnsT/KH1HwfBR42rIcUeTwM0cnXLtmybUyam4DWl+IYxvuC3H8gueAXuDwy2l8nfg29vuYT/aD55Kvq0EawzpU1Maj7OtuDCQ7ra8T+cORu2wHlbhOfF15tJgrVidHp8rVQqU8Xs1EM/uEHuUe+zqt3i5T8IF9RVbzdezPeiHuRopDXyc6ar4uTL9YyKaxP8ofUfDs69KW5Ygih31dJ1y7Zsklvm43pK8l15qv43Hq9Up+0Nfxc9mzySeFOfpenyNkn4r6xgGfoa8HO7F9mQfv4bgZ0/CcjeAvgnH7C4Z1/SQPFyn6aXuKMF8XD7tx1yu4+FFZxlEbKzsuek1pW6V8UWV6W2VHT6Srx1nk7PPjVES4OPAX4bbTb56+uZR4pAtO+0U4+YtcWtEhN3e9l8Ajz7XkwraQrPXJ32yHQXt05K42zDJePvVjhcgfjGZWuRDbR7SpTbQPd49hliXy2fijrTz1HYfX1mbahvWQ+sLbACVe+yv55XvcTWBd5Hrjc4Eul3UFuKyNww08+4A0W7bSLMXjPcRXKA6XzjIefp4GuRTa8TdoKhSHOpKPsF/6yee0L/1gfcJhlKv+a59vELxvK1kcZKnBt7VIq1tYl6SOaOUsabTl8GHStd2l/2FFTug2NUz5wXrMQ7x2lx61+ttqCe1GR5t0LaGdDfGIvxGW0PZSeWJ6tPPBfNUacXPUZvLtthmtHHxtptWWfbGhtsS6qdYcp7UZza5cdy5VdND6Oa3uXOqQE4ettdnL4fSCSzNOQTvY1YVc6nGKyJ+rccqWlHYV+1wTxj7ZNL5I85/acir3KehjtMcfbbkP+yN+XHxH4lR8Wxd8bVRbgj+4JZAei0KPt3ztYbZykEs+DyNfmZNnlg/CWO0Dw+708kmYfkijbXvg/GAdwj7oI9QH4XKMb/mfn7GeBX3Qx2c5pgi5nbBVP8Kf2sH0rvHukKJXfP3a5FrKWKZivghl/HnH434csHy+TOWDvlArH5GtTSNIWuRlHb8KOv4/T9tDHb/mwMXXr4tm4tgXRZE+3uEyxGkQDc/bDwT/WymfG6Q+hB0D5dTnBix/HgOl7Y/YTohHDvFBI4RnG8ZB6sVfQb34BrVvzY/Otg27xqsu3x94enIy7RhF5A9GIcdMjTGK9ilAX524TtFfxoMavlUdEnw8l8J+fgS4RC6+knY93eM+yjemiQP6nr8e1jkwf9q4SI7BR440vr/d+qzlqRvaTZp6rcnxjZmuMpSD7Zlf9wr0Cl9RbH8D6KmNkXn7XA3y0EMcGp7nNZm/RnhJ3xvp23mlPXC/d9qyR//Gdfyn1Pf68hgH+exjRtGpR8Hw1tHdUUO2pvMlpLPg/xf6at4erz274DYyfiWgvsUQOPnL5bshfRo/qi3X7QZMfZtVNNMuN1I6XBaskRyNm5fmNZ7dxMP5XAT3RhRubWk6/rc++Z3tMAjfTQlfL8jYo+jTR/jhZc167YuabeqzWfxvryIXj1kcIbl7SW5ch65f28wpuuHzAJY7lwmPU1nPKsULfhW05xXJNS/vxgH7x2OW6bLx+eEmj643KrruBlm7as3xgl8N9tq9VtcV9UFd529+Uh+bN8171Jrto/kP7VWLdv2HtnXgeorDvpj9rzY36OtjsBw0PM4LIP4UKGd5tvLNa8b80i9p8xY8B3AV5MHXT2nPu7jOccYyndf1epl8/pXX1J4E8xxnLdNlxwHbYLZN2Rc4ZP9kRYOzQDbU5j4sx39aWeHWDS4X37zeiJKeX5kI8RoVytT6Zx7rt/saFaZ3HQkg8XEIPJ5N/ewq8gcVm4R4dtWeLX1rOq0+Bc74moLXyg2fXdG3RiQXn11rdM/ni1v5hQ1t+gWcO0b818AvPJf8AurFr8mhz1gV6bpEkb+MRpT0fBxSqOfCVZSfazz5aXc9F9PP1aukq0iOq968gurNbF+Vfi/Um1d56g2vfWpr3VoZpJmD95XBlpRyru1QTtrXTB/LdWqrUZ16AOrUNs8477Fu5+sM5WhzPdoxeby1WOtnr/fI8R1T5ao3u5fpMtPWG8FfB/VmT4p6o5WB66gllDtXe3/myh/6uLSxt+C1sa1vDJZ2PUDqC47ZpG6Hfb0l/X4SkT9Iutrq0xjv7o5m2u4GxXZLo8bcR6myPZefOKcyve3qy3ZwYQjhSNRs5BoRCj6i35wuVqqXMNcoMuKA55FgRRqh9DygZv40OrXCtorXGuENjnxGUbpGiOnbPVuxBvGIfxNMoqQ5DwIrTzvnQexy6N6j5GHQkY5tzwMF1EnLs+Df6cnzdS3yfAHl2XWuG/5mXI+ShyWRvqnCd2bNEVGz7u3WJ0w/V4OVI0iOq3P/iGPy2LVBdSPEI/610Ll/nDp3bfAdOv+us58wXxsB4zqDpFfhjAO/iCL4zyd5Dzzxo75T5XsPCTfkf3FZa9v4ylzwr4Ay/3KKMve1H+1MM5+vOKQHMrlKNk0dR/mH/EDmu5lmI9eIUPAR/eZ0voEMY12NutOBjKaTC9vuQAafAHgg0+6OEUwvuLC7qfIzdjTjqk4NZLoOVMQdFr4nON59xfzcAeBLoZrteIeF4L8Jg5g9ySqnVlZHOvSLonRlhennanfPkSQnxCxuHHhGY64H6646KG+KtBok/aDNDhMfEhC/FDrMv6UOM+0usjQztVznoyjdDL+vvaVtP2yjXoUzDq6DcBclbzyHfYN2NDt/q3ajqTt/HtBpuyoGlbiODgUar+ayY2PjhWq+NFEZHeM+UnTle2lW9I5T8GFnjIrqoUA3gF3j0Atx11NcH8SJjtpBGWEGZsVyGvuj/BEFzwfbtjtrbMElh1toD+vz5cvSfiBD8EsS35T24Gnst3xvW19L6bSDp+PAPjEO65O/rWpStUUQeVI+ixVd+M2g+qQJ2GX/2ua8uHb+9Dryi3mLFA6X7ViGdljIa6Jm3a5LoZs28YQcVzn0jDnmageKJufYDuUcq8gJufKFMluNx05c3kiD/sa1InVOrRGP+P8ZaXCenHBqb//yzjttYhXHQuwjeecdY9jfCP4J0K5afZgA8+mrZ2k/TCD4s2g8Nh8TWpzn3qixuxf94/NrzXkQ/HFQzrnl7XG+wMH5yuUNzmKbnC90cD4fOMc99XF11CxP2wmq7XAfUdLjrlvUxbh86x9nuiwMf/1DPlsVW2CeRL7mY9rxZShrrt5a1/LmK2f8SB2vTGtcW9vkGlDiQpSp7+1IlD/s0VXLB48rNDmrFZsI/nKPXoiXNox1X9KKDfHjf4Y2zPvKGz9GKPJn83EmsdtqwvHHmdD2lzm4Ivq9mu71RPrHmWKf+XDi57V5k6McOosOfI/rP6bn+h/GZ45PazulJfBYjHXk0EO/Ue+4vP9tZYOXccjB9dj1oVPN57o4tLncVu0+DrgYIQue23ds3VZ5wbZNV5R2VM69orJlh1J/l1D+uN7xiXeXERbnZxHHi5lb6fcO+r1T0YcD2wTDsIJzBa19YHs8Da5n0z9gesFpck7oUM4Jihwf12kKl+C3KfgTFLzkQ/OX4gPwI6wh/LfWhrDPEPmz8d9it5MIJ89ciyJ3/9XKf59E91z+W6srlzr0FLmt6oo2RmAufH7CA2V5Dl/wN9HzUJjx7GRB/DuOMcRmYccMk4UMyRN74z2UP6zoI3oPKnGdzE/nJwq53MSBJfRKtpgtlbO+toz3uO3vUPBPUPBi651hbK0e5LwD7BqHXojbRnF9EIf9Cc9Ph/FPk6nsj/JHFDzPl6QtS43rgllyyfw0+nhp23Plm8L6lPbHk3z6A87H8EYuXO/BuXQO2jhU8hvX21vb+KALlgfPhV6m5MPXl+I9X1kJTsoK68uhWFbY9jhoZSX5bbessDy4rC5X8pGhONGH7/nK6nKPnKUdylmqyPH12Wn6VE2OprO2LwTnx99D85Hi73B+HNNeU2vEI34Q5k3f75mPRB2ROxPpa2HsoyU9zo/7xmKC/7BnfvxyyjPmk3XEPPcq+YoDz48L/hM0Hgz0HKDOj4ussOPB9n1RhuJwPfj8WgPHQfM3kqe4jFevavAyjvXBOskbxrVxKnLxc/qUoo/kc2fUrD+2jTjwui+m30lcrU784k3xmD7NG07IdTFx+dbeW53qfglxaS8oCNd1LbheQlyuU9q5XmlcO4lL+7ChcN3QgusK4tL2XghXrQXXlcSF6WvEtbsFF59qiel3E9eNLbiuJi5MfyNx3dSC6xriwvQ3OdJxv+Tb/xj2AzW5tj/cNlenAmp2921u36PoOqLE8Ryn9lG3PYocjWurIde1hlzbDLl2GnJdZch1jSHXLkOu6wy5rjfkusGQq2bItduQ60ZDrksNubYTl7aPQfNtS6PGs9DB9Z5nli7bvnNzJaKA40mRgb93OOSPKOkjDxem8eUFx5o854UnN2vrs8LHe0Z+Ac9AcjqXtgaH+vj2PgRe08+n7Ve7dW+FNp8haUeUOH7ObGdNs9M6Hgd83mJ9OH3Ugkt+41qi4LR5VswrP/NL28M5CeQ4p9aIR/yyRK520merZzFeA9Cet7BfF32WRzP9Bb+HoT1TanP7uG4Yh16IM6zX09oph2ifvlp6W8SBbef70hGWvXbyCK8FoJ/jcVWreiV+lJ8VMC3OiWlleTzJ1NaG8B73accredPknNChnBMUOT6u4xUuX/n51r59pzUHOk0u72vX2rzAbNa+xW5rCcdr39pcC3NF9Hst3Wu19o1leplDT5Hbqq5gel+dvLRDOZcqclw+Pg447uF5XcGfm/j4sGuvEwXfe49h3z+bSL3G7jo1E/UeVOJ6O9C1OpHPTheqlexoYWpqOlv2+Yx2TyA6ScGH3Vs+oa6x4zsNceiFuF0Uh30lftmA19jD+MGJbBr7o/wRBc/PG+2e5GrBJWvs2JdI254r3xTWp3TvGjvuDWln3RbLg9dtdyr58PXZ2nhSK6udHjmndCjnFEWONj7OOP6KHL7HcjSdW63bvoKeqbTTYjHttbVGPOL/DtZtX+XZE81jbW4TWAfjwO0eT99O078LvgzPcLxuq72beW3NrbPI6IX7vvfMBb+Jxhhh+nl93db33ivPF7T73qt2VkDYPI6X2a9h0Pwav4ODc7C8l6IGcbzfcDfE8fwMz3li3E0Qt4PitLUHidsLcXxGB35hAusoB8034+FkG9tY48Z6w2cFaGdsaHujToVrjBNd+R7XN0x/mSMd+5HA77zkArfp+ntJ2jvfmCceu892XxDKGiQua9v58ubbD4XrdLzOpnFd2ybXgBIXoky3efKt+QRNVy0f/DyvtbNTFZsIfpdHL8RrB7DN9XyNZkOr+Rqx2xmE43fNsA5e6+CK6PcZdM81X9Pq/fQHR3Sd054XJPjfh3HcQ3DN7/Eg1+aoOW4zxF2dXIdd4xmf0OZV2HZXg2x+BrpGyU/avlTyFNerxW30pThuQt2QE8vvSsDw+/uCfy+Mc/9gjc6Zifzz2lyH0p4hIPhHPGNtwfQ68rXVwfkVqIsfdtT1SOHU8sV7P1mHy0gHwX8c8iXrnlEUqf3sZvi9o9as2zZFVuS4x33BNkecT26rtPH1FXCt9fVcX68kvKyru2zKdUXwn/fUFW1Pr289m3VgzOUOHX5V0SHuJ4aS+Omtl13tWArthWt2z1pRchFsUXhcQcwQZ0+aA/PIb1/105aRI8c9LgZJi2dxliubKztca8WLiOxSh7BFkR7S7Mfrtn0Doffj+c6bQFtq+5J534D27lG7cma7b4DrwmaH/IySPqK0GeVeHA6OYxY/eq09i/LcR7vPolrjYC7XGUGVWiMe8X/s2W9wGeihccoea8Fr42LfQcatni/5/TTtOcUnG22ZZk7fp6u21oNjft5Lgfpd16auF8yxrpe1qaurXUofdsBJb7qisu15W3dUsKmwGhFdD9A9xvBrC5c7VF1KOJ725iPVuN/kPmm7op8WNNfAuvRErQN/Z+BvoIl+29FEo0hvorx9RHvVT3uk06ZlfcN37WNLyHFOTc/bP3ncT6tXKbjaa69LaEfgaa9eXE9xmA6XUQ5y1xpxggu83amsbXfC/PbVmm2hve7hO860puC147VHCI921JaGeNpWm77XloZavfpyoSO/fY788sdQBf9/nvpXU3TQjmoW/G4FXwMM1zG0726Kw3S8lI/1T3CB619Fq3+YX65/N0YzbYF4tt1NCh6XOHDrMuLRjiPRzLYrMjX/J+WBRy5qy9sZx1/Rle/5thZcVGuWE+oja7IsyO1JG8rF12dHzfgbQS63Jw0vdsapFq38+gi/esWjf/Gj5Dz1HIemD4Kv0GVj279W0ZVlj8Jx5ccm177hGx/lfQLo/uBad3peDsV+h49Cdx3ZivbHfGKZs48T/Cmg50O0NQJ9CU6jx6EX4gx9SbXdvmw3xKXpy3y+B202Es2sp67v6iAX2tw1DuqP9DEIHq2P+CyUEX+EHPtM/oD6VW3qnnZseC3k4wd0lD/akl8v0spK8/sjkbsPTFPuWn5vBJ01PPoJxD9FsT1z9kV6Xao5OJ8GnHyUdivOjQ7OZwAnj1W0/lP7ro3gtdeasE8VfbTXW/dQHOrO/eZNIJ+xm0g+xmEbZrmRR1/uc1vpy75d4i7BD1In1wPEZ+wXC76yfLySn7Rlea0n/8wl6XqjmfVVa0M3KfZ60Qqds69Nzpco/as21tlea8i+xDE2iAOPDeLAPvBaRS8cc2j9tOtzKK9S2uu8PUPmKlmt30Vb9IFc9J1R5N/WIHjfMyf2LyMK/vJac1yab92hnNn0a190fBtQ442vjyE9fOOx+LoM8Yjf4vHjmg19Nq8peOxTeUsrlkeN4rQ63W31Fe3D9bXmsUUc2n1e5/qKfpPHYb5PPrWax/LVVzxa/yM0DtO2UmtzCzylW1P0uUHJN9up34EXPu5Db0oxrkIdfK9apJ0f0Pq4myJdNrbbGvDzB74Ff0tKfy7lEvY5KpfT2gfalduHz4ZxaHeMWEuufa/3a+3jRorD+sltJ+08YKv5Hf7Ie6sjf1yfuMA6g2NM9vWCf8jj6637V55n0Ozq8x3dVpe7xdfzfIHm67X6h3MBW1OMNbZ49G+1tsH+L+3axlWg/0HuWjQj3/NR9nO5tsFlX4M4XtvQtqSn9SkvpXy08ik8byn4T7fpU3z1ytKnaN9mn795xu6uVz6f0m698vWB6INekeKTnL565Fv7Svvs56tHPYpe6Ce112jjsD75m+0w+NZkwn4GMTuaIXliD7yH8gcVO4bY/qWVq/ZZtbCfucwWY5fHbSUOr63NtA3rwe3pGtBdbHwJ8PB2be1Tv3F7+hbNNWnzAZhWZPB8wHdg7uzbxNnqyExf28f19Q3LdF2R1/dJyRuAS8Nj3hH/Pc8zYE3RQatbgt+t4GuKzu2ur+9yyNH2Emj9suB/mPL5UGSH7f/yufles+c5Et+aPZbBbpKj1VVsF9wGtDGa1l7xU5pa20KfgDqKHnF4DWB43kQb36Heckwqj+9+2ub4bgXca7df5jbT7rO4Vg4+n6GVzYw9OR6f0WqfD9u0noeVDc40+3x8Nt2t4GtKvnx+KK1NeSuoyElrU8Evgfy7/HBamwp+yGNTzUY+m7Zas2eb1iDuRuJqZVPetixy0tpU8Cs9NtWONvDZVPBHzqNNMc83Ujrt0+wZiMf7g450Ix7OGxycvvEnc7jKUvNpXJYneMpSy9cNKfNVM8pXrc18Cf6UQPm6ypGvq9rM1w0t8nUV5UvwZyj50vow13OtNucSB577F/zZSrs8nOfMeF6sBnFXUZy2f8lXX2bzfJOluQ3fkSPaXnVtno73aP1SyjqAx5LEoRfiQtcBrMtcB3yvhcRhtnPOIwpenpO1OuD63D3KmU0dOGNZMy7U3lo8mgrzjc8ROEfBzxE1kKu1RcZLu8O9tTXQmfefCP6FUF95b63r1f6LVuqyXW2F5zQEX13Z4Hxxcq29zs/7E9r13Whnl+9++YLvbvLdYjPNd3Ob9vnuSxU52nFa2rEHkvbgvobh1vprc8mC3w1cvjEYj/le6xkb7YY0WpvLOji3Qr2/dGVz/rX9TjHuypU2srd5nh20ZwHfK4Q3KXh8zqol1779FpxvLqsryS/UAMd7ViQdjlURz2NVjGvn2WK3kke2Yb8Dz2NwwV+v1LM0ex9afbLH1y/iuJp9uvXrpLy2o63f+N59mL81wnxe88WYX/bFvjFRHKz2RGp+Gn0xt49Wn8Py1RVJG9eVG5PC0OauXGsCKFPbg6GtnXNbkfw8CG2F981r86m+cXt9D47HL2p58LWFWuTOs9YWsJxqnnTaOifKWp/8zWarHQWRtzvhW6zoInK5f3k72HH/Wl3XzAx9Owta35khO6EPNvQN2QzJi6KZzwrcN2n9zXoTfRprsrtJH1e7E/vcGESfXBXXZLH+4poslo02ftDGv/g88gj1XZoPQH96FsQj/mMwLvuwgzOK2veduD/3m0ubeWsKbyd71Hz7uHZTHKbjvcFYJvws3urdJN7nKPjPgm/wvWMoeoXdO16d972xYjNtbyz33Vr9w7rA62rJT+c4lN9pEvxXPeNQ3/7cXW3qfr2iO7dzbjuPpBijdrI/9xiIR/zvesYGrdaR5mp/Lh7JeZC71ohb2J87cy8dvi+Udn/uZ8l3a+8Y+da6tTll1GMNxCP+u576Z33+Cb8HmHaP8Ly/C5TN5ed7zozXNGoQx2sh2r4obW8Kvov2UFL/QtpxfCJbH9NKGeIx9Bh6IR7xP0nq6yDkQ/529EmW8VKuWihVS6Olcrk4XeJj5eMgZRYfMxXXhx+tbNhM7GRtszgIf18Y/vp7v72Q1x4lTyJf6tIiwGccf6NIf2YRWYPEZZy3nC9vqD/PFfSSPnLt4uptk2vAEbfeJt/1Mu3x5Jvlu/BaG5D7/R5+xItfxzrcT7ZYHMYWeV+59YNMkT+bY7Pl97GE48+cob37HFwR/T6W7vVE+rHZ7JeGo5n5ljSBfUrq40RF/mAUtD3U/UAf6eNqu3ic4OatpXJyyie7PC46NCfScba56OrdIt3j6rCI0skwUOtCWc+MwqGZQDiXR806YFrNlfQ45EZRo7qy+2jFJdc9Hl1cHBniGPZwLDSdhaajhIWmk67pWI/G8xMTY5P5qWxxvDxdLRcLrUbj1vKnp8amipWp6bFccaxQzJbnWn5lqjg5PjU5PZotZydzk3Oe//HSxAHpk8VScSw7nR0fa+dpSOo+jqy4rWujxn6Fe0RJLzhNDtfhxR457DIzUWPU1x/5R4h9hH9KslKo7eTohzSSD/zg2mKHDr1KnuPAH1wT/HrQ4U202wpdN65uPGOVX1f2y71Rs2zBP2tVg/Pc5FrKRxvdjkS6n8E4LEux0VCUrtzFJlGkl2Mf4WXWw1XuSyjfgn+eUu7LCaPZYEDRD+/56v+Ag0srszhcU9N1fxHozjN/g4p+PYp+gh9S8OiTRB/NNkMUN0jcmhzMK5Y1f7BR8C9X8qrNJors+ThNGW3YV2vON57i3aPguTyGFfxSwIjNRgiPZaO10SGKQ7n9pIPm47Fe8sqMNjOAPkobnqMNRM8BJb92ZTedy5A8yR/eQ/mDpKtxXcq1W0fEPsNh7JP11cFhxT6iz7Ig+mTrHyEfUWSLrvIWE/oVxA+DDRGP15Ie7+2CD2TF95dDOuEfobg4yCnNGSWuR7m3aJ64RhQutJuUadyOLydb8JcJtL/Cy/dYRyxPqfM+HzFbOcgl4yitPcX/1ie/sx2FQl7ysUzJh8jGemXXdkbH0/o6kT8YBW3LOV8dRvtIuWltX9KORDPr8A21Bq5V/UY5Gtf9Xcq135DrTkOuewy5LO11myHXXYZctxhy7TLksszj3YZclnrtNeSybI+W5bjPkMuyDd1nyGVZjpZ19UFDLsv6da8h1xsMuSzrfbf6HMs8PmTIdZ0h18OGXJb2shybWNYvy3GOpZ+wrPeWebTshzYYct1hyHU4jOW6td5bjk0W+rT2uPYacnWrvSzrveVYztIXWpajpb26dfx1vSFXt46/bjbksmzblm3I0l6W/ZBlG+pW21v6L8t5uW6dG7KsX5Zj324dY3Zj3xFf85qVRd+x3MGN1761YU1ORtFZW1NeBBwD0cz8Wq4rC//KQPyS7xWKrTBPIp/XmCVe+ytcHCeyBonLOG85X958a9G47o42cHGtaJNrQIkLUaYjnnyj/GGPrlo+hg1t0mfIxXuDtPavrd8KfqWC1+rJckW2pJWyXQVxhmWb95Ut+giRP5u3jMRuLyacnCi8KJrZNlY4uCL6/WK61wN8GObKv/Nv2VuDe3plP4q2hyj+tz75ne0ojOV9vjVsPzNWyJA8sWlEdhP5c+W7fT4sDrwHI40Pi8PuWgPXid+Jw+sNue4x5NpvyLXXkOt+Qy7LPO4z5NplyGVZJzYYclnWidsNuQ6HOnGXIdfdhlzd2rYtbW9pr5sNuSzzeIchl2U5Wtb7Wwy5LOv9rYZclnXiIUMuyzqxMP56bPhoy752jyHX4eALHzbksvI58TU/a3ei1wM1Oy7LNmTpoy37tG4dF3Zrn9atz1aWtrdsQ5b2svTRewy5FvqO+Wvbls9Wlr7wXkOuhTmF+WtDlra3zOMbDLm69XnI0va3GXJ163yh5ThnwU/M33hiwU/Mn+271U+kGX/h+TV8fhyuKa+ImrlWtuC6gLgw/UriWtWC62Li0vYzSLojHHLwbA3cg3GEIlvjFw5tH0f8b33yO9tRyJeHFb0yyV+RfSTct1tbL05nSJ7YBO+h/EHF5iHW+o+MZpYR2ofX+o9SdB2huDjcVGvgOK5HubfIw3W3Idf9hlz7Dbl2GXLdasi1wZDrPkMuS3tZ5tFSr2cbclnW1XsNuSzbtqXt7zLkWvBfC/4rZB4tbb/XkMuy3j9gyGXZtru1PVr66G7tay3LcZ8h1+HQDx0OebTUy9KvdmO/HV/zc3u31C9Le73ekOs2Qy7LsUm39mkL7XH+8tit/fbh8Jxm6aN5b9djsd7fY8hlOY62rF8PGnKF8NH83l4c1id/sx2FQlHmonFtIxM1yw0zj5+tZEie2AjvofzBaObYaK7m8dE+i8g+R4XRp5ymDqG+UparlTjhOjr5jetMiD8K8oh4vJb0eO+PEkEjCif7ydVKfvCe2Dd+H/p3Et422kB+uporjFbGR7NjpeJoeayQL+fHs+XiaDWXm8jlJ4sThUJ1ujhRnsgXqvnx/PRwNLPcuQ0EKuNi2jYg8gejoG0y56tzRyplpNU5Sct1IQ47ag1cO3XBsl5pesn3gtKcIx+mLhSmZlsXQp8jr9UF3znyaevCjbUGrtPy22DIdZsh1x2GXPsNufYZcu0y5LrfkOtuQy7LPO415LLM452GXPcYcj1gyGVZvyzbo2X9svSFlnrdZchlWe8PhzpxqyGXZf26z5DLMo+Wtr/ZkMuy3t9ryLXgJx4bfsIyj28w5LIcT3Sr7R8y5FpoQ+1x7THkWmhD82d7y2d3y2dkeceB55DisD75m+0s5AcUuUbcReE+2p67fkbsMZ1zl/mGcK+x17sq3GsV7lyhkDugzniuWq4WRscn81O5scLYWLVYHR+bKJaro8VSebySK5YK+cnKeLaam6gcmLEuTI+PVSfL02N17mPN9S6Myjwdfr96W+3Rv/Gc+6uTyin1Hr9n3kNp4+tFEI/4rx3V4JxOroeBNwKOOAwQXyaynM/MZzMkL4r0+VWRP0i62urTmF9dRPqwfXh+tUfRdYTi4lCrNXAc16Pc83HdZsh1nyHXXkOuuw25HjTk2m/IdW+X6rXPkGuXIdeGLtXrfkMuy3pvqZel7e8w5LIsR0vb32zIZZnHhwy5rjPketiQy9JedxlydWvbtuw7ZDwh713j+FG+eb88mjl2GqK4XohDDoxD/Xo9+mH6Xkc6zoeMf/spfn3yO9tZyAn/kjD89e82LFZshXkS+TKe7QN8xvFXuDhOZA0Sl7XtfHlD/bkeLAZ9+PsOGtfiNrkGlLgQZdrvyTfKH/boquWjl2yitbOMYhO5v8SjF+KXK7IlrdhwAOIMbZj32RDbosifzTcvxG4nEO7CWsMOXAcXO7gi+n0C3esBPgzLiUPzo9yeXeU74kgfh2GPnGElneRvCHQ8AeKXePLbo9xjHTG94DQ5mQ7lZBQ5zKXN0cShUmvEI/73k3mZOA/fWtPMuU7Rz9cWT1Tw6wAj+mi2kbTDiuyM46/IiSJ/HVoHGPZTJxrKOREwfSTncYZyHgeYpSTnJEM5JwFmCNLFv0+GOKxn4kufAPF2vjRfknyeHs0MEncG3HtjraEHhx76jXrH7eGtaxu8jGOZp0DcGRR3KsSdSXGnQdwTKe7xEHcWxT1B0We25YxldYojXxZy0EankpxTDeWgvU8jOacZysGyk7IaiGaW3XzVfyxbiTsT4risnwhxXD5nQRzb9GyIw73RHLT2JnaK29sXU7S3w92+Wr2UsGDfRtxs7Yv9GocF+zbi0th3Njb8aRt9LpaV5EnGt5L+pGQxPH7uOWF1c3p81uT3P46DuIso7nglLub/cbKALeNbtAM/Y2A/1KPc8z1jnObg6gWuAeCScwn7CL8+sUfYOjk27huziOzTA8lO07ej/GFFH9F7UInr7UDX6vREtpAdGytXxopTo8VqJprZdnuUe/zcdYaC174xKLY+M4yt8/VvDtca/DgWjkMvxJ1OcX0QJzrG9f6ytc36nxFI/zT2R/kjCv5iyEM7ZRmSC/2BBdfiWXKtjJrbE/qcwP3ipOaDJGhtfoTisM6toDhsT/ydaewzce6NQ6t+ceTYBi/jOB/YP5zu4JS+4GSIl76sj7AvgD70udSH4vPhy2vNcfgcJnJijo2rG/dRjtYfx2G7Q68y9V9h5hyKZW1Mxf3XGYFkp+2/eM4B9RG9B5W4TvqvqVy1UMlOTRXzU+XRsbExX3+E97j/OlPBa+fmiq2fGMbWU1r/hfM1ceiFOO7bsP8SHbX+K0z/W5xKY3+UP6Lgt0Ee2ilL8e3auEnzFZfXmuNw/gfH1BupjYcZJ+antLnDiPTHcuP+Aesk9w/4bMT9Az57tts/iC3a7R/QT2KekLMX7mk+vo/wV0AfsYP6COzTRXaM+y8qW7STYdlW2daRYpMs3Gt3zlj0bnfOGOtyluKwveYoDsssT3FYDwsUd5aiT5r+JQ48HsSycj07WcjRxt1aW+1UjuYf2d4WcrDspKzC9mvt1X8sW4nLQRyXdR7iuHwKEMc2LULcarjmoLU37FvbmXM7XO2L+zQ4LNi3ETdb+2J/ymHBvo24NPadjQ3bmTPGssI8dTL2+QyNY8I8C2azKylfKGthDLUwhnLJWRhDPfb7IDynj8NCH9SIm619cS6Tw4J9G3ELY6iZ4XAYQ6Wd60k71npF7dG/PNb6Ocwz/Wy1W6/Hg+wbEue4MEZaGCO55CyMkRbmmTAs9DEL80wYusG+2LdyWLBvI64bxkhYVu3OM7nGPk+jccx8zjMFqiMVbQzBtsX60+4YCstztu93nE1xIcdXqM9sxwJYVnP1fsdjdawWdg9He/Ufy1bzn1zWFv6z3Xkm3MfZTh90uNq33Xmm2doX5RxO9m13DCV26pL3O7rKvmltONv3O7COcp+Lcz2Cw7ke5kAZYcso/XeNRP5gFLJNNs6ueDzpw/aR/m9p1HjHZWNlxwt2Tm3eNP3sytXbn76l/ILSth2bSpufXi5vq2zfjrlBCcNKbrm2MEauR5T7yHF6i1zIiQfLo5mlfDpxndGC6wLi0kYewnVmC66LiUsbXUi6JzrkIEab4UF9nthCn0tqbn2eSFxnteB6CXFh+rOI6+wWXDuJC9OfTemyDjmIQW+YVWRr/Fxvcy10vqLWrDPqlSOufAuuK4kL0+eJq9CC6yriwvQFSld0yEEM9qRFkJNR7mn6XF1z61MkrtEWXNcQF6YfJa6xFlzXEhemH6N04w45iBmD++MgJ6Pc0/Q5p+bWR9Km6eFQV8MeJfVbCSJ/rnq4VnblU2ImFF1HlDjsQzAO5UwocjSu0w25zjTkOsOQ64mGXGcbcmUNuXKGXAVDrrwhV9GQS3yi+DQsV/7auTZGONsjB9PzkwKmyzj+ihy+x3I0nbWZNDxN+3ePbqTBOognNWFa6Yv6CP+lNQ3OP0g4xZbak5L0AVi37HxuYUzyjX1rRDbB/ucYuOagPTWK3u3O1GIZcV+J7X+C4rA9T1IctqknUVxB0We29QvLaq7qMc9YZw3laONgtreFHG2MrI0xsZ1gnMjhe76ThXjG3tX+/+loXaar/Z9Ta8Qj/sPQ/n9MK0GYx/ls47wTROvHJW4S4rgOPgnisGw5aH5DbNHJbJPkqZt8aBzaXe1a8KF6vizkHA4+9HDyLxL3ZIhbA9ccWvmedlYLDlf7trvaNVv7hpl36H778vwUBsvVrkD1t8i7oDAMK3lk++I8HNsXy4Xt63rO5xBq/DEK/NwHIA7HkK557kjhYB7uFyVukZJWvnalzXUfSTK0+Xa8x33QkYq+vj5V6h+WkeG8YiFNX4ryBxWbhJjnzKW0qzb2ypHNMY7n2tp9PtKetdLMU58dxl7FtOUn8udqnlqb3zpSsetc1G9XOWc9+oR5HmqclN9qHUn0iU9a6Y9m1iHXmpm2foX1weWzfOvLmt/1tVPf+nIn64a8vqzZoI/iNiWTcrENLzmmGSProhXAvDy5Zr8icuIQuI6kbtMifzCKAo5RGm1aW4vVfGVcZxdH/rqDZedalz9LySvX5Se20InrsiZLG58I7uAJTce4cWd7cNpp4DHudR7cGQqOOaT+4j6SUyhOsFsSjoPj3eQEpcP1LTG0M4+9sEz5eQPrTDe8JfZYO8F+rnY4S1kdSm+BcFn7xp/YH7FN5+Mtm0A7RLvevrj/gUOr3aML9m1t33bfcJqtfQOdxNhV9k1rQzyJsdO3xOLdt/Km6sbKjmdXrn5xafOmcmnHpq1bLqxcvrOyfUcv0XIXd6pDPc4e8kQedeOwiOIeT/FyaOeiSA9hH/ULWW3oJEFbLml3WCV6tzuswiK2fsEem37oJa7HO/JlIQdtNNcvxbO9LeRoj2lhHyvaq/9Ytppr5LJO+4Iy2xSn5o+Faw6tHmPa6ZYOV/u2e4DObO0b5pD17rdvu0MC/JBcO/YN81J3d9k3rQ3FFp0cUMR9Lo555MMCEnccpOOPRB0PcXiwEX/0B6cI1iXXfSS7L9lXMEA44zIvp1l6OS2Q7DR9p2Zn1Ef0HlTiOvlwQb4yNT1WKlUL09XsdKl68IU95Bdd+R5/uEB7oW6Zgg/sO0vSJvDDBfwqXi/EnUZxfRCHfos/XBDmkbpQSmN/lD+i4C+EPLRTliOKHGzD7XCtjJrrLbZt7SPzJybXYdtifkIbs0tgnxmHdp+NRO92n43WQRx/LOJEiOOXkTv92Crqk8ZPxcFXX9Y58mUhZx1gTiQ5JxrKQXvP9RR64EMJ2qr/Wp+EU13rKA7Ha1w+aT+m2O7BZLPdpnW42hd9LgdL+6Kcw8m+OG7moNlX7LRQfxtx6Bc5tKqj7TwbYR2VPC2MPxbGHy456wDD9fdEQzlo74XxR3NcaP99NFxzWBh/NOJma992Pyq+YN/uHN8tjD8aGMvxB+vep2BPoDjB7oXXYh9JrrW5lsdFzXEnQNxJFLcO4nop7kRFpwzJwNcyBB+HSq05D4K/PdE7tuVDa3XORQ5O2farzQGuS+4NJH97Ic6u/k7nYr2/s6ahB9r0YH5rzXnC/rxHwfM866kKHuur2EjbPncyca1TuB4H92QeUbOn6Dgf9kQd2Z4nt8gT21OzP9ppXXKtjZmOI67jFK51cM9nT9FxPuy5DnRke57UIk9sT83+JwFGbDQSzbT18cSl2fNEuMfz3JK+X8EjXx/h3wc+5xtrmvVDv7mOdD9B4UbfmyEOzMegko9hisO0Me+rj2rmTftqiOC1o79wTVLqtnZchKQdUNIdTq+R8nFwGLSxgdgp7fgqQ3KEl30V15lTFB21IzeyKXl9evjqmO/VD62O4Tp7geJ8r+MJFscXmLdzao14xH8N2vq3wA8e1LfWkIGv/cehF+IMX5mpaP4Ybcj+WGvziG+3zYvNRgiPZaPtgeN2p70ygUc+oU+Tvx2tW5fLlVwxNz45USkWy5OjK4kfbTEUQH5xtDQ+XRrP5SaLuUoxN+fyp0fHpqYPKJGt5A6aY67lj5anJrLj+dJkeXqsXBidbiV/eXLdX2vEY3uLw+Lkd6xXj4IXvj7Cfw+ee75PbbpPkRfj/tWDyzj+HuRQ7vXWmu8N1Gbie2oz8SJ7sDZTR4kbgjj0BXFYmvxGeyGX6NFH+H+GZ8M4LIE0kn5Ekb+E5DfprdxDX8RcPco9wcfl88NER6m3mHfrVxYPyiR+vMe6Sd2J63Xsv3+UVH5+rhc+7S/aQGszIwrXjtqjf2UM1h8FsUle+BeTfkb8ObFTXzTTTiJ7SZC8VatpygHlD5KuIeofyhN92D68f2ogjH0q8Su5Uvew/fYrtmE9FpOOg4F01MZropO2x0v0iDFfpldbFwXSMWwbrdb3M+IzBx61t5jmzqRscLyM9R77VsQvXdvgHEyulwOvpBc/NQTxi5V4+S3ltUjB4jX/Ft3ZroiXOtnvyGs/5VXwK5P8xbqdtkrnRPuhXoscnEcC57doXgDnAHxtXvBDCh7bmOizPJrZNocoHeo+EDUHvKeVT4awPLaUfgrTuX4PKDwuHZYoPNo8zQDpijK5PsSBn6V7FDnYprDPD7vfJTuq9ZUSJK6f8otxmPfNtQaOgzZ3gXtTfkLjZcSxPlpbsxwbyf0+uM9yewjbT1jsz9lmfQY6jihy+ol3sUf/DPH0KumGI709an/T6ptR9NX6mk7lINeltWY5WM7Ypz2Z+jT04z1K2ufWGvGIXw992i+l7NPYl2AettQa99hn8ziW2yTPt3HfxRjsxxF/rtJ3sX9Arvje+SnGCNq4j8cIG8GeG8ie2hhgeTTTNlyHB0gWjo+lf2EbXAh6PH+tW5bYddiTx/jei9bqONQBccyh9Z3CobVrSbdc0YvbHvuOfo8MrT/TZPRRXKflo/XbONbQxjBaPPbnKIfvLVLwrcYfgw5ujbdf4dH8/BKKyyhx7MMwv+jDeGyiPZOhb9TanavsfGNvTfc046p+j+6a/dAPWc9RZieyuez0+Gi1miuPlaaKreYo5b7MK0q+Dv6Fe32Qrzjg/BnP3+FcYG+tWb7MleH8HXKJHn2EvwbKOg44TyXpRxT5OMfFsjT5PH+nzWsOKPi4TLcnOoaYe86PTk6UJqeyuXw1ny9MjM313PdYcSw3MVGamB6brk4Wp6fmfO5/cqw6WShM5QqT5cpkbs7zXykWpqq56uT4VKGaLUzk5nztoZTNH1hzmZoazVVKk5PVVvLxeS0D8uOQdj5E8HfCOOuJNEewyMMZh3NqzZyCv8czR6DtHdDyKff7FDw/m8ZheTSzP5G0/FyBuCD1KZfLVceKUxNj0/kDU1vTc76WVx0vjVXHs6P5crGSL5fmWv5UeWw6O1nIlUul8ez42EQ79Vl7Zqr762hmvTacm0h9/GR9bSiaWedCzKX3kD5sH7nW9mFKWm39Rc718bXNXkXOXHH5ntNDz1OlrQsifzAKWjdzPrv2KHbluR9My2P8OHD5aX5Xm8s9VLjQ/2tzd5fVmuO0vkJ7ZuFnb239gn2c9qzaS3rK8wTe71f05bmLX6P3+sOsO2az7NNRlu95X8uf9qx1sSN/fwlzIl9f21qe7/lRmxdYRHH4jMhlVF/LT5kHwf+eMj7S1gBx/TEOvbXm/K1P7mc7C0VtzxauXfTVmvPtW7eJA4/hlir4IcDw/M5SiOP2q7V/7Rmd61l/pM8BCh/Xs29DGfEeWqzzg6Q75p3nTXoUub71nljP/6T2HGiPxLi2viJhOJrZTtiXYjthf8nr5hiH9aDdd33EFgfL6NgGL+MkaH6CfYG2Bqr5id6oWR62W+Gfj3aL843cbrX1WcS3sz4bB+nfRqKZZcn1G9vMAMWhXJ6v09Y1fXPN2GZc/a42JhIdpex6lbzEgftdwf+c2imvq6xPfmc7DFq/y/tUAu3tGdPWDSQMR+5+VvMf7CN4/w/Gae8PpPURYot2fYQ2btT8B/sIbT1NawPcPrR5cN96h/bcJGeeZYgzivx9pbZW2Or5nNd+4xC47qd+Phf5g1HQPjPHYwzRh+3Ddd2370PrYzMUh3KWKHI0rkWGXL2UHywPrguB5kZSP5+L/MFopk1D1AWtzWUUu2pzNWn2ymaUuHbnV7qdyzcHmKbcNTlc/1EO9u+4P+OsY5vTSDp83sO0/Lwn+EeObXDmkmvtPWbeE4v5X5/8zbYXinwj7H7bbEl7fozI3kNKnjMKXuvPRe92z4PB/nyI4rB/WEpx2JcNUxz6xGUUF6ru9jnyZSFH29vl6+9nK0dbN9eePzuVg2XHc1NafzbbvlF7DtH6RvQtzztWl4m+BdNeUmvEZwD/RvAtL6S94IHmxie4/mNodz6A67M2LyRxOC/E73JgaLX3s50zLTIQNwD8mC+xr4TA4+C27B+Hds/cEr3b9bHYJgcoDuviIMV16ptRH/4bRe37Ct+cfqdyEMPj6BDvWWltLHSfEXiusm3/w31Mu/ORmv9hm2L7wDExh1bzmO2cWXQ42pd9MgdL+2YoH+uT39nOQtfbt90xueDatW+guYGusm9aG4otLMYnuL9f23+sPY8L3rdGgPK0cbSk7dZnzHbbAY8/l0Ec15nlEIc24dDqmbadM1W05xTE8X7ljKKj9iySUXj7FF7Bpp3/9OmN4y/et+97p0Bbr2M57T5TfSKxR5esz49q63xow75ac761Nq89v7bb5keimf6R9xRp69/aOF84cZ7Neh/ieH56tFQYncxOV0bHS2PjrfYh1tfdaw2cYTnmRa6UV0/U8Ae9tYZOIl/bjy840XUgjK5Z0VX26EsbQpmYl0WE52ve8/9H4HMwj5IPvIf8gtfO3sB3GkRH7Z2CoVp7XEuIa3EHXKKXdh7J4lnqpXH1E1c77zp8NSkb19qfa778W9SPaO8z+ubLBf8jmNP6Ns2Xow/htVdtXw/rEkX+Pmq2c6GB53xSr3d1w9qn75yPQPsRi76+Tyvn+FyQZdHMMtPe7cPxsowZ0uwT0OaUfPPPc7FPAGXj2RZp9mpq7ZjbOeL/FdrxkuOa86/tofCND33jSd94RxtPamdF+N4R9Y2TfOOqVudbsF7a+RaRIrtVHnz1TtvPOo972NSxLeadx7a+vaRx4DIYVvDa898I4dHmvvdetXY5RHFp2yXu+5T24uu/tGcybayN79VKH31Vcg/fnY0i+34C65s1/0R2rKKd9WKofyHsO0f5UuC1uqzUt3NqzfwRye0hHKfBdOcC5lwH5jzAnOfAnA+Y8x2YCwBzgQPzLMA8y4HZAJgNDsyzAfNsB+Y5gHmOA/NcwDzXgXkeYJ7nwDwfMM93YF4AmBc4MC8EzAsdmAsBc6EDcxFgLnJgXgSYFzkwFwPmYgfmxYB5sQPzEsC8xIF5KWBe6sBcAphLHJiXAeZlDszLAfNyB+YVgHmFA/PLgPllB+aVgHmlA/MqwLzKgXk1YF7twJQAU3JgpgAz5cBMA2bagSkDpuzAVABTcWCqgKk6MBsBs9GBeQ1gXuPAbALMJgfmtYB5rQPzOsC8jjAh16QmssXiXH3nDue/JS9h963nJzMkL4r0Z+f6HFUUss9vPDtr7zKhfXDd4iCm1tAnQ3G9tZn5kLg+iMN9MM8GnFa34hByre7A+G068PgnP3/1Llt4LNY7juutzcxHu/VO20cV414M1y9NrsP6wbFK4LXp7CpFf57bxvllbd5X7KqtD8zFeT0XJ7+7+bye5yXXuK7zzFqDz9LHyDz5NtEpCupX8jxukHUkbts89xpobrog+vjmKFB+p/vdUNZgFLT/yPny5nuvwXItQuOazzLVzu7M0G/EL1Ly5ltP1/qWforDvgXf8Xs26ZP2fRyf/lo5a/PY/B5moLWOvK8f19YylsJ1uTK1c+Nztm6MKPCcv+Tz8YQTH7oomlm3+x1cEf1+PN3rAT4M6Lt7a8349cn9bAdhfKKxzi31ENe5MfRCPOKvTH5b712ojpdy1UKpWhotlcvF6ZZnOJ2cXB/a87nFibmaz+0NzB+o71fnc7W93q3mYeN4fu5DXh6bx+FcisN2Ityxn5GxX3wt9Vb8Ns/zxiHsM2ZxPPC5YblVDv0lb3EINPbMydhTvv2n9dFYTgPKPStdfO8XhP7GS4bkRVG6cWOgdppLMyaOg9SZuI+WdcPtO7ZuK22sXFgplVF1Nh//5e5TfvMwm7vkRfSb8T0Kjy/4hl6YdWkSrY4f6PYhwEnJ7/keAsgnHw/tIcB44dBe0m18bqrbl3Q7GQLEXU6ya+PgtZwYL908L/liHA4B+HHwAtIP43Bpl7eu4JIuP26n3Z4e8rHtwDBkKuxrEY8usRzMY63B73ukXkJxfRCHryQ8gewTYsrhgH3Gwj4258urIvcjsgyjimATjBc82iFQOaZerhL5g0Ht1hjKpH2tIB7KHJFcb6zseMHOqc2bps8p7Si9ZNOOLZXt23n7LC/N8PiDh5Ouz86wnjLNoB1X5QqiD/tE5OPxkms8tUjhleBbcuPHK7SBtr2Lp1Wx33e9Yox25G3N3C5Ex25flsDPLcehG5clzkyuD4VxrXxefL7Htcck14f41Nb4wrjWH9KOazsZs8ornPH1cuCLgzZmDTw1NTafU1My5lkVNQLG90fu53Jf/3Uo+LbkK+7z7ttk2m7Bt3lDIfC2jFzgdqj6Nq1N+nxbK/91LnDzM/d5ityQeT5QJ0ZDb+1aFbn7CPFt0s57FCy2BXy1SSuXSLmXidz+kbcpRZDvXKGQy2bL47lquVoYHZ/MT+XGCmNj1WJ1fGyiWK6OFkvl8UquWCrkJyvj2WpuolIZHy1Mj49VJ8vTY1XO6yJP3oaj1j58kcN+3e7Dkzdk5t2Hn5hcL/hwb1gYn0YL41MKqcan8DXSJjvzMavIw585Oyr5G49pVzn40ox3exzp8BmVOSJDe2l6ZBQ9DvXx+brk93z79h8kEYe0b8+NztlrkkF8by47NlfbanBtyretRnCcBtvZwquLzdeMWXh1sfmaMQuvLjZfM2bh1cXma8Z0y6uLgtkMmM0OzKWAudSB2QKYLQ7MVsBsdWAuA8xlDszlgLncgdkGmG0OzHbAbHdgdgBmhwOzEzA7HZgrAHOFA3MlYK50YK4CzFUOzNWAudqBuQYw1zgw1wLmWgdmF2B2OTDXAeY6B+Z6wFzvwNwAmBscmBpgag7MbsDsdmBuBMyNDsxNgLnJgdkDmD0OzF7A7HVg9gFmnwOzHzD7HZibAXOzA3MLYG5xYG4FzK0OzG2Auc2BuR0wtzswdwDmDgfmTsDc6cDcBZi7HJi7AXO3A3MPYO5xYO4FzL0OzH2Auc+BuR8w9zswDwDmAQfmQcA86MC8HjCvd2DeAJg3ODAPAeYhB+ZhwDzswLwRMG90YN4EmDc5MG8GzJsdmLcA5i0OzFsB81YH5m2AeZsD83bAvN2BeQdg3uHAvBMw73Rg3gWYdzkw7wbMux2Y9wDmPQ7MewHzXgfmfYB5nwPzfsC834H5AGA+4MA8AphHHJgPAuaDDsyHAPMhB+bDgPmwA/MRwHzEgfkoYD7qwHwMMB9zYD4OmI87MJ8AzCccmE8C5pMOzK8A5lccmE8B5lMOzKcB82kH5jOA+YwD81nAfNaB+RxgPufAfB4wn3dgvgCYLzgwXwTMFx2YLwHmSw7MrwLmVx2YLwPmyw7MVwDzFQfm/wHm/zkwvwaYX3NgvgqYrzowvw6YX3dgvgaYrzkwXwfM1x2Y3wDMbzgwvwmY33Rgfgswv+XA/DZgftuB+R3A/I4D87uA+V0H5vcA83sOzO8D5vcdmD8AzB84MH8ImD90YP4IMH/kwHwDMN9wYL4JmG86MH8MmD92YL4FmG85MH8CmD9xYP4UMH/qwHwbMN92YP4MMH/mwPw5YP7cgfkOYL7jwPwFYP7CgflLwPylA/NdwHzXgfkeYL7nwPwVYP7Kgfk+YL7vwPwAMD9wYP4aMH/twPwNYP7GgflbwPytA/NDwPzQgfk7wPydA/P3gPl7B+YfAPMPDsw/AuYfHZh/Asw/OTA/AsyPHJh/Bsw/OzA/BsyPHZh/Acy/ODD/Cph/dWB+ApifODD/Bph/c2D+HTD/7sD8B2D+w4H5T8D8pwPzU8D81IH5L8D8lwPz34D5bwfmfwDzPw7MzwDzMwfmfwHzvw7MzwHzcwfm/wDzfw7MLwDzCwcm2t3AyDVjMoDJODCLALPIgekBTI8D0wuYXgemDzB9Dkw/YPodmMWAWezALAHMEgdmADADDswgYAYdmCHADDkwSwGz1IEZBsywA7MMMMscmOWAWe7AjABmxIFZAZgVDsxKwKx0YFYBZpUDcwRgjnBgjgTMkQ7MUYA5yoFZDZjVDszRgDnagTkGMMc4MGsAs8aBWQuYtQ7MsYA51oE5DjDHOTDHA+Z4B+YEwJzgwKwDzDoH5kTAnOjAPA4wj3NgTgLMSQ7MyYA52YE5BTCnODCnAuZUB+Y0wJzmwDweMI93YJ4AmCc4MKcD5nQH5gzAnOHAnAmYMx2YJwLmiQ7MWYA5y4E5GzBnOzBZwGQdmBxgcg5MHjB5B6YAmIIDUwRM0YEZBcyoAzMGmDEHZhww4w7MBGAmHJhJwEw6ME8CzJMcmCcD5skOzFMA8xQH5qmAeaoD80uA+SUH5mmAeZoDsx4w6x2YpwPm6Q7MMwDzDAfmmYB5pgNzDmDOcWDOBcy5Dsx5gDnPgTkfMOc7MBcA5gIH5lmAeZYDswEwGxyYZwPm2YDpAcxzAPMcwmj7FuP765Pf2Q4CHsETZP9WLlv0HSkY9OiZXPpP83TrkYXtHi+c9ii+0zINHNct3iuN+6Gl/mrHTEm9jfnlzJ/4ejzTrDum6SH5UTTzPY0QZTGRK5bD7lvMZbWyqz/LJH97IY7PzUhTdnH4ZfAXc/L+ENguTDvJ5XzvD0ldWVyL6qH+LA73xH7z9c57LiHo5nfeT08SzcFRvPV91OcE4c9lhf/cMPoXhf+8IPzFrLxT8fmkTELvq+azJUQGyg5zhG0ul7Zf7oZP5s31eURxXc4QP+qzRLGPlOWAEidc8r4Gvk+J+CWQR8TjtaTHe+cnBTaicPJ5T9o5NXgPfdPTaYyCZZNx/BVevie8I9FM2/STjtqnMbV3oPjTmK/MNHR/Lo15tHLEcRC/P4afG2M88vUR/oUw7vpKRud05cvF+WLI14uoTPqVPMT3XuHIfyby2zRt/hc5dH0Z5P+rDl1RH9TVdw5P/PfVHlyfgsuQrj2RPtaX/srnj2dbz7VPOYY9I6vxuc9BT75ZfvxvCPLQE830QYzX6hTyDxG+/l5dpPtSKUOuU5dD/X9dinaNz0s4lnLV6zRtcKvSrrUyxnotemufz8RPSDJHHNYnf7OdhVzQupbL1j+NhPUkY6d/VviHwvBPaO/5oy+5iuqbfB4zrQ8X/PVQh6+leoG+Jc15ZUMQL89PUdS5r8LPe/K4YRmk0dqZ+FDBj4DcHuLQ8PKMhr5hBHTg/kbw+6Bdfp36B+1TprH9b87osrFMlyq6suw3QpneRmWKssWuy6OZduYx4jJFF7TzObVmXQR/N9jht8AOccD5j/rzdvK3F+Isny9iPX6XygPLv6/WnO/lEKfVF2wHWDcQvxwwXLexLi2lOCyDZSRH+6Su1r9o7VXSan5kxJNfrj/xvxXApeGFr4/wb1X6LebEuoZ26nVwvgvq/TuojLEMBkHnjzpkY/57lPwIfqWSf8SvIF0F/z5P/keU/K8AzgHiFPwjSltjPTFfGbjH9XiVgl+p5Gt5NNMuklazveDQ9hrHMOkj8gYjvU4Mka4Yh/Ix71rbXqHo6ivrFYocLutPK2Wt9W3LSZ6mH7Z7buNLFS7sV7r9/IgvJwTzfX6EtfziaGl8ujSey00Wc5VibnSu5ecnJsYm81MHVvTK09VysTDX8seKY7mJidLE9Nh0dbI4PTXX8qdHx6amDxRCtpI7aI5W8rV5eRyrxEHm9nHuH/E4LkT8H0If9Q3oow5iFXkx7vseXMbx9yCHcq+31nxPWxPAtRLBi+zB2kwdJW4I4nAcFYelyW+0F3KJHn2E/y70EXHA9Q1JP6LIX0Lym/RW7vFayZCCH1Lwcfn8KfktzLv1XPRBmcSP91g3qTtxvT6d+oFD88yzRz8/i8FY/8Cfm8rl5+pcHDx3xncujuusmh7AuM6qadqrApjnODCus2oQ4zqrBjGus2oQ4zqrBjGus2oQ4zqrBjGus2oQ4zqrBjGus2oQ4zqrBjGus2oQ4zqrBjGus2oQ4zqrBjGus2ri+MD7mEpzsZ8D21gEeQm6j6mN9dLDbR9THnBct3z7mKT+avuYpN7G/E8FWedGzbojn+9ZO+xZvqOBP9Ou72Picu2tNcvGOCw7/NR4nuwT5pzMhn1C2D+2j++cTH6OiCJ9/C02mq+9Sk9JfnfzXqXR5HouPhsedq9SY+x8bhj+Qti9So29VueH0b++1+qCMPz1MzefFYL/wPSD7OX6RcLnGzuk6dvjwGsK6O8zJKfPUA6Op7hPC/SJ8/oegiWgp7be6fq+FK4TLvHgebzG/ANzk98Z+71wHdL3GXN+BjfSJxd4XX2ij/J7c/I3zuuLSSbO+XMZxQF9UPxvKZURY3i/1zDIZptj2j7Cvzz5G+ehL9PMqe0hGwLO84izvocMOJdkdD2jyD/elPvLFDyuQ4g+y6OZdllG6Xxrgxo34nscPLz2w/lcBPcGFW6po7x+sz75ne0wCB/uDcgoMnHNHPGbSa+VZFOfzeJ/KxS5OKc9SHJXkNy4Dg1RHRLdhiLdv+D6vNZW1ie/s52FItsRz4tHO/RTvOC3J38P7nNKrvm7kOgvY9w1lBd8VtbW8NkWy4LYIj+jnqEttPrB9eyq5O/BbxRk3LboV2zhey6fiz0aK0hf9Lt9pJPm/7S92e36v5FoZvkuoThtTyj6LJaj7cPgeufaAyh83DfsS/7iO0DaGC0D/NKvLlfkcBqcL/b1s9pcC+5vup14cY1M67dkjN9H+H8BzruS65BzBQfCBNtC228mMlGfQN93zXKdce1d7YmabSj4N0TNZSF1Ecu4T+ER/JAiF+sz74sbIrnYB/UoMvA5JfBe1Kzv2ShwOab+brDIH4z0sllvo099/lbbv4z24ee9oTD6TMRjl5GouX7EAZ/PsWxQD5wrZr+E/f874T63Gc0vydxSH+HfB5zvSa61vbS4X5ZlLnLI5GcZnl+PA3+vAq8XK3nCesbtVfAfSv5qzx1p6wj7DMRrvmo56cDl6pKN9eOcmi477Xszgv9k8hf7Vubsc+TH5QM/DZxsU21fp8+m2thnqZKv5dFMO/JzViub8jsLuI80jU0F/6Wokf/THPlPa1PBfwU40zwf+2zaanzINkV787NAK5ueW9N1TWtTwf9G1Mg/21TzZz6bCv63gXOubYp55jkH17wd+k18P1RLN+jhHHJwav5rsZIHX1lqPo3L8o+Tv1pZavkaSpmvpUb5WtpmvgT/54Hy1ePIV0+b+RpqkS8eSwv+r5R8aX0Yz8tjW9aeW3kuUPB/A/KkXWrP6zgnHIfeWnNe1if3sx0F/Xkd/V5frTnfvnFAHNh3aH2iNs4bifR6jnFYBlz+Wn3JwL1zalFTHjOKHBxPas/WXAfw3UJNJtcBwf978rdVHcBxehx6a806r0/uZzsKeh3A/oDrgLY/xNd/aP0oz7fEYSRy9xFaHeC5jlZ7N86pRU15xDqAa9Iy19Hte+57E4LH2p77+d7z3u6e88fcnvvJsepkoTCVK0yWK5O5sfncc39kQhC3y9XkK/sUeTHuVA8u4/h7kEO511trvtfte+5PgjFMHLpxz/2x5Lcw79bzYQdlEj/eY92k7nTDu0SvTa4P7T3/o9VD+zvnuamwezHTf+e8h3CcBtOdC5hzHZjzAHOeA3M+YM53YBa+u9t8zZiF7+42XzPmsfbd3cDvRBQD7w0vafvn6+OfaOazl6WvzZC8KJo5LkP5g1FI399YU+sjfdg+s30noo/icCyE++qfCjitbsUh8J77SuB+MDd/9S6bfyzWO9/7HLOtd9p+iRh3AVxvSK7D+sFHx5Wh6nscVin683OPPKdGkf48KHadr3dAzk9+d/M7IOuT67k4r1b28JdFpyioX8nxuKEn8s+ZBt6TXhB9fHO4KL/TdxxQVre9v6idtcdzyhpXf5tc81mmaGt+T0I7F3eRkjff+lQn73k+lfRpNX+/KIX+Wjlre+H5nYtAe8Tyvn5cW89cCtflytTOjc/ZujGi0EN2kHyuIZz40EXRzLrd7+CK6PcautcDfBjQd/fWmvHrk/vZDoLFesmm5Pd8r5dMJteH9rxeceLQPsujcc5o6LM8zqk1+H1neQiO08Tx/NyHmLDPfcXR0M9eC2OeWYeFMY8n39o4Je3zcdoxzDrAcRvksyqwr5K59JjjDOA7M7kOPIc4sfDs3MC7np1PT35387PzScn1UPIvrkMF4HO1EW2cL+NkbZwYuD3Xx8m9iq7auD0eJx+ZXG/fsXVb5Vlbzr2qMr1zx6atW55Zmn5NJaLAk4oZyLyrY8aMahyuwbCEQ2FQPJH8nu9B8drkemFQ7A2FwIOxYthDr/RBse/B1LVI3RO1XqSOg2/gzJ12HM6lOGxL51EcOivs0OWl7fha6v1juUOXjkcccuyc1yXXW7bu2FS9+twtl++s7KyUX7BzavOm6fN2bpl+1FFv3hxR4EF3hn4vot/sk3sVHg6YLgN56HZfLZMx8+2rT06uF3y1N4SewCh02wSGz1eH8MOxz5EBOPpaeSjAvqA+uI7C+Un88G6ohWHfwXRztXh2fMKnPXBjOQ0o96x0SfPid6AxTOrNAjwJFHqRMe2LGXH/LC/hxA9PpY2VCyulMqrO5uO/mHWMa7f7ZnyPwuMLGYVXy7o0Ce2dbuzaun0IcFLye76HADuT60P8PPLSob03OT+2sDe5+ZoxC3uTm68Zs7A3ufmaMY+1vcmCeSVgXunAvAowr3JgXg2YVzswJcCUHJgpwEw5MNOAmXZgyoApOzAVwFQcmCpgqg7MRsBsdGBeA5jXEObQ3ieeH52//br5sQzJiyJ9CH647RO/AHBa3YpD2EfgscmFfeKH3z5xrnfa9ESMuwiuL06uw/rBsdLCWncDL3rwWveFye9uXut+dnI9l/vEt4pOUVC/srBPPFrYM7WwT3ymTbBvySiye6Jm34v6+PQ/nPeJn0I4i33ip9C9nujQ3Se+I/k933OsuBcQ46z94cIyazr+hWXWhWVWyVscQo89T0r4tD4ay2lhmfXRsLDMWv/dzcusPIRk/WdTnaspQ0T2WBy5m3kfYR+X/I2b5hOS60NhOPP45Pdj7ZjA0VI2XynmpqZGc5XS5GS1lXz5DNMhfpxW4dBess5WF5asm68Zs7Bk3XzNmE6XrA/tZbdsZR6XP6o8RomihWW3eDyQA5xWt+IQ+Him/MKy2+G37Mb1zrXs9hS4/qXkOvDxTIWFZbcG3rXs9uTkdzcvuxWT67lcdnup6BQF9SsLy27RwrLbwrLbTJtg35JRZC8su7W/7LaMcBbLbsvo3qG87PbLye/5nqf61STikJ4nyhXm7NWGMP1FJT9Xy244D+NbdluYu2m+ZszC6wbN14xZeN2g+ZoxC68bNF8zZiNgNjowvtcNBLMJMJscmNcC5rUOzOsA8zoHZjNgNjswlwLmUgdmC2C2ODBbAbPVgbkMMJc5MJcD5nIHZhtgtjkw2wGz3YHZAZgdDsxOwOx0YK4AzBUOzJWAudKBuQowVzkwVwPmagfmGsBc48BcC5hrHZhdgNnlwFwHmOscmOsBc70DcwNgbnBgaoCpOTC7AbPbgbkRMDc6MDcB5iYHZg9g9jgwewGz14HZB5h9Dsx+wOx3YG4GzM0OzC2AucWBuRUwtzowtwHmNgfmdsDc7sDcAZg7HJg7AXOnA3MXYO5yYO4GzN0OzD2AuceBuRcw9zow9wHmPgfmfsDc78A8AJgHHJgHAfOgA/N6wLzegXkDYN7gwDwEmIccmIcB87AD80bAvNGBeRNg3uTAvBkwb3Zg3gKYtzgwbwXMWx2YtwHmbQ7M2wHzdgfmHYB5hwPzTsC804F5F2De5cC8GzDvdmDeA5j3ODDvBcx7HZj3AeZ9Dsz7AfN+B+YDgPmAA/MIYB5xYD4ImA86MB8CzIccmA8D5sMOzEcA8xEH5qOA+agD8zHAfMyB+ThgPu7AfAIwn3BgPgmYTzowvwKYX3FgPgWYTzkwnwbMpx2YzwDmMw7MZwHzWQfmc4D5nAPzecB83oH5AmC+4MB8ETBfdGC+BJgvOTC/CphfdWC+DJgvOzBfAcxXHJj/B5j/58D8GmB+zYH5KmC+6sD8OmB+3YH5GmC+5sB8HTBfd2B+AzC/4cD8JmB+04H5LcD8lgPz24D5bQfmdwDzOw7M7wLmdx2Y3wPM7zkwvw+Y33dg/gAwf+DA/CFg/tCB+SPA/JED8w3AfMOB+SZgvunA/DFg/tiB+RZgvuXA/Alg/sSB+VPA/KkD823AfNuB+TPA/JkD8+eA+XMH5juA+Y4D8xeA+QsH5i8B85cOzHcB810H5nuA+Z4D81eA+SsH5vuA+b4D8wPA/MCB+WvA/LUD8zeA+RsH5m8B87cOzA8B80MH5u8A83cOzN8D5u8dmH8AzD84MP8ImH90YP4JMP/kwPwIMD9yYP4ZMP/swPwYMD92YP4FMP/iwPwrYP7VgfkJYH7iwPwbYP7Ngfl3wPy7A/MfgPkPB+Y/AfOfDsxPAfNTB+a/APNfDsx/A+a/HZj/Acz/ODA/A8zPHJj/Bcz/OjA/B8zPHZj/A8z/OTC/AMwvHJhodwMj14zJACbjwCwCzCIHpgcwPQ5ML2B6HZg+wPQ5MP2A6XdgFgNmsQOzBDBLHJgBwAw4MIOAGXRghgAz5MAsBcxSB2YYMMMOzDLALHNglgNmuQMzApgRB2YFYFY4MCsBs9KBWQWYVQ7MEYA5woE5EjBHOjBHAeYoB2Y1YFY7MEcD5mgH5hjAHOPArAHMGgdmLWDWOjDHAuZYB+Y4wBznwBwPmOMdmBMAc4IDsw4w6xyYEwFzogPzOMA8zoE5CTAnOTAnA+ZkB+YUwJziwJwKmFMdmNMAcxpgegDzeMA8njCB9/2Ph92vUMn69vqFfRWzksuQvCiC/g7+dutewnb3/afdI9eTaeC4bvHnf3D/nNRfbU+91NuYf1mmcb0q06w7pukh+VE0c89qiLKYyOUnA38SPKuVXb3vTv72QlwvxaUpuzhMgr9g2/UEtl2gT7nXX2NH/VFWHBbXonqojz3hnthvvvbIDycE3bxHvj9JNBd75IX/nCD8uazwnxtG/6LwnxeEv5iVdwhen5RJ6H2E4sOxL+J+Ocze8lzqflnkD0YhxwmNflnb+63tyw+7vzuXzRA/6rNEsY+U5YASJ1yyP7kPuBC/BPKIeLyW9HjvpKTARhROfu9hQMkP3kPfdByNUbBsMo6/wsv3+H0KtE0/6dgP+RQdfecsCP5JmYbuT6Axj1aOOA7i967FJv0KHvn6CP9EGHe9OaNzuvLl4sxDvrJUJv1KHuJ7E478ZyK/TdPmf5FD1zHI/9scuqI+qCs/p2Ca+O9TPLg+BZchXXsifawv/ZXPH8+2nmOe2XdhO7XsJ9nfaPlm+fG/IchDTzTTBzFeq1PIP0T4+nskke5LpQy5Tj0X6v/5Kdo1Pi/hWMpVr9O0wWcr7VorY6zXovdyJa/8eUw+y2d98jfbWciFrWuVrPBjPcnY6V/nHwrDP6G9/4y+5EVU35YmcWl9uOBfBnX4JVQv0LfweAK5pW0NQbw8P0VR575qGDA8blgGabR2Jj5U8CMgt4c4NLw8o6FvGAEduL8R/BS0y3dS/7BUyU9s/3JGl41lKmlRV5Z9JZTpRipTlC12XR7NtDOPEZcpuqCdz6k16yL4zWCH94Ad4oDzH/Xn7eRvL8RZPl/EeryfygPLv6/WnO/lEKfVF35HdETBLwcM122sS0spDstgGclZqsjR+hetvUpazY+MePLL9Sf+twK4NLzw9RH+WqXfYk6sa2inXgdnDer99VTGWAaDoPPtDtmY/x4lP4JfqeQf8StIV8Hv8eR/RMn/CuAcIE7B71faGuuJ+crAPa7HqxT8SiVfy6OZdpG0mu0Fh7bXOIZJH5E3GOl1Yoh0xTiUj3nX2vYKRVdfWa9Q5HBZ36eUtda3LSd5mn7Y7rmNL1W4sF/p9vel35QQPNbO9SuOlsanS+O53GQxVynmRudafn5iYmwyP3VgRa88XS0XC3Mtf6w4lpuYKE1Mj01XJ4vTU3Mtf3p0bGr6QCEcWPY7aI5W8rV5eRyrxEHm9nHuH/E4LkT8h6CP+gj0UQexirwY9yUPLuP4e5BDuddba76nrQngWongRfZgbaaOEjcEcTiOisPS5DfaC7lEjz7Cfx76iDjg+oakH1HkLyH5TXor93itZEjBDyn4uHw+SX4L8249F31QJvHjPdZN6k5cr/PJ/UP8E5fVQ/sciO45fj3U0epHRY3r1SArDufXGnpg/WA+7ZlmTtb/k+P9w5VPfjzU+v+JZJ8ga/ywLyjQZ/gmfGv8shZ6JtgE7SB4tEOYtcH8RJo+F+V343Hua5LrjZUdz8m9aOtz8s+tXDpV2bb9NZsue8mmHVsq27cvIstiqaO004g9IhyG00A7F45bP9YI7akCQzu7l9A6Q9HMER7K66ZdJGckv7t5F8nJyfWhcFqXnA4330+f0nse4h/JGZ2rUVpI+4TqReOgjdI4L3HwjdLinlBmfZZEzbPomcBlG9D23pNwZQQgvi3Ov7SZLVt3bKpe/cxtldKOSvl5Ozdv3lTdVNkWUeBeRuvHRVK3e60jk9/z7bUmk+tD3GtNHuLPlqPd9mkvwXGaON7n2QJ/biu0nQoL5yrPOiycq+zJN5fpQUytEbeI4nohLu07IOsAx22Qn6Kwr5LzQWOOM4APP/sYcFQyuXA+fwPvemo8PfndzU+NJyXXQ1FjtFcAPlcb0eYKZW1ZO4s6cHuun8Xdq+iqnQ0ej2RlPBd/Xq/yrC3nXlWZ3rlj09YtzyxNv6YSUXBNnyyK3B0zZlTj6In0A7clHAqD4onk93wPisVO8vfIyN5eWRgUHxGGP4sb7CPKC8rlwX9kqIPwST3oi2YGXnStOybSL2OvX4510RZfJcgGmSPg3pEOXbEOWzon4R8Kw6/WGXxZZIjipOy0D3hmHL8X0V8fNuPhHVbihFPKCvWVfMjmH9yQJbyWtsTN4QH46/4j1MBWqwt4j9srlhUPFtmnGutaqg/kQIceksk6Ikarv7wk0kv3e1JgtforcfUBmycdv2DF9/jhIFLw9cFf8rfPwbUY4hG/mLChynCVopPo/v8BOBTReBOLQQA=",
      "debug_symbols": "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nPKKU14xJV/qidN5TnnFKa84vQ8yJ9+UV5zyilNeccorTnnFKa845RVL8pX0+6a84pRXnPKK0/sgS/JNecUprzjlFae84pRXnPKKU15xS74t/b4przjlFae84vQ+yD35przilFec8opTXnHKK055xSmvuCffnn7flFec8opTXnF6H2RNvimvOOUVp7zilFec8opTXnHKK7bka+n3TXnFKa845RWn90G25JvySlJeScorSXklKa8k5ZWkvJINvrL1xJoY51lSXkl6H5SSfFNeScorSXklKa8k5ZWkvJKUV1KTby2Ja2JKzImTb8orSc9Xkp6vJOWVpPdBoeSb+q8k5ZWkvJKUV5Ker44Z0bTvBFCOKdG0z5Etx5zok4+8OrkkrokpMSeWxC1xT5x8OflK8pXkK8lXkq8kX0m+knwl+UryleTbkm9Lvi35tuTbkm9Lvi35tuTbkm9Lvj359uR75NU+S7kcs6YHc+LDtzm3xD2xJjbwkVeHzpFXJyffI6/Ov8+Jk68mX02+mnw1+VryteRrydfS8Vo6Xku+lnwt+VryNfgeE6oHl8Q1MSWG7zGrenBL3BNr4uRbkm9JviX5luRbOLEkbol74uR75NXBdUtcEtfEybcm35p8a/Ktybdq4nS8lI6X0vFS8iVKnM4zpfNM6TxT8qXkS8mXky8nX07nmdPxcjpeTsfLyZfT78vpPHM6z5LOsyRfSb6SfCX5SvKVdJ4lHa+k45V0vC35tvT7tnSeWzrPLZ3nlnxb8m3JtyXflnx7Os89HW9Px9vT8aa8Oudmn5zOc0/nuafznPLqnKB9cvLV5JvyqqW8aimvWsqrlvLqnKh9+Gr6fVNetZRXLeXVOVv70LHkm/KqpbxqKa9ayquW8qqnvOopr85p2+57zts+mRNL4pa4Jx1NnHxTXvWUVz3lVU951VNe9ZRX5yTuw7f0xJoY57mnvDpnch86NfmmvOopr3rKq57yqqe86imvesqrc0r34UslcTrPKa96yqtzXvepk3xTXvWUVz3lVU951VNe9ZRXPeXVOcH78OX0+6a86imvesqrc5b3oSPJN+VVT3nVU171lFc95VVPedVTXp3TvQ9fSb9vyque8qqnvDrnfB86LfmmvOopr3rKq57yqqe86imvesqrnp6venq+6imvesqrnvKqp+ernp6vesqrnvKqp7zqKa96yque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f7XYv1rsXy32rxb7V4v9q8X+1WL/arF/tdi/WuxfLfavFvtXi/2rxf7VYv9qsX+12L9a8GrBqwWvFrxa8GrBqwWvFrxa8GrBqwWvFrxa8GrBqwWvFrxa8GrBqwWvFrxa8GrBqwWvFrxa8GrBqwWvFrxa8GrBqwWvFrxa8GrBqwWvFrxa8GrBqwWvFrwi357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k25N8e5JvT/LtSb49ybcn+fYk357k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k24t8e5FvL/LtRb69yLcX+fYi317k2380vvCKfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e5NuLfHuRby/y7UW+vci3F/n2It9e/fv/N1H9+/83Uf37/zdR7/ntj/77u0Zxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfnv1798HK75/H6z4/n2w4vv3wYrv3wcrvn8frPj+fbDi+/fB4vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz24vz2H40vvOL89h+NL7wKeBXwKuBVwKuAVwGvAl5xfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfntxfnslvEp4lfAq4VXCq4RXCa8SXnF+e73nt69fDa84v704v704v704v704v704v704v704v704v704v704v704v704v704v704v704v704v704v704v704v704v704v704v704v73Itxf5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NeHVhFcTXk14NeHV/Hx952egJ3qhv+M8WQ/Ohi+8mvBqwqsJrya8mvBqwqvZ8O0fdEN3dKDxhVeT+dVkfjXh1WQ9OANf9q8mvJrwasKryfxqXl7No4/vb255P/n2V++vfnh1dUN3dKATXeiBxjfxTXwL38K38C18C9/Ct/AtfAvfwnfgO/Ad+A58B74D34HvwHfgO/Cd+D68+s2N7yff/upAP75xdKEHeqIXen/f5+HV1fg+vHpe//DqanwXvgvfhe/Cd+G78d34bq53c70b343vxnfju/F9eHX0zbdf3dAd/fW9+farCz3QE714H3wbvg3fhm8LdKILPdD4Pry6+jvON99+dUPj2/Ht+HZ8O759ornezvUG1xv4RkczzsE4B+Mc+Aa+gW/gm/gm45xcb3K9yfUmvsn9TcY5GedknAvfwrfwLXwL32Kci+strre43sJ3cH8H4zwY58E4D3wHvgPfge/AdzDOk+udXO/keuHVzbdfzThPxnkyzvDq5tsfvfBd+MKrBa8WvFrwasGrm29/fBf3F14teLXg1c23P++z8YVXC14teLXg1YJXC15teHXz7cf35tuvDnSiCz14n4leaHzh1YZXG15teLXh1c23P75toCd6ob/jfPPtz/t0fOHVhlcbXm14teHVhlcbXt18++MbHzTjDK82vLr59ud9Al94teHVhlcbXm14teHVhlc33/74JvcXXm14teHVzbff98EXXm14teHVhlcbXm14teHVzbc/vsX9hVcbXm14dfPtz/sMfOHVhlcbXm14teHVhlcbXm3mV5v51YZXG15teLWZX23mVxtebXi14dWGVxtebXi14dXNtz++i/sLrza82vDq5tuf99n4wqsNrza82vBqw6sNrza8uvn2X9/2uQH3t2gW3SIs/sx/i7IYFtNiWWyKL7p+i2bRLeygpUVZDItpYQfNDroddDvodvDl2G/hGHTHoDsG3Q76svAuhHchvAthB2EHYQdhB2EH4V0IxyAcg3QM0g7Sz0F6F9K7kN6FtIO0g7SDtIOyg/IulGNQjkE5BmUH5eegvAvlXSjvwrCDYQfDDoYdDDsY3oXhGAzHYDgGww6mn4PpXZjeheldmHYw7WDawbSDaQfTu7Acg+UYLMdg2cHyc7C8C8u7sLwLyw6WHWw72Haw7WB7F7ZjsB2D7RhsO9h+DmRik4lNJrYP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",
      "brillig_names": [
        "discover_new_messages",
        "debug_log_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "attach_len_to_msg_block",
        "debug_log_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "storage_read",
        "debug_log_oracle_wrapper",
        "storage_read",
        "debug_log_oracle_wrapper",
        "build_msg_block",
        "get_l1_to_l2_membership_witness",
        "notify_created_nullifier_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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\n0wjG1j0HkTruZrSFZmQJ4zJievrMBCtdWDUY"
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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GOUY5TjyfLaglXTk+UVS1Iq0qBdZkReNonLMcqxyrHKscqxyrHKscqxyrHKscqx0xKSii6SoFWlRL7IiLxpFs6gcUg4ph5RDyiHlkHJIOaQcUg4pRytHK0crRytHK0crRytHK0crRyuHlkPLoeXQcmg5tBxaDi2HlkPL0cvRy9HL0cvRy9HL0cvRy9HL0cth5bByWDmsHFYOK4eVw8ph5bByeDm8HF4OL4eXw8vh5fByeDkiz48p1zE16SIpakVa1IusyItG0SwqxyzHLMcsxyzHLMcsxyzHLMcsxyzHKscqxyrHKscqxyrHKscqxyrHSkdMXLpIilqRFvUiK/KiUTSLyiHlkHJIOaQcUg4ph5RDyiHlkHK0crRytHK0crRytHK0crRytHK0cmg5tBxaDi2HlkPLoeXQcmg5tBy9HL0cvRy9HJHnI8iKvOjuWLegWbSSjjy/SIpakRb1IivyonJYOawcXg4vh5fDy+Hl8HJ4ObwcXg4vxyjHKMcoxyjHKMcoxyjHKMcoxyjHLMcsxyzHLMcsxyzHLMcsxyzHLMcqxyrHKscqxyrHKscqxyrHKsdKR0yOukiKWpEW9SIr8qJRNIvKIeWQckg5pBxSDimHlEPKIeWQcrRytHK0crRytHK0crRytHK0crRyaDm0HFoOLYeWQ8uh5dByaDm0HL0cvRy9HL0cvRy9HL0cledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnVnluledWeW6V51Z5bpXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnuledeee6V51557pXnXnnu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",
      "brillig_names": [
        "sync_private_state"
      ]
    },
    {
      "name": "withdraw_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "withdrawNonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "burnNonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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BicCCARlAAgBCAEnAwYEAQAiBgIILQoICS4MgEYACQAiCQIJLgyARwAJACIJAgkuDIBIAAkAIgkCCS4MgEkACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJACIJAgkuDIBbAAkAIgkCCS4MgFsACQAiCQIJLgyAWwAJ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",
      "debug_symbols": "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",
      "brillig_names": [
        "withdraw_public"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Beacon"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "target",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "overrides",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "minter",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "shield_gateway_beacon",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "shielded_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Portal"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "l1_portal",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "l1_tokens",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "l2_tokens",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token_contract_class_id",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "shield_gateway_beacon",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "eth_token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "recipient",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "amount",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            },
            {
              "name": "message_leaf_index",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::Deposit"
        },
        {
          "fields": [
            {
              "name": "eth_token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "aztec_token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::Register"
        },
        {
          "fields": [
            {
              "name": "token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "from",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "to",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "amount",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::Withdraw"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::_claim_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::_claim_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::_log_claim_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::_log_claim_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "aztec_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::_register_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::_register_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::claim_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::claim_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::claim_shielded_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::claim_shielded_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "l1_portal",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "token_contract_class",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "shield_gateway_beacon",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Portal::get_l1_portal_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::get_l1_portal_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "aztec_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::get_l1_token_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::get_l1_token_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::get_l2_token_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::get_l2_token_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::is_registered_l1_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::is_registered_l1_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "aztec_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::is_registered_l2_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::is_registered_l2_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "aztec_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "name",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  },
                  {
                    "name": "name_len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "symbol",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  },
                  {
                    "name": "symbol_len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "decimals",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::register_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::register_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Portal::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::sync_private_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "withdrawNonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "burnNonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::withdraw_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::withdraw_public_abi"
        }
      ]
    }
  },
  "file_map": {
    "101": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_private_state = generate_sync_private_state();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n"
    },
    "102": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "103": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/macros/events.nr",
      "source": "use super::utils::{compute_event_selector, get_trait_impl_method};\n\ncomptime fn generate_event_interface(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let event_type_id = compute_event_selector(s);\n\n    let from_field = get_trait_impl_method(\n        quote { crate::protocol_types::abis::event_selector::EventSelector }.as_type(),\n        quote { crate::protocol_types::traits::FromField },\n        quote { from_field },\n    );\n\n    quote {\n        impl aztec::event::event_interface::EventInterface for $name {\n            fn get_event_type_id() -> aztec::protocol_types::abis::event_selector::EventSelector {\n                $from_field($event_type_id)\n            }\n        }\n    }\n}\n\npub comptime fn event(s: TypeDefinition) -> Quoted {\n    let event_interface = generate_event_interface(s);\n    s.add_attribute(\"abi(events)\");\n    quote {\n        $event_interface\n    }\n}\n"
    },
    "105": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_public, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else if is_fn_public(f) {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    } else {\n        if is_void {\n            create_utility_void_stub(f)\n        } else {\n            create_utility_stub(f)\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n"
    },
    "106": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "109": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "111": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "112": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "113": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_utility(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"utility\")\n}\n\npub(crate) comptime fn is_fn_contract_library_method(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"contract_library_method\")\n}\n\npub(crate) comptime fn is_fn_test(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"test\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Type does not implement trait\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n"
    },
    "114": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "115": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "116": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "118": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_private_state},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncPrivateState` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_private_state(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "119": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "121": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "132": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/messaging.nr",
      "source": "use crate::{\n    hash::{compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness,\n};\n\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    merkle_tree::root::root_from_sibling_path,\n};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field,\n    leaf_index: Field,\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_l1_to_l2_message_hash(\n        portal_contract_address,\n        chain_id,\n        contract_address,\n        version,\n        content,\n        secret_hash,\n        leaf_index,\n    );\n\n    // We prove that `message_hash` is in the tree by showing the derivation of the tree root, using a merkle path we\n    // get from an oracle.\n    // Safety: The witness is only used as a \"magical value\" that makes the merkle proof below pass. Hence it's safe.\n    let (_leaf_index, sibling_path) =\n        unsafe { get_l1_to_l2_membership_witness(contract_address, message_hash, secret) };\n\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert_eq(root, l1_to_l2_root, \"Message not in state\");\n\n    compute_l1_to_l2_message_nullifier(message_hash, secret)\n}\n"
    },
    "142": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "145": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "148": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "149": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "150": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "151": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "152": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "153": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "154": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, constants::L1_TO_L2_MSG_TREE_HEIGHT};\n\n/// Returns the leaf index and sibling path of an entry in the L1 to L2 messaging tree, which can then be used to prove\n/// its existence.\npub unconstrained fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field,\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\n}\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field,\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {}\n"
    },
    "157": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "158": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "159": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "160": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, length, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "161": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_private_state(pending_tagged_log_array_base_slot: Field) {\n    sync_private_state_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncPrivateState)]\nunconstrained fn sync_private_state_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    // The log fields length is PUBLIC_LOG_SIZE_IN_FIELDS. + 1 because the contract address is prepended to the content.\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_SIZE_IN_FIELDS + 1>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "163": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{\n    note_interface::NoteType,\n    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}\n\npub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<NOTE_PCKD_LEN>,\n{\n    // N + 3 because of the contract address, nonce, and note_hash_counter that are stored out of the packed note.\n    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        MAX_NOTES,\n        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,\n    );\n\n    let mut notes = BoundedVec::<_, MAX_NOTES>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MAX_NOTES];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "165": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "167": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "169": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables, which is expected to never result in collisions or slots\n// being close to one another due to these being hashes. This mirrors the strategy adopted by Solidity mappings.\nimpl<K, T, Context> Storage<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "177": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "191": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/unencrypted_logs/unencrypted_event_emission.nr",
      "source": "use crate::{context::PublicContext, event::event_interface::EventInterface};\nuse protocol_types::traits::{Serialize, ToField};\n\nfn emit<Event, let N: u32>(context: &mut PublicContext, event: Event)\nwhere\n    Event: EventInterface + Serialize<N>,\n{\n    let selector = Event::get_event_type_id();\n\n    let serialized_event = event.serialize();\n    let mut emitted_log = [0; N + 1];\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    for i in 0..serialized_event.len() {\n        emitted_log[i] = serialized_event[i];\n    }\n\n    emitted_log[serialized_event.len()] = selector.to_field();\n\n    context.emit_public_log(emitted_log);\n}\n\npub fn encode_event<Event, let N: u32>(\n    context: &mut PublicContext,\n) -> fn[(&mut PublicContext,)](Event) -> ()\nwhere\n    Event: EventInterface + Serialize<N>,\n{\n    |e: Event| { emit(context, e); }\n}\n"
    },
    "192": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "195": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "196": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "198": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "199": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "201": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "203": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "207": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "214": {
      "path": "/home/twt/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "231": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "233": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "276": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "277": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr",
      "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH,\n    traits::{Deserialize, Empty, Packable, Serialize, ToField},\n};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl Packable<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn pack(self) -> [Field; ETH_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn to_be_bytes(self) -> [u8; 20] {\n        let field_bytes: [u8; 32] = self.inner.to_be_bytes();\n        let mut bytes = [0; 20];\n        for i in 0..20 {\n            bytes[i] = field_bytes[i + 12];\n        }\n        bytes\n    }\n}\n"
    },
    "279": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "281": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "285": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/noir-protocol-circuits/crates/types/src/contract_class_id.nr",
      "source": "use crate::constants::GENERATOR_INDEX__CONTRACT_LEAF;\nuse crate::traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField};\n\npub struct ContractClassId {\n    pub inner: Field,\n}\n\nimpl Eq for ContractClassId {\n    fn eq(self, other: ContractClassId) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl ToField for ContractClassId {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for ContractClassId {\n    fn from_field(value: Field) -> Self {\n        Self { inner: value }\n    }\n}\n\nimpl Serialize<1> for ContractClassId {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<1> for ContractClassId {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] }\n    }\n}\n\nimpl Empty for ContractClassId {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n// Implement the Packable trait so ContractClassId can be stored in contract's storage.\nimpl Packable<1> for ContractClassId {\n    fn pack(self) -> [Field; 1] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; 1]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl ContractClassId {\n    pub fn compute(\n        artifact_hash: Field,\n        private_functions_root: Field,\n        public_bytecode_commitment: Field,\n    ) -> Self {\n        let hash = crate::hash::poseidon2_hash_with_separator(\n            [artifact_hash, private_functions_root, public_bytecode_commitment],\n            GENERATOR_INDEX__CONTRACT_LEAF,\n        ); // TODO(@spalladino): Update generator index\n        ContractClassId::from_field(hash)\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "291": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "293": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "294": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "304": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "308": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "310": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "311": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "321": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "332": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "346": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    #[inline_always]\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// T = type of item in BoundedVec\n// M = max length of BoundedVec\n// O = field length of T\n// O * M + 1 = total serialized length of BoundedVec<T, M> (the +1 is for length of the BoundedVec)\nimpl<T, let M: u32, let O: u32> Deserialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Deserialize<O>,\n{\n    #[inline_always]\n    fn deserialize(fields: [Field; O * M + 1]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        let len = fields[0] as u32;\n        let mut index = 1;\n\n        for _ in 0..len {\n            let mut nested_fields = [0; O];\n            for j in 0..O {\n                nested_fields[j] = fields[index];\n                index += 1;\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\nimpl<T, let M: u32, let O: u32> Serialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Serialize<O>,\n{\n    #[inline_always]\n    fn serialize(self) -> [Field; O * M + 1] {\n        let mut fields = [0; O * M + 1];\n\n        let len = self.len();\n        fields[0] = len as Field;\n\n        let mut index: u32 = 1;\n\n        for i in 0..len {\n            let item = self.get_unchecked(i);\n            let serialized_item = item.serialize();\n\n            for j in 0..O {\n                fields[index] = serialized_item[j];\n                index += 1;\n            }\n        }\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    #[inline_always]\n    fn deserialize(fields: [Field; N]) -> Self {\n        str::<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "350": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "351": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "367": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"
    },
    "368": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "370": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "376": {
      "path": "/home/twt/nargo/github.com/noir-lang/sha256/v0.1.3/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "380": {
      "path": "/home/twt/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "397": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "51": {
      "path": "/home/twt/turnstile/turnstile-contracts/aztec/contracts/portal/src/encoding/deposit.nr",
      "source": "use aztec::{\n    protocol_types::{\n        address::{AztecAddress, EthAddress},\n        hash::sha256_to_field,\n        traits::{FromField, ToField},\n    },\n};\n\n// bytes4(keccak256(\"deposit(address,bytes32,uint256)\")) = 0xeb2243f8\nglobal DEPOSIT_SIGNATURE: [u8; 4] = [0xeb, 0x22, 0x43, 0xf8];\n\npub fn deposit_content_hash(\n    eth_token: EthAddress,\n    recipient: AztecAddress,\n    amount: Field,\n) -> Field {\n    let encoded = abi_encode_deposit(eth_token, recipient, amount);\n    let content_hash = sha256_to_field(encoded);\n    content_hash\n}\n\npub fn abi_encode_deposit(\n    eth_token: EthAddress,\n    recipient: AztecAddress,\n    amount: Field,\n) -> [u8; 100] {\n    // abi.encodeWithSignature(DEPOSIT_SIGNATURE, tokenAddr, recipient, amount)\n    // This encodes the following data:\n    // offset - data\n    // 0x00 - 4 bytes for the signature\n    // 0x04 - 32 bytes for the token address\n    // 0x24 - 32 bytes for the recipient\n    // 0x44 - 32 bytes for the amount\n    // Total: 100 bytes\n    let mut encoded = [0; 100];\n    for i in 0..4 {\n        encoded[i] = DEPOSIT_SIGNATURE[i];\n    }\n\n    let eth_token_bytes: [u8; 32] = eth_token.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = amount.to_be_bytes();\n\n    for i in 0..32 {\n        encoded[i + 0x4] = eth_token_bytes[i];\n        encoded[i + 0x24] = recipient_bytes[i];\n        encoded[i + 0x44] = amount_bytes[i];\n    }\n\n    encoded\n}\n\n// For testing purposes, enables printing the ABI-encoded data\npub unconstrained fn field_from_encoded_bytes(encoded: [u8; 100], offset: u32) -> Field {\n    let mut arr = [0; 31];\n    for i in 0..31 {\n        if offset + i >= 100 {\n            break;\n        }\n        arr[i] = encoded[offset + i];\n    }\n    aztec::protocol_types::utils::field::field_from_bytes(arr, true)\n}\n\n#[test]\nfn test_abi_encode_deposit() {\n    let eth_token = EthAddress::from_field(0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F);\n    let recipient = AztecAddress::from_field(\n        0x1e571fd19f8f3aab48fd795e1b39f72dd61f44735c88a7576721be8a5065f863,\n    );\n    let amount = 0x1234567890abcdef1234567890abcdef;\n    let encoded = abi_encode_deposit(eth_token, recipient, amount);\n\n    // abi.encodeWithSignature(\"deposit(address,bytes32,uint256)\", address(0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F), bytes32(hex\"1e571fd19f8f3aab48fd795e1b39f72dd61f44735c88a7576721be8a5065f863\"), 0x1234567890abcdef1234567890abcdef) =\n    // 0xeb2243f80000000000000000000000002458675deb5e0691da2d2ba8dcaf58cfd2c2651f1e571fd19f8f3aab48fd795e1b39f72dd61f44735c88a7576721be8a5065f863000000000000000000000000000000001234567890abcdef1234567890abcdef\n    let expected: [u8; 100] = [\n        0xeb, 0x22, 0x43, 0xf8, // Function selector - deposit(address,bytes32,uint256)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F\n        0x24, 0x58, 0x67, 0x5d, 0xeb, 0x5e, 0x06, 0x91, 0xda, 0x2d, 0x2b, 0xa8, 0xdc, 0xaf, 0x58,\n        0xcf, 0xd2, 0xc2, 0x65, 0x1f,\n        // Aztec Recipient Address\n        0x1e, 0x57, 0x1f, 0xd1, 0x9f, 0x8f, 0x3a, 0xab, 0x48, 0xfd, 0x79, 0x5e, 0x1b, 0x39, 0xf7,\n        0x2d, 0xd6, 0x1f, 0x44, 0x73, 0x5c, 0x88, 0xa7, 0x57, 0x67, 0x21, 0xbe, 0x8a, 0x50, 0x65,\n        0xf8, 0x63,\n        // Amount\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,\n        0xcd, 0xef,\n    ];\n\n    if encoded != expected {\n        std::println(f\"test_abi_encode_deposit: got: {encoded}\");\n        std::println(f\"test_abi_encode_deposit: expected: {expected}\");\n    }\n    assert_eq(encoded, expected);\n}\n\n#[test]\nfn test_deposit_content_hash() {\n    let content: [u8; 100] = [\n        0xeb, 0x22, 0x43, 0xf8, // Function selector - deposit(address,bytes32,uint256)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F\n        0x24, 0x58, 0x67, 0x5d, 0xeb, 0x5e, 0x06, 0x91, 0xda, 0x2d, 0x2b, 0xa8, 0xdc, 0xaf, 0x58,\n        0xcf, 0xd2, 0xc2, 0x65, 0x1f,\n        // Aztec Recipient Address\n        0x1e, 0x57, 0x1f, 0xd1, 0x9f, 0x8f, 0x3a, 0xab, 0x48, 0xfd, 0x79, 0x5e, 0x1b, 0x39, 0xf7,\n        0x2d, 0xd6, 0x1f, 0x44, 0x73, 0x5c, 0x88, 0xa7, 0x57, 0x67, 0x21, 0xbe, 0x8a, 0x50, 0x65,\n        0xf8, 0x63,\n        // Amount\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,\n        0xcd, 0xef,\n    ];\n\n    // sha256(content) = 0x5a05320993a46599dc6c5605c5f2bf139d6fb5f3709e23c5af2b530f1e883aa8\n    // sha256_to_field uses the first 31 bytes of the hash\n    let expected: Field = 0x5a05320993a46599dc6c5605c5f2bf139d6fb5f3709e23c5af2b530f1e883a;\n    let content_hash = sha256_to_field(content);\n    if content_hash != expected {\n        std::println(f\"test_deposit_content_hash: got: {content_hash}\");\n        std::println(f\"test_deposit_content_hash: expected: {expected}\");\n    }\n    assert_eq(content_hash, expected);\n}\n"
    },
    "53": {
      "path": "/home/twt/turnstile/turnstile-contracts/aztec/contracts/portal/src/encoding/register.nr",
      "source": "use aztec::{\n    protocol_types::{\n        address::EthAddress,\n        hash::sha256_to_field,\n        traits::ToField,\n    },\n};\n\n// bytes4(keccak256(register(address,string,string,uint8))) = 0x611a7a19\ncomptime global REGISTER_SIGNATURE: [u8; 4] = [0x61, 0x1a, 0x7a, 0x19];\n\npub fn register_content_hash(\n    eth_token: EthAddress,\n    name: str<31>,\n    name_len: u8,\n    symbol: str<31>,\n    symbol_len: u8,\n    decimals: u8,\n) -> Field {\n    let encoded = abi_encode_register(eth_token, name, name_len, symbol, symbol_len, decimals);\n    let content_hash = sha256_to_field(encoded);\n\n    // Debug log the ABI-encoded data\n    // let field_array: [Field; 9] = aztec::utils::bytes::bytes_to_fields::<260, 9>(encoded);\n    // dep::aztec::oracle::debug_log::debug_log_format(\"ABI Encoded: {}\", field_array);\n    content_hash\n}\n\npub fn abi_encode_register(\n    eth_token: EthAddress,\n    name: str<31>,\n    name_len: u8,\n    symbol: str<31>,\n    symbol_len: u8,\n    decimals: u8,\n) -> [u8; 260] {\n    // abi.encodeWithSignature(REGISTER_SIGNATURE, tokenAddr, token.name(), token.symbol(), token.decimals())\n    // This encodes the following data:\n    // offset - data\n    // 0x00 - 4 bytes for the signature\n    // 0x04 - 32 bytes for the token address\n    // 0x24 - 32 bytes for the name offset\n    // 0x44 - 32 bytes for the symbol offset\n    // 0x64 - 32 bytes for the decimals\n    // 0x84 - 32 bytes for the name length\n    // 0xa4 - 32 bytes for the name // Limited to 31 bytes\n    // 0xc4 - 32 bytes for the symbol length\n    // 0xe4 - 32 bytes for the symbol // Limited to 31 bytes\n    // Total: 260 bytes\n    let mut encoded = [0; 260];\n\n    let eth_token_bytes: [u8; 32] = eth_token.to_field().to_be_bytes();\n    let decimals_bytes: [u8; 32] = decimals.to_field().to_be_bytes();\n\n    let name_len_bytes: [u8; 32] = name_len.to_field().to_be_bytes();\n    let symbol_len_bytes: [u8; 32] = symbol_len.to_field().to_be_bytes();\n\n    // Fixed offsets for name and symbol\n    // Offset for the name is 0x80 per the ABI encoding, but 0x84 in the raw data\n    let name_offset_bytes: [u8; 32] = 0x80.to_field().to_be_bytes();\n    // Offset for the symbol is 0xc0 per the ABI encoding, but 0xc4 in the raw data\n    let symbol_offset_bytes: [u8; 32] = 0xc0.to_field().to_be_bytes();\n\n    let name_bytes: [u8; 31] = name.as_bytes();\n    let symbol_bytes: [u8; 31] = symbol.as_bytes();\n\n    for i in 0..32 {\n        // First 4 bytes are the function signature\n        if i < 4 {\n            encoded[i] = REGISTER_SIGNATURE[i];\n        }\n\n        encoded[i + 0x4] = eth_token_bytes[i];\n        encoded[i + 0x24] = name_offset_bytes[i];\n        encoded[i + 0x44] = symbol_offset_bytes[i];\n        encoded[i + 0x64] = decimals_bytes[i];\n        encoded[i + 0x84] = name_len_bytes[i];\n        encoded[i + 0xc4] = symbol_len_bytes[i];\n\n        // Copy name & symbol\n        if i < name_len {\n            encoded[i + 0xa4] = name_bytes[i];\n        }\n        if i < symbol_len {\n            encoded[i + 0xe4] = symbol_bytes[i];\n        }\n    }\n\n    encoded\n}\n\nunconstrained fn pad_31<let N: u32>(s: str<N>) -> str<31> {\n    let mut padded = [0; 31];\n    let s = s.as_bytes();\n    for i in 0..31 {\n        if i < N {\n            padded[i] = s[i];\n        }\n    }\n    padded.as_str_unchecked()\n}\n\n#[test]\nunconstrained fn test_abi_encode_register() {\n    let eth_token = EthAddress::from_field(0xbbEda607223492F9dce036A21C459fE1dcab56c7);\n    let name = pad_31(\"Test Token\");\n    let symbol = pad_31(\"TT\");\n    let decimals = 18;\n    let encoded = abi_encode_register(eth_token, name, 10, symbol, 2, decimals);\n\n    // abi.encodeWithSignature(\"register(address,string,string,uint8)\", address(0xbbEda607223492F9dce036A21C459fE1dcab56c7), \"Test Token\", \"TT\", 18) =\n    // 0x611a7a19000000000000000000000000bbeda607223492f9dce036a21c459fe1dcab56c7000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000a5465737420546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000025454000000000000000000000000000000000000000000000000000000000000\n    let expected: [u8; 260] = [\n        0x61, 0x1a, 0x7a, 0x19, // Function selector - register(address,string,string,uint8)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0xbbEda607223492F9dce036A21C459fE1dcab56c7\n        0xbb, 0xed, 0xa6, 0x07, 0x22, 0x34, 0x92, 0xf9, 0xdc, 0xe0, 0x36, 0xa2, 0x1c, 0x45, 0x9f,\n        0xe1, 0xdc, 0xab, 0x56, 0xc7,\n        // Name Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x80,\n        // Symbol Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0xc0,\n        // Decimals: 18\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12,\n        // Name Length: 10\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x0a,\n        // Name: Test Token\n        0x54, 0x65, 0x73, 0x74, 0x20, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n        // Symbol Length: 2\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x02,\n        // Symbol: TT\n        0x54, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n\n    if encoded != expected {\n        std::println(f\"test_abi_encode_register: got: {encoded}\");\n        std::println(f\"test_abi_encode_register: expected: {expected}\");\n    }\n    assert_eq(encoded, expected);\n}\n\n#[test]\nunconstrained fn test_register_content_hash() {\n    let content: [u8; 260] = [\n        0x61, 0x1a, 0x7a, 0x19, // Function selector - register(address,string,string,uint8)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0xbbEda607223492F9dce036A21C459fE1dcab56c7\n        0xbb, 0xed, 0xa6, 0x07, 0x22, 0x34, 0x92, 0xf9, 0xdc, 0xe0, 0x36, 0xa2, 0x1c, 0x45, 0x9f,\n        0xe1, 0xdc, 0xab, 0x56, 0xc7,\n        // Name Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x80,\n        // Symbol Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0xc0,\n        // Decimals: 18\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12,\n        // Name Length: 10\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x0a,\n        // Name: Test Token\n        0x54, 0x65, 0x73, 0x74, 0x20, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n        // Symbol Length: 2\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x02,\n        // Symbol: TT\n        0x54, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    // sha256(content) = 0x0448b4e27885c9528619c3ccd291634a7aa4f66d562d479904429803f535d9f4\n    // sha256_to_field uses the first 31 bytes of the hash\n    let expected: Field = 0x0448b4e27885c9528619c3ccd291634a7aa4f66d562d479904429803f535d9;\n    let content_hash = sha256_to_field(content);\n    if content_hash != expected {\n        std::println(f\"test_register_content_hash: got: {content_hash}\");\n        std::println(f\"test_register_content_hash: expected: {expected}\");\n    }\n    assert_eq(content_hash, expected);\n}\n"
    },
    "54": {
      "path": "/home/twt/turnstile/turnstile-contracts/aztec/contracts/portal/src/encoding/withdraw.nr",
      "source": "use aztec::protocol_types::{\n    address::EthAddress,\n    hash::sha256_to_field,\n    traits::ToField,\n};\n\n// bytes4(keccak256(\"withdraw(address,address,uint256)\")) = 0xd9caed12\nglobal WITHDRAW_SIGNATURE: [u8; 4] = [0xd9, 0xca, 0xed, 0x12];\n\npub fn withdraw_content_hash(eth_token: EthAddress, recipient: EthAddress, amount: Field) -> Field {\n    let encoded = abi_encode_withdraw(eth_token, recipient, amount);\n    let content_hash = sha256_to_field(encoded);\n    content_hash\n}\n\npub fn abi_encode_withdraw(\n    eth_token: EthAddress,\n    recipient: EthAddress,\n    amount: Field,\n) -> [u8; 100] {\n    // abi.encodeWithSignature(WITHDRAW_SIGNATURE, tokenAddr, recipient, amount)\n    // This encodes the following data:\n    // offset - data\n    // 0x00 - 4 bytes for the signature\n    // 0x04 - 32 bytes for the token address\n    // 0x24 - 32 bytes for the recipient\n    // 0x44 - 32 bytes for the amount\n    // Total: 100 bytes\n    let mut encoded = [0; 100];\n    for i in 0..4 {\n        encoded[i] = WITHDRAW_SIGNATURE[i];\n    }\n\n    let eth_token_bytes: [u8; 32] = eth_token.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = amount.to_be_bytes();\n\n    for i in 0..32 {\n        encoded[i + 0x4] = eth_token_bytes[i];\n        encoded[i + 0x24] = recipient_bytes[i];\n        encoded[i + 0x44] = amount_bytes[i];\n    }\n\n    encoded\n}\n\n#[test]\nfn test_abi_encode_withdraw() {\n    let eth_token = EthAddress::from_field(0xbbEda607223492F9dce036A21C459fE1dcab56c7);\n    let recipient = EthAddress::from_field(0x52b1D2CEBF3C80813f82dC4B5F56fCB4e04aC439);\n    let amount = 0x1234567890abcdef;\n    let encoded = abi_encode_withdraw(eth_token, recipient, amount);\n\n    // abi.encodeWithSignature(\"withdraw(address,address,uint256)\", address(0xbbEda607223492F9dce036A21C459fE1dcab56c7), address(0x52b1D2CEBF3C80813f82dC4B5F56fCB4e04aC439), 0x1234567890abcdef) =\n    // 0xd9caed12000000000000000000000000bbeda607223492f9dce036a21c459fe1dcab56c700000000000000000000000052b1d2cebf3c80813f82dc4b5f56fcb4e04ac4390000000000000000000000000000000000000000000000001234567890abcdef\n    let expected: [u8; 100] = [\n        0xd9, 0xca, 0xed, 0x12, // Function selector - withdraw(address,address,uint256)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0xbbEda607223492F9dce036A21C459fE1dcab56c7\n        0xbb, 0xed, 0xa6, 0x07, 0x22, 0x34, 0x92, 0xf9, 0xdc, 0xe0, 0x36, 0xa2, 0x1c, 0x45, 0x9f,\n        0xe1, 0xdc, 0xab, 0x56, 0xc7,\n        // Recipient Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0x52b1D2CEBF3C80813f82dC4B5F56fCB4e04aC439\n        0x52, 0xb1, 0xd2, 0xce, 0xbf, 0x3c, 0x80, 0x81, 0x3f, 0x82, 0xdc, 0x4b, 0x5f, 0x56, 0xfc,\n        0xb4, 0xe0, 0x4a, 0xc4, 0x39,\n        // Amount: 0x1234567890abcdef\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,\n        0xcd, 0xef,\n    ];\n\n    assert_eq(encoded, expected);\n}\n"
    },
    "55": {
      "path": "/home/twt/turnstile/turnstile-contracts/aztec/contracts/portal/src/main.nr",
      "source": "mod constants;\nmod encoding;\n\nuse aztec::macros::aztec;\n\n#[aztec]\npub contract Portal {\n    use std::meta::derive;\n\n    use aztec::{\n        event::event_interface::EventInterface,\n        hash::hash_args,\n        macros::{\n            events::event,\n            functions::{\n                initialization_utils::compute_initialization_hash, initializer, internal, private,\n                public, utility,\n            },\n            storage::storage,\n        },\n        protocol_types::{\n            address::{AztecAddress, EthAddress, PartialAddress},\n            contract_class_id::ContractClassId,\n            public_keys::PublicKeys,\n            traits::{FromField, Serialize, ToField},\n        },\n        state_vars::{Map, PublicImmutable},\n        unencrypted_logs::unencrypted_event_emission::encode_event,\n    };\n\n    use authwit::auth::assert_current_call_valid_authwit_public;\n\n    use token::Token;\n\n    use crate::{\n        constants::PUBLIC_NOT_SECRET_SECRET,\n        encoding::{\n            deposit::deposit_content_hash, register::register_content_hash,\n            withdraw::withdraw_content_hash,\n        },\n    };\n\n    #[storage]\n    struct Storage<Context> {\n        l1_portal: PublicImmutable<EthAddress, Context>,\n        l1_tokens: Map<EthAddress, PublicImmutable<AztecAddress, Context>, Context>,\n        l2_tokens: Map<AztecAddress, PublicImmutable<EthAddress, Context>, Context>,\n        token_contract_class_id: PublicImmutable<ContractClassId, Context>,\n        shield_gateway_beacon: PublicImmutable<AztecAddress, Context>,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Register {\n        eth_token: EthAddress,\n        aztec_token: AztecAddress,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Deposit {\n        eth_token: EthAddress,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Withdraw {\n        token: EthAddress,\n        from: AztecAddress,\n        to: EthAddress,\n        amount: u128,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(\n        l1_portal: Field,\n        token_contract_class: Field,\n        shield_gateway_beacon: AztecAddress,\n    ) {\n        assert(l1_portal != 0, \"L1 portal address cannot be zero\");\n        assert(token_contract_class != 0, \"Token contract class cannot be zero\");\n\n        storage.l1_portal.initialize(EthAddress::from_field(l1_portal));\n        storage.token_contract_class_id.initialize(ContractClassId::from_field(\n            token_contract_class,\n        ));\n        storage.shield_gateway_beacon.initialize(shield_gateway_beacon);\n    }\n\n    #[private]\n    fn register_private(\n        eth_token: Field,\n        aztec_token: AztecAddress,\n        name: str<31>,\n        name_len: u8,\n        symbol: str<31>,\n        symbol_len: u8,\n        decimals: u8,\n        message_leaf_index: Field,\n    ) {\n        aztec::oracle::debug_log::debug_log_format(\n            \"Registering L1 token {0} as L2 token {1}\",\n            [eth_token, aztec_token.to_field()],\n        );\n\n        let eth_token = EthAddress::from_field(eth_token);\n\n        assert(storage.l1_tokens.at(eth_token).read().is_zero(), \"Token already registered\");\n\n        // L1->L2 message content hash from token name, symbol, decimals\n        let content_hash =\n            register_content_hash(eth_token, name, name_len, symbol, symbol_len, decimals);\n        aztec::oracle::debug_log::debug_log_format(\"Register content hash: {0}\", [content_hash]);\n\n        // Set the shield gateway beacon\n        Token::at(aztec_token)\n            .set_shield_gateway_beacon(storage.shield_gateway_beacon.read())\n            .enqueue(&mut context);\n\n        // Ensure the supplied token address matches the expected address. This ensures its deployed with\n        // the correct code and initialization parameters.\n        let initializer = Token::interface().init(context.this_address(), name, symbol, decimals);\n        let args_hash = hash_args(initializer.args);\n        let init_hash = compute_initialization_hash(initializer.selector, args_hash);\n        let partial_address = PartialAddress::compute(\n            storage.token_contract_class_id.read(),\n            0x9876543210, // salt, hardcoded\n            init_hash,\n            AztecAddress::from_field(0),\n        );\n\n        let computed_address = AztecAddress::compute(PublicKeys::default(), partial_address);\n        // aztec::oracle::debug_log::debug_log_format(\n        //     \"Supplied Address: {0}, Computed address: {1}\",\n        //     [aztec_token.to_field(), computed_address.to_field()]\n        // );\n        // aztec::oracle::debug_log::debug_log_format(\"Gas left 4: {0}\", [context.l2_gas_left()]);\n        assert(\n            computed_address == aztec_token,\n            \"Expected address did not match supplized token address\",\n        );\n\n        // Consume the message\n        aztec::oracle::debug_log::debug_log_format(\n            \"Consuming message with leaf index {0}\",\n            [message_leaf_index],\n        );\n\n        let l1Portal = storage.l1_portal.read();\n        aztec::oracle::debug_log::debug_log_format(\"L1 Portal: {0}\", [l1Portal.to_field()]);\n\n        context.consume_l1_to_l2_message(\n            content_hash,\n            PUBLIC_NOT_SECRET_SECRET,\n            storage.l1_portal.read(),\n            message_leaf_index,\n        );\n\n        Portal::at(context.this_address())._register_public(aztec_token, eth_token).enqueue(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _register_public(aztec_token: AztecAddress, eth_token: EthAddress) {\n        // Initialize the token mappings\n        storage.l1_tokens.at(eth_token).initialize(aztec_token);\n        storage.l2_tokens.at(aztec_token).initialize(eth_token);\n        Register { eth_token, aztec_token }.emit(encode_event(&mut context));\n    }\n\n    #[private]\n    fn claim_public(\n        eth_token: Field,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        let eth_token = EthAddress::from_field(eth_token);\n\n        let content_hash = deposit_content_hash(eth_token, recipient, amount.to_field());\n        aztec::oracle::debug_log::debug_log_format(\"Deposit content hash: {0}\", [content_hash]);\n\n        // Consume the message\n        context.consume_l1_to_l2_message(\n            content_hash,\n            PUBLIC_NOT_SECRET_SECRET,\n            storage.l1_portal.read(),\n            message_leaf_index,\n        );\n\n        Portal::at(context.this_address())\n            ._claim_public(eth_token, recipient, amount, message_leaf_index)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _claim_public(\n        eth_token: EthAddress,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        Token::at(storage.l1_tokens.at(eth_token).read()).mint_to_public(recipient, amount).call(\n            &mut context,\n        );\n\n        Portal::at(context.this_address())\n            ._log_claim(eth_token, recipient, amount, message_leaf_index)\n            .call(&mut context);\n    }\n\n    #[private]\n    fn claim_shielded(\n        eth_token: Field,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        let eth_token = EthAddress::from_field(eth_token);\n\n        let content_hash = deposit_content_hash(eth_token, recipient, amount.to_field());\n        aztec::oracle::debug_log::debug_log_format(\"Deposit content hash: {0}\", [content_hash]);\n\n        // Consume the message\n        context.consume_l1_to_l2_message(\n            content_hash,\n            PUBLIC_NOT_SECRET_SECRET,\n            storage.l1_portal.read(),\n            message_leaf_index,\n        );\n\n        Token::at(storage.l1_tokens.at(eth_token).read()).mint_shielded(recipient, amount).call(\n            &mut context,\n        );\n\n        Portal::at(context.this_address())\n            ._log_claim(eth_token, recipient, amount, message_leaf_index)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _log_claim(\n        eth_token: EthAddress,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        Deposit { eth_token, recipient, amount, message_leaf_index }.emit(encode_event(\n            &mut context,\n        ));\n    }\n\n    #[public]\n    fn withdraw_public(\n        eth_token: EthAddress,\n        from: AztecAddress,\n        recipient: EthAddress,\n        amount: u128,\n        withdrawNonce: Field,\n        burnNonce: Field,\n    ) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(withdrawNonce == 0, \"Invalid nonce\");\n        }\n\n        // Burn the tokens\n        Token::at(storage.l1_tokens.at(eth_token).read()).burn_public(from, amount, burnNonce).call(\n            &mut context,\n        );\n\n        // Message the L1 Portal\n        let content_hash = withdraw_content_hash(eth_token, recipient, amount.to_field());\n        context.message_portal(storage.l1_portal.read(), content_hash);\n\n        aztec::oracle::debug_log::debug_log_format(\"Withdraw L2ToL1 Message {0}\", [content_hash]);\n\n        Withdraw { token: eth_token, from, to: recipient, amount }.emit(encode_event(&mut context));\n    }\n\n    #[utility]\n    unconstrained fn is_registered_l1(eth_token: Field) -> pub bool {\n        let eth_token = EthAddress::from_field(eth_token);\n        !storage.l1_tokens.at(eth_token).read().is_zero()\n    }\n\n    #[utility]\n    unconstrained fn is_registered_l2(aztec_token: AztecAddress) -> pub bool {\n        !storage.l2_tokens.at(aztec_token).read().is_zero()\n    }\n\n    #[utility]\n    unconstrained fn get_l2_token(eth_token: Field) -> pub AztecAddress {\n        let eth_token = EthAddress::from_field(eth_token);\n        storage.l1_tokens.at(eth_token).read()\n    }\n\n    #[utility]\n    unconstrained fn get_l1_token(aztec_token: AztecAddress) -> pub EthAddress {\n        storage.l2_tokens.at(aztec_token).read()\n    }\n\n    #[utility]\n    unconstrained fn get_l1_portal() -> pub EthAddress {\n        storage.l1_portal.read()\n    }\n}\n"
    },
    "57": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/authwit/src/auth.nr",
      "source": "use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\nuse dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::ToField,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\npub global IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "65": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "66": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let N: u32, T> UtilityCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\n// UtilityVoidCallInterface\n\npub struct UtilityVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n}\n\nimpl<let N: u32> UtilityVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: () }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "73": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "74": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "75": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "76": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "78": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/event/event_interface.nr",
      "source": "use dep::protocol_types::abis::event_selector::EventSelector;\n\npub trait EventInterface {\n    fn get_event_type_id() -> EventSelector;\n\n    fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n}\n"
    },
    "80": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "92": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "97": {
      "path": "/home/twt/nargo/github.com/AztecProtocol/aztec-packages/v0.87.2/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    }
  }
}
