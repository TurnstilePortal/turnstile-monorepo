{
  "transpiled": true,
  "noir_version": "1.0.0-beta.3+0000000000000000000000000000000000000000",
  "name": "Portal",
  "functions": [
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "8459146718181593566": {
            "error_kind": "string",
            "string": "L1 portal address cannot be zero"
          },
          "8606784891595333955": {
            "error_kind": "string",
            "string": "Token contract class cannot be zero"
          }
        },
        "parameters": [
          {
            "name": "l1_portal",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "token_contract_class",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "shield_gateway_beacon",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBNJwAABAMnAgQEAycCBQQAHxgABQAEgEouCIBKAAEuCIBLAAIuCIBMAAMlAAAAUSUAAACDKAIAAQSATScCAgQAOw0AAQACKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgAAACgAgEcBAAEoAIBIBAABKACASQQABCYlAAAIsS0IAQUAAAECAS4KgEQABS0IAQUAAAECAS4KgEYABS0IAQUAAAECAScCBgACLQ4GBR4CAAUANjgABQAHAAgAHAwICQAEOAkHCiQCAAgAAADhJwIHBAA8CQEHNjgABQAHAAgCHAwIBQAEOAUHCSQCAAgAAAEFJwIFBAA8CQEFLQgBBScCBwQCABABBwEnAwUEAQAoBQIHHySARYBIAAcBKAAFgEgACC0NCAccDAcIBBwMCAUALQgBBycCCAQEABABCAEnAwcEAQAoBwIIHySASIBDAAgtDQcIACgIAggtDggHASgAB4BIAAstDQsIJwILBAIAOAcLDS0NDQwBKAAHgEMADS0NDQsnAgcALC0IAQ0nAg4EBQAQAQ4BJwMNBAEAKA0CDi0MDg8tDgcPACgPAg8tDggPACgPAg8tDgwPACgPAg8tDgsPLQ0NBwAoBwIHLQ4HDSsCAAcAAAAAAAAAAAQAAAAAAAAAACcCDwQQLQgAEC0MBxEAEAAPACUAAAjaLQQAAC0MEQgtDBILLQwTDC0MFA4tDQgHACgHAgctDgcILQgBBwAAAQIBLQ4IBy0NCwgAKAgCCC0OCAstCAEIAAABAgEtDgsILQgBCwAAAQIBLQ4MCy0IAQwAAAECAS0ODgwuCIBFAAQjAAACdA0oAASASQAOJAIADgAACD4jAAACiScCDgQPLQgADy0MBxAtDAgRLQwLEi0MDBMAEAAOACUAAAl6LQQAAC0MEA0nAgcADS0IAQgnAgsEBAAQAQsBJwMIBAEAKAgCCy0MCwwtDgcMACgMAgwtDgUMACgMAgwtDg0MLQ0IBQAoBQIFLQ4FCCsCAAUAAAAAAAAAAAMAAAAAAAAAACcCDgQPLQgADy0MBRAAEAAOACUAAAjaLQQAAC0MEActDBELLQwSDC0MEw0tDQcFACgFAgUtDgUHLQgBBQAAAQIBLQ4HBS0NCwcAKAcCBy0OBwstCAEHAAABAgEtDgsHLQgBCwAAAQIBLQ4MCy0IAQwAAAECAS0ODQwuCIBFAAQjAAADkQ0oAASAQwANJAIADQAAB8sjAAADpicCCAQNLQgADS0MBQ4tDAcPLQwLEC0MDBEAEAAIACUAAAl6LQQAAC0MDgQKOAkEBSQCAAUAAAPjJQAACe4LKAAKgEYABB4CAAUBCjgKBQcSOAQHBSQCAAUAAAQHJQAACgALKAABgEYABAsoAASARAAFJAIABQAABCQlAAAKEgsoAAKARgAECygABIBEAAUkAgAFAAAEQSUAAAokHAwBBAAsAgAFAAAAAAAAAAAAAAAAAP//////////////////////////DjgEBQckAgAHAAAEfSUAAAo2KQIABAA7msoBLwwABAAFCygABYBGAAckAgAHAAAEoSUAAApIKAIABQDerTAMAAUABCsCAAQAAAAAAAAAAAEAAAAAAAAAACcCCwQMLQgADC0MBA0AEAALACUAAAjaLQQAAC0MDQctDA4ILQwPCS0MEAotDQcLACgLAgstDgsHLQgBCwAAAQIBLQ4HCy0NCAcAKAcCBy0OBwgtCAEHAAABAgEtDggHLQgBCAAAAQIBLQ4JCC0IAQkAAAECAS0OCgknAgoEDC0IAAwtDAsNLQwHDi0MCA8tDAkQLQwBEQAQAAoAJQAAClotBAAAJwIMBA0tCAANLQwLDi0MBw8tDAgQLQwJEQAQAAwAJQAACXotBAAALQwOCicCBwABMAwAAQAHMAwACgAGKQIAAQA7msoFLwwAAQAGCygABoBGAAckAgAHAAAFxyUAAApIMAwABQABJwIJBAotCAAKLQwECwAQAAkAJQAACNotBAAALQwLAS0MDAYtDA0HLQwOCC0NAQkAKAkCCS0OCQEtCAEJAAABAgEtDgEJLQ0GAQAoAQIBLQ4BBi0IAQEAAAECAS0OBgEtCAEGAAABAgEtDgcGLQgBBwAAAQIBLQ4IBycCCAQKLQgACi0MCQstDAEMLQwGDS0MBw4tDAIPABAACAAlAAAKWi0EAAAnAgoECy0IAAstDAkMLQwBDS0MBg4tDAcPABAACgAlAAAJei0EAAAtDAwIJwIBAAUwDAACAAEnAgEABjAMAAgAASkCAAEAO5rKBy8MAAEAAgsoAAKARgAGJAIABgAABtYlAAAKSDAMAAUAAScCBwQILQgACC0MBAkAEAAHACUAAAjaLQQAAC0MCQEtDAoCLQwLBS0MDAYtDQEEACgEAgQtDgQBLQgBBAAAAQIBLQ4BBC0NAgEAKAECAS0OAQItCAEBAAABAgEtDgIBLQgBAgAAAQIBLQ4FAi0IAQUAAAECAS0OBgUnAgYEBy0IAActDAQILQwBCS0MAgotDAULLQwDDAAQAAYAJQAAClotBAAAJwIHBAgtCAAILQwECS0MAQotDAILLQwFDAAQAAcAJQAACXotBAAALQwJBicCAQAHMAwAAwABJwIBAAgwDAAGAAEeAgABADQCAAEmJAIADQAAB9gjAAAILScCDgQDDDgEDg8kAgAPAAAH7yUAAAuFACgIAg4AOA4EDy0NDw0nAg4EDy0IAA8tDAUQLQwHES0MCxItDAwTLQwNFAAQAA4AJQAAClotBAAAIwAACC0BKAAEgEgADS0MDQQjAAADkSQCAA4AAAhLIwAACKAnAg8EBAw4BA8QJAIAEAAACGIlAAALhQAoDQIPADgPBBAtDRAOJwIPBBAtCAAQLQwHES0MCBItDAsTLQwMFC0MDhUAEAAPACUAAApaLQQAACMAAAigASgABIBIAA4tDA4EIwAAAnQoAIAEBHgADQAAAIAEgAMkAIADAAAI2SoBAAEF96Hzr6Wt1Mo8AQECJiUAAAixLQgBAicCAwQEABABAwEnAwIEAQAoAgIDLQwDBC4KgEYABAAoBAIELgqARgAEACgEAgQuCoBGAAQtDQIDACgDAgMtDgMCLQgBAycCBAQFABABBAEnAwMEAQAoAwIELQwEBS4KgEYABQAoBQIFLgqARgAFACgFAgUuCoBGAAUAKAUCBS0OAQUtDAIBLQwDAi4IgEUAAy4IgEQABCYlAAAIsS0NBAULKAAFgEQABiQCAAYAAAmcJwIHBAA8CQEHJwIFBAYtCAAGLQwBBy0MAggtDAMJLQwECgAQAAUAJQAAC5ctBAAALQ0BBS0NAgYtDQMHLQ4FAS0OBgItDgcDLgqARwAEASgABoBIAAItDQIBJioBAAEF9IABplnTJ0I8AQECJioBAAEFHwBQEkAkIu48AQECJioBAAEFdWTtHyggEd48AQECJioBAAEFd3FxQhm9IUM8AQECJioBAAEFWgLkG7UeqZ88AQECJioBAAEFHwotJ9yCh6I8AQECJiUAAAixLQ0DBi0NBAcLKAAHgEQACCQCAAgAAAqAJwIJBAA8CQEJCygABoBDAAckAgAHAAALESMAAAqVLQ0BBi0NAgctDQMILQ0ECScCCwQDDDgICwwkAgAMAAAKvCUAAAuFLgQABoADKACABAQABCUAAAzqLgiABQAKACgKAgsAOAsIDC0OBQwBKAAIgEgABQ44CAUGJAIABgAACvwlAAANeC0OCgEtDgcCLQ4FAy0OCQQjAAALhCcCBgQHLQgABy0MAQgtDAIJLQwDCi0MBAsAEAAGACUAAAuXLQQAAC0NAQYtDQIHLQ0ECC4EAAaAAygAgAQEAAQlAAAM6i4IgAUACQAoCQIKASgACoBFAAstDgULLQ4JAS0OBwIuCoBIAAMtDggEIwAAC4QmKgEAAQXonQn+oREtDjwBAQImJQAACLEuCIBFAAUjAAALpw0oAAWAQwAGJAIABgAADBIjAAALvC0NAQUtDQIGLQ0DBy0NBAgtCAEJJwIKBAUAEAEKAScDCQQBACgGAgonAgsEBAAoCQIMPw8ACgAMLQ0JBgAoBgIGLQ4GCS0OBQEtDgkCLQ4HAy0OCAQmLQ0DBgw4BQYHASgABYBIAAYkAgAHAAAMMCMAAAzhLQ0BBy0NAggtDQMJLQ0ECicCDAQEDDgFDA0kAgANAAAMVyUAAAuFACgIAgwAOAwFDS0NDQsnAg0EAww4BQ0OJAIADgAADHwlAAALhQAoBwINADgNBQ4tDQ4MADgLDA0nAgwEBAw4BQwOJAIADgAADKYlAAALhS4EAAiAAygAgAQEAAUlAAAM6i4IgAUACwAoCwIMADgMBQ4tDg0OLQ4HAS0OCwItDgkDLQ4KBCMAAAzhLQwGBSMAAAunLgGAA4AGCwCABgACgAckAIAHAAANBSMAAA0QLgCAA4AFIwAADXcuAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAANYy4BgAqACC4CgAiACwEAgAoAAoAKAQCACwACgAsjAAANMigBgAUEAAEDAIAGAAKABiMAAA13JioBAAEFRafKcRlB5BU8AQECJi4AGMoYyg==",
      "debug_symbols": "7Z3fbhypEsbfxde+gKL4l1dZHUVJ1htZsuzISY50FO27nx6vu6fjqW7SFbKG8N1EdtzfQP0KqAIa5tvVnzfvv358e3v/18Pnqzd/fLu6e/jw7svtw/3027e/r6/eP97e3d1+fLv+7ytz+se68CT4/Ond/en3z1/ePX65ehND9tdXN/d/Xr1Jhvz0EX/d3t1cvbHTz/+5vrJsVCqvUXmrUqnKCiq7gophVJUVVXYlVVmJJZUlk/OzzBJ5/k53ffm8z2F+PNiwepqEpznwXCcOq8+OSXg4cZprkrzx64ef6p+r1D+45fGQqFB/YpqtJT5Ven7aW+mzE5n5s1M03z19siCnzi0g47q34Bf4IBcsiME9PxzjucdweKqQDY1ViGxrFfJVKhRpLsPGGAsVcjbQ89OO1oOp2OjIxvmziRxfNDrH3VuQe7eA6/sg8c80a0+tVSg2VqFQZyRKfI4IvpSxeEv2+Wk/Jcb7GYs1THMTnX4O7kXOQsH3boGc13ZlQfc+SN37IHXvg+xew4J0tiCHF1VyxrZXpVfxs6dzleK+n0Oen43mXI0pd3iqvjV9V78S/XCufrKl6ju3NAjnC9WPKc8fHXO5IoU+6Wwey17iwewdzL9uMP+6wfzLsWN7TwZ427sBoXMDgmndgBx4XsQ3tlQRinb+aIqrtd1THnTxcLJh2eCYDD6nP2JFOC3rEJzceZHZefMPyQSSdUhGAslKJJsPEL2QTGiTtUg2HzJ7IZkZJCuRROz+YZImLiTJvCTJlTb0QZINYnclkhaxuxZJtMlKJAltshZJtMlKJF3zq3HdkGx+46wXkoz1yVokGSQrkWx+m6kXkh6zxVoksYJRiWRAZi6SfGKDtdtNNhHZ8zabkfNhsmc2ngqjU8zLAbeYsys87fx8kolXIxmxVGebZwuJLK0fPnkoj9yze/CQNyOPL314CKNc6x4aeebWhYcsw0ONewh9qHEP0cirKn14aOQ9qy48NPReWB8eQrbduoeQKTTuIUam0LqHRt7X6cJDfuT9oj48hLXtxj0UkG237iFk2617CNl24x6KDA817iFk2417aOhzuH14CGvbjXsoI9tu3UPIttv2UDAjn0vpw0MMDzXuIWTbjXvIYn+ocQ8R+tCre4jc2UPsX3po6NOCjXgo2rzU2bmXHvIMDzXuIYxyjXto6FOTfXgIu+CNeyhiTaF1DzE81LiHkG037qGEPtS6h5BtN+6hXCnbtnT2EBc85IxNz087y6Wnq97JEnIcyt5Y66x/N/aGsey1g/nXDuZfGsy/lb5RuR9781j21voisW7sTWPZW+scYDf2dp1PnizwXUeYJwu6zglOFtT67rRfaEEP7zDE1H5b7oNj+z2qC44Z/boORwbHKhzbn230wDEZtMc6HNufHXXB0ba/it8HR+Q9VTgS8p46HBFn6nBEnKnC0bW/utcHx/ZXDbvgyFjvqcMReU8Vjh55Tx2ODI5VOGK9pwrHgLynDkfkPVU4Rqz31OGIvKcKx4S8pw7H9t9+64Mj8p4qHDPynjocsf5Yg2O2aI8/yHH3JpHcwVu4PZyeyg5xpgrHDt4a7oMj5tdVOHbwTnQfHDGfqcMRcaYKx8DgWIUj2mMVjhF5Tx2OlfKePJ/1snlVyInMqZRa3xiwX0qtMwOFUupE5ulzZrcY+wM3c8wf7t3qsyk8naWzxlTpDmScWSrFqVApTkt34ERheVpssckvTTb5aNcP/2NAqmPAUiUy3hQMyDxXKa/uRlmYVloyyed1GePty+Y0FZP+lWIo/CvFyN/ZS9NSyrKo4s4Ny+dnVdao5DlbSSVn1iWVfM6QKM/xg5yNl6qkUcl7ayWVfKdTUSWTd8sYSOzMWiW0CctubkI2pFVHstJQFueHfT4f57TPw4B8XOm1qmM3WvOrVSc0VR1uy1m80ZTDEhJcDvvVmTrLUve8ytlslOJH9MtHR5/yfgCMLswfHdkUouXJ1cvFXdat8sHneGnl23h/U2MDVzA2z2U4Y/x3xj6VIb8YUrcMebO/chn+p8twNpznOZkLDSMZmmuUDFOhYSSau3BMkUsNg8OSnFhvzUXDyDSSsT/f5R3FuQxH6yFUNHbKX5bB2aRVW8u5nZ1NO/0ZXCQuxOAickE/Erk4AheRSwQXiQujvchcArhIXLwBF5EL4rTMBXFa5BIw7spcMO6KXKIFF5GLBxeRC+bTIpeEOC1zQZwWuWTEaZkL5tMSF2cQp2UuiNMiF4v5tMwFcVrmgjgtciEHLiIXxGmRi0Oclrlg/UXkwqPG6fWrh8Zfchk1rytxGXX9pcDFjxqnS1xGjdMFLmHUOF3ignFX5oJxV+QSR51Pl7igvYhc0qhxevek5cRl1PWXApdh90lKXEadT+9zYTPqfLrEZdQ4XeKCcVfkYhGnZS5oLyIXQpyWudSI084tXHyJyyseQuMqmx/dGBsHMla+SZCY7WwsJ7dvbDcnitnTSMamCsbuHzvmjZevq5axsRBVt4z802V0c6KYN86KHzL2N9yxZfkiKXDJDC4ilwQuAhdvHLiIXNBeRC6WwEXkEsBF4kKI0zIXxGmZC8ZdkYvDuCtzieAicZG/PBhcGPNpkYtHnJa5IE7LXBCnRS4B82mZC+K0yCUiTstcMJ8WuSTEaZkL4rTMJYOLxCUjTstcEKclLsFg/UXmMmqc3j9hEeyoeV2Jy6jrLyUuo8bpAhcaNU6XuIwapwtcHMZdmQvGXZELjzqfLnFBe5G5jBqn909YhGH3SUpcRt0nKXAJo86nS1xGnU8XuMRR43SJC8ZdmQvitMhl2H2SEhfEaZFLrhGnOzlfGapsfnRibKxy8qMbY9NAxm7cru2XE6sUTNw3tpuTs3Fjgfg3NTZXMHb/eG3ceKO6ahkbq0tVy9h4o/VIGd0cE57a5M8b+xtuT8eNC0bBxYOLyCWDi8QlMriIXNBeRC7JgYvIJYKLxCUjTstcEKdlLhh3JS7JYNyVuSRwkbhsXOcBLphPi1wIcVrmgjgtc0GcFrk4BheRC+K0yIURp2UumE+LXDzitMwFcVrkEgy4iFwQp2UuiNMil4j1F5nLqHF6/zhJSqPmdSUuo66/FLjkUeN0icuocbrEZdQ4vc8lG4y7MheMuyIXO+p8usQF7UXkQqPG6f3jJHnYfZISl1H3SQpc3Kjz6RKXUefTBS48apwuccG4K3LxiNMyF7QXmQvitMgl1IjTnZyvzFU2P3oxtsrJj26MzQMZK3+1qCWX5qmtJW9XQw55oRwf5yOSwdjVs5K1HJbhiYMvGJA4zfVPfjXFnqsvL4UfrX6wM//gqFR9Xo7nMie/X/0c4txocjT5RfXJyG8kWzJ58RrRipFc/dMbvPPjKXHBAGfs+Twrl55OZGdvJVodi5aDya8LPc6EZanF8ovQQ8Y6gKwDEi2yDkgKAFkFpHyZK0AeB4kWWQcko0VWAukB8sdA7u40kfEGIOuAZICsAxJ5ZB2Q8h25AHkcJNKfOiAjgk0lkAg2lUBmgKwCMqFF1gGZsR5ZBaSlSiDPd2qmVNqh8M7NN8J6589bPRtkwnzoJRlbqsi0hbpcNhtPn/f8dI7dzuItJbiocRc59KLWXVRrUREu+nUuCnBR4y7y6EXNuwi9qHUXBQMXNT4vCh4uat1FGS5q3EUR86LmXRThosZdlJB0N+8ipAvNuwjpQusuki+YgYtachF6UeMuIoP9otZdFMWMztNcgKd4qfHHNckoNIpysqKcrCknH9ZM+I9rrFFownENWYVGnLD5pbf6YC808hmPgiYc17DMbbm2MlzcWjlpWKHJxzVeUY5XlBMU5ciHnfc1UVFOVNizMR7sarKiHeRwWMPGHtfIfWH/7P2kkid44XxxQEgX/YHZaVQbm2wlVdCoNrYiYpyHoNPXY12qvEqVNaqNNcSSKmpUGystJZWKRlaRz7qyNOS9cSqVhry3VqXyKpWKBqloyHeO2Xx+8TDTpUq+eaqgCvJ9MtYsI5s1IV2qskYl30Vi7XIvw+k6hAuVnPcWVVmj2njXtqSSJ0/TfuCiShc0opFryGaZQrG5KCtuHKovqaJGJWeaRZXcovxyRYb13lyonFGpVGVtRNiSKmlUG4fXCir527GLqqBRRVKpokaVVGWlDbviMrL5fJGzxY2FwZIqK1RpI34VVJZUKg2NREal0jBMG2+2unMkmiaXl6qkUcnfv1RUBY1q40RvScUqlYpGUJEPqrKiinxUkU8q8hvR3HFcVOFitNm4yb+oigrVxm3nRVXSqDYyh4JqIwcoqbwic9i4a7ekck6lUpUlf3t6dHPaO6UWLzTOGLEVZp6bbvb+UpOOa+RoUtCE45qNSLKb+08qVqmyRuVUZTlVWawqi1VleVVZQeWvoCtLZdfGak1JFTWqjdWaksprVHIk2R8t5Kw1m3l1MpOgyYd7sZV78W45llihScc1jhSa4yPZxvGegkZRjmeFRuHToCgnKMqR+2v2c7vOkS416bgmKcrJVqEJhzVkrEKjKEfeVVz5R9L4wz4lMgqNohw5WytojmdDxMf7Anmr0BwfDyiQQhOPa6KinKiwJynaTlL4Jx1sB39Pv/333ePtu/d3N58nxemPX+8/fLl9uH/+9cv/Ps1/ef94e3d3+/Htp8eHDzd/fn28eXv38OH0tyvz/M8fwZvraTl6qstTr2SXrqfdutOvp4bjLV97G6ZSp5L/Dw==",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "_log_claim",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "11430482739715627628": {
            "error_kind": "string",
            "string": "Function _log_claim can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgUEBCcCBgQAHxgABgAFgEQdAIBGgEYGLgiARAABLgiARQACLgiARgADLgiARwAEJQAAAF4lAAAAXygCAAEEgEgnAgIEADsNAAEAAiYlAAACZh4CAAYAHgIABwAzOAAGAAcACCcCBgEBJAIACAAAAIglAAACjx4CAAYBHgIABwAKOAYHCCQCAAgAAACkJQAAAqEcDAMGACkCAAMAIxDODy0IAQcnAggEBgAQAQgBJwMHBAEAKAcCCC0MCAktDgEJACgJAgktDgIJACgJAgktDgYJACgJAgktDgQJACgJAgktDgMJJwIBAAAtCAECJwIDBAYAEAEDAScDAgQBACgCAgMtDAMELQ4BBAAoBAIELQ4BBAAoBAIELQ4BBAAoBAIELQ4BBAAoBAIELQ4BBC0IAQEAAAECAS0OAgEnAgIEBScCAwQBJwIEBAAtDAQFIwAAAWQMOAUCBCQCAAQAAAHuIwAAAXYtDQEDJwIFBAUGKAUCAScCBwQDADgFBwYtCAEEABABBgEnAwQEAQAoBAIGLQ4FBgAoBgIGLQ4FBicCBwQDADgEBwYAKAMCBy4EAAeAAy4EAAaABC4EAAWABSUAAAKzACgEAgYtDQYFJwIHBAIAOAYHAzcNAAMABSYnAgYEBQw4BQYIJAIACAAAAgUlAAAC+QAoBwIGADgGBQgtDQgELQ0BBicCCQQFDDgFCQokAgAKAAACLiUAAAL5LgQABoADKACABAQABiUAAAMLLgiABQAIACgIAgkAOAkFCi0OBAotDggBADgFAwQtDAQFIwAAAWQoAIAEBHgADQAAAIAEgAMkAIADAAACjioBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEFnqE7fY/72mw8AQECJgEAgAOABYAHLgCAA4AILgCABIAJCwCACIAHgAokAIAKAAAC+C4BgAiABi4CgAaACQEAgAgAAoAIAQCACQACgAkjAAACxyYqAQABBeidCf6hES0OPAEBAiYuAYADgAYLAIAGAAKAByQAgAcAAAMmIwAAAzEuAIADgAUjAAADmC4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAOELgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAAANTKAGABQQAAQMAgAYAAoAGIwAAA5gmLgAYyhjK",
      "debug_symbols": "7ZzbTuMwEIbfpde58Nhje8yrrBAqEFClqkWlrLRCvPvG3TpJHW+DICLx4QbhalL/83lSjyeO31eP9f3b891m97R/Xd38el9t9w/r42a/a1rvH9Xq/rDZbjfPd/2PV8z+AcZOF7y+rHe2/XpcH46rG+BKYLWqd4/2f61M8yVPm21tW/KjGtozzp05Q96z5gFrVCjP1qgkttaaAsaEZM7GJJnsG99WjX45jX7jOgEA84P6YSL+klr+NMYfpNbOWglxXb+R2jlrFNBAP02t/6S5p9/2wsVP9CLgR3pRwV5AUHsLATI20gsSuF6QuBqJQSlVG4Ma/DHEsN+NCtUp6vXxH0UT3hX4GUacLhTZ6yR88TrztesUhq4jLsE5J6DjJk2AhDbt0DDddQAhWxLUQusAA6mALTfOVoAYsQUy2A41GdkFHzf/glaZxToqldMgjbqwtcI1RSqceKzCdaTCTazETaTEOYuUOGcqUuHhdDMG4TJW4ZHOnJxjrMIjnfK5ELEKj3UCwlgnIFzuBKS4WwYqpBFbIqfBAFxfMQrN3PcKzbsVjRB4IhJe+mVNZLlT5kxE1HKzn7mIlBjxiOgSIz6REiM+keXm9DMRoeWmrnMRWe4qZCYiC66vzUVkueumeYgIVrJ4n0hZ6XlEFlzDnItIydB8IiVD84jwkqH5REqG5hGR+c011O5xEX3BjojG7IgYxhwRAwEiyd01nPWJWB/TW80GfMxgHE0G42jSH0dc8D6R6XxMrhYw9BEyGEfIYBx5clWagI/J5cJDH0VylZSAj8nVRoY+YgbjiBmMY3p7WAI+ZjA/qvTXHagSWXdo1vo49iacVu6dJUNsAEQnMujTAUnkTp8MyIJf6ZkJSImQSyAG8yvAi/aRBPXeHD+Xm9Hk9yDvOhHJSox4RNIrK32bSH4bi0aI8BIjPpESIx4Rkd/mM6L2YS8RDInkt7Ho+uNvmV6p7dtESox4RGR+W63GiOS31WqEyIJPjpmJiM5v9h0jkt92vBEiqVTQJiSSXxY/QiTD14zGiJTfkUsiipUsvk/ko2n+Xh826/ttfT4y9Olt99A7QfT456X2DhN9Oewf6se3Q22PFe1OFLVkAXUFihrSNhMGISpAcWtP67RNDhVwZZtwaja23DQaGh1/AQ==",
      "brillig_names": [
        "_log_claim"
      ]
    },
    {
      "name": "claim_shielded",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17288131482828810359": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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fc05R1+tXcSNc/T1fS6s+eU151ysn+dwLtaPEefo69cuztHX15xzsfq1KHAu1o8R5+jL167AOfr6mnOOvly7CMKaX97nnKOvrznnYv08h3Oxfow4R1+/dnGOvrzmkXOx+rUoci7WjxHn6OvXLs7R19dcWPOrtYvIOfr6PuccfX3NORfr5zmci/VjxDn68rUrcY6+vuaci9WvRYlzsX6MOEdfv3YJa355zTlHX65dJM7R1/c55+jra865WD/P4VysHiPhHH352iWco6+vOedi/WsR52L9GAkxunzt4hx9fc05R1+uXQjn6Ov7nHP09TXnXKye52TOxfox4hx9+dqVOUdfX3POxfrXIiFG6jHiHH392sU5+vqac46+XLvInKOv73PO0ZfXvHAuVs9zCudi/Rhxjr5+7eIcfX3NhTVXvxZxLtaPEefo69cuztHX15xz9OXaReEcfXmfV87R19ecc7F6nlM5F+vHiHP09WuXsOaX15xzsf61iHOxfow4R1+/dnGOvr7mnKMv1y4a5+jL+7xxjr6+5pyL1fOcxrlYP0ZCjC5fuzhHX19zzsX61yLOxfox4hx9/drFOfrymnfO0ZdrF51z9PV9zjn6+ppzLlbPc7oQI/UYcY6+fu3iHH19zTkX61+LOBfrx4hz9NVr161crPnlNeccfbV2kTbO0df3Oefo62surLlynpM2zsX6MeIcff3axTn6+ppzLta/FnEuVo9R4Bx9+doVOEdfX3PO0ZdrF4Fz9PV9Lqz55TXnXKyf53Au1o8R5+jr1y7O0dfXnHOx+rUoci7WjxHn6MvXrsg5+vqac46+XLuIwppf3ueco6+vOedi/TyHc7F+jDhHX792cY6+vOaJc7H6tShxLtaPEefo69cuztHX11xY86u1i8Q5el7zGFJ/PziGGgZV5GT8jc6V3h8bncigipxdV1SR0+WKKnJeXFBF4QS4ooqc0VZUkVPUiipyLlpRRWEVF1SRs8uKKnJ2uVzpEE4619ecc5F6pVs4danHKHOmu3ztypwAr68550X9axGnUf0YCTG6fO3iZHx9zTlHX/70OnOOvr7POUdfX3POxep5TuFcrB8jztGXr12Fc/T1NedcrH8tEmKkHiPO0devXZyjr6855+jLtYvCOfr6PuccfXnNK+di9Tynci7WjxHn6OvXLs7R19dcWHP1axHnYv0YcY6+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t3+37R+6UIqmo0+moxfT0WfT0Z+6Y/2+Qj39Cu30KyxY+0u4P7WRWsrk4H7HLH94ahDa6NlmvCnO7wfHGuM/8F3wI7dXRR7MRh7NRp7MRi5mI89mIy9mI69mI29mIze7h2aze2g2u4dms3toVrOH/o5Gzb74Oxo1e93vaNTsX7+jUbMn/Y5GzT7zOxo1e8evaIqa/eB3NGrW+N/RXLxu58cPWT++MDxet8PWHj9Kvf07/1MLKclw7GI49mw49qY59p4fUuHWS/hH7DWojr3dfwsQwraVf8auep2ZxK56nZnEfvU6kx+7TZNp7LXn570aPsWeDcdeDMdeDcfeNMe+vzfVbjf2thmOPRiOXfX6vs9nmup1Zn9fbarXmUnsqteZ/dj7qevM7yuE068QT79COv0KcvoVFrC/9nhzMcfZl/LCTcO+N14tz18o//os+//4O0l5wU86XxZ6tRt6sxt6txp6W/DT0peFHuyGHu2GnuyGLnZDN7ubts3sbto2s7tp28zupm2zu5sGu7tpsLubBru7abC7m674ce2rQtezm/4OR88O+TscPbve73D07GS/w9GzO/0KJ+rZcX6Ho2cX+R2Onp3hdzh6Vvvf4ehZwX+Ho2tVjrpW5ahrVY66VuWoa1VOulblpGtVTrpW5aRrVU66VuWka1VOulblpGtVTrpW5aRrVRZdq7LoWpVF16osulZl0bUqi65VWXStyqJrVRZdq7LoWpWzrlU561qVs65VOetalbOuVTnrWpWzrlU561qVs65VOetalYuuVbnoWpWLrlW56FqVi65VuehalYuuVbnoWpWLrlW56FqVq65VuepalauuVbnqWpWrrlW56lqVq65VuepalauuVbnqWpWbrlW56VqVm65VuelalZuuVbnpWpWbrlW56VqVm65VuelalbuuVbnrWpW7rlW561qVu65VWdFvaX+Ho2tVVvSb19/h6FqVFf029RZOV/R709/hqFqVu6Lfhf4OR9Wq3DdVq3JX9JvM3+GoWpW7ot9O/g5H1arcFf3G8Vc4in63+DscXauyot8X/g5H16qs6HeAv8PRtSrr+m1f1/Xbvq7rt31d12/7uq7f9nVdv+3run7b13X9tq/r+m1f1/Xbvq7rt31d12/7uq7f9nVdv+3run7b13X9tq/r+m1f1/Xbvq7rt31d12/7uq7f9nVdv+3run7b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",
      "brillig_names": [
        "discover_new_notes",
        "build_msg_block",
        "attach_len_to_msg_block",
        "debug_log_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "get_l1_to_l2_membership_witness",
        "notify_created_nullifier_oracle_wrapper",
        "storage_read",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "directive_to_radix",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "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"
    },
    {
      "name": "claim_public",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17288131482828810359": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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o0/P88w++vyYsy9WX+dk9sX6MRJidPraxT76/JizL9a/FrEv1o8R++jz1y720afHvLCPPp27KOyjz89z9tHnx5x9sfo6pwgxUo8R++jz1y720efHnH2x/rWIfbF+jNhHn752VfbR58ecffTp3EVlH31+nrOPPj/mwphrr3Mq+2L9GLGPPn/tYh99fszZF+tfi9gXa8fIL+yjz167/MI++vyYs48+m7vwC/vo8/NcGPPTY86+WH+dw75YP0bso89fu9hHnx9z9sXq1yLHvlg/RuyjT1+7HPvo82POPvp07sIJY356nrOPPj/m7Iv11znsi/VjxD76/LWLffTpMffsi9WvRZ59sX6M2Eefv3axjz4/5sKYn81dePbR5+c5++jzY86+WH+dw75YP0bso09fuwL76PNjzr5Y/VoU2Bfrx4h99PlrlzDmp8ecffTp3EVgH31+nrOPPj/m7Iv11znsi9VjJOyjT1+7hH30+TFnX6x/LWJfrB8jIUanr13so8+POfvo07kLYR99fp6zjz4/5uyL1dc5kX2xfozYR5++dkX20efHnH2x/rVIiJF6jNhHn792sY8+P+bso0/nLiL76PPznH306TFP7IvV1zmJfbF+jNhHn792sY8+P+bCmKtfi9gX68eIffT5axf76PNjzj76dO4isY8+Pc8z++jzY86+WH2dk9kX68eIffT5a5cw5qfHnH2x/rWIfbF+jNhHn792sY8+P+bso0/nLgr76NPzvLCPPj/m7IvV1zmFfbF+jIQYnb52sY8+P+bsi/WvReyL9WPEPvr8tYt99Okxr+yjT+cuKvvo8/OcffT5MWdfrL7OqUKM1GPEPvr8tYt99PkxZ1+sfy1iX6wfI/bRZ69dl3Ax5qfHnH302dxFWNhHn5/n7KPPj7kw5srrnLCwL9aPEfvo89cu9tHnx5x9sf61iH2xeowc++jT1y7HPvr8mLOPPp27cOyjz89zYcxPjzn7Yv11Dvti/Rixjz5/7WIffX7M2RerX4s8+2L9GLGPPn3t8uyjz485++jTuQsvjPnpec4++vyYsy/WX+ewL9aPEfvo89cu9tGnxzywL1a/FgX2xfoxYh99/trFPvr8mAtjfjZ3EdhH92PuXaifF3uXXSOK7Iy/kLlS67rRiTSiyN51RBTZXY6IIvvFAVEUdoAjosgebUQU2UWNiCL7ohFRFEZx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",
      "brillig_names": [
        "discover_new_notes",
        "build_msg_block",
        "attach_len_to_msg_block",
        "debug_log_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "get_l1_to_l2_membership_witness",
        "notify_created_nullifier_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "directive_to_radix",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "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"
    },
    {
      "name": "_claim_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7069518359247663558": {
            "error_kind": "string",
            "string": "Function _claim_public can only be called internally"
          }
        },
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_claim_public"
      ]
    },
    {
      "name": "process_log",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "15261044312996284873": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 33
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "log_plaintext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "tx_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "unique_note_hashes_in_tx",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 64,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "first_nullifier_in_tx",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "7Z3brvS4da3fpa99IZKTp7xKsBE4iRM0YNiB7Wxgw/C77/qXlqT6XdJSLTYlnr5cGN1pqYoc45M056AW6++//Ocf/v1///vffv3Tf/35r7/8y7/+/Zc//vk/fv+3X//8p8e//f0fv/vl3//y6x//+Ot//9vz//uX6cf/+Onj+L/+z+//9ONf//q33//lb7/8i9KTnn73yx/+9J8f/xzV4zP+69c//uHHv7l//O7l+DDZz6ODNuuxYdo51OrlUGun7WMl/uP//O4Xr7KMxrplND58PRox8fNQceFlNDrHaOJkPo+Oyn89GrfK6H581D+NxmQZjahlNFZORhOWD/bTq1OyPxrtzDoaN8nJaMyklhmbydptPHbv4BhWsyaR54N/DMjWNiBX24B8bQMKtQ0o3j6gxw1o+WwRNZ2MXsewfLJR2zjcj8GHqeXBq5YHrysfvHFxHXzwT4Pf+WC1TlS08v80UTPKRO9/utntOW4n438LjrblwbuWB+8rH3y26yOMMtFYYKLOrxON0z+VKHGqbUCqtgHpEgNy24D8Pw/I1DYgqW1AtrYBlXgKuTUYUdPLgAo8WZTR64Cc+ecBhdoGFEsMSK0D8v88IDUVuFVvzzKrnfr6YCVeloE8prKN40eI9PfXbCrsZVOP2+/HXNVAc9UDzdUMNFcZaK52oLm6gebqB5prGGiucZy5qoHqJjVQ3aQGqpvUQHWTkoHmOlDdpAaqm3RfzxxZDnZWvc61r3uTW0Ih9/wGzzLX2u9Ndv1kZY38NNeP8dd+vzkbf+33kLPx195PnY2/+h5pfR/tMX57cq0r59eVn8c/h23px82zrb5LyjlbU/0zK+tsq++Uss62+l4p62yvrkg+vkTu+BJ7x5dkeqi67UuCevmSPE8+ictbG8aacAKVXwDU01b2ae93jg3TUiMGE0+OjWFZ6o3x52M/JhpGmWgcZKIyjTJRNcpE9SgTNaNMVEaZqB1lom6UiY5SGckolZHkqYysrC8de62/nqh3apmpd8Z8fXC215mVnUaZaaY/4ZD1cCM+/nOTlOmF/2M5P74k3PEl8YYvidMdX6Lu+BJ9x5eYO75E7vgSe8eXuDu+5I4rPt5xxccbrng9TXd8ibrjS/QdX2Lu+BK540vsHV/i7vgSf8eXhDu+5I4rXt1xxas7rnh1xxWv7rji1R1XvLrjild3XPHqjite3XHFqzuueH3HFa/vuOL1HVe8vuOK13dc8fqOK17fccXrO654fccVr++44s0dV7y544o3d1zx5o4r3txxxZs7rnhzxxVv7rjizR1XvLnjipc7rni544qXO654ueOKlzuueLnjipc7rni544qXO654ueOKt3dc8faOK97eccXbO654e8cVb++44u0dV7y944q3d1zx9o4r3uW54r2sr5X6cLLc75e/3fHb8q34eTSqqtHoqkZjqhqNVDUaW9VoXFWj8VWNJlQ1mljTaHxV92Jf1b3YV3Uv9lXdi31V92Jf1b3YV3Uv9lXdi31V92Jf1b04VHUvDlXdizPtCP7lW5b6jlc5daZds0++xN3xJf6OLwl3fEm84UsyvZR68iXqji/Rd3zJHVd8vOOKj3dc8fGOKz7eccXHO674eMMVb6bpji9Rd3yJvuNLzB1fInd8ib3jS9wdX+Lv+JJwx5fcccWrO654dccVr+644tUdV7y644pXd1zx6o4rXt1xxas7rnh1xxWv77ji9R1XvL7jitd3XPH6jite33HF6zuueH3HFa/vuOL1HVe8ueOKN3dc8eaOK97cccWbO654c8cVb+644s0dV7y544o3d1zxcscVL3dc8XLHFS93XPFyxxUvd1zxcscVL3dc8XLHFS93XPH2jive3nHF2zuueHvHFW/vuOLtHVe8veOKt3dc8bajnZvcuhn8NOmfDv6YaUebWn49U9fRrpYnM+1oW8uTmXa0r+XJTDva2PJkpnmeh9dtsfbVL5gbZ5sevWt69P7+0Xu1HOy9xJMLKt8P7hgXBpprHGeufhpormqgueqB5moGmqsMNFc70FzdQHMdqG7yA9VNfqC6KQxUN4WB6qYwUN0UBqqbQl/P169+MNaEvu7DX/1grIm134e//sFPE2u/t56Nv/b75dn4a78Hno1far/WM/7wpInVd4RZZ1v9MyvrbKvvCrPOtvq+MOtsq6pIHiOSqaq64WNEVVUCHyMq8WwP6+YFUZ0crB5rectAvNuG/+Mfdx6kdn2QPlqFrw8O60M32Keac95EQSaDLru6CLrs6mLRZVcXhy67unh02dUlDKvL+gpTCPYnXV6P1VNchqzVtCVhsidGWI+NWp198KMhWT74cU9bjzaPtvTDnog9FdujJuyp2R6FPTXb020vpH+y52Ou3fY3O3OVgeZaeR+ip2mZq56e1oV25/roHpaDH5WHe5lr5b1F1rnW3i/EdQlPT8afzFUt92ExZzdtFaIsRz/+2W6xo456lqb2lqGgNLWX6+Wk0bWXygWlqb1MLShN7SViQWlqrygLSiNIcyRN7bl5QWlqj84LSkM1fCgN1fChNFTDR9IYquFDaaiGD6WhGj6Uhmr4UBpBmiNpqIYPpaEaPpSGavhQGqrhQ2moho+kEarhQ2mohg+loRo+lIZq+FAaQZojaaiGD6WhGj6Uhmr4UBqq4UNpqIaPpLFUw4fSUA0fSkM1fCgN1fChNII0R9JQDR9KQzV8KA3V8KE0VMOH0lANH0njqIYPpaEaPpSGavhQGqrhQ2kEaY6koRo+lIZq+FAaquFDaaiGD6WhGj6SxlMNH0pDNXwoDdXwoTRUw4fSCNIcSUM1fCgN1fChNFTDh9JQDR9KQzV8JE2gGj6Uhmr4UBqq4UNpqIYPpRGkOZKGavhQGqrhQ2mohg+loRo+lIZq+EiaSDV8KA3V8KE0VMOH0lANH0ojQ0jzMdUxqtuPqY5RrX5Mtavq0yyjeFTVr1Ptqpr8eqqVV4daqWmZqnrZTNxOlVdwZ8OvvMo6G37lldDZ8CuvVrQyy49Ja/00jt9erZi4fLAStR39+TMTdhKE2Rem9t8uKCZM7T90UEyYyqumcsJUXmOVE6b6iqyQMLX/dFg5YaqvIrMI8zHV6ivOfFMdozr9mKr0NNWv+m1b/a9fZZxqidLnWz8u75ef/FP26cev9n9c3slysLNPBMdpnmvoaq5++QE39+PT/nmusa+5qnWu7mWuRX6DqdRc1UBz1QPN1Qw0Vxlornagubqu5rou3zgXXufaV9309Vz7qpu+nmtfddOXczV91U1fz7WvuunrufZVN309177qpq/nKgPNta+66eu5DlQ3mYHqpky//zG5JegxU1DPw//4EnXHl+g7vsTc8SVyx5fYO77E3fEl/o4vCXd8SbzhS+wdV7y944q3d1zx9o4r3t5xxds7rnh7xxVv77ji7R1XvL3jind3XPHujive3XHFuzuueHfHFe/uuOLdHVe8u+OKd3dc8e6OK97fccX7O654f8cV7++44v0dV7y/44r3d1zx/o4r3t9xxfs7rvhwxxUf7rjiwx1XfLjjig93XPHhjis+3HHFhzuu+HDHFR/uuOLjHVd8vOOKj3dc8fGOKz7eccXHO674eMcVH++44uMdV3ymv36d4pLVG2XO/nbXr+/XTtsagPZ7L/6HaVkwCCaeHBvD8oZ1jD8f+5ioy/R3sg1MVI0yUd3PRN26LjZN+nWmZpiZyjAztcPM1A0zUz/MTPPUJkqWw42I/3qmj8xjOfhx6zdnsthFQ+Xd02sJZudg7ad1M5HnFx7cPNU4zFQz/X1pE1NV40xVjzNVM85UZZyp2nGm6saZqh9nquNUS2qcakmPUy3pcaolPU61pMepljL9VWwTUx2nWtLjVEt6nGpJt1stfQy/3Qrox/BNu1XNx/DbrVQ+ht9u9fEx/HYrio/hS9vDb/fJ/zH8dp/mH8Nv9wn9Mfy2n7qm7aeutP3UlbafutL2U1fafupm+qvhYsNv+6krbT91pe2nrrT91JW2n7q27aeubfupa9t+6tq2n7qZ/nK/2PDbfuratp+6tu2nrm37qWvbfuq6tp+6ru2nrmv7qevafupm2j2j2PDbfuq6tp+6ru2nrmv7qevafur6tp+6vu2nrm/7qevbfupm2sGm2PDbfur6tp+6vu2nrm/7qevbfuqGtp+6oe2nbmj7qRvafupm2kWq2PDbfuqGtp+6oe2nbmj7qRvafurGtp+6se2nbmz7qRvbfupm2smt2PDbfurGtp+6se2nbmz7qRubfur6qemnrp+afur6qemnrp+afur6qemnrp+afur6qemnrp+afur6hveC+xh+20/dhvds+xh+20/dhvdW+xh+20/dhvdA+xh+20/dhvcq+xh+20/dhvcU+xh+20/dhvf++hh+20/dhvfo+hh+20/dhvfS+hh+20/dhve8+hh+20/dtvem8m3vTeXb3pvKt703lW97byrf9t5Uvu29qXzbe1P5tvem8m3vTeXb3pvKt703lW97byrf9t5Uvu29qXzbe1P5tvem8m3vTeXb3pvKt703lW97byrf9t5Uvu29qXzbe1P5tvem8m3vTeXb3pvKt703lW97byrf9t5Uvu29qXzbe1P5tvem8m3vTeXb3pvKt703lW97byrf9t5Uvu29qXzbe1P5tvem8m3vTeXb3pvKt703lW97byrf9t5Uvu29qXzbe1P5tvem8m3vTeXb3pvKt703lW97byrf9t5Uvu29qXzbe1P5tvem8m3vTeXb3pvKt703lW97byrf9t5Uvu29qXzbe1P5tvem8m3vTeXb3pvK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",
      "brillig_names": [
        "process_log"
      ]
    },
    {
      "name": "is_registered_l2",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [
          {
            "name": "aztec_token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "H4sIAAAAAAAA/+19a6xcR3Jez32Rd+5rSD25klbaXWklSqR45j0jraShyJUoPiRSfFMvzlMWLIsbketgjRi5sGNn8yOBARs2ksBBAhhGACdGfgRwACMOYCSIYf8wkD+BgyA/DAQB8muBvJDEQTxHnJr55ps6Z865U33vSLoNkHfmVPdX1dVV1dV9+pzJuPslM/gXliW4xkWuNQZ/g9lK3hAryChyxnZCa/ALW/f/rg6+LwB90bDjq4osVvi1oFJfdZN9NpS/uDrA9KkfwfSAHxwY4Hy8PcLnvoRlw407B7Y5OKDL5wK0CctPAba096m3/rjXPOst/4CL1pXY3KltNyw2fEsdwT697aVfBcH/fnrZ89PABfuN9NhTi2C/6UcvJcE/4we/KPhvAX7GA/5ZP/hDuznnRz89wT8/wJ/BdibsVLAvgOwz4AdR+G/70c0Q/x0/8g/n6It+5B/iXxrg+5D9XXvsYUy4DHqx86nCcFyveMGvDHVz1Q/+MOZc84M/1P91P/hlwb/hB78i+Df94FcF/5Yf/GFu/Z4f/Lbgv+8Hf5hLfeAHvyv4H/rBH86JH3nBrw7jz20/+MOcoekHfxh/Wn7wh/Gn7Qd/GB86fvCH/tv1g98S/J4f/M6au7/ePDtIeNb7/zYH2B93773+6Z32T7/9w59pdT8fVBhKgatC7TqWEPXwCPXUnc/ufd5s3zvZ6XzevXuXEeI2jRg1C6g/1fzks7c6jLa8M7Rr3c/vfnLnM0ZbSYgma+cDUN9u3MqB7CUcJPmQN+4L2eWa+aa258XWgPyzJKt17pshfiIP60f2GUR3WUXWnELjMcwqfLIKn5xC4zxrFqzbhlg3DLE+NMSy7OP7hli3DLE+MMS6aYh12RDLso+W9tUyxLL0bUvdXzPEsrT7piHWVUMsS/tqG2LN69zRGWD5zTvu79GFmGt+8ItxusA+CX/JIw5A/UzEX8FimvDKuslcw0eOpPUN5Y8aZ9bBLDaDWKsKzceYrsb0m/lH1ddySam/HoOP9bfcpA2vky42/OiiEDdu68BT+K9Dnzvd1g8/Pn/nY0dlkfQgejtC9WTffsFN6nstAsvR9yN0bRHwsKyDHHd/9Fn77Tv3unfdlBLnzDIwfhYw+XrSYCH8dytYHCR5ooxadLeqyJpzkw7V3R7Vi3K2VYWPhtUzxLpsiPWRIdZ1Q6wPDLGuGWLdMsSy7ONNQ6x5ta8rhli3DbFahliW9mWpr/cMsSzty9KHPjTEsrQJy7gqi1nPi6Amb15iERoml0tEw0T1FPSfC2/jY5/Cuf1iZoTL9VgezJsw2YvKGZzzvjAYHgpc94M/XHisuXGdcp/WI3QldO2vYDFNeO3WhrvWN22RlHOTdskLLg1rLSXWXm4QaDa+ESOr1g9eYMctWlEnUn89Ri6s/3VZhD5K9eTw1SyL0EfpWtQidNbNIZEzLDkFSxbUvDYNS2PwN5itlHkus8O+f+Oc7cAIu+Y5DrS1uVSK0NB/DhBtE2g8P28BlszPQstBuyy1OxSDeTgG84EYOR+MwXwIaAeJ9jDQMKZx0XIMGbMQ83aKHGP3923uzwcsz1d530YOgMbNT0nyZWnv3GiMUIeNnemjwBc853gd9nUsmq9r9oL6w4Jyh2PypxsjXK7HPNHeN4mGY7BFNJwPc0TDWCqxRvIIzdYzbnJcF5VrbCPcHmXg+Vj7K3zcFD6azFuKDGyzmm/F5byab82a62t8NJl5zC34YH94Dsoa8tFyM+GzAO0kDwoPZh3KjNqE/+To17IbjRW2Pb09omN9Cewh5oODz6tUxziWtNjPsHC+ofkG5htsZxiD2Da2gIY656LFJ9FFyO8nKeITrlvWqa7UX3aT4/XG9ng94b+ktA/Lhe1xLKn/7cxI7tXNUf84Liwqsi+SvGHxbBuFJD6E/LMkq688Y5nkYf3I2IVjLHZ9996dz5sfd9/tNjsoOquP/7JJyvclusbfF+g748jzMksuWckouFrXZampTZEL1I6X8VJWFdzG4G/U2PQSFuEn/T6gyCJ8l6luAO6zvjmSDdsvK/0R912I0UlY1tyky5YhJL9JIXmFZG64eB0lLMOtijXokzZmK9RnqV8HPW1tjupjG+eSbe1o22Mriv623KQvSVvP+pqrKUxbMsedBNemN9FTKMvhzREu15OCthkXItHWJU5oU+My4B4Cmw/L0vaontUYVmujFx8sDvDF5rksAR3rvzMA4FRC4kdjh3L2qs18r9jsNcvNTqfUbh4mfAe642caNpxT5wbn5nfqXvIjT+zUvaToEqfuT+80O6eaP7j7w0+7PK3yrim7GtfHuk6hcZaVoe8L1E7cSDNVljNuCl9SMNNO4YsRfJ0bTX3alB+HJZ8XXfzUGZdSCMZGDAa7jnangF3H052CLod+LFro512tHMnlnEsc+vFVHGnudOL0hrIhJqYR2h2YZar/M5D6/MGBcX6HFXmShJyw8IobQ+oy9esBQz6447xCfB405IO717yz/ZAhnyQ74RZ8tF118c9HgCZ9Ff88AjTDU4vDkwjfcJNFaI8Bb7apx4EW91id5p/Sp7T++SjQUDbERP9EvT4KdKz/48xIlgu0HOK7hZj2y9Jz0U2O0yNusi+POB0b264qNMMxL2ljzvPBY354l5P4DfLPkqzG89MwlXqM5GH9pEyl0AwQ/kGCkzpYF8uDIBLWX6bvUWaVJJVadZNuYrmi9GtSwfBG8eN+8Ic30J/wg98W/G/6wR/epH/SD35F8J/ygp8f3gD8lh/5O4L/bT/4TcH/jh/8Kk9lvwep5j+AaVWbysLiOcUIkoZ84Z91Pqe/Ucg/QvKwfhZIP56moF7GTU43iwpPkVfG8mmFJljPDL5jGoT1vwF9xPr4WdrjtX8yGLAcYYaFb+w8rfQHr4l+Qzv97QHultKfR6lv2rgdUXBzLjrF0nY55UaTdjDoDaJtxNA2Y2hbSr94qRuWt6ndIQUz1NsjCyO8KJ2jXfF2COoZ7YPtQMM6TVjY/hnC+u4UrDOEhe2/S1jPTsF6k7Cw/bOE9VwMFuYUW0r75wjr6BSsJwkL2x8lrOenYH2HsLD984T1whSsxwgL279AWMemYH2TsLD9McI6PgXr24SF7Y8T1otTsB4hLGz/ImGdmIL1BGFh+xOEFUzB+hZhYXtpu0rfjeefrshamCJrQLLmgVagfsdhhUXejrml9I2xilPkeorkwvbSdpW+2+owP8wpylNkLZKsJaCVd0fW4R3RSkpZy0CTthtucowy1I+Kn34kziuFf9arXkd5paZX1A9vcVcVWXMKjefBqsKnqvDRsJ41xHrOEOuoIdbzhlgvGGIdM8Q6boj1oiHWCUOsvCFWYIhVMMQqGWLxPIJxwzD+Dh+kmpZDC/+4HHrRTcaSZ0nuRaU/Gu9nFd6Coa0JcD5AmlN4hoV1X4zgl0Q3sgbciunbFtXVZH5U4fNoQpl5HYprYnmTtnZrlNfSeAv5aaLhyZ9niLal9Eu7/fss0fBhGdEbron5JNc3Btf93l4JAj7Voul49/fh7uf5yM+5vd2H430sTRfPeOFdyifVxTOki6c96UL8WNvb0Pw4Lr5oe2x42+rj7r3zdz5+/UdXmh/z81Z8QgRdDuvxS3y+ESFWg+o9Q9/FbaOer8Th0eTg22JcvzGlPn5eV66HZUuh85ak9swuXovbkuRndvlwZWPwPZipVIe3sZ71gl8a3gZ6zgt+ocjh/B8PlBqG/OODz9oUxiHFz0mnQuLwKvyzbtLnfISUDZKH9cPL0U1F1pxCYzvaVPhsKnxyCo3fLbJTLM1/ZpHrAyO5wnLNEOuyIZZlH63G0Rn38aohlmUf3zfE+sgQ6z1DrOuGWC1DrFuGWJY2YemPlj5kaROW+rppiNU0xLLU/Q1DLEvd3zbEstSXZSy8Yohlqa95jYWW+rKMOV+HnMnSJiznbSvdh595fTmLXN1tO6zeAEvbLzhAmLgGxX0CWaPilqjlmlDwD/nBH94SyCl6xD4Jf+3IVCbir2AxTXhl3aSt+FhPa32LsxHcwuaniTSsXEqsVYXmY0y3YvqN/DdiZNX6sUE6SbpfIfUPxciF9bcU3tJWdIhb94Y6LMTpEH1R+O/kfXmit+NUj9+XhzaYi8By9P04XVsEPKfU1x50X1dkYtlXlPqIx0/V/fZgcL94gmgw6PyePWwf4v/ugCBjzscEGoPvwUylVBQ/eIH0g7zxKIDhXmTiH/cS/lmS1Vfs1I4Pon54L/K4ImtOofEYakcLjyt8cgqN87FZsN43xPrIEOs9Q6zrhlgtQ6xbhliWNvGBIdZlQyxLm7DU101DLEt93TDEstIXz5vzZKvXDLG+6uMYltuGWJb6spyHrhhiWeprXuchS31ZxntL+7KMOZb+aGkTljmTle7Dz7y3Notc3W07LN5bQzl5b+15pT9h8bvmGu2tvegHvxinR+yT8N9QdJCJ+CtYTBNeWTepdx/rQ61vKH+c7SZ5vCypHwjWqkLzMabHYvqN/DdiZE2yLtYeK9TW31L/xRi5sH7cY3WiQ3wkwMfemqZD9EXhv5O9NdHbUarHe2vaI4qM5ej7UboWtbfG59+ODIC1c3eG+lWPM/PRdDzDxmcj0/4mDLZfi8DCFxrKo9IhHd/+g/WfHFQOx/3y5jimdoQWj9zyI9MoE8fW5yL4Z9zI5pap7tMg27WBbBtuUk+if8/j3U46Nwj/3TrHqI2TZkfavq6hPK24WKrlHjKWLyg0jl34ugas/zz0keMMxr1lulYYDFzOTcb6N7bHZdAeE9fmhnAP/djieN92mmMgbs5N6obfGY+xEt8ZX10c74v2sl98tPARoGP939sYYb40wNQesefxY1/EWBSW09vj9WU85X4H1+E4JvVfg1hxk+LYtDefscyCiS8pRZn5vetS/zTNO57uGajzjvDSXl/Bj46mfU3IUUUPG0o7jsN+4kw+8SMqwj+r6MRHHH4+oV792sf9x7+nxS2UV8bymEITLMnZ0Iew/gvQR6yPn6U9XrtKcRhjNsdhLY/FaxiH36EYhf3hVwLFzVeIm1Pasw6x3azxXpM5zu92ygexMGfEccVxfwow8cwAjgfGTrRDjp1SvwXx+/2YXA/nts7idFnXFFmXqf7fg7ntY7IbPBMg46GND5/jOKLwzVBd5ybPtmjzkci5ElF/K6Jfn4FOL9KciLrQxpXP4whtSelXWHhcpf7nOxjXe4vTZdXWGstU/+dhXP8qjSvqL25cc0TDcRUdaXMuj3naORfbH4nh8xDRngKavFF3g74LPSx+10ztxHM1r5ke9iJP/JoJ9cNz9VE/+hnO1dorsrS82vMarqjlAlF731G5wFHQIdbHz9Ier/0qrZ20V2RZrtd2Gysuf8ExDePVj3dpHckx4qghH21NquVj6OtIEz58jflge6nn9wxbMdByeEP8vHZPxhC/oO3f2+GXhq8wwH1ynnP87HuXK0nnHOGfJVl9zTna6/NQP3zGL1BkzSk0HsNA4RMofHIKje/lzgvWdUOs9w2xPjLEstTXLUOsDwyxbhpiXTbEsuzjh4ZY8+pDlrq/ZohlafdNQ6yrhliW9tU2xLK0r9uGWB1DLEu7txxHy/hl2ceuEVb4mXP5WeTqGckVFkt9WeYTX4d5yNLu5zX/umKI9Z4h1n7+tXd2b5mb7M9p6bDmNZeb11homctZxkLLcbTU17zmX7zXOYtc85p/3TDEsvRtSx+y1JflPGTpQ/Oqe8v4ZbmXNq97Q5b2ZZn7zmuOOa9zB9/Hspg7tHuo+B5lz89XFAU/7wk/TlfYJ+HPz8AIXfsrWEwTXlnCMu5bPq5vcc8ioU0l+UmppPYpWJ5/Umo4pidi+o38094LtPKz8PMRQ6wNwop7JgmxpH5eqa/ZifazWdJWxhZ/nsRwbAtxY6v9JNhOnrcSvV2levIzgQtu0jeCCCxH36/StUWnP2+l/excLkJO4cvX4s67HYvh8/CMfB5OyOfL3B/GlnNW+O4vOZvk95xJpeX3nEmlpj1bbIdf7mk5hKH8BW2+scMvlbUcxQ6/WpP5CX/WUOKF35/rqxST5jTCP+u8xv9hTqP9LCPqh8/5lBRZcwqNbaSk8CkpfDSsvBFWWPie1SxY1w2xrhpitQyxLPt4zRDrsiGWpU1cMcSysgltzty3iXisDwyxPjTEmlffttS9pb5uGGJZ9vE9QyzLcbS0+5uGWFZ2H37m/H5ebKJriGVlE+Hn/fxrb2zVufmca8PPvIbdj4XxWD1DLKuYE37mvYJZsNaNsMJi6UOWMdpyTpvXvHBe57R5XFuFxTI3sfQhS31Zxej9ueOrMXeExXJtZRkLbxti7e8p7J0PWereso8dQ6x5XQ9Z6v6WIda87hda5jn7cWLv8on9OLF3up/XOMH5V6Bg5eDaxUF97QwF3xctTsE6TVjYvuim9xGxzhAWti9RuzLQUH58jw7aQVnhfUzBF4xV5Xr4rzH4HsxUqs1VpR92+IWO4Fe84Je6cr+9CnrNDP4K7xpctzsbUEr87mDhnyVZbeUZnVWokTysHz6rUFdkzSk0HsO6wqeu8MkpNJ5vZ8FqGWJdN8S6bIQVfuZ7MbPIdcVIrrA0DbGs9OWM+2g5jhzH58VWbxtiWfq2pU18YIi1H7/245fPPlra/VVDLCu7Dz/zHv68+Pa8+qNljJ7XudZyHK8ZYn0d5qGvQx8t5bKMq/M6b/O+wLzYl5W+ws98bmsWuW4ZyRUWy7XVvM5p+/64d32c13l7XucOSx+yjNF8Nu2raPcfGWLN615H2xDLR4zm5ybD0hj8DWYqxZLsReMz4Rk3zhf3zgz3zbsZ4ic6wmvIP0uyGssz3MfX7lOhfhZIP2U/8nQyhI/ylBX9yFhWFJpgyX0GvE+G9cvQR6yPn6U9Xvs/y/f/5hRMjpMVpT94TfQb/nbDfx/gpvCBQruXL5a71XJQaZbKnUqx0ClUg06p3Mvna/lCvVQrFnvtUq1TKxR7hWqhzc+OiqzI19MYl5L6gPDPOq8+mY+zOe1+tGZz0pZtISyXtkf10tiCpV1pcslvLnmMteUNN6lbtjPsn+G4FpLamfDPOq92n48bM9QP21lNkTWn0E5QOxzP3dF5sbVTnXt6x1Kszk8Y6PxZ+MzzxaJybSECKyy8RpoF65Yh1nuGWNcNsa4ZYl02xGoZYn1oiGXZx6uGWJZ9fN8Q6yMjrPAz33+aF/uy9EdL+7KMhZZyfWCIZWn3X3WbCD/zPe95sa+mEZZ1Hy3t/oYhlqXd3zbE2o8TX425w7KPHUMsq3wiLPOq+64h1r4PpZs7+LmPfR/6curecu1uuUbuDbBkD4nXNI3B92DGIvjPAm8j7CK/T3QG7GIQIfeL9nIXeN9uBuxOECE32rPdHlxpiF+310tP9uvWAFt+Kzq8l/IrK27MRl8a1MF7QWvQ72eAjvX/64ER5q8OMP36QWl4nxLfu5tx47z9/M59IcgQP+f0fVzhnyVZbeUZ7eM+TPKwfngf9xFF1pxC4zF8ROHziMInp9A4fs+C1TTEumqI9aEhVtsQ67oh1u05leuaIdZlQ6wrcypXyxDL0u4t5bLU/XuGWJbjaKn7G4ZYln3sGmGFn/n3bmeRq2ckV1gs9fWBIda8+rbl3CH5hLxvAPPH59w4DW3pKPE7AjTEl7z0caBb5oGC/00/+MPf13nCTeoY+yT8Jc98DOpnIv4KFtOEV5awrHUX1zeUn+3nCZAHdRCF9URKrFWF5mNMH4/pN/LfiJFV68cR0onGR1ujSP0nY+TC+uKXaPvSVnT4FNCsz1JFjfeTwFP47+S3iURvT1I9eXfLgpvU/TcjsBx9f5KuLQIeFtExrmP5N3Y2qQ9R45tT2ku9JGt7P3Gg0Ewal4T/bq3tH0uoV9Hd44qsOYXGa3vNPx9X+OQUGq/tZ8FqGmJdNcT60BCrbYh13RDr9pzKdc0Q67IhVtcIK/zM65JZ5OoZyRUWS319YIhl6Y8tQyxLu7eMhZbjeMMQy3IcLeOXpb4+MsS6YohlqS9LH7LMJyz19Z4h1n5c3bu4Oq85wAvOBisskgPI2g3z/QfdOA3XVA8R7SGgrZMs60q7sHje7yrM634X6iAT8VewmMb7XQ/56VvsfhfK/3Xa70JdW+13zaITXpuvK1hxe2dJx3bLTY6ntPXsY8O9syMuWk/Ifyd7Z6K3o1Tv9PZIDzx2j0dgOfp+lK5N2zvDMc1FyCl8+RrbCrZfj+Hz6Ix8Hk3I58vcn2lnpX5wQOcZdVbqEaBj/X8FZ6XuHhjvI7Y/7Fxk/x8g2gbQeE7HfUmpJz69BTQ7n84HoksZTyxCOwS814h2GGjYby6L9B37FMaIi5kRLtdjeVCHKBti4lhrel2m+r9wYCTLR5s6ZgYwUU7Z15f6ossVN+o31mEZpP4vgww3N3XMpYh+bUVg/ibY8N86oGM6p89R3K9D1C+WIUcySP2/Df26CAywjnzHWCDvGxBehxVeLuIa28bhCFpavqgfufZAAr4Zhca2xPrE9lE6Z1uS+r8RY0sbigyoDx73TZKB6xwiGaT+31dkCPUsMaR95wc/OtX8wd0fftp1VJbgM4d6bah5CDYUnKgiagi7J+7COPI9zkw0d3QR16KGfR2ud7qfdu91IxS0QGBrEcwWnF44lkq7sPidc5K/z0L4Z51utw0befIc50Ue1g/ft8spsmr5kQxu3DzPvoYyxN2TjYsdmwn7s+5Ghn333p3Po2wO53DN5tYj+GeU9o7aZpRrYQmd8ncHTrlKfI3tYPguoXVFRi33yBAN+8u2wr6ENLSVJaLhfLFMNJxbVoj2ANAOEO1BoB0kGq6rV4mG9/+z8JmLluvJmIX8bmdGuFxPStifPxgIHrb9qq1hGGvBTa5NwiK/qyO272ePqR2IPLKuXnbxe4bLVP+PYa7fonzjIUVfDyv6YhmwvranqcVT3tPReONYSR7jd/9zpN8nQH9a3x4HOtb/dzH61fbH4vQ7bY+U95NRp08Q1jT9nt6+/3fe9fsf9lC/6F9PEA1l53in6T5uPzgXIwPyeXRGPo8qfOKwcgoWrhP6ifAnP9v9/O0794avnRRIVKujz6t0jY+2cuq7GSEqrzU4jz9C39fp+zfo+yFFPq2IHFhYlkU3vYipi67+C5h6i0xdm9pwOpJwyVtw2Ba34MS8XoZ6bMYvKzzxWpwZSz2NDx8D/57SLkM0lOF7MTJge6knIe4VoNmFuNIwxL06wIvaznwF6Fj/f8SEOGmD/X9a6T/LgPWx3yKPpntpu6HwzkT8FT58jccFZfjuLvF5avB5S6GxrWt6fiWGD7Z/ZZf6k9slPlu7xGdjl/jwkehXDfm8CnVkvhF7ew1oHNdeIz58LS6uvUb9edmwP1qc3lDkm5UP6oYf/WkADec4keOkIofE+NfhuvUtb+Qn8rIOhH+WZDWWZ7g19jrJw/rh7Y5Tiqw5hfZd+Iw05HNK4aNhNUiGBrTbpfEr7HT8Gn7kiR2/hpvUa9rxe5H0espLP0avkDjtJovQvg+8G0R7A2joK1y0rSvpU5g3dTdHuFyP5UEbE9m23OR4Yz0el7ixyintpd6qm9SJ4XhUWK9O6f+bwPs4fOai6VzkDnX+pxsjXK7HPBtAe5NoOO5niIZ2+xbRTgPt7ODzlou2uQzRpI98jccR23+fZMB2s86JmsyaXaK+dmKXJxU+cbF5p/1pKDLHzeE75YP9OUV8ThnyQVs8TXxegnZ45OXywVEbbIdrRGwr28rLVL+3McK8NsCUWIL+bBhLatK3M26yCO0t4M2+cRZoDaKdAxrbxnmgoc65aPFJdBGq6Ccp4hPOQxxnGkrbVTdpe3uRrwj/3cpXTpI8UbFGi9/Slv0pLO9u3/+75aJjVJwMJxUZdhqH/OZMycdW+O/WWuJUQr1qeZ201eYyec3elou2iTgZ4tYZWuyX2Cm3An5uEC/D2PmzB8f7gLFXfq6E88SwvEG00wotxP/1tfH+SDzC42G4T83xXur/GsX4M9BPu7GvVDmOCw/kfdYT76R+IPy1eUXkziq0pRlk7bVrQTGoVDrdSqlVLvUyhC+y8jXejz2n1C8o9UXX5/3ouiBz4OL2CP8c6DUsS0A7S7RloImMoYn+aHNc/nOe5E+if+SfU+qfgT6kGUufWBgPLLA2d4h12I37E8YcvzGoVNdikBTN548RDW0uIBr6U5FoF4CGx4e4aHmm6CL0gb+RYu8Bc/WzEZgyF+AaXuaYZar7WzC3/SOa23DefGt7nIbzs/AJMX6f1ivCB89ryjwZlnci5PoXNH+hXRnaToftQ3gg73OeeCedvzDOsjwid1ahzTJ/tfK9YjdotUqFVqdcqVTi5iO8xvPXeaV+Vakvur7gR9ctbf46D3oNyxLQeG7D+Utk1OYvP/NvqZVE/8g/p9R/G/qQZiwltmt5k7ZO48d5cI8Lc93fJx/3kyfeH3vumyMZcdx4fkCb5PnhbaDx/PAO0NLOD6KLtPMDxknsE2IuwTUtxi9T/T+GOeKPaI7AOV14h/XeXh2vd06R26/PJL/nJvy1GOpjnazFRM3vNPtj/0YaH5G8oPC5oPDRsGQsPce1zoYil6P+o481iIY+huPGRfMxXId0d+hjItuWIgPWSxNvc0p7qSfjgf22G4/y8LHBi26yCO0S8D4On7loOhe5097/Qb1eIhra5rtEQ5u+TDS0qyuDz1su3q6QJn3kazyO2P4dkgHbZSL+Ch++xnw0mTW75HkhrV2eV/jExfmd9keTmcfcgg/25wLxuWDIB23xbeKD6w+8//MXtJ6Sdnj/R9tXWKb678D9n/9PeRf6wV7GEvaNd4HGdnYZaGwbV4CGOueixSfRRdr7P5i7Yp9Q9qR517CvgxzKc54UHKZ+aTrdz9/852+4p8KxJ23+JvY4b/nbSaLtRf6GvhqXv2G9ncyT2r7yfv62n79F8dnP33bGZx7yN7z3gPnba6ujNtgO8zdsG5W/1SB/e53yAj/7Zl/O/A33zdLkb7jW5vg0bY8rQ7yj8ryz2/f/8v7a5dUR5qXVaLnOAO9/v7+/xuVLtb/G90b399d0f4vLz7DeTuZBbL+fn41o+/mZzmc/P9sZn3neX/ulBPlZkv21b0F+9mPKz/b310Z19mJ/jfMuqf/rc7S/pj1n4Pf8SfL8TfhnSVZjefJx8VI7w6vNT3x+D2m8v6bliecVPhoW76/Ny9mFk0RD/8Rx4zJtLZUmf0M9i2za2W0ej7Rnt7Xz457PEXU5t3FK/zFPSJu/idxp8zfUK8d5tM2LREub9225eLtCmvSRr8U9F7Vb+cEp6g/KwPu+ae3yrMInLs7vtD+azFq+MysfbR97t/NRfIYM87c/ovxN2mH+hm05fxvuTUD+9ieUF3g6t5w6lrBvXAQa2xnmSGwbWt6XND7hueU0+RvGao5P2jOA2h6X9qys3zEKuklsGflnlf76yJHOkDysH/GtdTd6bf/H3XsXf9j69JP2ue6P7p78rHOx+fm9T5qfnux0Pu/evYu9QQ4bSm/ZWriOfA6U64hxdkov5K1UW25ylJPcnUOs04SlRTWOIlFYZwhLi1w882nexlkn1kd5LkyR583taHkuENbbMVjhZ3mbmDbTv01Y70zBepKwsP071O5iBB+sg9HwosJbw2e7vTRF5u+QzCgXrzzfnYL1GGFh+3cJ6/IUrG8SFra/TO2uRPDBOrjCvwK8M8o1TZ5vx8hzhbCuTsF6hLCw/VXCujYFi1+0iO2vUbvrEXywzjW4fh14Z5RrmjzfipFH2iaZ4VBWwxkl8VMown+3Zrg4vYaFdwFuKLLmFBrfNbih8Lmh8NGwzhpinTfEOmeIdcEQ6x1DrIuGWJcMsS4bYr1riHXFEEtionY3J0980t7Nwfa7dTcnT3xOQTtcbT6THbVBG8TVJq7K8aXFWP+/rY8wnxtgam8eEhk1PfPuWVo9a3xkrkEbNrxjMXy7FM7hUoSG81wFPnPRVqcid9rdM9Qrz8kYZ24QDePGTaKh794afN5yk/rlmKjlgXgtzo75Diy2m9VfNJk1u+S4nNYuLyp8fPs/74peNOSjrR/Yfiz4aGuLafHsLMUzaRcVz74FdKz/HyGeXRhgrrpJP9jLWMK+oeUlQrsJNLaNW0BDnXPR4pPoYpbdM45Pmk+suknb24s7h8I/6yZ9zseaQdsT0GKNFr+lreZPPNdqewiXFD4a1lWSIW7N52n8CjsdP99rPm384tZ8ScevTnq95KUf5QLP/Vh4Tsa+aScreP/KkW6wYJ/S3q1FGxPZtFyU5/W0b8HE9lLPc75ZYr06pf+4H3McPnOxzDdRrxwPcNyvEQ3tlucBnGdlbtPyTY5lafNNbL9b+Sa/ZVdbu+zULrU1VVxs3ml/4u6A+cpr5y3f/JUU+WZY+G6t1P83kG/+KuWbfubM9LGEfQP3kdnOME9l24jap+KixSfRRdp8E3N+6ZNn/eY1G2W5MMadUuRPqouFrREu12Oe6Lds59raWztRUoLPbOOa3bOvYfskJ0rmNf8/5Uee2PxR0+te5v/s33H5v6f1Uinp+An/3cr/tb2ikqLX3bDvqHE+FSOPn72OoBCXq2m5zSF3f25kG4q6lx11L1muRY1N3FkN9HXO0aat804TVtz+4qUpWHxWQ9MB+zDX07CjeGvrHPQzvC55DeqKT9RdorraiTDOpxYiZLgEdBxr7ktGqa/h8bkDLWdHTD5ncErBiltLiJ9hnrUXcVH4Z5V++4iL2vkJbY0W+v0B0jXbDI5f1Dmht5W+cjyYJhPHg7RnOhDrNGFpZzos16Da3vKsWNcNsLS18RWi4TrjKtFwncFrkBuKfOJvuB++F/4m/LMkqy9/u0nysH40f4ua77RTunF1bgJfuRb+uzVFJvY3HLNbhPXeFKzThIXtpe2CmxwL7Tzce1Po2r6Vg2vvEz/Eu0l1b1Jd7Uxa1Pf3U+CiDLeo7q0YGa5S3Xcj+GhjdhVw5TrqXvw5bYx4l2jamTg+v/C/BnsuYY75f7PRfM/F8L0Qw1fmH8TnJy7/H8iQWYuW4VSMDO/EyHDRTeLLmGr74kg/p/RFvmPfo/IqPr/1faU+5qqCp53/5X0JnOevEZ93FD5R53Lx+8GIfrB+LW2D+Yl9BAqPZaq7tTaSOwd7QVhHMMLi+UnMxPMgP4npez0+7Ux93Js0eHyRxmcw0z4xhlhnDbHkDObX9SlCHJfdfopwVpvA9vykFD9Tof0VPnwtyVtckjyfoj2xcyaGz1mFz4bSbtb+aDLzmFvwmYenCKPuS9XWRm2wXdL7UlL/d+G+1MsDTM9v+DF9ipDtzNdThPhmIKunCDWf8Pt0flBOOm/zr3R4elpxOG9rz9VpsSY0V3n25uPuvXPdH11rfvpJp3nvkzufvdv9Kz/s3r2H3UDoJaWbPPxLxE7q8dbgG9uT9bBot/15ukh72/+MIk9S9b25HS0Xu8kemGXxy26WWlohbbUwP+uL9hEr7qhJmfiktbmywsfzDxw1talciqbnMtFw2kL74KKFeenTLC8Q4Rdtxflt2hRLiyfz9kK+tKk/Tq07Tf2jXm6qTbtplwVbLt6ukCZ95GtxsXy3XmQWl/pzPEprl9pLP32n/vyDTm8Z8sH+7NUSIyr1/yVK/XHLKEnqL/V/A1L/H1Pq72ebJn0sYd/AZQHbGS4L2Da0ZUHS+CS6mOVIGscn/BFe+UFBob0O7d6kdqeBJvj4I7xaDvCKG6e9ArRXB5+XSa5/SvbwKrSxs4fi0B6kn8IDeZ/xxDuJz8bFM5Rby0dn+THDQrfVrjSbvWK7F7SbvW7auCz131Lqn1Dq+83vi03xF/wxQ/TRsCwBjV/lsgw0fMkb/5ihn5y02Eyif+SfU+pfhD7sZI61yCPlhxHxR1nFt7XYxL7oJw4kX/8J/yzJaizPcP33qpvU60uKXrV1gLTVcneMwUhDPnHrMsSS+UKL7w3i84rC55UYPg1FZr+2UKpqc4IULQY3iIYxAO2DizbXS5/Srv9Q55xnoww87i+RPFH2lVPaSz0ZD/Rpw/GoaXk89x91nnb9J3KnXf+hXjnfQ9vk/L0BNM65414EivpF3myri8o1HkdszzmelgsliY8aH01mzS5fpf6ktctXFT5x88lO+6PJzGNuwQf70yA+DUM+DajDx9ui1n9/Tus/PE6QZP0n9bdh/fefd2f9lzqWsG9gfsp2hns3bBu4D9KAz1x8rf84Pu3nWDvPsRqKrJo/vQGf2W8XlWtxviljueUmx+gk8dH682oMn5NKf1YVGfYyxzpJtFlyrMbgc9ocC3Uel2P5mMs8x8XU45E2x8IYttMci/dBGkDj+IY2zfkXxkW+V4L65Rwr7RoJ2+/WY9JxOVbDjfcnrV02FD6+c6wG8WkY8mlAnZPE56QhH7TFU8QH176YYz29PmqD7TDHwracY0n9TyDHenbwed7Wz+wbWmzX8q8G0TD/Qp1zmbbuTpNjaetuln1Zqfs9okndEoxXb/BZ8+WX3TjtZaC9RrTvKTJpezWIgTrRbC78XKM+SP2XB3KHunxgS8dccPF27Df/aAciz0mlj9raa5nqN6CPW5RD4B6z6H7wXna3tO2lP/lQjofpWLbYwRfyA1+Oo4tKfd7HP6nUb0AdzoPR/zgP/p6Chfmp7FPvpQ2gzzSAjvXPJ7QB0ete2ADqNYkNaOuEpDYgOtNs4HXCek3BQruYBxt4DXg2gI71byS0AVxXhWVp20t/VBtAvSaxAayf1gZEZ5oNnCYsbZ2KcwHfrxLsFafPR3wvWeq3YYwubo7Lh3Mq2+/LCjbOyxnCwH6sKf3YIBq2/eJVPyvj8ksO99OQE/w85XB+9txHr3OQnCYqB3jTjcss9e8ofpGhNqivuLij3VvEfvP5Alzf8Rm1eblHwTlv0n3FBtF8/ZAZ3hM5nGCPBG0zQzyFR5R/a7k0ni2RtRDvH/8C+MWvkV94Opc79AsZS23Pm/0G6/9yjF+cmaKvJGcrzig61PY2pK3nH2yqbyiyStFsn/fb0fbZL9D2eb8dbb9BNDzfpb1uRIrmF/hjTkn94tfIL7R9JPQV9otTirx4H4bP1f1d8IvfIb9AvfjwC+3HYFH+C25cZqn/mzF+cUHRl7bvxjJgfS0Wao/+Stt5e5yRzyEmfQSJ90XxESTeF9UeNU7qF6KnNH7xO+QX037ENM4vzgHuL5FfiO7+GfjFH5Jf+PnB4ZFfyFhG+QX6Ddb/5zF+EfezVGFhv9BeR4X9Zr/A+Mo/d+BHX6XehiKrFM32LxANbZ/9Iq3tCw1fw4M64aL5BT7un9Qv/pD8Qjvbn9QvzgNujfxC9PFvwS/+jPwC++7DL/B1GZpfXHHjMkv9P4nxC+1nuPiVE1hfey0T9pv9Qns9iV99lcsbiqxShIavg+BXgyV5jRH6ndDw9Sr8mPotoPFPpmHR/EL0lMYv/oz8Qns1TlK/eBdwf4VelyK0/wR+8ZPd8YuO9E3GMqlfSP0/T+kXcfOF9oqxpH4hbT37xVz9pIXQtNc3+fSLn3jyi7P0M0vaz8wIz2mv/eT9XE+v/2uzrUf5z2WgY/3/HeM/SV8lGudv2muW4n4Oci/jzSVFHo43YpzT9r8vQn/CsrTtpT9dbf8bx20Z+E4bo7CkjYmisySvDYv7GapTCib+nBqvbdY3RnW+Ofi8l2sb7dlYXtvkFNvJUBvnbNY2fF7ry7624XMkX5a1jdhmhngKDxyrsPBcpT23jD9qz/tK3wG/KJNf7NarsNEvtGe/l6n+szF+cXGKvtgvpr1uWeTZcpO2L23n7WcMOE9La9+8ltJ8DeM2/7Q2Fs0v8GcTkvpFmfxCi3/43Df7xVlF3i/2wiL84iXwi/Nz4Bd4byzKL15N6Reor7R+IfLs+8U4bbf94nwCv8B7S+wXbynyhrivRfjFJfCL9pdkvria0i9QX/vzxTjty+IXbU/zxV8cvP9ZbEzO7PwU+MXPkV/g+T4ffoFnTKRveG7nDTcus9T/NMYvpA3q63W4xn6hnVnBfvO5WjzrJG396sv23HWDaGgvJ4mG9wp5XYJrCtQJF80vRE9p/OLnyC9OEw8cq7CwX7ykyBviXh74hYxvDuo978ZpTwHtiBuX5wVFHqy/RvWPgQxafcFbpvq/CLZ/kd5RcRzaG/prS2R+EWRaVPp1nGSW+n8zxl+lDertKFxjf31RqY/9Fnm2SG/YdpW+2+orPzx7ekLR1wuKPMtU/+8k3HvLQX/CsrTtpT/q2VMct2XgO22MwsJjekKpj2MjOstRfRxfoT0PtONEQ599imTIKTIkPespbUNfvjcIeFtucrw5nqBtcjzR/ALrczx5EWTQ6kf55j+MiSeoZ8N40hOZA5BJiycnSGap/1sx8USzpS24xrYXKPWx3xxP0C6l7Sp99xVP8oq+jivyLFP930kYT16A/oRladtLf9R4guPG8SRujMLCY5pX6uPYcFzIA+1FomE8OUE09NljJIOWDySNJ9I29OUOxROs9xzxfF7hiXPp6e37f1cVmX3ce8KYs+gm9XkM6Fj/X8b49zGlj4/CNbaFaXGUYzLGa2nrWV+tOH0dTaCvf53Qv9egP2FZ2vbSn7bm32ib7N/amGL9tGMqOsu5yRjJuQT60PPEZ03hg/7EPoxjJW1DH64OfDjUy9nMeJsFwBuQhva2CNcNxyfxT6zItSzJaizP8H0di25S36gffl/HkiJrjmhheWN7VI9pi8q1hV3G2nKT4802r+lmMYYPj1VYNpR2bHOs08bgezBbSfzzAMI/67z6QD5u/DS9iu6WFVlzRAsL28mywmdZ4fNlwZL2YWF/DMuF7XEajjHrNKmtynsUwtiKsXTLRY+N8B48gjd2fVmRd5nq/0/aEz1AsjYG34MZy2HAdcRrVemfIe/hWbsVN1k2lH7zuB8EGo/tKsmMtCzQ+Dc0sCzSd9RFyPsY5BpcT4pmIxmirSj9EBqPe1hybtK2l4mGtr1CNIxtB4iGviTvcc4QpnMjn8Wx45+/1Hwv9CHUvwO+jcH3IG0pdNqVbqFaC6qVfKHeYZt2nvmXm0GhW8q3WuV8t1mv93abf7dW7wT1XreZz+cLnaA7jb8Ww9AGxT40G+T4Jj6I1w8AX45vUv8I7fmwvzZ2qAsuWnxbpT4cgD5ods3vwpH6pUEfwrqPb47rbIV4IA31yf5+kPSANJRb9C36W/Ojv+E9s8Ex1rE1Isq65sZ1JPWfHuhl2hpxBfoTlqVtL/0paWtE8ccv5Ae+2C/nRv3G+pwvryv1cWxEZzmqr80RWo50EK7x+wxEhytOHyPB41zjBIwRv88A/SZLsmPfeR5ZVPjyHIM2/cXZDIoJHJMag+/BbKXKuQUWLbfgvAP9kPOOLMmMNLSDtHmH6CJt3mERh5bcOL958VvhGRb2W/TRRaU+++00P5c1QM5NjiXbtzbXpPGZsFwkfmgvMjboMz7yinar0iqFv9uQL1WKpWDX86pSuVltN6v5fL2U7+dX5V3Pq1qlerVVb5eDfnqVrxd3m3+1Wetzr5eapUrQ7ue2u82/UKtV6oVWUKp22r1Oadf73+pU2kG9mO80m9V+92u73v9Op5sv5av1WrdU6tR33f7KnVZ/SVNo1vvLm06x3E6T12fceNwIy6Ibj09h4TXbIsk+DWshBisTg7U8Bes0YWn7J0n2sj3tXSTeyxb+u7WXPU2vnK+sKLLmnJ5/yWekIZ8VhY+GlTHEWqL+IDb6hlw/sD3O64u/cE3yCMl1DmJ9oq0CbWl7xDcs2cF3WVMylsixTPV/EdaRYVmBNtI+p/BfIf5jcivX0A4Za1G5JvVD3f81yDkw5vA+LseaVeVaY/C3v2/T6nX6ob5calWDSqFTaZVLpW61W6y06kG1WCmWg16l12oG+UKh1i7l29VCUK+X+/se5WqQ7/KaAbGLQalQ6VZKzW63GHTr9Vo7X2zX2t1uu9MsNqvhvlGn1W12yoVWu9ArtnpBt9mtlfOtvij5oJ3nPVjEDurVYisotMvtZrNdLNa73VIfqNPs7wUVC/V6IehVW718q9IMqt1+71rdcqdXqQaloFUMgnqlINgHNexmrd/LbqWffvT/65U7tX5KVKp3SrVev0ulTtBPzIJWf3bqVPPVZr1VLhaavUqxL3G5GFTred5bGdN3vpgv96Wq1HqVoBgUioVS0K73871wBKqlSqWvkmKr1k++2uVCX9mlWiFfaObLrXZQLHWbFcHOanJ3O618t1Avtovtbj3f6rWDUrf/sdnsZ1J9VZXyvWa4YxWOYT/HCordXivf7jUL7VaxWK72eE8DsQu1QrldrbfblWa53Wp1u71qp9KsfaHifKFV7AvZLBZrpVLQ7Pb64MV6X0m1dq2eL1X7YtQFe13TSbGU71Sq5V6zr5Fuu1vsK6k/mMV2s1jq22axla+3Kt16tVIISpVq/1qpD10otUt9CTrdYlmwN1SdBJ1mp1AoB+Vasdef03tBs91PrbqdbqeX71twq1ZuBcW+zprdarnY61t+vtSq1Zq9Wr7dKg/tZFPDLvV9otjvYKtSC2p9HbdrhW6tWS436+VCp9TpFYJCudLrBuV6sVMv1fuX+/7TDIK+DH3jHL4LAs8r8TyK51OtzxghP+f0eVT4Z0lWX/Oodi5PO88lujukyJpTaJvwGWnI55DCR8M6aIQVFtmntZBrw0gujLnz1seskVwYi+atjytGcuEcNG99XDOSS9pbYGEf/d7/zQcSvzDeSdFiG+eNjvqIBeUOY9UPEuxbann8IaKhXcqamPOovdYTz2FYND2J3Gn1hOPBekKbYT35ud+WXk+4VuCi6UnkTqsnHA/WE9oM64n38xuD78FMJb2e0t4vELnT6gnHg/WENsN68nP/MZ2ewvLu9kgOLpqeRO60esLxYD2hzRwm2pqCy2sSWx3eP+fL/dBybOGfdT7HdJRjx90rDQvn2BuKrDmFxvPwhsJnQ+GjYa0YYi0YYh0wxFo0xDpoiLVsiLVqiLVkiCWxgvMe5ybjg6e948R72cI/6yb9zEd8WFD0qq3BPZ9bHz43pt3/WIuRx9O9h+Fvt2v75hlFnkODupoNOTdp0yj3CuA74LE4hTffC4o7a6vZWNTeMsuB8i/G8HJO73cUf+axqOCd3x6nLSWQTdO5U65psi1OkW1JkY1xF2L6EcUHZYo7Q50hmia7l/vk/T3lZrFcD9rdcrVZqe76OYVen2uvGoSbrd1CpzmNv3ZvB8/UhEXuD+H9I6wveMtU/xsD8C/OJFI+u6zwC+u9EFMvE/H3Cwzl2tL2+DXtvhLeb5P6wju7PSmj0NaAtkx81gffUV+IJXIsU/3nBn2XMcF7ZNI+p/A/SPzH5Fau8b7JmlJ/Takfjs+3BsKJ3WLfrefdL3gSPl5j2cR2OF7zejIs+HuUJ+h3/GSewfOl2JbP4Er9N8DeCzCWPI9J33Z65n7aubjwO95n49zNzz5C8uebhH+WZPVhQ8hP5EGdOzeZK3laa5ZEHm2tqZ0HDHOlTTc5ZiifYOF8++b2/b+affHaI+15B2zPz3LgGMc9A8LnENFGop4BQXtfc/HPCmQIS/NjbhulC/R7ySP57P058PvPyO+1Z4Y0/2W/154ZEpr2zJDnfZuh7Q7nZafrFM/mY/3LA71oz7Nr/oBnEJLsVWhn17X3BQzPy9B3Y30Nn1XYnKKvDdKX1L8Voy+t/wdi9LWp1N+I0RfqEtsy76hYtFu2OE23bItSv6XoVjtPfhD6E5albS/9KWvnyXEtjzlWlL9oa/+48df8JUf1cby1GM+xGvmuEQ1jM8d/jPES2zCWavcD8PmSEzCekvP5fpZbyymlaPcGUW9ctH0BkTvs08IO78GtEE2bZ5mftP/+9ojGa/Bl+r6g4PB38UEtR1imun990F/Pz96oz+OxzjJKPzVd457CXwL9I0boOnkCAA==",
      "debug_symbols": "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",
      "brillig_names": [
        "is_registered_l2"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "11430482739715627628": {
            "error_kind": "string",
            "string": "Function _log_claim can only be called internally"
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14788743618517749904": {
            "error_kind": "string",
            "string": "Function _register_public can only be called internally"
          },
          "16541607464495309456": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 16
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7069518359247663558": {
            "error_kind": "string",
            "string": "Function _claim_public can only be called internally"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8459146718181593566": {
            "error_kind": "string",
            "string": "L1 portal address cannot be zero"
          },
          "8606784891595333955": {
            "error_kind": "string",
            "string": "Token contract class cannot be zero"
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "get_l1_portal",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_l1_portal"
      ]
    },
    {
      "name": "withdraw_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          }
        },
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "withdrawNonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "burnNonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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BigHAgctDQgGACgGAgYtDgYIJAIABAAACscjAAAKqwAoCAIJLQ0JBicCCgQCADgJCgQ8DQQGIwAACsctDQgGACgGAgYtDgYICygAB4BcAAYkAgAGAAAK7ScCCAQAPAkBCC0IAQYAAAECAS0IAQcnAggEZQAQAQgBJwMHBAEAKAcCCC0MCAkuCoBFAAkAKAkCCS4KgEYACQAoCQIJLgqARwAJACgJAgkuCoBIAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkA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",
      "debug_symbols": "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",
      "brillig_names": [
        "withdraw_public"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "H4sIAAAAAAAA/7WTyw7CIBBFqcUo0sTEx39MU0y7dOHafyCtLHVRN+766dZkJkyI0QVwEzJMgMNcHoXwKjBKESGCHDEqjAs2Xs7tjDnEqVbBvin5HRijvvhLWH+jkFnk4QPxM50/rJBzmTyfe6F913PTrF8J/z5y+af7y+l//8OzRq9bzCvh/8P4uvfXx/M2ij/SbJGc0ptoOwAqvkT+EvmhJBvn8w+Yb4Svj6KMqNO1tnaNdfZkh8H0dhfwP+KH/QbzqHp4zgQAAA==",
      "debug_symbols": "ZY5bCoMwEEX3Mt/5MLEKdStSJOoogZBIHoUSsvdORGioP5e5w+FyEqw4x31SZrMehjGBtosMyhpqKTOYndJa7VP9hqYEb0/eH9KU6oN0AQbePoVggGY9776jjU1ppCb6zG484Rf94PzH9k1+Zapv6ZScNV42WzRLJRc+B/55Hs4uuEaHxbiSpRx5x0RDszT9BQ==",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "is_registered_l1",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "is_registered_l1"
      ]
    },
    {
      "name": "get_l2_token",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_l2_token"
      ]
    },
    {
      "name": "register_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17288131482828810359": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18159344801564042747": {
            "error_kind": "string",
            "string": "Token already registered"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "8998099065237381256": {
            "error_kind": "string",
            "string": "Expected address did not match supplized token address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "aztec_token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "name",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          },
          {
            "name": "name_len",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "symbol",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          },
          {
            "name": "symbol_len",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "decimals",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7P3dkiS50hwIvsu55oUDMPzxVVZWVrg7nBWKjJAjQ84VZd59vLo6IrNOwh1Z06gINah+V/21xMk2M3UH1NVdFf/zX//Lf/7//p/////Pf/mv/+t/++//+o//r//5r//tv/3//tP/+C//7b+e/9///Fc7/vp3//1//0//9cf/+9//x3/6P/7Hv/5jtFL/w7/+83/9X85/zCn+X//hX//rf/nf/vO//mOI+f/6D19/HY/y+HWM7fnrXkc/bu35p3s57n8ccg+PX5//nD5+Hmsb/b7k9vh5qfXj131Ud0glPX5t4fjl1//v//CvFjSaq9FEjeZqNEmjuRqNaTRXo8kazdVoikZzNZqq0VyNpmk0V6PpGs3FaLrY8OVoxIYvRyM2fDkaseHL0ZhGczUaseHL0YgNX45GbPhyNGLDl6MRG74aTThEh69nIz58PRsR4uvZiBFfz8Y0m8vZiBNfz0ak+Ho2YsXXsxEtvp6NePHlbIJ48fVsxIuvZyNefD0b8eLr2Zhmczkb8eLr2YgXX89GvPh6NuLF17MRL76cTRQvvp6NePH1bMSLr2cjXnw9G9NsLmcjXnw9G/Hi69mIF1/PRrz4ejbixZezSeLF17MRL76ejXjx9WzEi69nY5rN5WzEi69nI158PRvx4uvZiBdfz0a8+HI2Jl58PRvx4uvZiBdfz0a8+Ho2ptlczka8+Ho24sXXsxEvvp6NePH1bMSLL2eTxYuvZyNefD0b8eLr2YgXX8/GNJvL2YgXX89GvPh6NuLF17MRL76ejXjx5WyKePH1bMSLr2cjXnw9G/Hi69mYZnM5G/Hi69mIF1/PBp0XZ/uYTWmT2cQQn5Wcr1D+6WzQefE7Z4POi984m4rOi985mwtefISP2aTJbOxUgf7+tYUenr8+F8O//hPxz/8nhiztHFR6TjbW0if/kZDio6SQcvn06zj69ZHSc584UrbPRQ1gS4c9G05HPb70YBv0MGQ9IZ1b/rOoFH691/76340ZQT8exaWjfFzpuQ9qa8djTC31T7fQ34UNt9V09Pj4D/w1zrv/QAj2vJPC57u0hMGvc338OPdPmLWf1Qw3svTxHzgHlibVHB/3dQifbp8yvCryc8k4Pqafwui3tdvjVqu9p8lqlJ5/2eKn1cVGV08N/VFF/XTHD398Iva8ZGrPkx8fz798zqV9/vFf4+4a9wvHPT4zS+P+U+MOGvcrxx3/+bhDez4xxk8MbjzunJ/Fl3bUT3vnkB2m0J47dPr0t2v8WX7yXb5Ny6/9vnw7qcTzKvtMPOuQIdX4pF+1fCr/3NX/KiijFVTQCqpoBTW0gjpYQf1AKyigFRTRCkovLiiej+SPldp6/FrQq1fqGMuTEeTw64TuKc/R8uTX+9GYngUPMjyv3sVPDe4DnlomA+/hA538UXw4hspMfK4ULeY4QWdDLKuw3AbLJiy3wbILy02wjMcBjeUpdhyP6u0z+Tn6z/KD7/Ijdvk9PW+lnvvkVjrviMedFD7fSOO3ws+b9HwrXH/59V+DSRrMeDCmwYwHk2kHk+JzMDYYDPYT0RsHg/148cbBYHP1PzmY/DGYGr4OBpv4vm8wAZxFvm8w4Pz0T27XnwYTvw6Gl/nWj+8he/k6GF7mOxmMaTDjwfAy309rTP/KY8JOzLeVp5JwfPq+YzyZP6dTxeeHnzEdM+kpPfH58fXqP9Kpwk5knR3LnZ4vQLB8l34cdnokIscy7vQUtwzLvyaD/hgXns32TyafC4plD3NI/XwNtOFnpe1Z9fmDT3/577mgP8W9ay7oD3HvmotpLsO5oD/CvWsu6E9w75oL+tPQu+aC/mTxrrmgs/Q3zSWhM953zUV8dzwX8d3xXMR3x3MxzWU4F/Hd8VzEd8dzEd8dz0V8dzwX8d3hXEx8dzwX8d3xXMR3x3MR3x3PxTSX4VzEd8dzEd8dz0V8dzwX8d3xXMR3h3PJ4rvjuYjvjucivjuei/jueC6muQznIr47nov47ngu4rvjuYjvjucivjucSxHfHc9FfHc8F/Hd8Vx24rsfrbZ2/DKXv1o1nlZ3YqW9fJw/cYTJ5Z5TfBSSU54dlLKfs6XsxLuF/O8gv9OThZD/HeR3enYS8r+D/E5Ph0L+N5CvOz3/CvnfQX6nJ3wh/zvI76RhCPnfQX4nlUbI/w7yJuRJkZeGx4q8NDxW5KXhsSIvDY8VeWl4pMg3aXisyEvDY0VeGh4r8tLwWJE3IU+KvDQ8VuSl4bEiLw2PFXlpeKzIS8MjRb5Lw2NFXhoeK/LS8FiRl4bHirwJeVLkpeGxIi8NjxV5aXisyEvDY0VeGh4n8umQhseKvDQ8VuSl4bEiLw2PFXkT8qTIS8NjRV4aHivy0vBYkZeGx4q8NDxS5IM0PFbkpeGxIi8NjxV5aXisyJuQJ0VeGh4r8tLwWJGXhseKvDQ8VuSl4ZEiH6XhsSIvDY8VeWl4rMhLw2NF3oQ8KfLS8FiRl4bHirw0PFbkpeGxIi8NjxT5JA2PFXlpeKzIS8NjRV4aHivyJuRJkZeGx4q8NDxW5KXhsSIvDY8VeWl4pMibNDxW5KXhsSIvDY8VeWl4rMibkCdFXhoeK/LS8FiRl4bHirw0PFbkpeGRIp+l4bEiLw2PFXlpeKzIS8NjRd6EPCny0vBYkZeGx4q8NDxW5KXhsSIvDY8U+SINjxV5aXisyEvDY0VeGh4r8ibkSZGXhseKvDQ8VuSl4bEiLw2PFXlpeKTIV2l4rMhLw2NFXhoeK/LS8FiRNyFPirw0PFbkpeGxIi8NjxV5aXisyEvDI0W+ScNjRV4aHivy0vBYkZeGx4q8CXlS5KXhsSIvDY8VeWl4rMhLw2NFXhoeKfJdGh4r8tLwWJGXhseKvDQ8VuRNyJMiLw2PFXlpeKzIS8NjRV4aHivy0vA4kbdDGh4r8tLwWJGXhseKvDQ8VuRNyJMiLw2PFXlpeKzIS8NjRV4aHivy0vBIkQ/S8FiRl4bHirw0PFbkpeGxIm9CnhR5aXisyEvDY0VeGh4r8tLwWJGXhkeKfJSGx4q8NDxW5KXhsSIvDY8VeRPypMhLw2NFXhoeK/LS8FiRl4bHirw0PFLkkzQ8VuSl4bEiLw2PFXlpeKzIm5AnRV4aHivy0vBYkZeGx4q8NDxW5KXhkSJv0vBYkZeGx4q8NDxW5KXhsSJvQp4UeWl4rMhLw2NFXhoeK/LS8FiRl4ZHinyWhseKvDQ8VuSl4bEiLw2PFXkT8qTIS8NjRV4aHivy0vBYkZeGx4q8NDxS5Is0PFbkpeGxIi8NjxV5cA2vPWf4Bfm/yjfo8mPu4fHrko/JhRtitEezMX38OuUwusxTe/y621E//vb4UuztMZFyfCq7jn4c02PoKVr8/OO/Zo4tAe05c2zxZc+ZY8see84cW3BwOvP0ZEQptfZl5tiP+lvOvGI/ZDud+fnnHj+2GO9/HFt6PFPEZrMfB3v+OOT6BU3sB2eh+W8/jsdzejFNfpzrA8Tc++f2/gIe+7lZwP8x4LEfmwX8HwPeBLwr4HN+Al/bPwFeqgcp8JJeXAH/8eAVU09fqLpEnZ3QlFy0E5oSolyhac8yzkHW+x+H3OJjHOU4/h36Jj2MFnqJZ/tCX+Pjx6Hm8A9YeJPSpqtkfpVIltNVMr9KTFfJvldJfX4qWH99xPjdq0SCn66S+VUidfDtV0kpz6tkpvROXuQ3qYOu0Fz2Wq9JSCQFXpqjL+BXvdbrUhxJgZfe6Ar4+3dGXbrgTmhKv9sJTROantBc+FKvSzyjhV6K2L7QL3sH06W06SqZXyWS5XSVzK8SaXgbXyWL3tTlQ4KfrpL5VSJ18N1XSbdHGbHXf/Qskg+pgzuhKXXQFZqrCF4+TMBzAi8ZkRR4iYi+gF/Gv6ULkgIvqe9PAN+e4zufp2eP58sSsfIhSc4Vmqu+p8xBKhsp8BLOSIGXxuYL+EUf0uYgOY4UeBPwnoC//UozB2lsO6Ep4WwnNKWGuUJz3We0OUgPo4Ve4tm+0C97RRaltOkqmV8lkuV0lcyvEml4G18lq17RRgl+ukrmV4npKnn3VbIsEStHqYOu0Fz2Wi9KSCQFXpqjL+BXvdaLUhxJgZfe6Ar4+3dGSbrgTmhKv9sJTelsrtBc+FIvSTyjhd4E/bbQL3sHk6S06SqZXyWS5XSVzK8SaXgbXyWr3tQlCX66SuZXidTBd18lCzOUTOrgTmhKHXSF5jKCZxISSYGXjEgKvAl4V8Cv4t8mXZAUeHCpr7Tnq85fljZs4M83tI8fx1+/oP5r5uDC2ZYzB5ehtpw5uKiz48wzuPTic+YfH9yk1NqXmYMLJFvOHFyb8Dnz3ztoY12SZwYXHITmrz9e5gPJJuA5gQcXHAT8nwJegoMv4FcZgLJUD1LgJb24Av7eXZIl6myEZpFctBOaEqJcobnQ/lOkh9FCL/FsX+iXfdpTTFeJrpLpVSJZTlfJ/CqRhrfxVbLq07IiwU9XyfwqkTr49qtkXZJnkTroCs1lr/WqhERS4KU5+gJ+1Wu9KsWRFHjpja6Av39nVE1oboSm9Lud0JTO5grNhS/1qsQzWuiliO0L/bJ3MFVKm66S6VXSJMvpKplfJdLwNr5KVr2paxL8dJXMrxKpg+++ShZmPzYTmhuhKXXQFZrrCJ6ERFLgJSOSAi8R0Rfwy/i3dEFO4Lukvj8B/G8dtLEuEatLknOF5rLvKbtUNlLgJZyRAm8C3hXwqz6k7ZLjSIGXHOcK+PuvNLs0tp3QlHC2E5pSw1yhue4z2vPfCHpW6CWe7Qv9qldk5ZDSpqtkfpVIltNVMr9KTFfJvlfJole05ZDgp6tkfpVIHXz7VbIsEascUgddobnqtV45JCSSAi/N0Rfwi17rlSDFkRR46Y2ugL99Z1SCdMGd0JR+txOaJjQ9obnwpV6QeEYLvRSxfaFf9g4mSGnTVTK/SiTL6SqZXyXS8Da+Sla9qYsS/HSVzK8SqYPvvkrWZSiVKHVwJzSlDrpCcxnBiybgOYGXjEgKvEREX8Av49/SBUmBB5f6Wn3+uh/tF+D/Kh9cg2q5fZTfv5SfsMWRdITHr9NR49fysZ/ap+W//DH13GAf5ZeUfyn/r4ISWkGGVlBGK+jljKmU56f0pYWvBVW0ghpaQS/fM3q25zoU6peCbL4L9PC5oL/+R+O1N6X8pBwhTbqoj7Jy/mBJeUg4Ss9PwhHr/Y9LP8LfPy49TBhVi0/e086b7d/5iUWONhNHm8bRZuZos3C0WTnabBxtdoo288HRJgcLyhwsKHOwoGwcbXKwoMzBgjIHC8ocLChzsKDCwYIKBwsqHCyocLCgYhxtcrCgwsGCCgcLKhwsqHCwoMrBgioHC6ocLKhysKBqHG3isqAa7fGNVo3FvlSOS2xmleNylVnluPSjxv74pqym8LVyXEYxqbzhkoRZ5bj7/qxy3K18Vjnu7jxZWxruhjur3O0e2pD30PvrHHkPva/c7R7a3O6h3e0e2t3uod3tHtrd7qHd7R7a3e6h3e1zaHf7HNrd7qHd6x5aD697aD287qH18LqH1gN5D72vHHkPva8ceQ+9r9zrc2g9vO6h9UDeQ+8rR95DbysPyHvofeXIe+h95W730OB2Dw1u99Dgdg8NbvfQ4FXLrcHrc2gNbp9Do9vn0Oh2D43Ie+h95V613Bq9ark1etVya3S7h0a3e2h0u4dGt3tocruHJrdabnL7HJrcPocmt8+hye0emry+D63JrZab3Gq5ya2Wa273UOCEulnlbvdQ4By5WeVu91DgtLdZ5W6fQ4Ez2WaVu30OBU5Om+yhwGFos8rdarnAkWWzyt1qucDBYpO1BTgrbFa52z0UONFrVrnbPRQ4d2tSOXCU1qxyt8+hwIFXs8rd7qHAsVSzyt1qucDhUbPK3Wq5wBFPs7XF7R4KHMQ0q9ztHgoclzSr3K2WCxxqNKvc7XModE7RfeVu91DonKL7yt1qudA5RfeVu9Vy3eYUVeicovvK3e6h0DlF95W73UPd5hRVtzlF1W1OUXWbU1Shc4pu91DonKL7yt1quW5ziqrbnKIKnVN0v7a43UPd5hRVtzlFzW1OUXObU9Tc5hQ1tzlF7UDeQ+8r97qHNuicovvKvWq5zW1OUXObU9Sgc4pu1xbonKL7yt3uoW5ziprbnKLmNqeouc0pam5ziprbnKIGnVN0u4dC5xTdV+5Vy21uc4qa25yiBp1TdLu2QOcU3Vfudg91m1PU3OYUNbc5Rc1tTlFzm1PU3OYUNeicots9FDqn6L5yt1qu25yi5janqEHnFN2vLW73ULc5Rc1tTlFzm1PU3OYUNbc5Rc1tTlFzm1PUoHOKbvdQ6Jyi+8rdarluc4qa25yiBp1TdLu2QOcU3Vfudg91m1PU3OYUNbc5Rc1tTlFzm1PU3OYUNeicots9FDqn6L5yt1qu25yi5janqEHnFN2vLW73ULc5Rc1tTlFzm1PU3OYUNbc5Rc1tTlFzm1PUoHOKbvdQ6Jyi+8rdarluc4qa25yiBp1TdLu2QOcU3Vfudg91m1PU3OYUNbc5Rc1tTlFzm1PU3OYUNeicots9FDqn6L5yt1qu25yi5janqEHnFN2uLdA5RfeVu91D3eYUNbc5Rc1tTlF3m1PU3eYUdbc5RR06p+huD+0H8h56X7lXLbe7zSnqbnOKOnRO0f3a4nYPdZtT1N3mFHW3OUXdbU5Rd5tT1N3mFHW3OUUdOqfodg+Fzim6r9yrltvd5hR1tzlFHTqn6HZtgc4puq/c7R7qNqeou80p6m5zirrbnKLuNqeou80p6tA5Rbd7KHRO0X3lbrVctzlF3W1OUYfOKbpfW9zuoW5zirrbnKLuNqeou80p6m5zirrbnKLuNqeoQ+cU3e6h0DlF95W71XLd5hR1tzlFHTqn6HZtgc4puq/c7R7qNqeou80p6m5zirrbnKLuNqeou80p6tA5Rbd7KHRO0X3lbrVctzlF3W1OUYfOKbpdW6Bziu4rd7uHus0p6m5zirrbnKLuNqeou80p6m5zijp0TtHtHgqdU3RfuVst121OUXebU9Shc4ru1xa3e6jbnKLuNqeou80p6m5zirrbnKLuNqeou80p6tA5Rbd7KHRO0X3lbrVctzlF3W1OUYfOKbpdW6Bziu4rd7uHus0p6m5zirrbnKLuNqeou80pCofboKKzdK+76Fm611eiZ+le9dyzdOSNdFK6V0X3LN3rVnqW7nUvPUv3upmepfvdTd1GFp2le9V1z9K9PpSepXt9Kj1LR95NJ6X73U2hg4smpXtVd8/Svcq7Z+le9d1wQIcX3a8w0OlFk9L97qZu84vO0v3upm4TjM7S/T6bus0wOkv3+2wKnWJ0v5tCxxhNSver9LoNMjpL96v0QkcZ3a8w0FlGk9L97qZu04zO0v3upm7zjMLhNtDoLN3vs6nbSKOzdL+7KXSo0aR0v0qv21ijs3S/Si90sNFkhfG7m7qNNjpL97ubug03Okv3q/S6jTc6S/f7bOo24Ogs3e9uCh1xNCndr9LrNuToLN2v0gsdc3S/wkDnHE1K97ubuk06Okv3u5u6zTo6S/f7bOo27SgcbuOOztL97qbQgUeT0v0qvW4jj87S/Sq90KFHkxXG77MpdOzRpHS/z6bQwUeT0v3upm6jj87S/e6m0OFHk9L97qbQ8UeT0v3uptABSJMVxu+zKXQE0qR0v+9NkUOQLD5+fP5j/Vr6a3fTWsqz9D4pvfQj/P3j0sMvpX/9cYv2qKLFEr/2aSR9ZpI+C0mflaTPRtJnp+gzvDhG6n19BpI+I0mfHHwoHEbSJwcfCgcHHwoHBx8KBwcfCgcJHwokfCiQ8KFAwocCCR96cXjZ+/ok4UOBhA8FEj4USPhQIOFDkYQPRRI+FEn4UCThQy+On3tfnyR8KJLwoYjLhyZfzISIS3GmpeOyllnpCZeITD47CQmXW0xLx6UL09JxGcC0dPNbOu4+PV1hcLfeael+d9OEvJtOrnXk3fS+dPO7m5rf3dT87qbmdzd9cQre0tL97qbmdzc1v7up+X02Nb/Pptnvbpr97qbZ726a/e6mL07BW1o68m46KR15N52UjrybTkr3+2ya/e6mBXk3nZSOvJtOSkfeTSelI++mk9L97qbF725a/O6mxe9uWvzupsWv0lv9PptWv8+m1e+zafW7m744BW9p6X6V3upX6a1+ld7qdzetfnfT5nc3bX530+Z3N21+ld4Xp+AtLd3vs2nz+2za/O6mze970+ZX6e1+ld7uV+ntfndT4BS8ael+d1PgrLpp6X53U+BEuWnpfp9NgXPfJqVH4Ci3aelud9MIHLg2Ld2t0hsP5N10UrpbpTcCh5dNVxi3u2kEjhiblu53NwUOApuW7lbpjcBxXdPS3T6bRuBQrWnpfndT4Oiraeluld4IHFA1Ld2t0huBY6RmKwxwMtS0dL+7KXB+07R0v7spcMrStHS/z6bQWUiT0v0+m/rNQorQWUiT0v0qvdBZSJPS/Sq9frOQInQW0qR0v7spdBbSpHS/u6nfLKToNwsp+s1Cin6zkCJ0FtL9bgqdhTQp3a/S6zcLKfrNQorQWUiTFcbvbuo3Cyn6zUKKfrOQot8spOg3Cyn6zUKKfrOQInQW0v1uCp2FNCndr9LrNwsp+s1CitBZSPcrDHQW0qR0v7up3yyk6DcLKfrNQop+s5Ci3yyk6DcLKUJnId3vptBZSJPS/Sq9frOQot8spAidhTRZYfzupn6zkKLfLKToNwsp+s1Cin6zkKLfLKToNwspQmch3e+m0FlIk9L9Kr1+s5Ci3yykCJ2FdL/CQGchTUr3u5v6zUKKfrOQot8spOg3Cyn6zUKKfrOQInQW0u1umqCzkCalu1V6k98spOQ3CykdbnfTBJ2FNCnd7W6a/GYhJb9ZSMlvFlLym4WU/GYhJb9ZSAk6C+l+N4XOQpqU7lbpTX6zkJLfLKQEnYU0WWH87qZ+s5CS3yyk5DcLKfnNQkp+s5CS3yyk5DcLKUFnId3vptBZSJPS/Sq9frOQkt8spASdhXS/wkBnIU1K97ub+s1CSn6zkJLfLKTkNwsp+c1CSn6zkBJ0FtL9bgqdhTQp3a/S6zcLKfnNQkrQWUiTFcbvbuo3Cyn5zUJKfrOQkt8spOQ3Cyn5zUJKfrOQEnQW0v1uCp2FNCndr9LrNwsp+c1CStBZSPcrDHQW0qR0v7up3yyk5DcLKfnNQkp+s5CS3yyk5DcLKUFnId3vptBZSJPS/Sq9frOQkt8spASdhXS/wkBnIU1K97ub+s1CSn6zkJLfLKTkNwsp+c1CSn6zkBJ0FtL9bgqdhTQp3a/S6zcLKfnNQkrQWUiTFcbvbuo3Cyn5zUJKfrOQkt8spOQ3Cyn5zUJKfrOQEnQW0v1uCp2FNCndrdJrfrOQzG8WkkFnId2uMAadhTQp3e1uan6zkMxvFpL5zUIyv1lI5jcLyfxmIRl0FtL9bgqdhTQp3a3Sa36zkMxvFpJBZyFNVhi/u6nfLCTzm4VkfrOQzG8WkvnNQjK/WUjmNwvJoLOQ7ndT6CykSelulV7zm4VkfrOQDDoL6X6Fgc5CmpTudzf1m4VkfrOQzG8WkvnNQjK/WUjmNwvJoLOQ7ndT6CykSel+lV6/WUjmNwvJoLOQ7lcY6CykSel+d1O/WUjmNwvJ/GYhmd8sJPObhWR+s5AMOgvpfjeFzkKalO5X6fWbhWR+s5AMOgtpssL43U39ZiGZ3ywk85uFZH6zkMxvFpL5zUIyv1lIBp2FdL+bQmchTUr3q/T6zUIyv1lIBp2FdL/CQGchTUr3u5v6zUIyv1lI5jcLyfxmIZnfLCTzm4Vk0FlI97spdBbSpHS/Sq/fLCTzm4Vk0FlIkxXG727qNwvJ/GYhmd8sJPObhWR+s5DMbxaS+c1CMugspPvdFDoLaVK6X6XXbxaS+c1CytBZSLcrTIbOQpqU7nY3zX6zkPLhdjfNfrOQst8spOw3Cyn7zULK0FlI97spdBbSpHS3Sm/2m4WU/WYhZegspPsVBjoLaVK6393UbxZS9puFlP1mIWW/WUjZbxZS9puFlKGzkO53U+gspEnpbpXe7DcLKfvNQsrQWUiTFcbvsyl0FtKkdL/PptBZSJPS/e6mfrOQMnQW0mTqfndT6CykSelu35tmv1lIGToL6X6Fgc5CmpTu99kUOgtpUjrwbmrxUcT5j/Vr6a/dTVuqj9Jbafc/Lv0If/+49PBL6V9/3KI9qmixxK99FpI+K0mfjaTPztHni8Oe3tdnIOkzkvSZSPo0kj5J+FAm4UOZhA9lEj6USfhQIeFDhYQPFRI+VEj40Isjxt7XJwkfKiR8qJDwoULChwoJH6okfKiS8KFKwocqCR96cUjc+/ok4UOVhA9VEj5USfhQxeVDsy9mGi7FmZaOy1qmpeMSkdlnJw2XW0xLN7+l4zKAaem4m/q0dNx9errC4G6909L97qYdeTe9v9Y78m46Kd3vbtr97qYvTsFbWrrf3bT73U273920+91Nu9vdtBxun03L4fbZtBxud9NyuN1Ny+F2Ny2H2920HG5303Ig76aT0pF300npyLvpfenB7bNpCX5304C8m05KR95NJ6Uj76aT0pF300npfnfT4Hc3DX530+B3N41+d9PoVukt0e+zafT7bPriFLylpfvdTSPybjop3a3SW6JbpbdEv0pv8rubJr+7afK7mya/u+mLU/CWlu5X6U1+n02T32fT5PfZNPndTc3ve1Pzq/SaX6XX/Cq9L07BW7nCAKfgTUv3u5sCZ9VNS/e7mwInys1KBw6Jm5bu99kUOMptWrrf3RQ4cG1aul+lFzgWbVq6X6UXOLxsusL43U2BI8ampfvdTYGDwKal+1V6geO6pqX7fTYFDtWalu53NwWOvpqW7lfpBQ6ompbuV+kFjpGarTDAyVDT0v3upsD5TdPS/e6mwClL09L9PptCZyHdlw6dhTQp3e9uCp2FNCndr9ILnYU0Kd2v0us3C6lAZyFNSve7m0JnId2X7jcLqfjNQip+s5CK3yyk4jcLqUBnId3vptBZSJPS/Sq9frOQit8spAqdhXS7wlToLKRJ6W530+o3C6kebnfT6jcLqfrNQqp+s5Cq3yykCp2FdL+bQmchTUp3q/RWv1lI1W8WUoXOQrpfYaCzkCal+91N/WYhVb9ZSNVvFlL1m4VU/WYhVb9ZSBU6C+l+N4XOQpqU7lbprX6zkKrfLKQKnYU0WWH87qZ+s5Cq3yyk6jcLqfrNQqp+s5Cq3yyk6jcLqUJnId3vptBZSJPS/Sq9frOQqt8spAqdhXS/wkBnIU1K97ub+s1Cqn6zkKrfLKTqNwup+s1Cqn6zkCp0FtL9bgqdhTQp3a/S6zcLqfrNQqrQWUiTFcbvbuo3C6n6zUKqfrOQqt8spOo3C6n6zUKqfrOQKnQW0v1uCp2FNCndr9LrNwup+s1CqtBZSPcrDHQW0qR0v7up3yyk6jcLqfrNQqp+s5Cq3yyk6jcLqUJnId3vptBZSJPS/Sq9frOQqt8spAqdhXS/wkBnIU1K97ub+s1Cqn6zkKrfLKTqNwup+s1Cqn6zkCp0FtL9bgqdhTQp3a/S6zcLqfrNQqrQWUiTFcbtbtr8ZiE1v1lIzW8WUvObhdQO5N10UrrbZ9PmNwupQWch3e6mDToLaVK6W6W3+c1Can6zkBp0FtL9CgOdhTQp3e9u6jcLqfnNQmp+s5Ca3yyk5jcLqfnNQmrQWUj3uyl0FtKkdLdKb/ObhdT8ZiE16CykyQrjdzf1m4XU/GYhNb9ZSM1vFlLzm4XU/GYhNb9ZSA06C+l+N4XOQpqU7lfp9ZuF1PxmITXoLKT7FQY6C2lSut/d1G8WUvObhdT8ZiE1v1lIzW8WUvObhdSgs5Dud1PoLKRJ6X6VXr9ZSM1vFlKDzkK6X2Ggs5AmpfvdTf1mITW/WUjNbxZS85uF1PxmITW/WUgNOgvpfjeFzkKalO5X6fWbhdT8ZiE16CykyQrjdzf1m4XU/GYhNb9ZSM1vFlLzm4XU/GYhNb9ZSA06C+l+N4XOQpqU7lfp9ZuF1PxmITXoLKT7FQY6C2lSut/d1G8WUvObhdT8ZiE1v1lIzW8WUvObhdSgs5Dud1PoLKRJ6X6VXr9ZSM1vFlKDzkKarDB+d1O/WUjNbxZS95uF1P1mIXW/WUjdbxZSP5B300npbnfTDp2FNCndrdLb/WYhdb9ZSB06C+l+hYHOQpqU7nc39ZuF1P1mIXW/WUjdbxZS95uF1P1mIXXoLKT73RQ6C2lSulult/vNQup+s5A6dBbS/QoDnYU0Kd3vbuo3C6n7zULqfrOQut8spO43C6n7zULq0FlI97spdBbSpHS/Sq/fLKTuNwupQ2chTVYYv7up3yyk7jcLqfvNQup+s5C63yyk7jcLqfvNQurQWUj3uyl0FtKkdL9Kr98spO43C6lDZyHdrzDQWUiT0v3upn6zkLrfLKTuNwup+81C6n6zkLrfLKQOnYV0v5tCZyFNSver9PrNQup+s5A6dBbSZIXxu5v6zULqfrOQut8spO43C6n7zULqfrOQut8spA6dhXS/m0JnIU1K96v0+s1C6n6zkDp0FtL9CuM3C6lDZyFNSvf7bAqdhTQp3e9u6jcLqUNnIU2m7nc3hc5Cui8dOgtpUrrf3RQ6C+l+hYHOQpqUjrybTkr3+94UOQvJ4qOI8x/r19Jfu5v24zHIH98p3v+49CP8/ePSwy+lf/1xi/aoosUSv/bZSPrsDH3G48WRTO/rM5D0GUn6TCR9GkmfmaTPQtInBR86+6TgQ2efJHwokPChQMKHAgkfCiR86MVBYO/rk4QPBRI+FEj4UCDhQ4GED0USPhRJ+FAk4UORhA+9OMrtfX2S8KFIwociCR+KJHwokvChRMKHEi4fuv9i5iwdl+JMS8dlLdPSDbj0u89OztJxucW0dFy6MC0dlwFMS8fd1Kel4+7TsxXGcLfeael+d1ND3k3vr3VD3k0npfvdTc3vbmp+d1Pzu5ua393U/O6m2e9umv3uptnvs2n2+2z64hS8lStM9rubZr+7afa7m2a/u2lG3k3vSy/Iu+mkdOTddFK632fT4nc3fXEK3tLSkXfTSenIu+mkdOTddFK63920+N1Nq9/dtPrdTavf3bT6VXpfnIK3tHS/z6bV77Np9bubVuTddFK6X6W3+VV6m1+lt/ndTZvf3fTFKXhLS/e7mza/u2nzq/Q2v8+mze+zaff7bNr97qbd73vT7lfpfXEK3tLS/Sq93e9uCpyCNy3d724KnFU3KT0Ax89NS3er9AbgkLhp6W6fTcOBvJtOSne7mwbgwLVp6W6V3gAcizYt3a3SG4DDy2YrDHAe2bR0v7spcGrYtHS/uylwtte0dLfPpgE4gWtauttn0wCckzXbTYGjr6alu1V6A3BA1bR0t0pvAI6Rmq0wwMlQ09L97qbA+U3T0v3upsApS7PSgYOTpqX7fTaFzkKalO53N4XOQpqU7lfphc5CmpTuV+n1m4UUoLOQ7kuHzkKalO53N/WbhRT8ZiEFv1lIwW8WUvCbhRSgs5Dud1PoLKRJ6X6VXr9ZSMFvFlKAzkK6X2Ggs5AmpfvdTf1mIQW/WUjBbxZS8JuFFPxmIQW/WUgBOgvpfjeFzkKalO5X6fWbhRT8ZiEF6CykyQrjdzf1m4UU/GYhBb9ZSMFvFlLwm4UU/GYhBb9ZSAE6C+l+N4XOQpqU7lfp9ZuFFPxmIQXoLKT7FQY6C2lSut/d1G8WUvCbhRT8ZiEFv1lIwW8WUvCbhRSgs5Dud1PoLKRJ6X6VXr9ZSMFvFlKAzkK6X2Ggs5AmpfvdTf1mIQW/WUjBbxZS9JuFFP1mIUW/WUgROgvpdjeNB/JuOindrdIb/WYhRb9ZSBE6C2mywvjdTf1mIUW/WUjRbxZS9JuFFP1mIUW/WUjRbxZShM5Cut9NobOQJqW7VXqj3yyk6DcLKUJnId2vMNBZSJPS/e6mfrOQot8spOg3Cyn6zUKKfrOQot8spAidhXS/m0JnIU1K96v0+s1Cin6zkCJ0FtJkhfG7m/rNQop+s5Ci3yyk6DcLKfrNQop+s5Ci3yykCJ2FdL+bQmchTUr3q/T6zUKKfrOQInQW0v0KA52FNCnd727qNwsp+s1Cin6zkKLfLKToNwsp+s1CitBZSPe7KXQW0qR0v0qv3yyk6DcLKUJnId2vMNBZSJPS/e6mfrOQot8spOg3Cyn6zUKKfrOQot8spAidhXS/m0JnIU1K96v0+s1Cin6zkCJ0FtJkhfG7m/rNQop+s5Ci3yyk6DcLKfrNQop+s5Ci3yykCJ2FdL+bQmchTUr3q/T6zUKKfrOQInQW0v0KA52FNCnd727qNwsp+s1Cin6zkKLfLKToNwsp+c1CStBZSLe7aYLOQpqU7lbpTQfybjop3a3Sm6CzkCYrjNvdNPnNQkp+s5CS3yyk5DcLKfnNQkp+s5CS3yykBJ2FdL+bQmchTUp3q/Qmv1lIyW8WUoLOQrpfYaCzkCal+91N/WYhJb9ZSMlvFlLym4WU/GYhJb9ZSAk6C+l+N4XOQpqU7lfp9ZuFlPxmISXoLKT7FQY6C2lSut/d1G8WUvKbhZT8ZiElv1lIyW8WUvKbhZSgs5Dud1PoLKRJ6X6VXr9ZSMlvFlKCzkKarDB+d1O/WUjJbxZS8puFlPxmISW/WUjJbxZS8puFlKCzkO53U+gspEnpfpVev1lIyW8WUoLOQrpfYaCzkCal+91N/WYhJb9ZSMlvFlLym4WU/GYhJb9ZSAk6C+l+N4XOQpqU7lfp9ZuFlPxmISXoLKTJCuN3N/WbhZT8ZiElv1lIyW8WUvKbhZT8ZiElv1lICToL6X43hc5CmpTuV+n1m4WU/GYhJegspPsVBjoLaVK6393UbxZS8puFlPxmISW/WUjJbxZS8puFlKCzkG53U4POQpqU7lbpNb9ZSOY3C8kOt7upQWchTUp3u5ua3ywk85uFZH6zkMxvFpL5zUIyv1lIBp2FdL+bQmchTUp3q/Sa3ywk85uFZNBZSJMVxu9u6jcLyfxmIZnfLCTzm4VkfrOQzG8WkvnNQjLoLKT73RQ6C2lSul+l128WkvnNQjLoLKT7FcZvFpJBZyFNSvf7bAqdhTQp3e9u6jcLyaCzkO6nDp2FNCnd724KnYU0Kd3vbgqdhXS/wkBnIU1K9/tsCp2FNCkdeDc9lZZH6efj/9fSX7qbxtbC37+NrafPP/6rmtfGG02rCVDVRKhqXrozxV4ev429tq/VGFQ1GaqaAlVNhbqKG1Q1UGtxgVqLX5t3M7uKXxthM60Gai0uUGtxefFa3NPj7x7h+FpNgaqmQlUDtRYXqLW4Qq3FFYoXV6i1uEKtxRVqLa5QvLhCrcUVai1+beTHtJqOVM1rgzmm1QSoaqA0itcmYkyrMahqMlQ1UBpFq1DVNKhqOlI1HWot7lBrcY9Q1SSoagyqGiiNokPx4g7FizsUL+5IGkU+kDSKfCBpFPlA4sX5QNIo8mFQ1SBpFPlA4sX5QFqL84G0FucDSaPIAYkX54DEi3NA4sU5IPHiHAyqGiRenAMSL84Bai0OUGtxgOLFEYoXRyheHKF4cYTixdGgqoHixRGKF0eotThCrcURihcnKF6coHhxguLFCYoXJ4OqBooXJyhenKDW4gS1Fieotdig1mKDWosNihcb0ncU+bXGwmk1SN9RZIPixYb0HUU2pO8osiF9R5Ez1FqcodbiDMWLMxQvfrXvblINFC/OULw4Q/HiDMWLMxQvLlBrcYFaiwvUWlyg1uICtRZD+e4ylO8uQ/nuMpTvLkP57jKU7y5D+e4ylO8uQ/nuMpTvLkP57jKU7y5D+e4ylO8uQ/nuMpTvLkP57nKD4sUNihe/2Hc3qwaKFzeotbhBrcUNai1uUGsxlO8uQ/nuMpTvLkP57jKU7y5D+e4ylO8ud6ScttyhNAoo312B8t2VAymnrRxIGkWB8t2Vw6CqQVqLy4G0Fhco312B8t0VKN9dgfLdFSjfXYHy3RUo312B8t0VKN9dgfLdFSjfXYHy3ZUAtRZHqLU4Qq3FEWotjlBrcYRaiyPUWhyh1mIo312B8t2VCKVRJCiNIiF9R1ESktejJCiN4tW+u0k1SN9RlITk9ShQvrsC5bsrUL67AuW7K1C+u2JQvNigePGLfXezaqB4sUHxYoNaiw1qLTaotRjKd1egfHcFyndXoHx3Bcp3V6B8dwXKd1egfHcFyndXoHx3Bcp3V6B8dwXKd1egfHflxb67iX5TkPIoyot9d7NqkL5pKwUpj6IUpDyK8mLf3awaqG/aKtRaXKHW4lf77ibVQPFiKN9dgfLdFSjfXYHy3RUo312B8t0VKN9dgfLdFSjfXYHy3RUo312B8t0VKN9dgfLdFSjfXYHy3RUo312B8t0VKN9dgfLdFSjfXYE6765AnXdXOtJaXA+ktbgeSGtxhTrvrh5I+cX1MKhqkPTiCnXeXT2Q8ovrgaQX1wNJL65QvrsK5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu6tQvrsKdd5dhTrvrkKdd1ehzrurUOfdVajz7irUeXcV6ry7CuW7q1C+uwrlu6tQvrsK5burUL67CnXeXYU6765CnXdXDen74gp13l2FOu+uQp13VzPS98UVyndXoXx3Fcp3V6F8dxXKd1ehfHcVyndXoXx3Fcp3V6F8dxXKd1ehfHcVyndXoc67q1Dn3VWo8+4q1Hl3tUCtxQVqLa5Qa3GFWouhfHcVyndXoXx3Fcp3V6F8dxXKd1ehfHcVyndXoXx3Fcp3V6F8dxXKd1ehfHcVyndXoXx3tSHlUdSGdMZSbUj5xbUj5RfXjpRHUTvSGUu1I+UX11f77ibVQK3FUL67CuW7q1C+uwrlu2tQvrsG5btrBxIvbgcSL24HEi9uUOfdNajz7hrUeXcN6ry7BnXeXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXXux7+7+PUNLSF6PlpC8Hi0hvbtrCcnr0RKS16MZktejGdK7uwblu2tQ5901qPPuGtR5dw3qvLsGdd5dgzrvrkGdd9egzrtrUL67BuW7a1C+uwblu2tQvrsG5btrUL67BuW7a1C+uwblu2tQvrsG5btrUL67BuW7a1C+uwblu2tQvrsG5btrUL67BuW7a1C+uwblu2tQvrsG5btrUL67BuW7a1C+uwblu2tQvrsG5btrUL67BuW7a1C+u/Zi393kjVCDenfXoN7dQfnuWoN6d9eg3t11qHd3UL67BnXeXYM6765BnXfXoHx3Dcp316B8dw3Kd9egfHcdynfXoXx3Hcp316F8d/1AWos7lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765DnXfXoc6761Dn3XUo311PSJmZPSFlZnZDyszsUL67bkiZmd2QMjP7q313k2qg1mIo312H8t11KN9dh/LddSjfXYfy3XUo312H8t11KN9dh/LddSjfXYfy3XUo312H8t11KN9dh/LddSjfXYfy3XUo312H8t11KN9dh/LddSjfXYfy3XUo312H8t11KN9dh/LddSjfXYfy3XUo312H8t11KN9dh/LddSjfXYfy3XUo312H8t11qPPuOtR5dx3qvLveoNbiBrUWN6i1uEOtxR1qLYby3fUX++4mb1lf7LubVYPkge4dyQPdX+27u3/L2pE80L0DeaDTcQB5oM9qgNbisxqgtfisBogXn9UA8eKzGiBefFYDxIvPaoB48VkNEC8+qwHixT/+FVQ1UGsxku/u/FdQazGS7+78V1BrMZLv7vxXUGsx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QvnuKpTvrkL57iqU765C+e4qlO+uQvnuKpTvrkL57iqU765C+e4qlO+uQvnuKpTvrkL57iqU765C+e4qlO+uQvnuKpTvrkL57iqU765C+e4qlO+uQvnuKpTvrkL57iqU765C+e4qlO+uQvnuKpTvrkL57iqU765C+e4qlO+uQvnuKpTvrkL57iqU765C+e4qlO+uQvnuKpTvrkL57hqU765B+e4alO+uQfnu2oG0Fjco312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYfy3XUo312H8t11KN9dP5DW4g7lu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW76y/23bUW/v5tPF9Gfa0mQFUToapJUNW8eC2O7VHNeZF8rebFa3GxZzW1fa2mQFVToappUNW8dC1OxxGea/HRv1TzWt/dtBooXgzlu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW760i+u3wg+e7OaoDW4rMa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5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu2tQvrsG5btrUL67BuW7awfSWtygfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dx3Kd9ehfHcdynfXoXx3/UBaizuU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uL/Dd5fr47fnn7qsJR3lUE44enz+OtQ1+XSz+/eNS6vO3qeTRX7beH385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",
      "brillig_names": [
        "discover_new_notes",
        "debug_log_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "attach_len_to_msg_block",
        "debug_log_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "storage_read",
        "debug_log_oracle_wrapper",
        "storage_read",
        "debug_log_oracle_wrapper",
        "build_msg_block",
        "get_l1_to_l2_membership_witness",
        "notify_created_nullifier_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "_register_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14788743618517749904": {
            "error_kind": "string",
            "string": "Function _register_public can only be called internally"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "aztec_token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_register_public"
      ]
    },
    {
      "name": "get_l1_token",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [
          {
            "name": "aztec_token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_l1_token"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Beacon"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "target",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "overrides",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "minter",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "shield_gateway_beacon",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "private_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "shielded_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Portal"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "l1_portal",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "l1_tokens",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "l2_tokens",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token_contract_class_id",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "shield_gateway_beacon",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "eth_token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "recipient",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "amount",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            },
            {
              "name": "message_leaf_index",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::Deposit"
        },
        {
          "fields": [
            {
              "name": "token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "from",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "to",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "amount",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::Withdraw"
        },
        {
          "fields": [
            {
              "name": "eth_token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "aztec_token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::Register"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "aztec_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "name",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  },
                  {
                    "name": "name_len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "symbol",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  },
                  {
                    "name": "symbol_len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "decimals",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::register_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::register_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "aztec_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::_register_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::_register_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::claim_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::claim_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::_log_claim_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::_log_claim_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "withdrawNonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "burnNonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::withdraw_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::withdraw_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::_claim_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::_claim_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::claim_shielded_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::claim_shielded_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "l1_portal",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "token_contract_class",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "shield_gateway_beacon",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::constructor_abi"
        }
      ]
    }
  },
  "file_map": {
    "109": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "114": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "118": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/dispatch/mod.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let name = function.name();\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_struct().map(|typ: (StructDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "119": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/events/mod.nr",
      "source": "use super::utils::compute_event_selector;\nuse protocol_types::meta::generate_serialize_to_fields;\n\ncomptime fn generate_event_interface(s: StructDefinition) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let (serialization_fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let content_len = serialization_fields.len();\n\n    let event_type_id = compute_event_selector(s);\n\n    quote {\n        impl aztec::event::event_interface::EventInterface<$content_len> for $name {\n            fn get_event_type_id() -> aztec::protocol_types::abis::event_selector::EventSelector {\n                aztec::protocol_types::traits::FromField::from_field($event_type_id)\n            }\n\n            fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n                _emit(self);\n            }\n        }\n    }\n}\n\npub comptime fn event(s: StructDefinition) -> Quoted {\n    let event_interface = generate_event_interface(s);\n    s.add_attribute(\"abi(events)\");\n    quote {\n        $event_interface\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "121": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "122": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "125": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_initializer, is_fn_internal,\n        is_fn_private, is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform note discovery, since they may need to access notes. This is slightly inefficient\n    // and could be improved by only doing it once we actually attempt to read any.\n    let note_discovery_call = if NOTES.len() > 0 {\n        create_note_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $note_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_unconstrained(f: FunctionDefinition) {\n    let context_creation = quote { let mut context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All unconstrained functions perform note discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let note_discovery_call = if NOTES.len() > 0 {\n        create_note_discovery_call()\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $note_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_return_public(true);\n    f.set_body(modified_body);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::discovery::discover_new_notes`, causing for new notes to be added to PXE and made\n/// available for the current execution.\ncomptime fn create_note_discovery_call() -> Quoted {\n    quote {\n        /// Safety: note discovery returns nothing and is performed solely for its side-effects. It is therefore always\n        /// safe to call.\n        unsafe {\n            dep::aztec::discovery::discover_new_notes(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            )\n        };\n    }\n}\n"
    },
    "126": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/mod.nr",
      "source": "pub mod dispatch;\npub mod functions;\npub mod utils;\npub mod notes;\npub mod storage;\npub mod events;\n\nuse functions::{stub_registry, utils::transform_unconstrained};\nuse notes::{generate_note_export, NOTES};\nuse storage::STORAGE_LAYOUT_NAME;\n\nuse dispatch::generate_public_dispatch;\nuse utils::{get_trait_impl_method, module_has_storage};\n\nuse crate::discovery::MAX_NOTE_PACKED_LEN;\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `process_log` and `sync_notes` functions PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n    let unconstrained_functions = m.functions().filter(|f: FunctionDefinition| {\n        f.is_unconstrained() & !f.has_named_attribute(\"test\") & !f.has_named_attribute(\"public\")\n    });\n    for f in unconstrained_functions {\n        transform_unconstrained(f);\n    }\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let process_log = generate_process_log();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $process_log\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    let mut max_note_packed_len: u32 = 0;\n    if notes.len() > 0 {\n        max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (StructDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The note discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_notes`, `do_process_log`\n            /// and `process_private_note_log`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_process_log() -> Quoted {\n    // This mandatory function processes a log emitted by the contract. This is currently used to process private logs\n    // and perform note discovery of either private notes or partial notes.\n    // The bulk of the work of this function is done by aztec::discovery::do_process_log, so all we need to do is call\n    // that function.\n\n    // We'll produce the entire body of the function in one go and then insert it into the function.\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        quote {\n            unconstrained fn process_log(\n                log_plaintext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                tx_hash: Field,\n                unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                first_nullifier_in_tx: Field,\n                recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                // Because this unconstrained function is injected after the contract is processed by the macros, it'll not\n                // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\n                // unconstrained execution context since it will not be available otherwise.\n                let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\n\n                // TODO(#10727): allow other contracts to process logs and deliver notes\n                let contract_address = context.this_address();\n\n                aztec::discovery::private_logs::do_process_log(\n                    contract_address,\n                    log_plaintext,\n                    tx_hash,\n                    unique_note_hashes_in_tx,\n                    first_nullifier_in_tx,\n                    recipient,\n                    _compute_note_hash_and_nullifier,\n                );\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            unconstrained fn process_log(\n                _log_plaintext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                _tx_hash: Field,\n                _unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                _first_nullifier_in_tx: Field,\n                _recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (StructDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    quote {\n        unconstrained fn sync_notes() {\n            aztec::oracle::note_discovery::sync_notes();\n        }\n    }\n}\n"
    },
    "127": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/notes/mod.nr",
      "source": "use crate::{note::note_getter_options::PropertySelector, prelude::Point};\nuse super::utils::AsStrQuote;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, derive_generators, Hash, Hasher, poseidon2::Poseidon2Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (StructDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: StructDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: StructDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: StructDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` implementation for a given partial note struct `s` and returns it as a quote.\n///\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field {\n///         ...\n///     }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n///         ...\n///     }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n///\n/// # On differences from `generate_note_hash_trait_impl`\n/// We use multi-scalar multiplication (MSM) instead of Poseidon2 here since this is a partial note and therefore\n/// does require MSM's additive homomorphism property (the property is used to add to the commitment in public).\n/// We don't use this implementation for standard notes as well because Poseidon2 is significantly cheaper\n/// constraints-wise.\n///\n/// # On including length in note hash preimage\n/// For a given commitment C = a*G1 + b*G2 + c*G3 we take an x-coordinate of C.x and use it as the hash.\n/// However, due to elliptic curve symmetry about the x-axis, for any x-coordinate,\n/// there are two points with that x-coordinate. This means -C has the same hash (x-coord) as C,\n/// and the tuple [-a, -b, -c] produces the same hash as [a, b, c].\n///\n/// This property makes the hash trivially not collision resistant without including the length.\n/// By including the length l, the commitment becomes:\n/// C = a*G1 + b*G2 + c*G3 + l*G_len\n///\n/// Since -l would be -3 (an extraordinarily large number that cannot be a valid preimage length),\n/// including the length protects against these collisions.\ncomptime fn generate_note_hash_trait_impl_for_partial_note(\n    s: StructDefinition,\n    indexed_fixed_fields: [(Quoted, Type, u32)],\n    indexed_nullable_fields: [(Quoted, Type, u32)],\n) -> Quoted {\n    let name = s.name();\n\n    // First we compute quotes for MSM\n    // `compute_note_hash()` is computed over all the fields so we need to merge fixed and nullable.\n    let merged_fields = indexed_fixed_fields.append(indexed_nullable_fields);\n    // Now we prefix each of the merged fields with `self.` since they refer to the struct members here.\n    let prefixed_merged_fields = merged_fields.map(|(name, typ, index): (Quoted, Type, u32)| {\n        (quote { self.$name }, typ, index)\n    });\n    let (new_generators_list, new_scalars_list, _, new_aux_vars) =\n        generate_multi_scalar_mul(prefixed_merged_fields);\n\n    let (g_slot, g_len) = generate_fixed_generators();\n    let new_generators = new_generators_list.push_back(g_slot).push_back(g_len).join(quote {,});\n\n    let merged_fields_len = merged_fields.len() + 1; // +1 for the storage slot appended below\n    let new_scalars = new_scalars_list\n        .push_back(quote { std::hash::from_field_unsafe(storage_slot) })\n        .push_back(quote { std::hash::from_field_unsafe($merged_fields_len) })\n        .join(quote {,});\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                $new_aux_vars\n                let point = std::embedded_curve_ops::multi_scalar_mul(\n                    [$new_generators],\n                    [$new_scalars]\n                );\n                point.x\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly in\n                // the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly in\n                // the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: StructDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: StructDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Number of fixed generators used to ensure that we don't have a collision of indices in derive_generators(...) in\n/// the generate_multi_scalar_mul(...) function. If the indices collided this could result in a critical vulnerability\n/// (e.g. in case of G_slot collision with other another note field an attacker could move a note to an arbitrary\n/// slot).\nglobal NUM_FIXED_GENERATORS: u32 = 2;\n\n/// Generates G_slot and G_len generator point quotes.\ncomptime fn generate_fixed_generators() -> (Quoted, Quoted) {\n    let generators: [Point; NUM_FIXED_GENERATORS] =\n        derive_generators(\"aztec_nr_generators\".as_bytes(), 0);\n\n    let g_slot_x = generators[0].x;\n    let g_slot_y = generators[0].y;\n    let g_len_x = generators[1].x;\n    let g_len_y = generators[1].y;\n\n    let g_slot = quote {\n        aztec::protocol_types::point::Point { x: $g_slot_x, y: $g_slot_y, is_infinite: false }\n    };\n    let g_len = quote {\n        aztec::protocol_types::point::Point { x: $g_len_x, y: $g_len_y, is_infinite: false }\n    };\n\n    (g_slot, g_len)\n}\n\n/// Generates quotes necessary for multi-scalar multiplication of `indexed_fields` (indexed struct fields). Returns\n/// a tuple containing quotes for generators, scalars, arguments and auxiliary variables. For more info on what are\n/// auxiliary variables and how they are used, see `generate_serialize_to_fields` function.\n///\n/// Example return values:\n/// generators_list: [aztec::generators::Ga1, aztec::generators::Ga2, aztec::generators::Ga3, aztec::generators::Ga4]\n/// scalars_list: [\n///     std::hash::from_field_unsafe(amount.lo as Field),\n///     std::hash::from_field_unsafe(amount.hi as Field),\n///     std::hash::from_field_unsafe(npk_m_hash as Field),\n///     std::hash::from_field_unsafe(randomness as Field)\n/// ]\n/// args_list: [amount: u128, npk_m_hash: Field, randomness: Field]\n/// aux_vars: []\ncomptime fn generate_multi_scalar_mul(\n    indexed_fields: [(Quoted, Type, u32)],\n) -> ([Quoted], [Quoted], [Quoted], Quoted) {\n    let mut generators_list = &[];\n    let mut scalars_list = &[];\n    let mut args_list = &[];\n    let mut aux_vars_list = &[];\n    for i in 0..indexed_fields.len() {\n        // Destructure tuple containing:\n        // - field_name: the name of the struct field/member (as a Quoted type)\n        // - typ: the type of the struct field/member (as a Type)\n        // - field_start_index: index where this field starts in the serialized note array (as u32)\n        let (field_name, typ, field_start_index) = indexed_fields[i];\n        // We add NUM_FIXED_GENERATORS to the start index to avoid collision with fixed generators.\n        let start_generator_index = NUM_FIXED_GENERATORS + field_start_index;\n        let (serialization_fields, aux_vars) =\n            generate_serialize_to_fields(field_name, typ, &[], true);\n        for j in 0..serialization_fields.len() {\n            let serialization_field = serialization_fields[j];\n            let generator_index = start_generator_index + j;\n\n            let generators: [Point; 1] =\n                derive_generators(\"aztec_nr_generators\".as_bytes(), generator_index);\n            let generator_x = generators[0].x;\n            let generator_y = generators[0].y;\n\n            generators_list = generators_list.push_back(\n                quote {\n                aztec::protocol_types::point::Point { x: $generator_x, y: $generator_y, is_infinite: false }\n                },\n            );\n            scalars_list = scalars_list.push_back(\n                quote { std::hash::from_field_unsafe($serialization_field) },\n            );\n        }\n        args_list = args_list.push_back(quote { $field_name: $typ });\n        aux_vars_list = aux_vars_list.append(aux_vars);\n    }\n\n    let aux_vars = if aux_vars_list.len() > 0 {\n        let joint = aux_vars_list.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n    (generators_list, scalars_list, args_list, aux_vars)\n}\n\n/// TODO: The macros shouldn't have a hard-coded opinion of a log layout; not even for partial notes.\n/// Since partial notes are about to be refactored, I won't tackle it yet.\n//\n/// Generates setup payload for a given note struct `s`. The setup payload contains log plaintext and hiding point.\n///\n/// # On including length in note hash preimage\n/// The hiding point is computed as a multi-scalar multiplication that includes the length of the preimage\n/// to protect against collisions due to elliptic curve symmetry.\n///\n/// When computing a note hash in the partial notes flow, we take the hiding point, add the nullable fields to it\n/// in public and then we take the x-coordinate of the point and use it as the note hash. E.g. for a given commitment\n/// C = a*G1 + b*G2 + c*G3 we take an x-coordinate of C.x. However, due to elliptic curve symmetry about the x-axis,\n/// for any x-coordinate, there are two points with that x-coordinate. This means -C has the same hash (x-coord) as C,\n/// and the tuple [-a, -b, -c] produces the same hash as [a, b, c].\n///\n/// This property makes the hash trivially not collision resistant without including the length.\n/// By including the length l, the commitment becomes:\n/// C = a*G1 + b*G2 + c*G3 + l*G_len\n///\n/// Since -l would be -3 (an extraordinarily large number that cannot be a valid preimage length),\n/// including the length protects against these collisions.\n///\n/// # Example function output\n/// ```\n/// struct TokenNoteSetupPayload {\n///     log_plaintext: [u8; 160],\n///     hiding_point: aztec::protocol_types::point::Point\n/// }\n///\n/// impl TokenNoteSetupPayload {\n///     fn new(mut self, npk_m_hash: Field, randomness: Field, storage_slot: Field) -> TokenNoteSetupPayload {\n///         let hiding_point = std::embedded_curve_ops::multi_scalar_mul(\n///             [\n///                 Point { x: 0x..., y: 0x... },\n///                 Point { x: 0x..., y: 0x... },\n///                 Point { x: 0x..., y: 0x... },\n///                 Point { x: 0x..., y: 0x... }\n///             ],\n///             [\n///                 std::hash::from_field_unsafe(npk_m_hash),\n///                 std::hash::from_field_unsafe(randomness),\n///                 std::hash::from_field_unsafe(storage_slot),\n///                 std::hash::from_field_unsafe(3)\n///             ]\n///         );\n///\n///         let let storage_slot_bytes = storage_slot.to_be_bytes();\n///         let let note_type_id_bytes = TokenNote::get_id().to_be_bytes();\n///\n///         for i in 0..32 {\n///             log_plaintext[i] = storage_slot_bytes[i];\n///             log_plaintext[32 + i] = note_type_id_bytes[i];\n///         }\n///\n///         let packed_note = [npk_m_hash as Field, randomness as Field];\n///\n///         for i in 0..packed_note.len() {\n///             let bytes: [u8; 32] = packed_note[i].to_be_bytes();\n///             for j in 0..32 {\n///                 log_plaintext[64 + i * 32 + j] = bytes[j];\n///             }\n///         }\n///\n///         TokenNoteSetupPayload {\n///             log_plaintext,\n///             hiding_point\n///         }\n///     }\n///\n///     fn encrypt_log(self, context: &mut PrivateContext, recipient_keys: aztec::protocol_types::public_keys::PublicKeys, recipient: aztec::protocol_types::address::AztecAddress) -> [Field; 17] {\n///\n///         let encrypted_log_bytes: [u8; 513] = aztec::encrypted_logs::log_assembly_strategies::default_aes128::partial_note::::compute_partial_public_log_payload(\n///             context.this_address(),\n///             self.log_plaintext,\n///             recipient,\n///             sender\n///         );\n///\n///         aztec::utils::bytes::be_bytes_31_to_fields(encrypted_log_bytes)\n///     }\n///\n/// impl aztec::protocol_types::traits::Empty for TokenNoteSetupPayload {\n///     fn empty() -> Self {\n///         Self { log_plaintext: [0; 160], hiding_point: aztec::protocol_types::point::Point::empty() }\n///     }\n/// }\n/// ```\ncomptime fn generate_setup_payload(\n    s: StructDefinition,\n    indexed_fixed_fields: [(Quoted, Type, u32)],\n    indexed_nullable_fields: [(Quoted, Type, u32)],\n    note_type_id: Field,\n) -> (Quoted, Quoted) {\n    let name = s.name();\n    let setup_payload_name = f\"{name}SetupPayload\".quoted_contents();\n\n    // First we get the MSM related quotes\n    let (new_generators_list, new_scalars_list, new_args_list, new_aux_vars) =\n        generate_multi_scalar_mul(indexed_fixed_fields);\n    let new_args = &[quote {mut self}]\n        .append(new_args_list)\n        .push_back(quote { storage_slot: Field })\n        .join(quote {,});\n\n    let (g_slot, g_len) = generate_fixed_generators();\n    let new_generators = new_generators_list.push_back(g_slot).push_back(g_len).join(quote {,});\n    let merged_fields_len = indexed_fixed_fields.len() + indexed_nullable_fields.len() + 1; // +1 for storage_slot\n    let new_scalars = new_scalars_list\n        .push_back(quote { std::hash::from_field_unsafe(storage_slot) })\n        .push_back(quote { std::hash::from_field_unsafe($merged_fields_len) })\n        .join(quote {,});\n\n    // Then the log plaintext ones\n    let log_plaintext_length = indexed_fixed_fields.len() * 32 + 64;\n    let setup_log_plaintext: Quoted = get_setup_log_plaintext_body(\n        s,\n        log_plaintext_length,\n        indexed_nullable_fields,\n        note_type_id,\n    );\n\n    // Then we compute values for `encrypt_log(...)` function.\n    // First, the length of the items that are broken into bytes:\n    let encrypted_log_bytes_length = 1 /* eph_pk_sign */\n        + 48 /* header_ciphertext */\n        + log_plaintext_length /* log_plaintext */\n        + 16\n        - (log_plaintext_length % 16); /* pkcs#7 aes padding */\n\n    // Each field contains 31 bytes so the length in fields is computed as ceil(encrypted_log_byte_length / 31)\n    // Recall: ceil(x / y) = (x + y - 1) // y (integer division).\n    let encrypted_log_fields_length = 1 /* tag */\n        + 1 /* eph_pk.x */\n        + (encrypted_log_bytes_length + 30) / 31;\n\n    (\n        quote {\n        pub struct $setup_payload_name {\n            pub log_plaintext: [u8; $log_plaintext_length],\n            pub hiding_point: aztec::protocol_types::point::Point\n        }\n\n        impl $setup_payload_name {\n            pub fn new($new_args) -> $setup_payload_name {\n                $new_aux_vars\n                let hiding_point = std::embedded_curve_ops::multi_scalar_mul(\n                    [$new_generators],\n                    [$new_scalars]\n                );\n                $setup_log_plaintext\n\n                $setup_payload_name {\n                    log_plaintext,\n                    hiding_point\n                }\n            }\n\n            pub fn encrypt_log(self, context: &mut aztec::prelude::PrivateContext, recipient: aztec::protocol_types::address::AztecAddress, sender: aztec::protocol_types::address::AztecAddress) -> [Field; $encrypted_log_fields_length] {\n                aztec::encrypted_logs::log_assembly_strategies::default_aes128::partial_note::compute_partial_public_log_payload(\n                    context.this_address(),\n                    self.log_plaintext,\n                    recipient,\n                    sender,\n                )\n            }\n        }\n\n        impl aztec::protocol_types::traits::Empty for $setup_payload_name {\n            fn empty() -> Self {\n                Self { log_plaintext: [0; $log_plaintext_length], hiding_point: aztec::protocol_types::traits::Empty::empty() }\n            }\n        }\n    },\n        setup_payload_name,\n    )\n}\n\n/// Generates setup log plaintext for a given note struct `s`. The setup log plaintext is computed by serializing\n/// storage slot from target function arguments, note type id from the note struct `s` and the fixed fields. The fixed\n/// fields are obtained by passing the whole note struct to the `generate_serialize_to_fields(...)` function but omitting the\n/// nullable fields.\ncomptime fn get_setup_log_plaintext_body(\n    s: StructDefinition,\n    log_plaintext_length: u32,\n    indexed_nullable_fields: [(Quoted, Type, u32)],\n    note_type_id: Field,\n) -> Quoted {\n    // Now we compute serialization of the fixed fields. We do that by passing the whole note struct\n    // to the generate_serialize_to_fields function but we omit the nullable fields.\n    let to_omit = indexed_nullable_fields.map(|(name, _, _): (Quoted, Type, u32)| name);\n    let (fields_list, aux_vars) =\n        generate_serialize_to_fields(quote { }, s.as_type(), to_omit, true);\n\n    // If there are `aux_vars` we need to join them with `;` and add a trailing `;` to the joined string.\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n    let fields = fields_list.join(quote {,});\n\n    quote {\n        let mut log_plaintext: [u8; $log_plaintext_length] = [0; $log_plaintext_length];\n\n        let storage_slot_bytes: [u8; 32] = storage_slot.to_be_bytes();\n        let note_type_id_bytes: [u8; 32] = $note_type_id.to_be_bytes();\n\n        for i in 0..32 {\n            log_plaintext[i] = storage_slot_bytes[i];\n            log_plaintext[32 + i] = note_type_id_bytes[i];\n        }\n\n        $aux_vars_for_serialization\n        let packed_note = [$fields];\n\n        for i in 0..packed_note.len() {\n            let bytes: [u8; 32] = packed_note[i].to_be_bytes();\n            for j in 0..32 {\n                log_plaintext[64 + i * 32 + j] = bytes[j];\n            }\n        }\n    }\n}\n\n/// Generates finalization payload for a given note struct `s`. The finalization payload contains log and note hash.\n///\n/// Example:\n/// ```\n/// struct TokenNoteFinalizationPayload {\n///     context: &mut aztec::prelude::PublicContext,\n///     hiding_point_slot: Field,\n///     setup_log_slot: Field,\n///     public_values: [Field; 2]\n/// }\n///\n/// impl TokenNoteFinalizationPayload {\n///     fn new(mut self, context: &mut aztec::prelude::PublicContext, slot: Field, amount: u128) -> TokenNoteFinalizationPayload {\n///         self.context = context;\n///         self.hiding_point_slot = slot;\n///         self.setup_log_slot = slot + aztec::protocol_types::point::POINT_LENGTH as Field;\n///         self.public_values = [amount.lo as Field, amount.hi as Field];\n///         self\n///     }\n///\n///     fn emit(self) {\n///         self.emit_note_hash();\n///         self.emit_log();\n///     }\n///\n///     fn emit_note_hash(self) {\n///         let hiding_point: aztec::prelude::Point = self.context.storage_read(self.hiding_point_slot);\n///         assert(!aztec::protocol_types::traits::is_empty(hiding_point), \"transfer not prepared\");\n///\n///         let finalization_hiding_point = std::embedded_curve_ops::multi_scalar_mul([aztec::generators::Ga3, aztec::generators::Ga4], [std::hash::from_field_unsafe(self.public_values[0]), std::hash::from_field_unsafe(self.public_values[1])]) + hiding_point;\n///\n///         let note_hash = finalization_hiding_point.x;\n///\n///         self.context.push_note_hash(note_hash);\n///\n///         // We reset public storage to zero to achieve the effect of transient storage - kernels will squash\n///         // the writes\n///         // self.context.storage_write(self.hiding_point_slot, [0; aztec::protocol_types::point::POINT_LENGTH]);\n///     }\n///\n///     fn emit_log(self) {\n///         let setup_log_fields: [Field; 8] = self.context.storage_read(self.setup_log_slot);\n///\n///         let mut finalization_log = [0; 11];\n///\n///         for i in 0..setup_log_fields.len() {\n///             finalization_log[i + 1] = setup_log_fields[i];\n///         }\n///\n///         for i in 0..self.public_values.len() {\n///            finalization_log[i + 1 + 8] = self.public_values[j];\n///         }\n///\n///         finalization_log[0] = aztec::protocol_types::utils::field::field_from_bytes([\n///                 (2 >> 8) as u8, 2 as u8, 0,\n///                 (8 >> 8) as u8, 8 as u8, 0,\n///                 (91 >> 8) as u8, 91 as u8,\n///                ], true);\n///\n///         self.context.emit_public_log(finalization_log);\n///\n///         // We reset public storage to zero to achieve the effect of transient storage - kernels will squash\n///         // the writes\n///         // self.context.storage_write(self.setup_log_slot, [0; 8]);\n///     }\n/// }\n///\n/// impl aztec::protocol_types::traits::Empty for TokenNoteFinalizationPayload {\n///     fn empty() -> Self {\n///         Self { context: &mut aztec::prelude::PublicContext::empty(), hiding_point_slot: 0, setup_log_slot: 0, public_values: [0, 0] }\n///     }\n/// }\n/// ```\ncomptime fn generate_finalization_payload(\n    s: StructDefinition,\n    indexed_fixed_fields: [(Quoted, Type, u32)],\n    indexed_nullable_fields: [(Quoted, Type, u32)],\n) -> (Quoted, Quoted) {\n    let name = s.name();\n    let finalization_payload_name = f\"{name}FinalizationPayload\".quoted_contents();\n\n    // We compute serialization of the nullable fields which are to be emitted as a public log. We do that by\n    // passing the whole note struct to the `generate_serialize_to_fields(...)` function but we omit the fixed fields.\n    let to_omit = indexed_fixed_fields.map(|(name, _, _): (Quoted, Type, u32)| name);\n    let (nullable_fields_list, aux_vars) =\n        generate_serialize_to_fields(quote { }, s.as_type(), to_omit, true);\n\n    // If there are `aux_vars` we need to join them with `;` and add a trailing `;` to the joined string.\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    // We compute the log length and we concatenate the fields into a single quote.\n    let public_values_length = nullable_fields_list.len();\n    let nullable_fields = nullable_fields_list.join(quote {,});\n\n    // Now we compute quotes relevant to the multi-scalar multiplication.\n    // Note 1: We ignore the `scalars_list` and `aux_vars` return values because it's not used by the `emit_note_hash`\n    // function. Instead, we use `public_values` (defined on the finalization payload struct) and the scalar list\n    // is computed in the for-loop below.\n    // Note 2: The `args_list` is not used for note hash MSM but instead for the `new` function.\n    let (generators_list, _, args_list, _) = generate_multi_scalar_mul(indexed_nullable_fields);\n\n    // We generate scalars_list manually as we need it to refer self.public_values\n    let mut scalars_list: [Quoted] = &[];\n    for i in 0..public_values_length {\n        scalars_list =\n            scalars_list.push_back(quote { std::hash::from_field_unsafe(self.public_values[$i]) });\n    }\n\n    let generators = generators_list.join(quote {,});\n    let scalars = scalars_list.join(quote {,});\n    let args = args_list.join(quote {,});\n\n    // Then we compute values for `encrypt_log(...)` function\n    let setup_log_plaintext_length = indexed_fixed_fields.len() * 32 + 64;\n\n    let setup_log_bytes_length = 1 /* eph_pk_sign */\n        + 48 /* header_ciphertext */\n        + setup_log_plaintext_length /* log_plaintext */\n        + 16\n        - (setup_log_plaintext_length % 16); /* pkcs#7 aes padding */\n\n    // Each field contains 31 bytes so the length in fields is computed as ceil(encrypted_log_byte_length / 31)\n    // Recall: ceil(x / y) = (x + y - 1) // y (integer division).\n    let setup_log_fields_length = 1 /* tag */\n        + 1 /* eph_pk.x */\n        + (setup_log_bytes_length + 30) / 31;\n\n    let finalization_log_fields_length =\n        1 /* some length encodings (see below) */ + setup_log_fields_length + public_values_length;\n\n    (\n        quote {\n        pub struct $finalization_payload_name {\n            pub context: &mut aztec::prelude::PublicContext,\n            pub hiding_point_slot: Field,\n            pub setup_log_slot: Field,\n            pub public_values: [Field; $public_values_length],\n        }\n\n        impl $finalization_payload_name {\n            pub fn new(mut self, context: &mut aztec::prelude::PublicContext, slot: Field, $args) -> $finalization_payload_name {\n                self.context = context;\n\n                self.hiding_point_slot = slot;\n                self.setup_log_slot = slot + aztec::protocol_types::point::POINT_LENGTH as Field;\n\n                $aux_vars_for_serialization\n                self.public_values = [$nullable_fields];\n\n                self\n            }\n\n            pub fn emit(self) {\n                self.emit_note_hash();\n                self.emit_log();\n            }\n\n            pub fn emit_note_hash(self) {\n                // Read the hiding point from \"transient\" storage and check it's not empty to ensure the transfer was prepared\n                let hiding_point: aztec::prelude::Point = self.context.storage_read(self.hiding_point_slot);\n                assert(!aztec::protocol_types::traits::is_empty(hiding_point), \"transfer not prepared\");\n\n                let finalization_hiding_point = std::embedded_curve_ops::multi_scalar_mul(\n                    [$generators],\n                    [$scalars]\n                ) + hiding_point;\n\n                let note_hash = finalization_hiding_point.x;\n\n                self.context.push_note_hash(note_hash);\n\n                // We reset public storage to zero to achieve the effect of transient storage - kernels will squash\n                // the writes\n                // TODO(#9376): Uncomment the following line.\n                // self.context.storage_write(self.hiding_point_slot, [0; aztec::protocol_types::point::POINT_LENGTH]);\n            }\n\n            pub fn emit_log(self) {\n                let max_log_len = aztec::protocol_types::constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS;\n                // Make sure we aren't overflowing the public log maximum\n                assert(\n                    $finalization_log_fields_length <= max_log_len,\n                    f\"finalization public log must not exceed {max_log_len} fields\",\n                );\n\n                // We load the setup log from storage\n                let setup_log_fields: [Field; $setup_log_fields_length] = self.context.storage_read(self.setup_log_slot);\n\n                // We append the public value to the log and emit it as unencrypted log\n                let mut finalization_log = [0; $finalization_log_fields_length];\n\n                // Populate the first field with number of public values and private values:\n                // Search the codebase for \"disgusting encoding\" to see other hardcoded instances of this encoding, that you might need to change if you ever find yourself here.\n                finalization_log[0] = aztec::protocol_types::utils::field::field_from_bytes([\n                    ($public_values_length >> 8) as u8,\n                    $public_values_length as u8,\n                    0,\n                    ($setup_log_fields_length >> 8) as u8,\n                    $setup_log_fields_length as u8,\n                ], true);\n                let mut offset = 1;\n\n                // Iterate over the partial log and copy it to the final log\n                for i in 0..setup_log_fields.len() {\n                    finalization_log[offset + i] = setup_log_fields[i];\n                }\n                offset += setup_log_fields.len();\n\n                // Iterate over the public values and append them to the log\n                for i in 0..self.public_values.len() {\n                    finalization_log[offset + i] = self.public_values[i];\n                }\n\n                // We emit the finalization log via the public logs stream\n                self.context.emit_public_log(finalization_log);\n\n                // We reset public storage to zero to achieve the effect of transient storage - kernels will squash\n                // the writes\n                // TODO(#9376): Uncomment the following line.\n                // self.context.storage_write(self.setup_log_slot, [0; $setup_log_field_length]);\n            }\n        }\n\n        impl aztec::protocol_types::traits::Empty for $finalization_payload_name {\n            fn empty() -> Self {\n                Self { context: &mut aztec::protocol_types::traits::Empty::empty(), public_values: [0; $public_values_length], hiding_point_slot: 0, setup_log_slot: 0 }\n            }\n        }\n    },\n        finalization_payload_name,\n    )\n}\n\n/// Generates `PartialNote` implementation for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// impl PartialNote<TokenNoteSetupPayload, TokenNoteFinalizationPayload> for TokenNote {\n///     fn setup_payload() -> TokenNoteSetupPayload {\n///         TokenNoteSetupPayload::empty()\n///     }\n///\n///     fn finalization_payload() -> TokenNoteFinalizationPayload {\n///         TokenNoteFinalizationPayload::empty()\n///     }\n/// }\n/// ```\ncomptime fn generate_partial_note_impl(\n    s: StructDefinition,\n    setup_payload_name: Quoted,\n    finalization_payload_name: Quoted,\n) -> Quoted {\n    let name = s.name();\n    quote {\n        impl aztec::note::note_interface::PartialNote<$setup_payload_name, $finalization_payload_name> for $name {\n            fn setup_payload() -> $setup_payload_name {\n                aztec::protocol_types::traits::Empty::empty()\n            }\n\n            fn finalization_payload() -> $finalization_payload_name {\n                aztec::protocol_types::traits::Empty::empty()\n            }\n        }\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: StructDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: StructDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - SetupPayload\n/// - FinalizationPayload\n/// - PartialNote trait implementation\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\n///\n/// `nullable_fields` are a list of quotes passed in as varargs which are used to identify which fields/struct members\n/// in the partial note are nullable.\n#[varargs]\npub comptime fn partial_note(s: StructDefinition, nullable_fields: [Quoted]) -> Quoted {\n    assert_has_owner(s);\n\n    // We separate struct members into fixed ones and nullable ones and we store info about the start index of each\n    // member in the packed note array.\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, nullable_fields);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let (setup_payload_impl, setup_payload_name) = generate_setup_payload(\n        s,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n        note_type_id,\n    );\n    let (finalization_payload_impl, finalization_payload_name) =\n        generate_finalization_payload(s, indexed_fixed_fields, indexed_nullable_fields);\n    let note_hash_impl = generate_note_hash_trait_impl_for_partial_note(\n        s,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n    let partial_note_impl =\n        generate_partial_note_impl(s, setup_payload_name, finalization_payload_name);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $setup_payload_impl\n        $finalization_payload_impl\n        $note_interface_impl\n        $note_hash_impl\n        $partial_note_impl\n        $packable_impl\n    }\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: StructDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: StructDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro and #[partial_note] macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: StructDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "128": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/storage/mod.nr",
      "source": "use std::{collections::umap::UHashMap, hash::{BuildHasherDefault, poseidon2::Poseidon2Hasher}};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: StructDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: StructDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_struct().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_struct().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_struct().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_struct().is_some() {\n        let (def, generics) = typ.as_struct().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_struct().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "129": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_struct().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_struct().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_struct().is_some() {\n        let (s, generics) = typ.as_struct().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: StructDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: StructDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\npub(crate) comptime fn is_note(typ: Type) -> bool {\n    typ.as_struct().map_or(false, |struc: (StructDefinition, [Type])| {\n        let (def, _) = struc;\n        def.has_named_attribute(\"note\")\n            | def.has_named_attribute(\"partial_note\")\n            | def.has_named_attribute(\"custom_note\")\n    })\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n"
    },
    "130": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/messaging.nr",
      "source": "use crate::{\n    hash::{compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness,\n};\n\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    merkle_tree::root::root_from_sibling_path,\n};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field,\n    leaf_index: Field,\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_l1_to_l2_message_hash(\n        portal_contract_address,\n        chain_id,\n        contract_address,\n        version,\n        content,\n        secret_hash,\n        leaf_index,\n    );\n\n    // We prove that `message_hash` is in the tree by showing the derivation of the tree root, using a merkle path we\n    // get from an oracle.\n    // Safety: The witness is only used as a \"magical value\" that makes the merkle proof below pass. Hence it's safe.\n    let (_leaf_index, sibling_path) =\n        unsafe { get_l1_to_l2_membership_witness(contract_address, message_hash, secret) };\n\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert_eq(root, l1_to_l2_root, \"Message not in state\");\n\n    compute_l1_to_l2_message_nullifier(message_hash, secret)\n}\n"
    },
    "140": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "143": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "146": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "147": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize, ToField}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "148": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "149": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "150": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\n}\n\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\n    let _ = store_in_execution_cache_oracle(values);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "151": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n    traits::{Deserialize, FromField},\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "152": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{address::AztecAddress, constants::L1_TO_L2_MSG_TREE_HEIGHT};\n\n/// Returns the leaf index and sibling path of an entry in the L1 to L2 messaging tree, which can then be used to prove\n/// its existence.\npub unconstrained fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field,\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {\n    let returned_message =\n        get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = array::subarray(returned_message, 1);\n\n    (leaf_index, sibling_path)\n}\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field,\n) -> [Field; L1_TO_L2_MSG_TREE_HEIGHT + 1] {}\n"
    },
    "155": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\n    }\n}\n"
    },
    "156": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::{\n    abis::validation_requests::{\n        key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n    },\n    traits::Deserialize,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "157": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "160": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr",
      "source": "use crate::discovery::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them\n/// available for later querying via the `get_notes` oracle.\npub unconstrained fn sync_notes() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emtitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "161": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n    traits::{Deserialize, FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    let _ = notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<RetrievedNote<Note>>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter TODO(benesjan): try removing this.\n) -> [Option<RetrievedNote<Note>>; S]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            placeholder_opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_indexed_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "163": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "165": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "172": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub unconstrained fn read(self) -> T {\n        WithHash::unconstrained_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub fn read(self) -> T {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "186": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/unencrypted_logs/unencrypted_event_emission.nr",
      "source": "use crate::{context::PublicContext, event::event_interface::EventInterface};\nuse protocol_types::traits::ToField;\n\nfn emit<Event, let N: u32>(context: &mut PublicContext, event: Event)\nwhere\n    Event: EventInterface<N>,\n{\n    let selector = Event::get_event_type_id();\n\n    let serialized_event = event.serialize();\n    let mut emitted_log = [0; N + 1];\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    for i in 0..serialized_event.len() {\n        emitted_log[i] = serialized_event[i];\n    }\n\n    emitted_log[serialized_event.len()] = selector.to_field();\n\n    context.emit_public_log(emitted_log);\n}\n\npub fn encode_event<Event, let N: u32>(\n    context: &mut PublicContext,\n) -> fn[(&mut PublicContext,)](Event) -> ()\nwhere\n    Event: EventInterface<N>,\n{\n    |e: Event| { emit(context, e); }\n}\n"
    },
    "187": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "189": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/utils/array/mod.nr",
      "source": "mod append;\nmod collapse;\nmod subarray;\nmod subbvec;\n\npub use append::append;\npub use collapse::collapse;\npub use subarray::subarray;\npub use subbvec::subbvec;\n\n// This will eventually be replaced by `BoundedVec::for_each`, once that's implemented.\npub unconstrained fn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..vec.len() {\n        f(vec.get_unchecked(i), i);\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "190": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "191": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "199": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UnconstrainedContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress,\n    block_header::BlockHeader,\n    hash::poseidon2_hash,\n    traits::{Packable, ToField},\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn unconstrained_public_storage_read(\n        context: UnconstrainedContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "215": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "217": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "24": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "253": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "260": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "261": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr",
      "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH,\n    traits::{Deserialize, Empty, Packable, Serialize, ToField},\n};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl Packable<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn pack(self) -> [Field; ETH_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "263": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "265": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "269": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_class_id.nr",
      "source": "use crate::constants::GENERATOR_INDEX__CONTRACT_LEAF;\nuse crate::traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField};\n\npub struct ContractClassId {\n    pub inner: Field,\n}\n\nimpl Eq for ContractClassId {\n    fn eq(self, other: ContractClassId) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl ToField for ContractClassId {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for ContractClassId {\n    fn from_field(value: Field) -> Self {\n        Self { inner: value }\n    }\n}\n\nimpl Serialize<1> for ContractClassId {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<1> for ContractClassId {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] }\n    }\n}\n\nimpl Empty for ContractClassId {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n// Implement the Packable trait so ContractClassId can be stored in contract's storage.\nimpl Packable<1> for ContractClassId {\n    fn pack(self) -> [Field; 1] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; 1]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl ContractClassId {\n    pub fn compute(\n        artifact_hash: Field,\n        private_functions_root: Field,\n        public_bytecode_commitment: Field,\n    ) -> Self {\n        let hash = crate::hash::poseidon2_hash_with_separator(\n            [artifact_hash, private_functions_root, public_bytecode_commitment],\n            GENERATOR_INDEX__CONTRACT_LEAF,\n        ); // TODO(@spalladino): Update generator index\n        ContractClassId::from_field(hash)\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "275": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "277": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "278": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "288": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "292": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_struct().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_struct().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_struct().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_struct().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: StructDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: StructDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: StructDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: StructDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "294": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "295": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "304": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "315": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "333": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "334": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "350": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "351": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "353": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "365": {
      "path": "/home/vscode/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "46": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "47": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "50": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"
    },
    "55": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/portal/src/encoding/deposit.nr",
      "source": "use aztec::{\n    protocol_types::{\n        address::{AztecAddress, EthAddress},\n        hash::sha256_to_field,\n        traits::{FromField, ToField},\n    },\n};\n\n// bytes4(keccak256(\"deposit(address,bytes32,uint256)\")) = 0xeb2243f8\nglobal DEPOSIT_SIGNATURE: [u8; 4] = [0xeb, 0x22, 0x43, 0xf8];\n\npub fn deposit_content_hash(\n    eth_token: EthAddress,\n    recipient: AztecAddress,\n    amount: Field,\n) -> Field {\n    let encoded = abi_encode_deposit(eth_token, recipient, amount);\n    let content_hash = sha256_to_field(encoded);\n    content_hash\n}\n\npub fn abi_encode_deposit(\n    eth_token: EthAddress,\n    recipient: AztecAddress,\n    amount: Field,\n) -> [u8; 100] {\n    // abi.encodeWithSignature(DEPOSIT_SIGNATURE, tokenAddr, recipient, amount)\n    // This encodes the following data:\n    // offset - data\n    // 0x00 - 4 bytes for the signature\n    // 0x04 - 32 bytes for the token address\n    // 0x24 - 32 bytes for the recipient\n    // 0x44 - 32 bytes for the amount\n    // Total: 100 bytes\n    let mut encoded = [0; 100];\n    for i in 0..4 {\n        encoded[i] = DEPOSIT_SIGNATURE[i];\n    }\n\n    let eth_token_bytes: [u8; 32] = eth_token.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = amount.to_be_bytes();\n\n    for i in 0..32 {\n        encoded[i + 0x4] = eth_token_bytes[i];\n        encoded[i + 0x24] = recipient_bytes[i];\n        encoded[i + 0x44] = amount_bytes[i];\n    }\n\n    encoded\n}\n\n// For testing purposes, enables printing the ABI-encoded data\npub unconstrained fn field_from_encoded_bytes(encoded: [u8; 100], offset: u8) -> Field {\n    let mut arr = [0; 31];\n    for i in 0..31 {\n        if offset + i >= 100 {\n            break;\n        }\n        arr[i] = encoded[offset + i];\n    }\n    aztec::protocol_types::utils::field::field_from_bytes(arr, true)\n}\n\n#[test]\nfn test_abi_encode_deposit() {\n    let eth_token = EthAddress::from_field(0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F);\n    let recipient = AztecAddress::from_field(\n        0x1e571fd19f8f3aab48fd795e1b39f72dd61f44735c88a7576721be8a5065f863,\n    );\n    let amount = 0x1234567890abcdef1234567890abcdef;\n    let encoded = abi_encode_deposit(eth_token, recipient, amount);\n\n    // abi.encodeWithSignature(\"deposit(address,bytes32,uint256)\", address(0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F), bytes32(hex\"1e571fd19f8f3aab48fd795e1b39f72dd61f44735c88a7576721be8a5065f863\"), 0x1234567890abcdef1234567890abcdef) =\n    // 0xeb2243f80000000000000000000000002458675deb5e0691da2d2ba8dcaf58cfd2c2651f1e571fd19f8f3aab48fd795e1b39f72dd61f44735c88a7576721be8a5065f863000000000000000000000000000000001234567890abcdef1234567890abcdef\n    let expected: [u8; 100] = [\n        0xeb, 0x22, 0x43, 0xf8, // Function selector - deposit(address,bytes32,uint256)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F\n        0x24, 0x58, 0x67, 0x5d, 0xeb, 0x5e, 0x06, 0x91, 0xda, 0x2d, 0x2b, 0xa8, 0xdc, 0xaf, 0x58,\n        0xcf, 0xd2, 0xc2, 0x65, 0x1f,\n        // Aztec Recipient Address\n        0x1e, 0x57, 0x1f, 0xd1, 0x9f, 0x8f, 0x3a, 0xab, 0x48, 0xfd, 0x79, 0x5e, 0x1b, 0x39, 0xf7,\n        0x2d, 0xd6, 0x1f, 0x44, 0x73, 0x5c, 0x88, 0xa7, 0x57, 0x67, 0x21, 0xbe, 0x8a, 0x50, 0x65,\n        0xf8, 0x63,\n        // Amount\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,\n        0xcd, 0xef,\n    ];\n\n    if encoded != expected {\n        std::println(f\"test_abi_encode_deposit: got: {encoded}\");\n        std::println(f\"test_abi_encode_deposit: expected: {expected}\");\n    }\n    assert_eq(encoded, expected);\n}\n\n#[test]\nfn test_deposit_content_hash() {\n    let content: [u8; 100] = [\n        0xeb, 0x22, 0x43, 0xf8, // Function selector - deposit(address,bytes32,uint256)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F\n        0x24, 0x58, 0x67, 0x5d, 0xeb, 0x5e, 0x06, 0x91, 0xda, 0x2d, 0x2b, 0xa8, 0xdc, 0xaf, 0x58,\n        0xcf, 0xd2, 0xc2, 0x65, 0x1f,\n        // Aztec Recipient Address\n        0x1e, 0x57, 0x1f, 0xd1, 0x9f, 0x8f, 0x3a, 0xab, 0x48, 0xfd, 0x79, 0x5e, 0x1b, 0x39, 0xf7,\n        0x2d, 0xd6, 0x1f, 0x44, 0x73, 0x5c, 0x88, 0xa7, 0x57, 0x67, 0x21, 0xbe, 0x8a, 0x50, 0x65,\n        0xf8, 0x63,\n        // Amount\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,\n        0xcd, 0xef,\n    ];\n\n    // sha256(content) = 0x5a05320993a46599dc6c5605c5f2bf139d6fb5f3709e23c5af2b530f1e883aa8\n    // sha256_to_field uses the first 31 bytes of the hash\n    let expected: Field = 0x5a05320993a46599dc6c5605c5f2bf139d6fb5f3709e23c5af2b530f1e883a;\n    let content_hash = sha256_to_field(content);\n    if content_hash != expected {\n        std::println(f\"test_deposit_content_hash: got: {content_hash}\");\n        std::println(f\"test_deposit_content_hash: expected: {expected}\");\n    }\n    assert_eq(content_hash, expected);\n}\n"
    },
    "57": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/portal/src/encoding/register.nr",
      "source": "use aztec::{\n    protocol_types::{\n        address::EthAddress,\n        hash::sha256_to_field,\n        traits::{FromField, ToField},\n    },\n};\n\n// bytes4(keccak256(register(address,string,string,uint8))) = 0x611a7a19\ncomptime global REGISTER_SIGNATURE: [u8; 4] = [0x61, 0x1a, 0x7a, 0x19];\n\npub fn register_content_hash(\n    eth_token: EthAddress,\n    name: str<31>,\n    name_len: u8,\n    symbol: str<31>,\n    symbol_len: u8,\n    decimals: u8,\n) -> Field {\n    let encoded = abi_encode_register(eth_token, name, name_len, symbol, symbol_len, decimals);\n    let content_hash = sha256_to_field(encoded);\n\n    // Debug log the ABI-encoded data\n    // let field_array: [Field; 9] = aztec::utils::bytes::bytes_to_fields::<260, 9>(encoded);\n    // dep::aztec::oracle::debug_log::debug_log_format(\"ABI Encoded: {}\", field_array);\n    content_hash\n}\n\npub fn abi_encode_register(\n    eth_token: EthAddress,\n    name: str<31>,\n    name_len: u8,\n    symbol: str<31>,\n    symbol_len: u8,\n    decimals: u8,\n) -> [u8; 260] {\n    // abi.encodeWithSignature(REGISTER_SIGNATURE, tokenAddr, token.name(), token.symbol(), token.decimals())\n    // This encodes the following data:\n    // offset - data\n    // 0x00 - 4 bytes for the signature\n    // 0x04 - 32 bytes for the token address\n    // 0x24 - 32 bytes for the name offset\n    // 0x44 - 32 bytes for the symbol offset\n    // 0x64 - 32 bytes for the decimals\n    // 0x84 - 32 bytes for the name length\n    // 0xa4 - 32 bytes for the name // Limited to 31 bytes\n    // 0xc4 - 32 bytes for the symbol length\n    // 0xe4 - 32 bytes for the symbol // Limited to 31 bytes\n    // Total: 260 bytes\n    let mut encoded = [0; 260];\n\n    let eth_token_bytes: [u8; 32] = eth_token.to_field().to_be_bytes();\n    let decimals_bytes: [u8; 32] = decimals.to_field().to_be_bytes();\n\n    let name_len_bytes: [u8; 32] = name_len.to_field().to_be_bytes();\n    let symbol_len_bytes: [u8; 32] = symbol_len.to_field().to_be_bytes();\n\n    // Fixed offsets for name and symbol\n    // Offset for the name is 0x80 per the ABI encoding, but 0x84 in the raw data\n    let name_offset_bytes: [u8; 32] = 0x80.to_field().to_be_bytes();\n    // Offset for the symbol is 0xc0 per the ABI encoding, but 0xc4 in the raw data\n    let symbol_offset_bytes: [u8; 32] = 0xc0.to_field().to_be_bytes();\n\n    let name_bytes: [u8; 31] = name.as_bytes();\n    let symbol_bytes: [u8; 31] = symbol.as_bytes();\n\n    for i in 0..32 {\n        // First 4 bytes are the function signature\n        if i < 4 {\n            encoded[i] = REGISTER_SIGNATURE[i];\n        }\n\n        encoded[i + 0x4] = eth_token_bytes[i];\n        encoded[i + 0x24] = name_offset_bytes[i];\n        encoded[i + 0x44] = symbol_offset_bytes[i];\n        encoded[i + 0x64] = decimals_bytes[i];\n        encoded[i + 0x84] = name_len_bytes[i];\n        encoded[i + 0xc4] = symbol_len_bytes[i];\n\n        // Copy name & symbol\n        if i < name_len {\n            encoded[i + 0xa4] = name_bytes[i];\n        }\n        if i < symbol_len {\n            encoded[i + 0xe4] = symbol_bytes[i];\n        }\n    }\n\n    encoded\n}\n\nunconstrained fn pad_31<let N: u32>(s: str<N>) -> str<31> {\n    let mut padded = [0; 31];\n    let s = s.as_bytes();\n    for i in 0..31 {\n        if i < N {\n            padded[i] = s[i];\n        }\n    }\n    padded.as_str_unchecked()\n}\n\n#[test]\nunconstrained fn test_abi_encode_register() {\n    let eth_token = EthAddress::from_field(0xbbEda607223492F9dce036A21C459fE1dcab56c7);\n    let name = pad_31(\"Test Token\");\n    let symbol = pad_31(\"TT\");\n    let decimals = 18;\n    let encoded = abi_encode_register(eth_token, name, 10, symbol, 2, decimals);\n\n    // abi.encodeWithSignature(\"register(address,string,string,uint8)\", address(0xbbEda607223492F9dce036A21C459fE1dcab56c7), \"Test Token\", \"TT\", 18) =\n    // 0x611a7a19000000000000000000000000bbeda607223492f9dce036a21c459fe1dcab56c7000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000a5465737420546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000025454000000000000000000000000000000000000000000000000000000000000\n    let expected: [u8; 260] = [\n        0x61, 0x1a, 0x7a, 0x19, // Function selector - register(address,string,string,uint8)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0xbbEda607223492F9dce036A21C459fE1dcab56c7\n        0xbb, 0xed, 0xa6, 0x07, 0x22, 0x34, 0x92, 0xf9, 0xdc, 0xe0, 0x36, 0xa2, 0x1c, 0x45, 0x9f,\n        0xe1, 0xdc, 0xab, 0x56, 0xc7,\n        // Name Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x80,\n        // Symbol Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0xc0,\n        // Decimals: 18\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12,\n        // Name Length: 10\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x0a,\n        // Name: Test Token\n        0x54, 0x65, 0x73, 0x74, 0x20, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n        // Symbol Length: 2\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x02,\n        // Symbol: TT\n        0x54, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n\n    if encoded != expected {\n        std::println(f\"test_abi_encode_register: got: {encoded}\");\n        std::println(f\"test_abi_encode_register: expected: {expected}\");\n    }\n    assert_eq(encoded, expected);\n}\n\n#[test]\nunconstrained fn test_register_content_hash() {\n    let content: [u8; 260] = [\n        0x61, 0x1a, 0x7a, 0x19, // Function selector - register(address,string,string,uint8)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0xbbEda607223492F9dce036A21C459fE1dcab56c7\n        0xbb, 0xed, 0xa6, 0x07, 0x22, 0x34, 0x92, 0xf9, 0xdc, 0xe0, 0x36, 0xa2, 0x1c, 0x45, 0x9f,\n        0xe1, 0xdc, 0xab, 0x56, 0xc7,\n        // Name Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x80,\n        // Symbol Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0xc0,\n        // Decimals: 18\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12,\n        // Name Length: 10\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x0a,\n        // Name: Test Token\n        0x54, 0x65, 0x73, 0x74, 0x20, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n        // Symbol Length: 2\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x02,\n        // Symbol: TT\n        0x54, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    // sha256(content) = 0x0448b4e27885c9528619c3ccd291634a7aa4f66d562d479904429803f535d9f4\n    // sha256_to_field uses the first 31 bytes of the hash\n    let expected: Field = 0x0448b4e27885c9528619c3ccd291634a7aa4f66d562d479904429803f535d9;\n    let content_hash = sha256_to_field(content);\n    if content_hash != expected {\n        std::println(f\"test_register_content_hash: got: {content_hash}\");\n        std::println(f\"test_register_content_hash: expected: {expected}\");\n    }\n    assert_eq(content_hash, expected);\n}\n"
    },
    "58": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/portal/src/encoding/withdraw.nr",
      "source": "use aztec::protocol_types::{\n    address::EthAddress,\n    hash::sha256_to_field,\n    traits::{FromField, ToField},\n};\n\n// bytes4(keccak256(\"withdraw(address,address,uint256)\")) = 0xd9caed12\nglobal WITHDRAW_SIGNATURE: [u8; 4] = [0xd9, 0xca, 0xed, 0x12];\n\npub fn withdraw_content_hash(eth_token: EthAddress, recipient: EthAddress, amount: Field) -> Field {\n    let encoded = abi_encode_withdraw(eth_token, recipient, amount);\n    let content_hash = sha256_to_field(encoded);\n    content_hash\n}\n\npub fn abi_encode_withdraw(\n    eth_token: EthAddress,\n    recipient: EthAddress,\n    amount: Field,\n) -> [u8; 100] {\n    // abi.encodeWithSignature(WITHDRAW_SIGNATURE, tokenAddr, recipient, amount)\n    // This encodes the following data:\n    // offset - data\n    // 0x00 - 4 bytes for the signature\n    // 0x04 - 32 bytes for the token address\n    // 0x24 - 32 bytes for the recipient\n    // 0x44 - 32 bytes for the amount\n    // Total: 100 bytes\n    let mut encoded = [0; 100];\n    for i in 0..4 {\n        encoded[i] = WITHDRAW_SIGNATURE[i];\n    }\n\n    let eth_token_bytes: [u8; 32] = eth_token.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = amount.to_be_bytes();\n\n    for i in 0..32 {\n        encoded[i + 0x4] = eth_token_bytes[i];\n        encoded[i + 0x24] = recipient_bytes[i];\n        encoded[i + 0x44] = amount_bytes[i];\n    }\n\n    encoded\n}\n\n#[test]\nfn test_abi_encode_withdraw() {\n    let eth_token = EthAddress::from_field(0xbbEda607223492F9dce036A21C459fE1dcab56c7);\n    let recipient = EthAddress::from_field(0x52b1D2CEBF3C80813f82dC4B5F56fCB4e04aC439);\n    let amount = 0x1234567890abcdef;\n    let encoded = abi_encode_withdraw(eth_token, recipient, amount);\n\n    // abi.encodeWithSignature(\"withdraw(address,address,uint256)\", address(0xbbEda607223492F9dce036A21C459fE1dcab56c7), address(0x52b1D2CEBF3C80813f82dC4B5F56fCB4e04aC439), 0x1234567890abcdef) =\n    // 0xd9caed12000000000000000000000000bbeda607223492f9dce036a21c459fe1dcab56c700000000000000000000000052b1d2cebf3c80813f82dc4b5f56fcb4e04ac4390000000000000000000000000000000000000000000000001234567890abcdef\n    let expected: [u8; 100] = [\n        0xd9, 0xca, 0xed, 0x12, // Function selector - withdraw(address,address,uint256)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0xbbEda607223492F9dce036A21C459fE1dcab56c7\n        0xbb, 0xed, 0xa6, 0x07, 0x22, 0x34, 0x92, 0xf9, 0xdc, 0xe0, 0x36, 0xa2, 0x1c, 0x45, 0x9f,\n        0xe1, 0xdc, 0xab, 0x56, 0xc7,\n        // Recipient Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0x52b1D2CEBF3C80813f82dC4B5F56fCB4e04aC439\n        0x52, 0xb1, 0xd2, 0xce, 0xbf, 0x3c, 0x80, 0x81, 0x3f, 0x82, 0xdc, 0x4b, 0x5f, 0x56, 0xfc,\n        0xb4, 0xe0, 0x4a, 0xc4, 0x39,\n        // Amount: 0x1234567890abcdef\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,\n        0xcd, 0xef,\n    ];\n\n    assert_eq(encoded, expected);\n}\n"
    },
    "59": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/portal/src/main.nr",
      "source": "mod constants;\nmod encoding;\n\nuse aztec::macros::aztec;\n\n#[aztec]\npub contract Portal {\n    use std::meta::derive;\n\n    use aztec::{\n        event::event_interface::EventInterface,\n        hash::hash_args,\n        macros::{\n            events::event,\n            functions::{\n                initialization_utils::compute_initialization_hash, initializer, internal, private,\n                public,\n            },\n            storage::storage,\n        },\n        protocol_types::{\n            address::{AztecAddress, EthAddress, PartialAddress},\n            contract_class_id::ContractClassId,\n            public_keys::PublicKeys,\n            traits::{FromField, Serialize, ToField},\n        },\n        state_vars::{Map, PublicImmutable},\n        unencrypted_logs::unencrypted_event_emission::encode_event,\n    };\n\n    use authwit::auth::assert_current_call_valid_authwit_public;\n\n    use token::Token;\n\n    use crate::{\n        constants::PUBLIC_NOT_SECRET_SECRET,\n        encoding::{\n            deposit::deposit_content_hash, register::register_content_hash,\n            withdraw::withdraw_content_hash,\n        },\n    };\n\n    #[storage]\n    struct Storage<Context> {\n        l1_portal: PublicImmutable<EthAddress, Context>,\n        l1_tokens: Map<EthAddress, PublicImmutable<AztecAddress, Context>, Context>,\n        l2_tokens: Map<AztecAddress, PublicImmutable<EthAddress, Context>, Context>,\n        token_contract_class_id: PublicImmutable<ContractClassId, Context>,\n        shield_gateway_beacon: PublicImmutable<AztecAddress, Context>,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Register {\n        eth_token: EthAddress,\n        aztec_token: AztecAddress,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Deposit {\n        eth_token: EthAddress,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Withdraw {\n        token: EthAddress,\n        from: AztecAddress,\n        to: EthAddress,\n        amount: u128,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(\n        l1_portal: Field,\n        token_contract_class: Field,\n        shield_gateway_beacon: AztecAddress,\n    ) {\n        assert(l1_portal != 0, \"L1 portal address cannot be zero\");\n        assert(token_contract_class != 0, \"Token contract class cannot be zero\");\n\n        storage.l1_portal.initialize(EthAddress::from_field(l1_portal));\n        storage.token_contract_class_id.initialize(ContractClassId::from_field(\n            token_contract_class,\n        ));\n        storage.shield_gateway_beacon.initialize(shield_gateway_beacon);\n    }\n\n    #[private]\n    fn register_private(\n        eth_token: Field,\n        aztec_token: AztecAddress,\n        name: str<31>,\n        name_len: u8,\n        symbol: str<31>,\n        symbol_len: u8,\n        decimals: u8,\n        message_leaf_index: Field,\n    ) {\n        aztec::oracle::debug_log::debug_log_format(\n            \"Registering L1 token {0} as L2 token {1}\",\n            [eth_token, aztec_token.to_field()],\n        );\n\n        let eth_token = EthAddress::from_field(eth_token);\n\n        assert(storage.l1_tokens.at(eth_token).read().is_zero(), \"Token already registered\");\n\n        // L1->L2 message content hash from token name, symbol, decimals\n        let content_hash =\n            register_content_hash(eth_token, name, name_len, symbol, symbol_len, decimals);\n        aztec::oracle::debug_log::debug_log_format(\"Register content hash: {0}\", [content_hash]);\n\n        // Set the shield gateway beacon\n        Token::at(aztec_token)\n            .set_shield_gateway_beacon(storage.shield_gateway_beacon.read())\n            .enqueue(&mut context);\n\n        // Ensure the supplied token address matches the expected address. This ensures its deployed with\n        // the correct code and initialization parameters.\n        let initializer = Token::interface().init(context.this_address(), name, symbol, decimals);\n        let args_hash = hash_args(initializer.args);\n        let init_hash = compute_initialization_hash(initializer.selector, args_hash);\n        let partial_address = PartialAddress::compute(\n            storage.token_contract_class_id.read(),\n            0x9876543210, // salt, hardcoded\n            init_hash,\n            AztecAddress::from_field(0),\n        );\n\n        let computed_address = AztecAddress::compute(PublicKeys::default(), partial_address);\n        // aztec::oracle::debug_log::debug_log_format(\n        //     \"Supplied Address: {0}, Computed address: {1}\",\n        //     [aztec_token.to_field(), computed_address.to_field()]\n        // );\n        // aztec::oracle::debug_log::debug_log_format(\"Gas left 4: {0}\", [context.l2_gas_left()]);\n        assert(\n            computed_address == aztec_token,\n            \"Expected address did not match supplized token address\",\n        );\n\n        // Consume the message\n        aztec::oracle::debug_log::debug_log_format(\n            \"Consuming message with leaf index {0}\",\n            [message_leaf_index],\n        );\n\n        let l1Portal = storage.l1_portal.read();\n        aztec::oracle::debug_log::debug_log_format(\"L1 Portal: {0}\", [l1Portal.to_field()]);\n\n        context.consume_l1_to_l2_message(\n            content_hash,\n            PUBLIC_NOT_SECRET_SECRET,\n            storage.l1_portal.read(),\n            message_leaf_index,\n        );\n\n        Portal::at(context.this_address())._register_public(aztec_token, eth_token).enqueue(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _register_public(aztec_token: AztecAddress, eth_token: EthAddress) {\n        // Initialize the token mappings\n        storage.l1_tokens.at(eth_token).initialize(aztec_token);\n        storage.l2_tokens.at(aztec_token).initialize(eth_token);\n        Register { eth_token, aztec_token }.emit(encode_event(&mut context));\n    }\n\n    #[private]\n    fn claim_public(\n        eth_token: Field,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        let eth_token = EthAddress::from_field(eth_token);\n\n        let content_hash = deposit_content_hash(eth_token, recipient, amount.to_field());\n        aztec::oracle::debug_log::debug_log_format(\"Deposit content hash: {0}\", [content_hash]);\n\n        // Consume the message\n        context.consume_l1_to_l2_message(\n            content_hash,\n            PUBLIC_NOT_SECRET_SECRET,\n            storage.l1_portal.read(),\n            message_leaf_index,\n        );\n\n        Portal::at(context.this_address())\n            ._claim_public(eth_token, recipient, amount, message_leaf_index)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _claim_public(\n        eth_token: EthAddress,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        Token::at(storage.l1_tokens.at(eth_token).read()).mint_public(recipient, amount).call(\n            &mut context,\n        );\n\n        Portal::at(context.this_address())\n            ._log_claim(eth_token, recipient, amount, message_leaf_index)\n            .call(&mut context);\n    }\n\n    #[private]\n    fn claim_shielded(\n        eth_token: Field,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        let eth_token = EthAddress::from_field(eth_token);\n\n        let content_hash = deposit_content_hash(eth_token, recipient, amount.to_field());\n        aztec::oracle::debug_log::debug_log_format(\"Deposit content hash: {0}\", [content_hash]);\n\n        // Consume the message\n        context.consume_l1_to_l2_message(\n            content_hash,\n            PUBLIC_NOT_SECRET_SECRET,\n            storage.l1_portal.read(),\n            message_leaf_index,\n        );\n\n        Token::at(storage.l1_tokens.at(eth_token).read()).mint_shielded(recipient, amount).call(\n            &mut context,\n        );\n\n        Portal::at(context.this_address())\n            ._log_claim(eth_token, recipient, amount, message_leaf_index)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _log_claim(\n        eth_token: EthAddress,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        Deposit { eth_token, recipient, amount, message_leaf_index }.emit(encode_event(\n            &mut context,\n        ));\n    }\n\n    #[public]\n    fn withdraw_public(\n        eth_token: EthAddress,\n        from: AztecAddress,\n        recipient: EthAddress,\n        amount: u128,\n        withdrawNonce: Field,\n        burnNonce: Field,\n    ) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(withdrawNonce == 0, \"Invalid nonce\");\n        }\n\n        // Burn the tokens\n        Token::at(storage.l1_tokens.at(eth_token).read()).burn_public(from, amount, burnNonce).call(\n            &mut context,\n        );\n\n        // Message the L1 Portal\n        let content_hash = withdraw_content_hash(eth_token, recipient, amount.to_field());\n        context.message_portal(storage.l1_portal.read(), content_hash);\n\n        aztec::oracle::debug_log::debug_log_format(\"Withdraw L2ToL1 Message {0}\", [content_hash]);\n\n        Withdraw { token: eth_token, from, to: recipient, amount }.emit(encode_event(&mut context));\n    }\n\n    unconstrained fn is_registered_l1(eth_token: Field) -> pub bool {\n        let eth_token = EthAddress::from_field(eth_token);\n        !storage.l1_tokens.at(eth_token).read().is_zero()\n    }\n\n    unconstrained fn is_registered_l2(aztec_token: AztecAddress) -> pub bool {\n        !storage.l2_tokens.at(aztec_token).read().is_zero()\n    }\n\n    unconstrained fn get_l2_token(eth_token: Field) -> pub AztecAddress {\n        let eth_token = EthAddress::from_field(eth_token);\n        storage.l1_tokens.at(eth_token).read()\n    }\n\n    unconstrained fn get_l1_token(aztec_token: AztecAddress) -> pub EthAddress {\n        storage.l2_tokens.at(aztec_token).read()\n    }\n\n    unconstrained fn get_l1_portal() -> pub EthAddress {\n        storage.l1_portal.read()\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "61": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/authwit/src/auth.nr",
      "source": "use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\nuse dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::ToField,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\nglobal IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "69": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T, let N: u32> CapsuleArray<T>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T) {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().unkonstrained().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n}\n"
    },
    "70": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.set_public_teardown_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "77": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, FromField, Hash, ToField},\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        execution_cache::store(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            enqueue_public_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.set_public_teardown_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            set_public_teardown_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "78": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, args);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, args);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "79": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "80": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "82": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/discovery/mod.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS, debug_log::debug_log,\n};\n\npub mod private_logs;\npub mod partial_notes;\npub mod nonce_discovery;\n\n/// We reserve two fields in the note private log that are not part of the note content: one for the storage slot, and\n/// one for the combined log and note type ID.\nglobal NOTE_PRIVATE_LOG_RESERVED_FIELDS: u32 = 2;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size and extra\n/// fields in the log (e.g. the combined log and note type ID).\n// TODO (#11634): we're assuming here that the entire log is plaintext, which is not true due to headers, encryption\n// padding, etc. Notes can't actually be this large.\npub global MAX_NOTE_PACKED_LEN: u32 = PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_PRIVATE_LOG_RESERVED_FIELDS;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of note discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note_content, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note_content */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the note discovery process, in which private and public logs are downloaded and inspected to find private\n/// notes, partial notes, and their completion. This is the mechanism via which PXE learns of new notes.\n///\n/// Receives the address of the contract on which discovery is performed (i.e. the contract that emitted the notes)\n/// along with its `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_notes<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing note discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "83": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/discovery/nonce_discovery.nr",
      "source": "use crate::{discovery::{ComputeNoteHashAndNullifier, MAX_NOTE_PACKED_LEN}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting note discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    array::for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n            // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n            // the note hash at the array index we're currently processing.\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes = compute_note_hash_and_nullifier(\n                packed_note_content,\n                storage_slot,\n                note_type_id,\n                contract_address,\n                candidate_nonce,\n            )\n                .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n            let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n            let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n            if unique_note_hash == expected_unique_note_hash {\n                // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n                // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n                // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n                // PXE may fail to realize that a given note has been nullified already, and calls to the application\n                // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n                // application already has more direct means of making a call to it fail the transaction.\n                discovered_notes.push(\n                    DiscoveredNoteInfo {\n                        nonce: candidate_nonce,\n                        note_hash: hashes.note_hash,\n                        inner_nullifier: hashes.inner_nullifier,\n                    },\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n"
    },
    "84": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    discovery::{\n        ComputeNoteHashAndNullifier,\n        nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n        private_logs::MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN,\n    },\n    oracle::note_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    traits::{Deserialize, Serialize, ToField},\n};\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\n// TODO(#11630): come up with some sort of slot allocation scheme.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = 77;\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    let mut i = &mut 0;\n    whyle(\n        || *i < pending_partial_notes.len(),\n        || {\n            let pending_partial_note: DeliveredPendingPartialNote = pending_partial_notes.get(*i);\n\n            let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n            if maybe_log.is_none() {\n                debug_log_format(\n                    \"Found no completion logs for partial note #{}\",\n                    [(*i) as Field],\n                );\n                *i += 1 as u32;\n                // Note that we're not removing the pending partial note from the PXE DB, so we will continue searching\n                // for this tagged log when performing note discovery in the future until we either find it or the entry\n                // is somehow removed from the PXE DB.\n            } else {\n                debug_log_format(\"Completion log found for partial note #{}\", [(*i) as Field]);\n                let log = maybe_log.unwrap();\n\n                // Public logs have an extra field at the beginning with the contract address, which we use to verify\n                // that we're getting the logs from the expected contract.\n                // TODO(#10273): improve how contract log siloing is handled\n                assert_eq(\n                    log.log_content.get(0),\n                    contract_address.to_field(),\n                    \"Got a public log emitted by a different contract\",\n                );\n\n                // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n                // private and public packed fields (i.e. the contents of the log sans the extra fields) to get the\n                // complete packed content.\n                let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                    array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n                let complete_packed_note_content = array::append(\n                    pending_partial_note.packed_private_note_content,\n                    packed_public_note_content,\n                );\n\n                let discovered_notes = attempt_note_nonce_discovery(\n                    log.unique_note_hashes_in_tx,\n                    log.first_nullifier_in_tx,\n                    compute_note_hash_and_nullifier,\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    pending_partial_note.note_type_id,\n                    complete_packed_note_content,\n                );\n\n                debug_log_format(\n                    \"Discovered {0} notes for partial note {1}\",\n                    [discovered_notes.len() as Field, (*i) as Field],\n                );\n\n                array::for_each_in_bounded_vec(\n                    discovered_notes,\n                    |discovered_note: DiscoveredNoteInfo, _| {\n                        // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                        // temporary node connectivity issue - is simply throwing good enough here?\n                        assert(\n                            deliver_note(\n                                contract_address,\n                                pending_partial_note.storage_slot,\n                                discovered_note.nonce,\n                                complete_packed_note_content,\n                                discovered_note.note_hash,\n                                discovered_note.inner_nullifier,\n                                log.tx_hash,\n                                pending_partial_note.recipient,\n                            ),\n                            \"Failed to deliver note\",\n                        );\n                    },\n                );\n\n                // Because there is only a single log for a given tag, once we've processed the tagged log then we\n                // simply delete the pending work entry, regardless of whether it was actually completed or not.\n                // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n                // being completed.\n                pending_partial_notes.remove(*i);\n            }\n        },\n    );\n}\n\n/// Custom version of a while loop, calls `body` repeatedly until `condition` returns false. To be removed once Noir\n/// supports looping in unconstrained code.\nfn whyle<Env, Env2>(condition: fn[Env]() -> bool, body: fn[Env2]() -> ()) {\n    if condition() {\n        body();\n        whyle(condition, body);\n    }\n}\n"
    },
    "85": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/discovery/private_logs.nr",
      "source": "use std::static_assert;\n\nuse crate::{\n    capsules::CapsuleArray,\n    oracle::note_discovery::{deliver_note, sync_notes},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\n    debug_log::{debug_log, debug_log_format},\n};\n\nuse crate::discovery::{\n    ComputeNoteHashAndNullifier,\n    MAX_NOTE_PACKED_LEN,\n    nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n    NOTE_PRIVATE_LOG_RESERVED_FIELDS,\n    partial_notes::{\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT, DeliveredPendingPartialNote,\n    },\n};\n\npub global PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN: u32 = 1;\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private log (i.e.\n/// the note completion log tag).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_NOTE_PACKED_LEN - PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN;\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    _contract_address: AztecAddress,\n    _compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually fetch tagged logs, decrypt and process them here, but for now we simply call the `syncNotes`\n    // oracle. This has PXE perform tag synchronization, log download, decryption, and finally calls to the the\n    // `process_log` contract function with the decrypted payload, which will in turn call `do_process_log` with a\n    // decrypted log, letting us continue the work outside of PXE.\n    sync_notes();\n}\n\n/// Processes a log's plaintext, searching for private notes or partial notes. Private notes result in nonce discovery\n/// being performed prior to delivery, which requires knowledge of the transaction hash in which the notes would've been\n/// created (typically the same transaction in which the log was emitted), along with the list of unique note hashes in\n/// said transaction and the `compute_note_hash_and_nullifier` function.\npub unconstrained fn do_process_log<Env>(\n    contract_address: AztecAddress,\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // The first thing to do is to determine what type of private log we're processing. We currently just have two log\n    // types: 0 for private notes and 1 for partial notes. This will likely be expanded and improved upon in the future\n    // to also handle events, etc.\n\n    let (storage_slot, note_type_id, log_type_id, log_payload) =\n        destructure_log_plaintext(log_plaintext);\n\n    if log_type_id == 0 {\n        debug_log(\"Processing private note log\");\n\n        process_private_note_log(\n            contract_address,\n            tx_hash,\n            unique_note_hashes_in_tx,\n            first_nullifier_in_tx,\n            recipient,\n            compute_note_hash_and_nullifier,\n            storage_slot,\n            note_type_id,\n            log_payload,\n        );\n    } else if log_type_id == 1 {\n        debug_log(\"Processing partial note private log\");\n\n        process_partial_note_private_log(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            log_payload,\n            recipient,\n        );\n    } else {\n        panic(f\"Unknown log type id {log_type_id}\");\n    }\n}\n\nunconstrained fn destructure_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    assert(log_plaintext.len() >= NOTE_PRIVATE_LOG_RESERVED_FIELDS);\n\n    // If NOTE_PRIVATE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\n    // `storage_slot` and `note_type_id` must be updated as well.\n    static_assert(\n        NOTE_PRIVATE_LOG_RESERVED_FIELDS == 2,\n        \"unexpected value for NOTE_PRIVATE_LOG_RESERVED_FIELDS\",\n    );\n    let storage_slot = log_plaintext.get(0);\n\n    // We currently identify log types by packing the log type ID and note type ID into a single field, called the\n    // combined type ID. We can do this because the note type ID is only 7 bits long, and so use an 8th bit to\n    // distinguish private note logs and partial note logs.\n    // This abuses the fact that the encoding of both of these logs is extremely similar, and will need improving and\n    // more formalization once we introduce other disimilar log types, such as events. Ideally we'd be able to leverage\n    // enums and tagged unions to achieve this goal.\n    let combined_type_id = log_plaintext.get(1);\n    let note_type_id = ((combined_type_id as u64) % 128) as Field;\n    let log_type_id = ((combined_type_id as u64) / 128) as Field;\n\n    let log_payload = array::subbvec(log_plaintext, NOTE_PRIVATE_LOG_RESERVED_FIELDS);\n\n    (storage_slot, note_type_id, log_type_id, log_payload)\n}\n\nunconstrained fn process_private_note_log<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note_content,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private log\",\n        [discovered_notes.len() as Field],\n    );\n\n    array::for_each_in_bounded_vec(\n        discovered_notes,\n        |discovered_note: DiscoveredNoteInfo, _| {\n            // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n            // issue, and we should perhaps not have marked the tag index as taken.\n            assert(\n                deliver_note(\n                    contract_address,\n                    storage_slot,\n                    discovered_note.nonce,\n                    packed_note_content,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    tx_hash,\n                    recipient,\n                ),\n                \"Failed to deliver note\",\n            );\n        },\n    );\n}\n\nunconstrained fn process_partial_note_private_log(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    log_payload: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    recipient: AztecAddress,\n) {\n    // We store the information of the partial note we found so that we can later search for the public log that will\n    // complete it. The tag is the first value in the payload, with the packed note content taking up the rest of it.\n    static_assert(\n        PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN == 1,\n        \"unexpected value for PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN\",\n    );\n\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag: log_payload.get(0),\n        storage_slot,\n        note_type_id,\n        packed_private_note_content: array::subbvec(log_payload, 1),\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n"
    },
    "97": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    }
  }
}
