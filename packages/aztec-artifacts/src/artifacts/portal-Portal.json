{
  "transpiled": true,
  "noir_version": "1.0.0-beta.3+0000000000000000000000000000000000000000",
  "name": "Portal",
  "functions": [
    {
      "name": "claim_shielded",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17288131482828810359": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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fc05R1+tXcSNc/T1fS6s+eU151ysn+dwLtaPEefo69cuztHX15xzsfq1KHAu1o8R5+jL167AOfr6mnOOvly7CMKaX97nnKOvrznnYv08h3Oxfow4R1+/dnGOvrzmkXOx+rUoci7WjxHn6OvXLs7R19dcWPOrtYvIOfr6PuccfX3NORfr5zmci/VjxDn68rUrcY6+vuaci9WvRYlzsX6MOEdfv3YJa355zTlHX65dJM7R1/c55+jra865WD/P4VysHiPhHH352iWco6+vOedi/WsR52L9GAkxunzt4hx9fc05R1+uXQjn6Ov7nHP09TXnXKye52TOxfox4hx9+dqVOUdfX3POxfrXIiFG6jHiHH392sU5+vqac46+XLvInKOv73PO0ZfXvHAuVs9zCudi/Rhxjr5+7eIcfX3NhTVXvxZxLtaPEefo69cuztHX15xz9OXaReEcfXmfV87R19ecc7F6nlM5F+vHiHP09WuXsOaX15xzsf61iHOxfow4R1+/dnGOvr7mnKMv1y4a5+jL+7xxjr6+5pyL1fOcxrlYP0ZCjC5fuzhHX19zzsX61yLOxfox4hx9/drFOfrymnfO0ZdrF51z9PV9zjn6+ppzLlbPc7oQI/UYcY6+fu3iHH19zTkX61+LOBfrx4hz9NVr161crPnlNeccfbV2kTbO0df3Oefo62surLlynpM2zsX6MeIcff3axTn6+ppzLta/FnEuVo9R4Bx9+doVOEdfX3PO0ZdrF4Fz9PV9Lqz55TXnXKyf53Au1o8R5+jr1y7O0dfXnHOx+rUoci7WjxHn6MvXrsg5+vqac46+XLuIwppf3ueco6+vOedi/TyHc7F+jDhHX792cY6+vOaJc7H6tShxLtaPEefo69cuztHX11xY86u1i8Q5el7zGFJ/PziGGgZV5GT8jc6V3h8bncigipxdV1SR0+WKKnJeXFBF4QS4ooqc0VZUkVPUiipyLlpRRWEVF1SRs8uKKnJ2uVzpEE4619ecc5F6pVs4danHKHOmu3ztypwAr68550X9axGnUf0YCTG6fO3iZHx9zTlHX/70OnOOvr7POUdfX3POxep5TuFcrB8jztGXr12Fc/T1NedcrH8tEmKkHiPO0devXZyjr6855+jLtYvCOfr6PuccfXnNK+di9Tynci7WjxHn6OvXLs7R19dcWHP1axHnYv0YcY6+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",
      "brillig_names": [
        "discover_new_notes",
        "build_msg_block",
        "attach_len_to_msg_block",
        "debug_log_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "get_l1_to_l2_membership_witness",
        "notify_created_nullifier_oracle_wrapper",
        "storage_read",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "directive_to_radix",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "AAAAAAAQAAAAAAAAAAAAFAAAAAAAAAAQAAAAAAADKLEBAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAF\nAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAAAAAAAAAAAAAIlcysnvz\nnRFunYZwuSRCP2oAUtO15Kwi3n5/mI6S0qscUxsE2DSR68Vs7zsdu9z87ker/NpFO+d+efRViVse\nYh3HqN6ggtfOfB3mfkW/cqBghs9tYpjMar5nFW3uNt3OBy9wc5qHPopMWOcy4D/tdgCsPv1Aagao\nEeqK+i2b4Z4tZ+ILzvZ0xFrH7Fn1ig+dZK0iXlPYx68bWZY8RsbomRrtW+ZM69giLyZZhi710dOO\nm57I+oq5GK/eh5l2mSKpLNF1Qn5HkhK4ZmPLoKCi5dhKS7McyQmPWct1zxIlZxkuaGyVUXepwPmh\n/s3lA3VVZ3GXQyyfmifNQB2JO+njXQTq9+7SrTfYKaldTVT7xnnfd5NysEk/LJPmxTzQ04KqKc/T\nAXB01BqLxZsUzvALHN36oh/vJfG0ftkeeYy170cvXe7AxZR8psVtRiMP0SdJWzh36NLk93q/RhPz\nUHAZqwaVo4/fe9ScMSy2bd8CiLhqYg/uxx+pl+2Jz/e641wzBFa7cBtbC0Y7vPDE/nGQVSOT0JUz\n4bIAS9hOn4pTqI8DgPTmuzBHdr/U+yLiCYd0FWSB6aP48JHTDbEAOm2qtCUI3qkVY5FXVdHPGQg5\n35uiQvGSOTVst6RKBDABT+ysElXqfxPOkV4iF+ZsYbNAdCiSf6fdU7llZwmCFJGZhFMDVCN6Qevs\nQprhdNLMZ5aWBDN24ie6V8p43N0h4NZb3CtbY6VlsJGBcX1uPDLW1EZHjHFEZPDAwVa7agV6Hxw2\nH9T2Ov/uYe14M4VmWPTGuKgsDwdUC2iIiaE8i9ztu9wrB/gURPUAWACNsAnVQgzIrhvi6oVVUpCa\nGGrGgGF/hACmHerHazcMpPQvc6Zly3Wp69xYzUvfivfn/P+jbVtxLll4nw2duz8VreU4S3hJDbHY\nM3nHO+QRI96/yIyfyNYrcq3BN0OMoNM3FEWlepaQ5kT1hLr6RUEkzwGtW+CxOQEZ4kHuu+v/XH1/\nINxsWtG2r3jcIG1/d4U/Bf3n69NyAAheVLFSBkNjDK6SHL1Lw3ES2y1wOPHClvz6uqUQepgjXvTj\nmjfzkmU5+q9OkMw9IT/y7hcVjoyWs8d+acFC5BW+nyUAwyp4DncOz0Tm3Vze5lrRPKkH8rmTufKb\nR5HeCASS2byrNEN1Q8mW+UQRV4Pu3QN6+NE6fmyUhbKR2o0IEYl3uDB4DTujojMQW5j0IF6B8Oqg\nJA+27ILPZU+M5ye+PemONnHqm1QA0If2yi34D+2Dm//xHV1qdSQMsccmIPTAhsod6PGFdAFOPbPO\n8xmiQ6nwdlPh4uhrQwRXyZUOQfZKxzbwduEzJqXrCYnmFPliZLsX5fdBnjMa2mZMFwI7nFwbXtPt\nkrQre7tQ51TRxwcLobIp9BZlShR+bhbiKeP1e5qa5GAn9atfI8sg60XThAY8j6cfbYdVqSp+d0EI\nVocoNElUQs6WucJGnagDQmUZK0uwhdKJxtFlN15XJySZ+n+cdTeMU1Eis+w18bwInZnzFq7YBp89\nx4y6WSHnI4A9Zf9/PwtcEbwqKc5d1FFB31ntgXx2DRkNr2Imj1sNlPf1o3nD+pzxE+vEfnFeJsT4\nOduGft90S8YWNpBbswL6ppVvIUm9IgH4ASn2lbe35lGALV0EggPIGt+yDXL4C4klv+M0Met4DGj8\nkRYQITSxnW9W3fEGVY2T3IKE7QcW81jYNoJwnC3x14+fVdjQgFvwXTyU0nRYT40l2IVSawYPL5MP\n7p2KYp16084lDj+P37XwChsbEByU4tQgSeJpE+UHy5qrG84s/jcJMMVG0INIdS0PeQCeinL3O8Mb\nwxEXTGMdPe5L8fKtYPC6yy3xGFNiR6Mb3NOSPeUWaRQeexAoqtx1Nsj14OtC+xqxo1GsW0GdqFah\nvIm0lDIYUvfLAHYXaAmc4dFUb8HF2T8KO2o9Ml9fz2XeBm/nwG55ldcBazN1btkZIJ9Nb1xpPOIS\nQctqyc8U7pzyCvnJ83Em6gMIU1PxSp2rBzzBk7mLR7GQkPwwLqaUFvfU+HMKjogaLESUKWtigfab\nefMtYKTgpFbKL/hvYxhz/mw3BiBl7EAtm+c5KAbUenket2ewpJYNTV7J9tYNWNz+Y4AqqMsQoA6e\nfOievCZP3GlpR5CVadLo3HzKsWxO4cFJtAqHGXu8IO1CrgTw2toWiVQkdyQBK/11f+E0D/PzBUjh\nc8VPLg0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAACFXLkY667Cy/J6u84/KSAvHqcUNLmfV9DONMRgpR/x1sVkxK3AbNGNcdR8H+j\nPFtj1vqMtCx5vUmlfmpxC/VZJADENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04s\nAZaN5cMkgqp9HQoJ1xeOyTuteFj5bmTwtI0dWKphxkrVIgQ9ecSAIhnlW6GXUa3+bDYyTT+2wtoJ\niS18GKk8Pa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "is_registered_l2",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "parameters": [
          {
            "name": "aztec_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+19fYhcV5bfK3VXS13d1V2Sv6SxPfb4W7Y+Xn13+bNkybYsS7K+JcuWrfr0mvFYE0veZQKBZsgkE0LYgQkJS5KFLMmSP8IyEMgHC5uwf20mC7NMICFLWFiyMCEbWAgzsOwuSepZdap+9avzXr3XdW512e4LUle9c+/vnHvuOeeee999r1Le3ZLq/wvKIlzjItfq/b/+dCVviOWnFDkjO6E1eHX97t/l/vddQF8w7PiyIosV/oZfqS174302lL+43Md0qR/BdIDv7+7jfLg5xOe+BCXrjToHttnTp8vnArQJyi8BtrR3qbfeuG841lv+Hi9cV2Jzxze9QbHhW2oL9olNJ/0qCP5ryWXPTwIX7NeTY08sgv2GG72UBP+kG/yi4L8J+CkH+Kfc4A/s5i03+ukK/uk+/hS2M2angn0GZJ8C3w/DP+tGNwP8t93IP5ijz7mRf4B/vo/vQvYL9tiDmHAR9GLnU4XBuF5ygl8Z6OayG/xBzLniBn+g/6tu8MuCf80NfkXw33GDXxX8627wB7n1u27wW4L/nhv8QS51ww1+R/Dfd4M/mBM/cIJfHcSfm27wBzlDww3+IP403eAP4k/LDf4gPrTd4A/8t+MGvyn4XTf47RXv7nrzVD/hWe39W+tjf9i58+rHt1rfPPvZt5qdT/sVBlLgqlC7jiVA3TdEPX7rkzufNlp3jrXbn3Zu32aEqE0jRs0A6i81PvrkzTajpbeGdqXz6e2Pbn3CaEsx0WTtvBvq241b2Ze9hD0kH/LGfSG7XDPf0Pa82BqQf4Zktc59U8RP5GH9yD6D6C6jyJpTaDyGGYVPRuGTU2icZ02DddMQ65oh1vuGWJZ9fM8Q67oh1g1DrHcMsS4aYln20dK+moZYlr5tqfsrhliWdt8wxLpsiGVpXy1DrHmdO9p9LLd5x909ugBzxQ1+MUoX2CfhL3nEbqifCvkrWEwTXhlvPNdwkSNpfUP5w8aZdTCNzSDWskJzMabLEf1m/mH1tVxS6q9G4GP9dW/chldJF1k3uihEjdsq8BT+q9Dndqf52Yenb33oUVkgPYjeDlA92bff5Y3reyUEy6PvB+jaAuBhWQU5bn/nk9bZW3c6t70JJcqZZWDcLGDytbjBQvjPKljsIXnCjFp0t6zImvPGHaqzOawX5mzLCh8Nq2uIddEQ6wNDrKuGWDcMsa4YYl03xLLs4zuGWPNqX5cMsW4aYjUNsSzty1Jf7xpiWdqXpQ+9b4hlaROWcVUWs44XQQ3evMQiNEwuF4mGiepx6D8X3sbHPgVz+7nUEJfrsTyYN2GyF5YzeJ7zhcHgUOCqG/zBwmPFG9Up92k1RFdC1/4KFtOE16w23LW+aYuknDdul7zg0rBWEmJt5waBZuPZCFm1fvACO2rRijqR+qsRcmH9r8oidD/Vk8NX0yxC99O1sEXotJtDImdQcgqWLKh5bRqUev+vP10p81xmh11tcHw3xK45jgMtbS6VIjT0n91EWwMaz8/rgCXzs9By0C5D7fZGYO6LwLwnQs57IzDvA9oeot0PNIxpXLQcQ8YswLyZIMeY/b7N3fmA5fky79vIAdCo+SlOviztPW84RqjD+tb0UeALjnO8Nvs6Fs3XNXtB/WFBuYMx+dXsEJfrMU+09zWi4RisEw3nwxzRMJZKrJE8QrP1lDc+rgvKNbYRbo8y8Hys/RU+3gQ+mszrigxss5pvReW8mm9Nm+trfDSZecwt+GB/eA7KGPLRcjPhswvaSR4UHMzamxq2Cf7J0a+0NxwrbHtic0jH+hLYA8x7+5+XqY5xLGmyn2HhfEPzDcw32M4wBrFtrAMNdc5Fi0+ii4DfjxLEJ1y3rFJdqZ/2xsfr9c3ResJ/UWkflDObo1hS/7HUUO7/mB32j+PCgiL7AskbFMe2UYjjQ8g/Q7K6yjPSJA/rR8YuGGOx69t3bn3a+LBzodNoo+isPv7LJinfF+kaf99F3xlHnpdZ9OKVlIKrdV2WmtoUuYva8TJeyrKCW+//DRubbswi/KTfuxVZhG+a6vrgPr8P/o7t00p/xH13RegkKCveuMuWISS/QSF5iWSue9E6ilkGWxUr0CdtzJaoz1K/Bnr6SXZYH9t4XrytHW17bEnR37o37kvS1rG+5moK05bMUSfBtelN9BTI8tMY0xvaZlSIRFuXOKFNjWnA3Qs2H5TFzWE9qzGsbgxffLDQxxeb57IIdKz/dh+AUwmJH/UtytmtNvLdYqPbKDfa7VKrsY/wPdAdP9OQ9Tx1bvC8+Z26F93IEzl1Lyq6xKn741uN9vHGt29/9nGHp1XeNWVX4/pY11NonGWl6PsuaidupJkqyxk1hS8qmEmn8IUQvp43nPq0KT8KSz4veNFTZ1RKIRjZCAx2He1OAbuOozsFHQ79WLTQz7taOZLL87zYoR9fxZHkTidObygbYmIaod2BSVP9b0Hq8zu7R/ntU+SJE3KCwituDKlp6tc9hnxwx3mJ+NxryAd3r3ln+z5DPnF2wi34aLvq4p8PAE36Kv55AGiGpxYHJxG+5o0XoT0IvNmmHgJa1GN1mn9Kn5L6536goWyIif6Jet0PdKz//dRQluzaKH++W4hpvyw9F7zxcXrAG+/LA56OjW2XFZrhmJe0Mef54EE3vMtx/Ab5Z0hW4/lpkEo9SPKwfhKmUmgGCH8vwUkdrIvlXhAJ66fpe5hZxUmllr1xN7FcUbo1KX/whquH3OAPbqA/7Aa/Jfhfd4M/uJH+iBv8iuA/6gQ/P7gB+A038rcF/zE3+INDEo+7wa/yVPZvINX8dZhWtaksKI5TDD9uyBf+Gc/l9DcM+QdIHtbPLtKPoymom/LGp5sFhafIK2P5hEITrCf73zENwvpfgz5iffws7fHav+wPWI4wg8I3dp5Q+oPXRL+Bnf5mH3dd6c9+6ps2bgcU3JwXnmJpu5xyo0k7GPQ60bIRtLUI2rrSL17qBuUstdurYAZ6e2DXEC9M52hXvB2Cekb7YDvQsE4QFrZ/krCemoB1krCw/VOE9fQErDcIC9s/TVjPRGBhTrGutH+GsA5OwHqEsLD9QcJ6dgLW44SF7Z8lrOcmYD1IWNj+OcI6NAHr64SF7Q8R1uEJWI8RFrY/TFhHJmA9QFjY/ghhHZ2A9TBhYfujhOVPwPoGYWF7abtM343nn47IWpggq0+y5oFWoH5HYQVF3o65rvSNsYoT5HqU5ML20naZvtvqMD/IKcoTZC2SrCWglWcj6+COaCWhrGWgSdusNz5GKepHxU0/YueVwj/jVK/DvFLTK+qHt7iriqw5hcbzYFXhU1X4aFhPG2I9Y4h10BDrWUOs5wyxDhliHTbEOmKIddQQK2+I5RtiFQyxSoZYPI9g3DCMv4MHqSbl0MI/Kode8MZjydMk94LSH4330wpvwdDWBDgfIM1TeAaFdV8M4RdHN7IGXI/o2zrV1WTer/DZH1NmXofimljepK3dGuW1NN5CfoJoePLnSaKtK/3Sbv8+TTR8WEb0hmtiPsn1tf51t7dXfJ9PtWg6nv0+3N08H/l53vbuw/E+lqaLJ53wLuXj6uJJ0sUTjnQhfqztbWh+HBVftD02vG31YefO6VsfvvqdS40P+XkrPiGCLof1+CU+XwsRq071nqTv4rZhz1fi8Ghy8G0xrl+fUB8/ryrXg7Ku0HlLUntmF69FbUnyM7t8uLLe/+5PVaqD21hPO8EvDW4DPeMEv1DkcP4v+koNQv7h/mdtCuOQ4uakUyF2eBX+GW/c51yElCzJw/rh5eiaImtOobEdrSl81hQ+OYXG7xbZKpbmP9PIdcNIrqBcMcS6aIhl2UercfSM+3jZEMuyj+8ZYn1giPWuIdZVQ6ymIdZ1QyxLm7D0R0sfsrQJS329Y4jVMMSy1P01QyxL3d80xLLUl2UsvGSIZamveY2FlvqyjDlfhZzJ0iYs520r3QefeX05jVydTTusbh9L2y/YTZi4BsV9Almj4pao5ZpQ8Pe6wR/cEsgpesQ+CX/tyFQq5K9gMU14ZbxxW3Gxntb6FmUjuIXNTxNpWLmEWMsKzcWYrkf0G/lnI2TV+pElncTdr5D6eyPkwvrrCm9pKzrErXtDHRaidIi+KPy38r480dthqsfvy0MbzIVgefT9MF1bADxPqa896L6qyMSyLyn1EY+fqvvN/uAGusr1B53fs4ftA/zf6hNkzPmYQL3/3Z+qlIriB8+RfpA3HgUw3IuM/eNewj9DsrqKndrxQdQP70UeVmTNKTQeQ+1o4WGFT06hcT42DdZ7hlgfGGK9a4h11RCraYh13RDL0iZuGGJdNMSytAlLfb1jiGWpr2uGWFb64nlznmz1iiHWl30cg3LTEMtSX5bz0CVDLEt9zes8ZKkvy3hvaV+WMcfSHy1twjJnstJ98Jn31qaRq7Nph8V7aygn7609q/QnKG7XXMO9tSNu8ItResQ+Cf+sooNUyF/BYprwynjjenexPtT6hvJH2W6cx8vi+oFgLSs0F2N6KKLfyD8bIWucdbH2WKG2/pb6RyLkwvpRj9WJDvGRABd7a5oO0ReF/1b21kRvB6ke761pjygylkffD9K1sL01Pv92oA+snbsz1K96nJmPpuMZNj4bmfQ3YbD9SggWvtBQHpUO6Pj2H6z/SL9yMO73rI1iakdo8cgtPzKNMnFsfSaEf8ob2lya6j4Bst3fly3rjetJ9O94vFtx5wbhP6tzjNo4aXak7esaytOMiqVa7iFj+ZxC49iFr2vA+s9CHznOYNxL07VCf+By3nisf31zVAbtMXFtbgj20A8tjPZtqzkG4ua8cd3wO+MxVuI746sLo33RXvaLjxY+AHSs/yvZIebzfUztEXseP/ZFjEVBObE5Wl/GU+53cB2OY1L/FYgVByiOTXrzGcssmPiSUpSZ37su9U/QvOPonoE67wgv7fUV/Oho0teEHFT0kFXacRx2E2fysR9REf4ZRScu4vCzMfXq1j7uPv49KW6hvDKWhxSaYEnOhj6E9Z+DPmJ9/Czt8dplisMYszkOa3ksXsM4/DbFKOwPvxIoar5C3JzSnnWI7aaN95rMUX63VT6IhTkjjiuO+6OAiWcGcDwwdqIdcuyU+k2I3w9F5Ho4t7UXJsu6osiapvrXYW77kOwGzwTIeGjjw+c4Dih8U1TX88bPtmjzkci5FFJ/PaRfn4BOczQnoi60ceXzOEJbVPoVFB5Xqf/pFsb1zsJkWbW1RprqvwTj+is0rqi/qHHNEQ3HVXSkzbk85knnXGx/IILPfUR7FGjyRt0sfRd6UNyumVqx52peM93vRJ7oNRPqh+fqg270M5irtVdkaXm14zVcUcsFwva+w3KBg6BDrI+fpT1e+yGtnbRXZFmu12aNFZW/4JgG8er7M1pHcow4aMhHW5Nq+Rj6OtKED19jPthe6rk9w1b0tRzeED+v3ZMxxC9o+/d2+KXBKwxwn5znHDf73uVK3DlH+GdIVldzjvb6PNQPn/HzFVlzCo3H0Ff4+AqfnELje7nzgnXVEOs9Q6wPDLEs9XXdEOuGIdY7hlgXDbEs+/i+Ida8+pCl7q8YYlnafcMQ67IhlqV9tQyxLO3rpiFW2xDL0u4tx9Eyfln2sWOEFXzmXH4aubpGcgXFUl+W+cRXYR6ytPt5zb8uGWK9a4i1k39tn91b5iY7c1oyrHnN5eY1Flrmcpax0HIcLfU1r/kX73VOI9e85l/XDLEsfdvShyz1ZTkPWfrQvOreMn5Z7qXN696QpX1Z5r7zmmPO69zB97Es5g7tHiq+R9nx8xVFwc87wo/SFfZJ+PMzMELX/goW04RXhrCM+5aP6lvUs0hoU3F+UiqufQqW45+UGozp0Yh+I/+k9wKt/Cz4fMAQK0tYUc8kIZbUzyv1NTvRfjZL2srY4s+TGI5tIWpstZ8E28rzVqK3y1RPfiZwlzfuG34IlkffL9O1BU9/3kr72blciJzCl69FnXc7FMHn/in53B+Tzxe5P4wt56zw3V9yNsntOZNK0+05k8qG9myxHX65q+UQhvIXtPnGDr9U1nIUO/zqhsxP+LOGEi/c/lxfpRg3pxH+Gc9p/B/kNNrPMqJ++JxPSZE1p9DYRkoKn5LCR8PKG2EFhe9ZTYN11RDrsiFW0xDLso9XDLEuGmJZ2sQlQywrm9DmzB2biMa6YYj1viHWvPq2pe4t9XXNEMuyj+8aYlmOo6Xdv2OIZWX3wWfO7+fFJjqGWFY2EXzeyb+2x1Y9bz7n2uAzr2F3YmE0VtcQyyrmBJ95r2AarFUjrKBY+pBljLac0+Y1L5zXOW0e11ZBscxNLH3IUl9WMXpn7vhyzB1BsVxbWcbCm4ZYO3sK2+dDlrq37GPbEGte10OWur9uiDWv+4WWec5OnNi+fGInTmyf7uc1TnD+5StYObh2rl9fO0PB90WLE7BOEBa2L3qT+4hYJwkL25eoXRloKD++RwftoKzwPqTgC8aycj34V+9/96cq1cay0g87/EJb8CtO8Esdud9eBb2m+n+F9wZctzsbUIr97mDhnyFZbeUZnlXYIHlYP3xWoabImlNoPIY1hU9N4ZNTaDzfToPVNMS6aoh10Qgr+Mz3YqaR65KRXEFpGGJZ6csz7qPlOHIcnxdbvWmIZenbljZxwxBrJ37txC+XfbS0+8uGWFZ2H3zmPfx58e159UfLGD2vc63lOF4xxPoqzENfhT5aymUZV+d13uZ9gXmxLyt9BZ/53NY0cl03kisolmureZ3Tdvxx+/o4r/P2vM4dlj5kGaP5bNqX0e4/MMSa172OliGWixjNz00Gpd7/609ViiXZi8ZnwlPeKF/cOzPcN++kiJ/oCK8h/wzJaizPYB9fu0+F+tlF+im7kaedInyUp6zoR8ayotAES+4z4H0yrF+GPmJ9/Czt8dpfpO/+zSmYHCcrSn/wmug3+O2Gn/dxE/hAodXNF8udatmvNErldqVYaBeqfrtU7ubzG/lCrbRRLHZbpY32RqHYLVQLLX52VGRFvo7GuBTXB4R/xnPqk/kom9PuR2s2J23ZFoJyfnNYL4ktWNqVJpf85pLDWFvOeuO6ZTvD/hmOayGunQn/jOfU7vNRY4b6YTvbUGTNKbSj1A7HczY6Lza3qnNH71iK1PlRA50/DZ95vlhQru0KwQoKr5GmwbpuiPWuIdZVQ6wrhlgXDbGahljvG2JZ9vGyIZZlH98zxPrACCv4zPef5sW+LP3R0r4sY6GlXDcMsSzt/stuE8Fnvuc9L/bVMMKy7qOl3V8zxLK0+5uGWDtx4ssxd1j2sW2IZZVPBGVedd8xxNrxoWRzBz/3seNDX0zdW67dLdfI3T6W7CHxmqbe/+5PWQT/aeBthF3k94lOgV30Q+Q+Yi93gfftpsBu+yFyoz3b7cGVBvg1e710Zb9uBbDlt6KDeyk/WPJGbPT5fh28F7QC/X4S6Fj/f+0eYv6wj+nWD0qD+5T43t2UN8rbze/cF/wU8fM8fR9X+GdIVlt5hvu495M8rB/ex31AkTWn0HgMH1D4PKDwySk0jt/TYDUMsS4bYr1viNUyxLpqiHVzTuW6Yoh10RDr0pzK1TTEsrR7S7ksdf+uIZblOFrq/pohlmUfO0ZYwWf+vdtp5OoayRUUS33dMMSaV9+2nDskn5D3DWD++Iw3SkNbOkj8DgAN8SUvfQjolnmg4H/dDf7g93Ue9sZ1jH0S/pJnPgj1UyF/BYtpwitDWNa6i+obys/28zDIgzoIw3o4IdayQnMxpg9F9Bv5ZyNk1fpxgHSi8dHWKFL/kQi5sL74Jdq+tBUdPgo067NUYeP9CPAU/lv5bSLR2yNUT97dsssb1/3XQ7A8+v4IXVsAPCyiY1zH8m/srFEfwsY3p7SXenHW9m7iQKERNy4J/1mt7R+MqVfR3UOKrDmFxmt7zT8fUvjkFBqv7afBahhiXTbEet8Qq2WIddUQ6+acynXFEOuiIVbHCCv4zOuSaeTqGskVFEt93TDEsvTHpiGWpd1bxkLLcbxmiGU5jpbxy1JfHxhiXTLEstSXpQ9Z5hOW+nrXEGsnrm5fXJ3XHOA5zwYrKJIDyNoN8/17vVEarqnuI9p9QFslWVaVdkFxvN9VmNf9LtRBKuSvYDGN97vuc9O3yP0ulP+rtN+Furba75pGJ7w2X1WwovbO4o7tujc+ntLWsY8N9s4OeOF6Qv5b2TsTvR2keic2h3rgsXsoBMuj7wfp2qS9MxzTXIicwpevsa1g+9UIPvun5LM/Jp8vcn8mnZX69m6dZ9hZqQeAjvX/PZyVur17tI/Yfp/nhfb/HqJlgcZzOu5LSj3x6XWg2fl03hddynhiEdpe4L1CtH1Aw35zWaDv2KcgRpxLDXG5HsuDOkTZEBPHWtNrmup/d/dQlkfWdMwUYKKcsq8v9UWXS96w31iHZZD6fwtkOLCmYy6G9Gs9BPOfgA3/nd06pufpcxT3ay/1i2XIkQxS/+9Bv3LAAOvId4wF8r4B4bVP4eWFXGPb2BdCS8oX9SPX7onBN6XQ2JZYn9g+TOdsS1L/H0bYUlaRAfXB475GMnCdvSSD1P9HigyBniWGtG59+zvHG9++/dnHHY/KInzmUK8NNQ9BVsEJK6KGoHviLowj36PMRHNHL+Ra2LCvwvV25+POnU6IgnYR2EoIs12eXjiWSruguJ1z4r/PQvhnPN1u6zby5DnOizysH75vl1Nk1fIjGdyoeZ59DWWIuicbFTvWYvZn1Rsa9u07tz4NszmcwzWbWw3hn1Lae9Q2pVwLSuCUv9V3ymXia2wHg3cJrSoyarlHimjYX7YV9iWkoa0sEg3nizTRcG5ZIto9QNtNtHuBtodouK5eJhre/8/AZy5aridjFvC7mRricj0pQX9+py940PbLtoZhrF3e+NokKPK7OmL7bvaYWr7II+vqtBe9Z5im+j+Guf4n2dE+3qfo635FXywD1tf2NLV4yns6Gm8cK8lj3O5/DvX7MOhP69tDQMf6P43Qr7Y/FqXfSXukvJ+MOn2YsCbp98Tm3b/zrt8/3Eb9on89TDSUneOdpvuo/eBchAzIZ/+UfPYrfKKwcgoWrhN6ifBHv9z59OytO4PXTgokqtWjz8t0jY+2cuq7FiIqrzU4jz9A31fp+9fo+15FPq2IHFhYlgVvchFTF139DEz9MVoaalMbTkcSLnkLDtviFpyY1wtQj834BYUnXosyY6mn8eFj4C8q7VJEQxlejJAB20s9CXEvAc0uxJUGIe7lPl7YduZLQMf6v4gIcdIG+/+E0n+WAetjv0UeTffSNqvwToX8FT58jccFZXhqRnwe7X9eV2hs65qeX4rgg+1fmlF/cjPisz4jPtkZ8eEj0S8b8nkZ6sh8I/b2CtA4rr1CfPhaVFx7hfrzgmF/tDidVeSblg/qhh/9qQMN5ziR45gih8T4V+G69S1v5Cfysg6Ef4ZkNZZnsDX2KsnD+uHtjuOKrDmF9hR8RhryOa7w0bDqJEMd2s1o/ApbHb+6G3kix6/ujes16fgdIb0ed9KP4SskTnjjRWivAe860V4HGvoKF23rSvoU5E1Prg1xuR7LgzYmsq174+ON9XhcosYqp7SXesveuE4Mx6PCevWU/r8BvA/DZy6azkXuQOe/mh3icj3mWQfaG0TDcT9JNLTbN4l2Amin+p/XvXCbSxFN+sjXeByx/WskA7abdk7UZNbsEvW1Fbs8pvCJis1b7U9dkTlqDt8qH+zPceJz3JAP2uIJ4vM8tMMjLxf3DNtgO1wjYlvZVk5T/aeyQ8wrfUyJJejPhrFkQ/p20hsvQnsTeLNvnAJanWhvAY1t4zTQUOdctPgkughU9KME8QnnIY4zdaXtsjdue9uRrwj/WeUrx0iesFijxW9py/4UlAubd/+ue+ExKkqGY4oMW41DbnOm+GMr/Ge1ljgeU69aXidttblMXrO37oXbRJQMUesMLfZL7JRbAX+9Hy+D2PnLe0b7gLFXfq6E88SgvE60Ewrt89i8MtofiUd4PAz3qTneS/2/TzH+JPTTbuwrVY7jwgN5n3LEO64fCH9tXhG5MwptcQpZu60Nv+hXKu1OpdQsl7opwhdZ+Rrvx76l1C8o9UXXp93ouiBz4MLmEP8t0GtQFoF2imhpoImMgYnW1kblf8uR/HH0j/xzSv2T0IckY+kSC+OBBdbaFrH2eaP+hDHHbQwq1bQYJEXz+UNEQ5vziYb+VCTaGaDh8SEuWp4pugh84ESCvQfM1U+FYMpcgGt4mWPSVPefwdz2T2luw3nzzc1RGs7PwifA+G1arwgfPK8p82RQ3g6R69/S/IV2ZWg7bbYP4YG833LEO+78hXGW5RG5Mwptmvmrme8WO36zWSo02+VKpRI1H+E1nr9OK/WrSn3R9Rk3um5q89dp0GtQFoHGcxvOXyKjNn+5mX9LzTj6R/45pf5Z6EOSsZTYruVN2jqNH+fBPS7MdX+bfNxNnnh37LlvHsmI48bzA9okzw9ngcbzw9tASzo/iC6Szg8YJ7FPiLkI17QYn6b6P4Y54vdojsA5XXgH9c4uj9Z7S5Hbrc/Ev+cm/LUY6mKdrMVEze80+2P/RhofkTyj8Dmj8NGwZCwdx7V2VpHLo/6jj9WJhj6G48ZF8zFchzy5RR8T2dYVGbBeknibU9pLPRkP7LfdeJQHjw2e88aL0M4D78PwmYumc5E76f0f1Ot5oqFtXiAa2vRFoqFdXep/Xvei7Qpp0ke+xuOI7d8mGbBdKuSv8OFrzEeTWbNLnheS2uVphU9UnN9qfzSZecwt+GB/zhCfM4Z80BbPEh9cf+D9n7+i9ZS0w/s/2r5Cmuqvw/2f/0d5F/rBdsYS9o0LQGM7uwg0to1LQEOdc9Hik+gi6f0fzF2xTyh73Lxr0Nd+DuU4T/L3Ub80ne7kb+7zN9xT4diTNH8Te5y3/O0Y0bYjf0NfjcrfsN5W5kltX3knf9vJ38L47ORvW+MzD/kb3nvA/O2V5WEbbIf5G7YNy9/+fHWI+SrlBW72zb6Y+RvumyXJ33CtzfFp0h5XiniH5XmnNu/+5f21i8tDzPPL4XKdBN7/dWd/jcsXan+N743u7K/p/haVn2G9rcyD2H4nPxvSdvIznc9OfrY1PvO8v/a9GPlZnP21P4b87PuUn+3srw3rbMf+GuddUv8fzNH+mvacgdvzJ/HzN+GfIVmN5clHxUvtDK82P/H5PaTx/pqWJ55W+GhYvL82L2cXjhEN/RPHjcuktVSS/A31LLJpZ7d5PJKe3dbOjzs+R9Th3MZT+o95QtL8TeROmr+hXjnOo22eI1rSvG/di7YrpEkf+VrUc1Gzyg+OU39QBt73TWqXpxQ+UXF+q/3RZNbynWn5aPvYs85H8RkyzN9+j/I3aYf5G7bl/E3q/xjyt/9EeYGjc8uJYwn7xjmgsZ1hjsS2oeV9ceMTnltOkr9hrOb4pD0DqO1xac/Kuh0jvxPHlpF/RumvixzpJMnD+hHfCsxaXtv/YefOuc+aH3/UeqvzndvHPmmfa3x656PGx8fa7U87t29jb5BDVuktWwvXkc++ch0xTk3ohbyVat0bH+U4d+cQ6wRhaVGNo0gY1knC0iIXz3yat3HWifVRnjMT5HljM1yeM4R1NgIr+CxvE9Nm+rOE9fYErEcIC9u/Te3OhfDBOhgNzym8NXy22/MTZH6cZEa5eOV5YQLWg4SF7S8Q1sUJWF8nLGx/kdpdCuGDdXCFfwl4p5RrmjyPRchzibAuT8B6gLCw/WXCujIBi1+0iO2vULurIXywzhW4fhV4p5RrmjzfiJBH2saZ4VBWwxkl9lMown9WM1yUXoPCuwDXFFlzCo3vGlxT+FxT+GhYpwyxThtivWWIdcYQ621DrHOGWOcNsS4aYl0wxLpkiCUxUbubkyc+Se/mYPtZ3c3JE5/j0A5Xm09mhm3QBnG1iatyfGkx1v9XsNp8po+pvXlIZNT0zLtnSfWs8ZG5Bm3Y8I7F4O1SOIdLERrOcxX4zEVbnYrcSXfPUK88J2OcuUY0jBvvEA1993r/87o3rl+OiVoeiNei7JjvwGK7af1Fk1mzS47LSe3ynMLHtf/zrug5Qz7a+oHtx4KPtraYFM9OUTyTdmHx7BtAx/r/GOLZmT7msjfuB9sZS9g3tLxEaO8AjW3jOtBQ51y0+CS6mGb3jOOT5hPL3rjtbcedQ+Gf8cZ9zsWaQdsT0GKNFr+lreZPPNdqewjnFT4a1mWSIWrN52j8ClsdP9drPm38otZ8ccevRno976Qf5QLP/Vh4Tsa+aScreP/KI91gwT4lvVuLNiayabkoz+tJ34KJ7aWe43yzxHr1lP7jfsxh+MzFMt9EvXI8wHG/QjS0W54HcJ6VuU3LNzmWJc03sf2s8k1+y662dtmqXWprqqjYvNX+RN0Bc5XXzlu++YME+WZQ+G6t1P8e5Js/nE2+mTiWsG/gPjLbGeapbBth+1RcLPNNjNXSp3mbO88p8kfpAufH393iaSYeU/Q1PuGM8pXgM9JEVr7Gvobt46xV3Y5V/Pxf+GcUnbjIH8/H1Ks2Z54nnSON50ztvt8FhY+Gxf4dlf87Wi+V4o6f8J9V/q/tFZUUvc7CvsPG+VyEPG7yWH/w9sqoe7Ioz17v7twYlg+wTWr3gtEewmJW1FmNqD3B8xOwThDWVu/BB4XPamg6YB/W5lrt3q7GO2zfIChxfN5N/hLf54X/rHx+0vihTe/2om0LdR92Buas0le29UnnbdjWNV4etZMc1ldkTFPdn/Rz2iBX+QPIVSbZjqMnBWLbDj8p4Np2Jp35inrSk58UQBqfEUh6ohmxThliyRmBr+opdxyXWZ9yn9YmsP2sTrmfpP5EnZ/UTpSejOBzSuGTVdpN2x9NZh5zCz7zcMr9OLTDfZM/p30T7ZR71L6J1P8E9k3+kvZNHD2BbnrKne3M1Sl3fHLd6pS75hNunx7zy3HnbX6LtKPT9IN5Wzv3rcWawFzlbOiHnTtvdb5zpfHxR+3GnY9ufXKh89c+69y+g91A6EWlmzz8i8RO6r1G9V7fHK+HRduW5uki6bb0SUWeuOp7YzNcLnaTbTDL4hfdLLW0QtpqYX7aF8EiVtStkDLxSWpzZYWP4xfwN7SpXIqm5zLRcNpC++CihXnp0zQPuPKLIKL8NmmKpcWTeXthTNLUH6fWrab+YS/f0qbdpMuCdS/arpAmfeRrUbF8Vi/aiEr9OR4ltUvtpVSuU3/+wYE3Dflgf7ZriRGW+r+2MmyD7eKm/lL/KqT+J/uYjn9MNnEsYd/AZQHbGS4L2Da0ZUHc+CS6SJr6Hwcaxyf8kTj5wRuhvQrt+Idt8QdqBR9/JE7LAeSH69fpe/BZfmw+TXJ9i+wBf5Tezh6KA3uQfgoP5H3SEe84PhsVz1BuLR+d5sd2Cp1mq9JodIutrt9qdDtJ47LUf1Opf1Sp7za/LzbEX/DHdtBHg7IINH7UOA00fAkJ/9iOm5y02Iijf+SfU+qfgz5sZY61yCPlh3vwR8PEt7XYxL7oJg7EX/8J/wzJaizPYP33sjeu1+cVvWrrAGmr5e4Yg5GGfKLWZYgl84UW3+vE5yWFz0sRfOqKzG5toVTV5gQpWgyuEw1jANoHF22ulz4lXf+hzjnPRhl43J8necLsK6e0l3rz9qPdSdd/+APbSdZ/qFfO99A2OX+vA41z7qgXVaF+kTfb6oJyjccR23OOp+VCceKjxkeTWbPLl6k/Se3yZYVP1Hyy1f5oMvOYW/DB/tSJT92QTx3q8BHQsPXfb9D6D48TxFn/Sf06rP/++WzWf4ljCfsG5qdsZ7h3w7aB+yB1+MzF1fqP49NOjrX1HKuuyKr50+vwmf12QbkW5Zsyluve+BgdIz5af16O4HNM6c+yIsN25ljHiDZNjlXvf06aY6HOo3IsF3OZ47iYeDyS5lgYw7aaY/E+SB1oHN/Qpjn/wrjI90pQv5xjJV0jYftZPcYTlWPVvdH+JLXLusLHdY5VJz51Qz51qHOM+Bwz5IO2eJz44NoXc6w/oRxL2mGOhW05x5L6ByHH+tlM9lSTxxL2DS22a/lXnWiYf6HOuUxadyfJsbR1N8ueVuq+SDSp+/P+GAXj9VR/7DRffsEbpb0AtFeI9qIik7ZXgxioE83mgs8b1Aep/5f9PgS6/M9rOuYuL9qO3eYfLV/kOab0UVt7pam+/KJ40MefkL3gHrPovv/eUG9x00l/8oEc/4WOZYsdfC4/8OU4uqDU5338Y0r9OtThPBj9j/PgFxUszE9ln3o7bQB9pg50rL8a0wZEr9thA6jXODagrRPi2oDoTLOBVwnrFQUL7WIebOAV4FkHOtbfH9MGcF0VlMVNJ/1RbQD1GscGsH5SGxCdaTZwgrC0dSrOBXy/SrCXPH0+4nvJUv9xGKPc2qh8OKey/b6gYOO8nCIM7MeK0o8s0bDt54+iL43KLzncc5DDvdT/7HbPffi4oeQ0YTnAG96ozFL/qOIXKWqD+oqKO9q9Rew3ny/A9R2fUZuXexSc88bdV6wTzdUPbeA9kZ/GyIfRNlPEU3iE+beWS+PZElkL8f7xq+AXl8gvHJ3LHfiFjGXYa8nQb7D+6xF+cXKCvuKcrTip6FDb25C2jn9QoJZVZJWi2T7vt6Pts1+g7fN+O9p+nWh4vosfh8Wi+QX+2EBcv7hEfqHtI6GvsF8cV+TF+zB8ru4d8Itvkl+gXlz4hfZjZSj/GW9UZql/I8Ivzij60vbdWAasr8VC7VFZaTtvjzPyOcS4jyDxvig+gsT7ovjIfdLHk0RPSfzim+QXk35kK8ov3gLc18gvRHffBr/4LvmFmx/EG/qFjGWYX6DfYP07EX4R9bMJQWG/0F5lgf1mv8D4yq/jdaOvUjeryCpFs/0zREPbZ79IavtCw1fgoU64aH6BPy4Y1y++S36hne2P6xenAVce2eRXV/1t8ItfI7/AvrvwC3mVU5hfXPJGZZb6fzfCL7RXkmivSGEZsD72m/0C7YhfReVGX+VyVpFVitDwdV78Wih8nRevPeK+dpYfU78ONP5JDyyaX4iekvjFr5FfaK/piOsXFwD3ByF+8evgFz+ajV+0pW8ylnH9Qur/RkK/iJovtJ81iesX0taxX8zVK5eF9i7QZuEXP3LkF6foZwC016ALz/MxeTp+LVWLbT3Mfy4CHev/uwj/ifo5pKCw/2j+hv2O8h9pu53x5rwiD8eb/xBz//sc9Ccoi5tO+tPR9r9x3NLAd9IYBSVpTORX9uGcfIFoUT+TcFzBxJ/74LXN78Nc9UdzsLbRno3ltc0fzHBtw+e1vuhrGz5H8kVZ2/xRjLWN9sySdm4E1zbyo6u8r/Q/wC9+QX7h8qcIcLzQL7Rnv9NU/2cRfnFugr7YL6JeP4ryaD+HKG3d6quczyqyStHsm/O0pPbNaynN1zBu808/YtH8QvSUxC9+QX6hxT987pv94pQib4D7vRC/+Avwi9W+cNvpF3hvLMwv/m9Cv0B9JfULkWfHL0Zps/aL1Rh5Ad5bYr94U5E3wH0lxC/2Zod1Hp8Dv4gzX9zXlzOuX6C+duaLUdoXxS8ej+EXW5kv/mrP3c9iY3Jm5xnwi+fJL/B8nwu/wDMm0jc8t/O6Nyqz1D8U4RfSBvX1Klxjv9DOrGC/+VwtnnWStm71ZXvuuk40tJdjRMN7hbwuwTUF6oSL5heipyR+8TyN8wnigWMVFPaL5xV5A9yLfb+Q8c1BvWe9UdqjQDvgjcrznCIP1l+h+odABq2+4KWp/nGw/Ry9o+IwtDf016bIfARkWlD6dZhklvpvRPirtEG9HYRr7K9HlPrYb5FnnfSGbZfpu62+8oOzp0cVfT2nyJOm+mcVfWl7bznoT1AWN530Rz17iuOWBr6TxigoPKZHlfo4NqKzHNXH8RXas0A7TDT02UdJhpwiQ9yzntI28OU7/YC37o2PN8cTtE2OJ5pfYH2OJ0dABq1+mG/ejIgnqGfDeNIVmX2QSYsnR0lmqd+OiCeaLa3DNbY9X6mP/eZ4gnYpbZfpu6t4klf0dViRJ031vxkznjwH/QnK4qaT/qjxBMeN40nUGAWFxzSv1Mex4biAPwN+hGgYT44SDX32EMmg5QNx44m0DXy5TfEE6z1DPJ9VeOJcemLz7t9lRWYX954w5ix44/o8BHSs/zci/PuQ0sf9cI1tYVIc5ZiM8VraOtZXM0pfB2Po62/G9O8V6E9QFjed9Kel+TfaJvu3NqZYP+mYis5y3niM5FwCfehZ4rOi8EF/Yh/GsZK2gQ9X+z4c6OVUarTNLsDrkwb2tgDXDccn9k+syLUMyWosz+B9HQveuL5RP/y+jkVF1hzRgvL65rAe0xaUa7tmjLXujY8327ymm4UIPjxWQckq7djmWKf1/nd/uhL75wGEf8Zz6gP5qPHT9Cq6Syuy5ogWFLaTtMInrfD5omBJ+6CwPwblzOYoDceYdRrXVuU9CkFsxVi67oWPjfDuP4I3cj2tyJum+v+a9kR3k6z1/nd/yrIPcD3itaz0z5D34Kzdkjdeskq/edz3AI3HdplkRloGaPwbGlgW6DvqIuD9vyHX4HpSNBtJEW1J6YfQeNyDkvPGbTtNNLTtJaJhbNtNNPQleY9zijA9b+izOHb8k3Ga7wU+hPr3gG+9/91PWgrtVqVTqG741Uq+UGuzTXuO+ZcbfqFTyjeb5XynUat1Z82/s1Fr+7Vup5HP5wttvzOJvxbD0AbFPjQb5PgmPojXdwNfjm9S/79RfGN/rW9RF1y0+LZMfdgNfdDsmt+FI/V/Dvew/nt2VGdLxANpqE/29z2kB6Sh3KJv0d+KG/0N7pn1j0qMrBFR1hVvVEdS/09irhGXoD9BWdx00p+StkYUf/xcfuCL/fK8Yb+xPufLq0p9HBvRWY7qa3OEliPtgWv8PgPR4ZKnj5Hgca7xZ8perDbHZEh27DvPIwsKX55j0KY/P5tB+8Ack+r97/50pcq5BRYtt+C8A/2Q844MyYw0tIOkeYfoImneYRGHFr1RfvPit8IzKOy36KMLSn3220l+LmuAnDc+lmzf2lyTxGeCco74ob3I2KDPuMgrWs1KsxT8bkO+VCmW/JnnVaVyo9pqVPP5Winfy6/KM8+rmqVatVlrlf1eepWvFWfNv9rY6HGvlRqlit/q5baz5l/Y2KjUCk2/VG23uu3SzPvfbFdafq2Ybzca1V73N2be/3a7ky/lq7WNTqnUrs3c/srtZm9JU2jUesubdrHcSpLXp7zRuBGUBW80PgWF12wLJPskrF0RWKkIrPQErBOEpe2fxNnLdrR3EXsvW/jPai97kl45X1lSZM15ev4ln5GGfJYUPhpWyhBrkfqD2Ogbcn335iivz//CNckjJNfZg/WJtgy0xc0h36Bk+t9lTclYIkea6h/vz+dydmAJ2kj7nMJ/ifiPyK1cQztkrAXlmtQPdP8i5BwYc3gfl2PNsnKt3v/b27dpdtu9UF8uNat+pdCuNMulUqfaKVaaNb9arBTLfrfSbTb8fKGw0SrlW9WCX6uVe/se5aqf7/CaAbGLfqlQ6VRKjU6n6HdqtY1WvtjaaHU6rXaj2KgG+0btZqfRLhearUK32Oz6nUZno5xv9kTJ+60878Eitl+rFpt+oVVuNRqtYrHW6ZR6QO1Gby+oWKjVCn632uzmm5WGX+30etfslNvdStUv+c2i79cqBcHeo2E3Nnq97FR66Ufvv265vdFLiUq1dmmj2+tSqe33EjO/2Zud2tV8tVFrlouFRrdS7ElcLvrVWp73Vkb0nS/myz2pKhvdil/0C8VCyW/VevleMALVUqXSU0mxudFLvlrlQk/ZpY1CvtDIl5stv1jqNCqCndHk7rSb+U6hVmwVW51avtlt+aVO72Oj0cukeqoq5buNYMcqGMNejuUXO91mvtVtFFrNYrFc7fKeBmIXNgrlVrXWalUa5Vaz2el0q+1KY+NzFecLzWJPyEaxuFEq+Y1OtwderPWUtNHaqOVL1Z4YNcFe1XRSLOXblWq52+hppNPqFHtK6g1msdUolnq2WWzma81Kp1atFPxSpdq7VupBF0qtUk+CdqdYFuysqhO/3WgXCmW/vFHs9ub0rt9o9VKrTrvT7uZ7FtzcKDf9Yk9njU61XOz2LD9fam5sNLob+VazPLCTNQ271POJYq+DzcqGv9HTcWuj0NlolMuNWrnQLrW7Bb9QrnQ7frlWbNdKtd7lnv80fL8nQ884B++CwPNKPI/i+VTrM0bIz/P0eVT4Z0hWV/Oodi5PO88luturyJpTaGvwGWnIZ6/CR8PaY4QVFNmntZArayQXxtx562PGSC6MRfPWxyUjuXAOmrc+rhjJJe0tsLCPbu//5n2JXxjvpGixjfNGj/qIBeUOYpW/PsTleswTdbmXaGiXsibmPGq79cRzGBZNTyJ3Uj3heLCe0GZYT27utyXXE64VuGh6ErmT6gnHg/WENsN64v38ev+7P1VJrqek9wtE7qR6wvFgPaHNsJ7c3H9MpqegXNgcysFF05PInVRPOB6sJ7SZfURbUXB5TWKrw7vnfLkfWo4t/DOeyzEd5thR90qDwjl2VpE1p9B4Hs4qfLIKHw1ryRBrlyHWbkOsBUOsPYZYaUOsZUOsRUMsiRWc93jeeHxwtHccey9b+Ge8cT9zER92KXrV1uCOz60PnhvT7n+sRMjj6N7D4LfbtX3zlCLP3n5dzYY8b9ymUe4lwPeAx8IE3nwvKOqsrWZjYXvLLAfKvxDBy/P0fofxZx4LCt7pzVHaYgzZNJ17yjVNtoUJsi0qsjHuroh+hPFBmaLOUKeIpsnu5D55b0+5USzX/FanXG1UqjM/p9Dtce1W/WCztVNoNybx1+7t4JmaoMj9Ibx/hPUFL031/7C/wfj5mUQ6J5RW+AX1/jSiXirk7+cYyrXFzdFr2n0lvN8m9YV3ZnNcRqGtAC1NfFb731FfiCVypKn+/6T7bXiPTNrnFP57iP+I3Mo13jdZUeqvKPWD8fnjvoxit9h363n3c56Ej9dYtj8NuRfI68mg4O9R/hn9jp/MM3i+FNvyGdzBWcf1Ieb/gbHkeUz6ttUz95POxQXf8T4b525u9hHiP98k/DMkqwsbQn4iD+rc88ZzJUdrzZLIo601tfOAQa605o2PGconWDjfvrF5969mX7z2SHreAdvzsxw4xlHPgPA5RLSRsGdA0N5XvOhnBVKEpfkxtw3TBfq95JF89n4F/P5I/7Pmv+z32jND2vl69nvtmSHH+zYD2x3My56uUzybj/Xv6etFe55d8wc8gxBnr0I7u669L2BwXoa+G+tr8KzC2gR9ZUlfUv9rEfrS+r87Ql9rSv1shL5Ql9iWeYfFolnZ4iTdsi1K/ccU3WrnyfdAf4KyuOmkP2XtPDmu5THHCvMXbe0fNf6av+SoPo63FuM5ViPfFaJhbOb4jzFeYhvGUu1+AD5fIvkb5nyun+XWckop2r1B1BsXbV9A5A769LsxnrHQ1sBLRNPmWeYn7V/bHNJ4DZ6m77sUHP4uPqjlCGmq+0p/3B0/e6M+j8c6Syn91HSNewr/HyPkB1zabwIA",
      "debug_symbols": "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",
      "brillig_names": [
        "is_registered_l2"
      ]
    },
    {
      "name": "is_registered_l1",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "is_registered_l1"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "l1_portal",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "token_contract_class",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "shield_gateway_beacon",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "8459146718181593566": {
            "error_kind": "string",
            "string": "L1 portal address cannot be zero"
          },
          "8606784891595333955": {
            "error_kind": "string",
            "string": "Token contract class cannot be zero"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3fbhypEsbfxde+gKL4l1dZHUVJ1htZsuzISY50FO27nx6vu6fjqW7SFbKG8N1EdtzfQP0KqAIa5tvVnzfvv358e3v/18Pnqzd/fLu6e/jw7svtw/3027e/r6/eP97e3d1+fLv+7ytz+se68CT4/Ond/en3z1/ePX65ehND9tdXN/d/Xr1Jhvz0EX/d3t1cvbHTz/+5vrJsVCqvUXmrUqnKCiq7gophVJUVVXYlVVmJJZUlk/OzzBJ5/k53ffm8z2F+PNiwepqEpznwXCcOq8+OSXg4cZprkrzx64ef6p+r1D+45fGQqFB/YpqtJT5Ven7aW+mzE5n5s1M03z19siCnzi0g47q34Bf4IBcsiME9PxzjucdweKqQDY1ViGxrFfJVKhRpLsPGGAsVcjbQ89OO1oOp2OjIxvmziRxfNDrH3VuQe7eA6/sg8c80a0+tVSg2VqFQZyRKfI4IvpSxeEv2+Wk/Jcb7GYs1THMTnX4O7kXOQsH3boGc13ZlQfc+SN37IHXvg+xew4J0tiCHF1VyxrZXpVfxs6dzleK+n0Oen43mXI0pd3iqvjV9V78S/XCufrKl6ju3NAjnC9WPKc8fHXO5IoU+6Wwey17iwewdzL9uMP+6wfzLsWN7TwZ427sBoXMDgmndgBx4XsQ3tlQRinb+aIqrtd1THnTxcLJh2eCYDD6nP2JFOC3rEJzceZHZefMPyQSSdUhGAslKJJsPEL2QTGiTtUg2HzJ7IZkZJCuRROz+YZImLiTJvCTJlTb0QZINYnclkhaxuxZJtMlKJAltshZJtMlKJF3zq3HdkGx+46wXkoz1yVokGSQrkWx+m6kXkh6zxVoksYJRiWRAZi6SfGKDtdtNNhHZ8zabkfNhsmc2ngqjU8zLAbeYsys87fx8kolXIxmxVGebZwuJLK0fPnkoj9yze/CQNyOPL314CKNc6x4aeebWhYcsw0ONewh9qHEP0cirKn14aOQ9qy48NPReWB8eQrbduoeQKTTuIUam0LqHRt7X6cJDfuT9oj48hLXtxj0UkG237iFk2617CNl24x6KDA817iFk2417aOhzuH14CGvbjXsoI9tu3UPIttv2UDAjn0vpw0MMDzXuIWTbjXvIYn+ocQ8R+tCre4jc2UPsX3po6NOCjXgo2rzU2bmXHvIMDzXuIYxyjXto6FOTfXgIu+CNeyhiTaF1DzE81LiHkG037qGEPtS6h5BtN+6hXCnbtnT2EBc85IxNz087y6Wnq97JEnIcyt5Y66x/N/aGsey1g/nXDuZfGsy/lb5RuR9781j21voisW7sTWPZW+scYDf2dp1PnizwXUeYJwu6zglOFtT67rRfaEEP7zDE1H5b7oNj+z2qC44Z/boORwbHKhzbn230wDEZtMc6HNufHXXB0ba/it8HR+Q9VTgS8p46HBFn6nBEnKnC0bW/utcHx/ZXDbvgyFjvqcMReU8Vjh55Tx2ODI5VOGK9pwrHgLynDkfkPVU4Rqz31OGIvKcKx4S8pw7H9t9+64Mj8p4qHDPynjocsf5Yg2O2aI8/yHH3JpHcwVu4PZyeyg5xpgrHDt4a7oMj5tdVOHbwTnQfHDGfqcMRcaYKx8DgWIUj2mMVjhF5Tx2OlfKePJ/1snlVyInMqZRa3xiwX0qtMwOFUupE5ulzZrcY+wM3c8wf7t3qsyk8naWzxlTpDmScWSrFqVApTkt34ERheVpssckvTTb5aNcP/2NAqmPAUiUy3hQMyDxXKa/uRlmYVloyyed1GePty+Y0FZP+lWIo/CvFyN/ZS9NSyrKo4s4Ny+dnVdao5DlbSSVn1iWVfM6QKM/xg5yNl6qkUcl7ayWVfKdTUSWTd8sYSOzMWiW0CctubkI2pFVHstJQFueHfT4f57TPw4B8XOm1qmM3WvOrVSc0VR1uy1m80ZTDEhJcDvvVmTrLUve8ytlslOJH9MtHR5/yfgCMLswfHdkUouXJ1cvFXdat8sHneGnl23h/U2MDVzA2z2U4Y/x3xj6VIb8YUrcMebO/chn+p8twNpznOZkLDSMZmmuUDFOhYSSau3BMkUsNg8OSnFhvzUXDyDSSsT/f5R3FuQxH6yFUNHbKX5bB2aRVW8u5nZ1NO/0ZXCQuxOAickE/Erk4AheRSwQXiQujvchcArhIXLwBF5EL4rTMBXFa5BIw7spcMO6KXKIFF5GLBxeRC+bTIpeEOC1zQZwWuWTEaZkL5tMSF2cQp2UuiNMiF4v5tMwFcVrmgjgtciEHLiIXxGmRi0Oclrlg/UXkwqPG6fWrh8Zfchk1rytxGXX9pcDFjxqnS1xGjdMFLmHUOF3ignFX5oJxV+QSR51Pl7igvYhc0qhxevek5cRl1PWXApdh90lKXEadT+9zYTPqfLrEZdQ4XeKCcVfkYhGnZS5oLyIXQpyWudSI084tXHyJyyseQuMqmx/dGBsHMla+SZCY7WwsJ7dvbDcnitnTSMamCsbuHzvmjZevq5axsRBVt4z802V0c6KYN86KHzL2N9yxZfkiKXDJDC4ilwQuAhdvHLiIXNBeRC6WwEXkEsBF4kKI0zIXxGmZC8ZdkYvDuCtzieAicZG/PBhcGPNpkYtHnJa5IE7LXBCnRS4B82mZC+K0yCUiTstcMJ8WuSTEaZkL4rTMJYOLxCUjTstcEKclLsFg/UXmMmqc3j9hEeyoeV2Jy6jrLyUuo8bpAhcaNU6XuIwapwtcHMZdmQvGXZELjzqfLnFBe5G5jBqn909YhGH3SUpcRt0nKXAJo86nS1xGnU8XuMRR43SJC8ZdmQvitMhl2H2SEhfEaZFLrhGnOzlfGapsfnRibKxy8qMbY9NAxm7cru2XE6sUTNw3tpuTs3Fjgfg3NTZXMHb/eG3ceKO6ahkbq0tVy9h4o/VIGd0cE57a5M8b+xtuT8eNC0bBxYOLyCWDi8QlMriIXNBeRC7JgYvIJYKLxCUjTstcEKdlLhh3JS7JYNyVuSRwkbhsXOcBLphPi1wIcVrmgjgtc0GcFrk4BheRC+K0yIURp2UumE+LXDzitMwFcVrkEgy4iFwQp2UuiNMil4j1F5nLqHF6/zhJSqPmdSUuo66/FLjkUeN0icuocbrEZdQ4vc8lG4y7MheMuyIXO+p8usQF7UXkQqPG6f3jJHnYfZISl1H3SQpc3Kjz6RKXUefTBS48apwuccG4K3LxiNMyF7QXmQvitMgl1IjTnZyvzFU2P3oxtsrJj26MzQMZK3+1qCWX5qmtJW9XQw55oRwf5yOSwdjVs5K1HJbhiYMvGJA4zfVPfjXFnqsvL4UfrX6wM//gqFR9Xo7nMie/X/0c4txocjT5RfXJyG8kWzJ58RrRipFc/dMbvPPjKXHBAGfs+Twrl55OZGdvJVodi5aDya8LPc6EZanF8ovQQ8Y6gKwDEi2yDkgKAFkFpHyZK0AeB4kWWQcko0VWAukB8sdA7u40kfEGIOuAZICsAxJ5ZB2Q8h25AHkcJNKfOiAjgk0lkAg2lUBmgKwCMqFF1gGZsR5ZBaSlSiDPd2qmVNqh8M7NN8J6589bPRtkwnzoJRlbqsi0hbpcNhtPn/f8dI7dzuItJbiocRc59KLWXVRrUREu+nUuCnBR4y7y6EXNuwi9qHUXBQMXNT4vCh4uat1FGS5q3EUR86LmXRThosZdlJB0N+8ipAvNuwjpQusuki+YgYtachF6UeMuIoP9otZdFMWMztNcgKd4qfHHNckoNIpysqKcrCknH9ZM+I9rrFFownENWYVGnLD5pbf6YC808hmPgiYc17DMbbm2MlzcWjlpWKHJxzVeUY5XlBMU5ciHnfc1UVFOVNizMR7sarKiHeRwWMPGHtfIfWH/7P2kkid44XxxQEgX/YHZaVQbm2wlVdCoNrYiYpyHoNPXY12qvEqVNaqNNcSSKmpUGystJZWKRlaRz7qyNOS9cSqVhry3VqXyKpWKBqloyHeO2Xx+8TDTpUq+eaqgCvJ9MtYsI5s1IV2qskYl30Vi7XIvw+k6hAuVnPcWVVmj2njXtqSSJ0/TfuCiShc0opFryGaZQrG5KCtuHKovqaJGJWeaRZXcovxyRYb13lyonFGpVGVtRNiSKmlUG4fXCir527GLqqBRRVKpokaVVGWlDbviMrL5fJGzxY2FwZIqK1RpI34VVJZUKg2NREal0jBMG2+2unMkmiaXl6qkUcnfv1RUBY1q40RvScUqlYpGUJEPqrKiinxUkU8q8hvR3HFcVOFitNm4yb+oigrVxm3nRVXSqDYyh4JqIwcoqbwic9i4a7ekck6lUpUlf3t6dHPaO6UWLzTOGLEVZp6bbvb+UpOOa+RoUtCE45qNSLKb+08qVqmyRuVUZTlVWawqi1VleVVZQeWvoCtLZdfGak1JFTWqjdWaksprVHIk2R8t5Kw1m3l1MpOgyYd7sZV78W45llihScc1jhSa4yPZxvGegkZRjmeFRuHToCgnKMqR+2v2c7vOkS416bgmKcrJVqEJhzVkrEKjKEfeVVz5R9L4wz4lMgqNohw5WytojmdDxMf7Anmr0BwfDyiQQhOPa6KinKiwJynaTlL4Jx1sB39Pv/333ePtu/d3N58nxemPX+8/fLl9uH/+9cv/Ps1/ef94e3d3+/Htp8eHDzd/fn28eXv38OH0tyvz/M8fwZvraTl6qstTr2SXrqfdutOvp4bjLV97G6ZSp5L/Dw==",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "get_l1_portal",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_l1_portal"
      ]
    },
    {
      "name": "process_log",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "parameters": [
          {
            "name": "log_plaintext",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tx_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "unique_note_hashes_in_tx",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 64,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "first_nullifier_in_tx",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "15261044312996284873": {
            "error_kind": "fmtstring",
            "length": 33,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "process_log"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/7WTyw7CIBBFqcUo0sTEx39MU0y7dOHafyCtLHVRN+766dZkJkyI0QVwEzJMgMNcHoXwKjBKESGCHDEqjAs2Xs7tjDnEqVbBvin5HRijvvhLWH+jkFnk4QPxM50/rJBzmTyfe6F913PTrF8J/z5y+af7y+l//8OzRq9bzCvh/8P4uvfXx/M2ij/SbJGc0ptoOwAqvkT+EvmhJBvn8w+Yb4Svj6KMqNO1tnaNdfZkh8H0dhfwP+KH/QbzqHp4zgQAAA==",
      "debug_symbols": "ZY5bCoMwEEX3Mt/5MLEKdStSJOoogZBIHoUSsvdORGioP5e5w+FyEqw4x31SZrMehjGBtosMyhpqKTOYndJa7VP9hqYEb0/eH9KU6oN0AQbePoVggGY9776jjU1ppCb6zG484Rf94PzH9k1+Zapv6ZScNV42WzRLJRc+B/55Hs4uuEaHxbiSpRx5x0RDszT9BQ==",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "_log_claim",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "11430482739715627628": {
            "error_kind": "string",
            "string": "Function _log_claim can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgUEBCcCBgQAHxgABgAFgEQdAIBGgEYGLgiARAABLgiARQACLgiARgADLgiARwAEJQAAAF4lAAAAXygCAAEEgEgnAgIEADsNAAEAAiYlAAACZh4CAAYAHgIABwAzOAAGAAcACCcCBgEBJAIACAAAAIglAAACjx4CAAYBHgIABwAKOAYHCCQCAAgAAACkJQAAAqEcDAMGACkCAAMAIxDODy0IAQcnAggEBgAQAQgBJwMHBAEAKAcCCC0MCAktDgEJACgJAgktDgIJACgJAgktDgYJACgJAgktDgQJACgJAgktDgMJJwIBAAAtCAECJwIDBAYAEAEDAScDAgQBACgCAgMtDAMELQ4BBAAoBAIELQ4BBAAoBAIELQ4BBAAoBAIELQ4BBAAoBAIELQ4BBC0IAQEAAAECAS0OAgEnAgIEBScCAwQBJwIEBAAtDAQFIwAAAWQMOAUCBCQCAAQAAAHuIwAAAXYtDQEDJwIFBAUGKAUCAScCBwQDADgFBwYtCAEEABABBgEnAwQEAQAoBAIGLQ4FBgAoBgIGLQ4FBicCBwQDADgEBwYAKAMCBy4EAAeAAy4EAAaABC4EAAWABSUAAAKzACgEAgYtDQYFJwIHBAIAOAYHAzcNAAMABSYnAgYEBQw4BQYIJAIACAAAAgUlAAAC+QAoBwIGADgGBQgtDQgELQ0BBicCCQQFDDgFCQokAgAKAAACLiUAAAL5LgQABoADKACABAQABiUAAAMLLgiABQAIACgIAgkAOAkFCi0OBAotDggBADgFAwQtDAQFIwAAAWQoAIAEBHgADQAAAIAEgAMkAIADAAACjioBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEFnqE7fY/72mw8AQECJgEAgAOABYAHLgCAA4AILgCABIAJCwCACIAHgAokAIAKAAAC+C4BgAiABi4CgAaACQEAgAgAAoAIAQCACQACgAkjAAACxyYqAQABBeidCf6hES0OPAEBAiYuAYADgAYLAIAGAAKAByQAgAcAAAMmIwAAAzEuAIADgAUjAAADmC4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAOELgGACoAILgKACIALAQCACgACgAoBAIALAAKACyMAAANTKAGABQQAAQMAgAYAAoAGIwAAA5gm",
      "debug_symbols": "7ZzbTuMwEIbfpde58Nhje8yrrBAqEFClqkWlrLRCvPvG3TpJHW+DICLx4QbhalL/83lSjyeO31eP9f3b891m97R/Xd38el9t9w/r42a/a1rvH9Xq/rDZbjfPd/2PV8z+AcZOF7y+rHe2/XpcH46rG+BKYLWqd4/2f61M8yVPm21tW/KjGtozzp05Q96z5gFrVCjP1qgkttaaAsaEZM7GJJnsG99WjX45jX7jOgEA84P6YSL+klr+NMYfpNbOWglxXb+R2jlrFNBAP02t/6S5p9/2wsVP9CLgR3pRwV5AUHsLATI20gsSuF6QuBqJQSlVG4Ma/DHEsN+NCtUp6vXxH0UT3hX4GUacLhTZ6yR88TrztesUhq4jLsE5J6DjJk2AhDbt0DDddQAhWxLUQusAA6mALTfOVoAYsQUy2A41GdkFHzf/glaZxToqldMgjbqwtcI1RSqceKzCdaTCTazETaTEOYuUOGcqUuHhdDMG4TJW4ZHOnJxjrMIjnfK5ELEKj3UCwlgnIFzuBKS4WwYqpBFbIqfBAFxfMQrN3PcKzbsVjRB4IhJe+mVNZLlT5kxE1HKzn7mIlBjxiOgSIz6REiM+keXm9DMRoeWmrnMRWe4qZCYiC66vzUVkueumeYgIVrJ4n0hZ6XlEFlzDnItIydB8IiVD84jwkqH5REqG5hGR+c011O5xEX3BjojG7IgYxhwRAwEiyd01nPWJWB/TW80GfMxgHE0G42jSH0dc8D6R6XxMrhYw9BEyGEfIYBx5clWagI/J5cJDH0VylZSAj8nVRoY+YgbjiBmMY3p7WAI+ZjA/qvTXHagSWXdo1vo49iacVu6dJUNsAEQnMujTAUnkTp8MyIJf6ZkJSImQSyAG8yvAi/aRBPXeHD+Xm9Hk9yDvOhHJSox4RNIrK32bSH4bi0aI8BIjPpESIx4Rkd/mM6L2YS8RDInkt7Ho+uNvmV6p7dtESox4RGR+W63GiOS31WqEyIJPjpmJiM5v9h0jkt92vBEiqVTQJiSSXxY/QiTD14zGiJTfkUsiipUsvk/ko2n+Xh826/ttfT4y9Olt99A7QfT456X2DhN9Oewf6se3Q22PFe1OFLVkAXUFihrSNhMGISpAcWtP67RNDhVwZZtwaja23DQaGh1/AQ==",
      "brillig_names": [
        "_log_claim"
      ]
    },
    {
      "name": "get_l2_token",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_l2_token"
      ]
    },
    {
      "name": "claim_public",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17288131482828810359": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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gOdUC89pgOc0C8/pgOd0C88ZgOcMC8+ZgOdMC89ZgOcsC8/ZgOdsC885gOccC8+5gOdcC8+/AM+/LDznAZ7zLDznA57zLTwXAJ4LLDwXAp4LLTwXAZ6LLDz/Bjz/tvBcDHgutvBcAngusfBcCngutfBcBngus/BcDngut/BcAXiusPBcCXiutPBcBXiusvD8B/D8x8JzNeC52sLzX8DzXwvPNYDnGgvPtYDnWgvPdYDnOgvP9YDnegvPDYDnBgvPjYDnRgvP/wDP/yw8NwGemyw8NwOemy08twCeWyw8twKeWy08twGe2yw8twOe2y08dwCeOyw8dwKeOy08dwGeuyw8dwOeuy089wCeeyw89wKeey089wGe+yw89wOe+y08DwCeByw8DwKeBy08DwGehyw8DwOehy08jwCeRyw8jwKeRy08jwGexyw8jwOexy08TwCeJyw8TwKeJy08TwGepyw8TwOepy08zwCeZyw8zwKeZy08zwGe5yw8zwOe5y08LwCeFyw8LwKeFy08LwGelyw8LwOely08rwCeVyw8rwKeVy08rwGe1yw8rwOe1y08bwCeNyw8bwKeNy08bwGetyw8bwOety087wCedyw87wKedy087wGe9yw87wOe9y08HwCeDyw8HwKeDy08HwGejyw8HwOejy08nwCeTyw8nwKeTy08nwGezyw8nwOezy08XwCeLyw8XwKeLy08XwGeryw8XwOery083wCebyw83wKeby083wGe7yw83wOe7y08PwCeHyw8PwKeHy08PwGenyw8PwOeny08vwCeXyw8vwKeXy08vwGe3yw8vwOe3y08fwCePyw8fwKePy08fwGevyw8fwOevy08nS+ugXPMEwE8EQtPBeCpsPBUAp5KC08V4Kmy8FQDnmoLTw3gqbHwDAI8gyw8gwHPYAtPLeCptfDUAZ46C0894Km38AwBPEMsPA2Ap8HCMxTwDLXwDAM8wyw8jYCn0cIzHPAMt/CMADwjLDxNgKfJwjMS8Iy08IwCPKMsPLMAnlksPLMCnlktPLMBntksPKMBz2gLzxjAM8bCMzvgmd3CMwfgmcPCMxbwjLXwzAl45rTwzAV45rLwzA145rbwzAN45rHwzAt45rXwzAd45rPwzA945rfwLAB4FgA8lYBnQcCzIOLxuScMXF/tZ71CPlrM3kV+tkrNhxFUXhCA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",
      "debug_symbols": "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zj768pgrv8+ddc4vjNgX68eIffT1axf76OtjLoy5+rWIfbF+jNhHX792sY++Pubsoy/nLhz76Mvz3LOPvj7m7IvV1zmefbF+jNhHX792CWN+eczZF+tfi9gX68eIffT1axf76Otjzj76cu4isI++PM8D++jrY86+WH2dE9gX68dIiNHlaxf76Otjzr5Y/1rEvlg/Ruyjr1+72EdfHnNhH305dyHso6/Pc/bR18ecfbH6OkeEGKnHiH309WsX++jrY86+WP9axL5YP0bsoy9fuyL76Otjzj76cu4iso++Ps/ZR18fc2HMtdc5kX2xfozYR1+/drGPvj7m7Iv1r0Xsi9VjlNhHX752JfbR18ecffTl3EViH319ngtjfnnM2Rfrr3PYF+vHiH309WsX++jrY86+WP1alNkX68eIffTla1dmH319zNlHX85dZGHML89z9tHXx5x9sf46h32xfozYR1+/drGPvjzmhX2x+rWosC/WjxH76OvXLvbR18dcGPOruYvCPvr6PGcffX3M2Rfrr3PYF+vHiH305WtXZR99fczZF6tfiyr7Yv0YsY++fu0SxvzymLOPvpy7qOyjr89z9tHXx5x9sf46h32xdozcxj766rXLbeyjr485+2L9axH7Yv0YCTG6fO1iH319zNlHX81duI199PV5zj76+pizL1Zf5zj2xfoxYh99+drl2EdfH3P2xfrXIiFG6jFiH3392sU++vqYs4++nLtw7KOvz3P20ZfH3LMvVl/nePbF+jFiH3392sU++vqYC2Oufi1iX6wfI/bR169d7KOvjzn76Mu5C88++vI8D+yjr485+2L1dU5gX6wfI/bR169dwphfHnP2xfrXIvbF+jFiH3392sU++vqYs4++nLsQ9tHjmPtbar4/7F12jSiyM/5C5kqt+0Yn0ogie9cZUWR3OSOKwihOiCI7wBlRZI82I4rsomZEkX3RjCiy05kQxcjeZUYU2bvMiCJ7lxlRZO8yI4rCKE6IInuXGVFk7zIjiuxdZkSRvcuMKLJ3ufxkLLHTuT7m7IvUfxmR2HXpx4g93fVrlzDml8ec/aL+tYjdqH6M2Otev3axM74+5uyjL//aMbOPvjzPM/vo62POvlh9nZPZF+vHSIjR5WsX++jrY86+WP9axL5YP0bso69fu9hHXx7zwj76cu6isI++Ps/ZR18fc/bF6uucIsRIPUbso69fu9hHXx9z9sX61yL2xfoxYh99+dpV2UdfH3P20ZdzF5V99PV5zj76+pgLY669zqnsi/VjxD76+rWLffT1MWdfrH8tYl+sHSO/sY++eu3yG/vo62POPvpq7sJv7KOvz3NhzC+POfti/XUO+2L9GLGPvn7tYh99fczZF6tfixz7Yv0YsY++fO1y7KOvjzn76Mu5CyeM+eV5zj76+pizL9Zf57Av1o8R++jr1y720ZfH3LMvVr8WefbF+jFiH3392sU++vqYC2N+NXfh2Udfn+fso6+POfti/XUO+2L9GLGPvnztCuyjr485+2L1a1FgX6wfI/bR169dwphfHnP20ZdzF4F99PV5zj76+pizL9Zf57AvVo+RsI++fO0S9tHXx5x9sf61iH2xfoyEGF2+drGPvj7m7KMv5y6EffT1ec4++vqYsy9WX+dE9sX6MWIfffnaFdlHXx9z9sX61yIhRuoxYh99/drFPvr6mLOPvpy7iOyjr89z9tGXxzyxL1Zf5yT2xfoxYh99/drFPvr6mAtjrn4tYl+sHyP20devXeyjr485++jLuYvEPvryPM/so6+POfti9XVOZl+sHyP20devXcKYXx5z9sX61yL2xfoxYh99/drFPvr6mLOPvpy7KOyjL8/zwj76+pizL1Zf5xT2xfoxEmJ0+drFPvr6mLMv1r8WsS/WjxH76OvXLvbRl8e8so++nLuo7KOvz3P20dfHnH2x+jqnCjFSjxH76OvXLvbR18ecfbH+tYh9sX6M2EdfvXbdwsWYXx5z9tFXcxdhYx99fZ6zj74+5sKYK69zwsa+WD9G7KOvX7vYR18fc/bF+tci9sXqMXLsoy9fuxz76Otjzj76cu7CsY++Ps+FMb885uyL9dc57Iv1Y8Q++vq1i3309TFnX6x+LfLsi/VjxD768rXLs4++Pubsoy/nLrww5pfnOfvo62POvlh/ncO+WD9G7KOvX7vYR18e88C+WP1aFNgX68eIffT1axf76OtjLoz51dxFYB89jrl3ob4/7F12jSiyM/5C5kqt+0Yn0ogie9cZUWR3OSOK7BcnRFHYAc6IInu0GVFkFzUjiuyLZkRRGMUJUWTvMiOK7F0uZzqEnc71MWdfpJ7pFnZd6jGK7OkuX7siO8DrY85+Uf9axG5UP0ZCjC5fu9gZXx9z9tGXn15H9tHX5zn76Otjzr5YfZ2T2Bfrx4h99OVrV2IffX3M2RfrX4uEGKnHiH309WsX++jrY84++nLuIrGPvj7P2UdfHvPMvlh9nZPZF+vHiH309WsX++jrYy6Mufq1iH2xfozYR1+/drGPvj7m7KMv5y4y++jL87ywj74+5uyL1dc5hX2xfozYR1+/dgljfnnM2RfrX4vYF+vHiH309WsX++jrY84++nLuorKPvjzPK/vo62POvlh9nVPZF+vHSIjR5WsX++jrY86+WP9axL5YP0bso69fu9hHXx1z2dhHX81dyMY++vo8Zx99fczZF2uvc2QTYqQeI/bR169d7KOvjzn7Yv1rEfti/Rixj7587XLso6+POfvoy7kLxz76+jxnH319zIUx117nOPbF+jFiH3392sU++vqYsy/WvxaxL1aPkWcfffna5dlHXx9z9tGXcxeeffT1eS6M+eUxZ1+sv85hX6wfI/bR169d7KOvjzn7YvVrUWBfrB8j9tGXr12BffT1MWcffTl3EYQxvzzm7KOvjzn74utjzj73+pizz70+5uxzL4+5sG+9PubsQ6+POfvQccy9C/X9Ye+ya0SRneWMKAqjOCGK7P5mRJH93IwoskObEUX2XDOiyC5qQhQj+6IZUWSn84Uoxnz/yz650ogie5cZUWTvMiOKwihOiCJ7lxlRZO8yI4rsXWZEkb3LjCiyd5kQxcTeZUYU2bt8IYp5/xbNl+E3msMv1xI7netjzr5oesxnf7mchBipx4g93fVrFzvA62POflH/WsRuVD9G7HUvX7syO+PrY84+enrMR187ZvbR1+c5++jrYy6MufY6J7Mv1o8R++jr1y720dfHnH2x/rWIfbF6jAr76MvXrsI++vqYs4++nLso7KOvz3NhzC+POfti/XUO+2L9GLGPvn7tYh99fczZF6tfiyr7Yv0YsY++fO2q7KOvjzn76Mu5iyqM+eV5zj76+pizL9Zf57Av1o8R++jr1y720VfHPG7si7WvRXFjX6wfI/bR169d7KOvj7kw5hdzF7fFhzG/PM/ZR18fc/bF+usc9sX6MWIfffna5dhHXx9z9sXq1yLHvlg/Ruyjr1+7hDG/PObsoy/nLhz76OvznH309TFnX6y/zmFfrB4jzz768rXLs4++Pubsi/WvReyL9WMkxOjytYt99PUxZx99OXfh2Udfn+fso6+POfti9XVO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2+up68zvN7jT3+BPf0M4/Q1y+hsmVH9l/3Ix+tFNee7GYd8TL6fHL5R/Xcv+f79HKU/4SefLTM/rml7WNb2uanqZ8NPSl5nu1jXdr2t6WNd0Wdf0ZXfTsi27m5Zt2d20bMvupmVbdzd16+6mbt3d1K27m7p1d9MZP659lel6dtPf5ujZIX+bo2fX+22Onp3stzl6dqdf5ng9O85vc/TsIr/N0bMz/DZHz2r/2xw9K/hvc3Styl7Xqux1rcpe16rsda3KQdeqHHStykHXqhx0rcpB16ocdK3KQdeqHHStykHXqhx0rcqia1UWXauy6FqVRdeqLLpWZdG1KouuVVl0rcqia1UWXaty1LUqR12rctS1Kkddq3LUtSpHXaty1LUqR12rctS1Kkddq3LStSonXaty0rUqJ12rctK1Kiddq3LStSonXaty0rUqJ12rcta1Kmddq3LWtSpnXaty1rUqZ12rcta1Kmddq3LWtSpnXaty0bUqF12rctG1Khddq3LRtSoXXaty0bUqF12rctG1Khddq3LVtSpXXaty1bUqV12rctW1Kiv6Le1vc3Styop+8/rbHF2rsqLfpt7MqYp+b/rbHFWrclX0u9Df5qhaleumalWuin6T+dscVatyVfTbyd/mqFqVq6LfOP4yR9HvFn+bo2tVVvT7wt/m6FqVFf0O8Lc5ulZlXb/tq7p+21d1/bav6vptX9X1276q67d9Vddv+6qu3/ZVXb/tq7p+21d1/bav6vptX9X1276q67d9Vddv+6qu3/ZVXb/tq7p+21d1/bav6vptX9X1276q67d9Vddv+6qu3/ZVXb/tq7p+21d1/bav6vptX9X1276q67d9Vddv+6qu3/ZVXb/tq7p+21d1/bav6vptX9X1276q67d9Vddv+6qu3/ZVXb/tq7p+21d1/bav6vptX9X1276q67d9Vddv+6qu3/ZVXb/tq7p+21d1/bav6vptX9X1276q67d9Vddv+6qu3/ZVXb/tq7p+21d1/bav6vptX9X1276q67d9Vddv+6qu3/ZVXb/tq7p+21d1/bav6vptX9X1276q67d9Vddv+6qu3/ZVXb/tq7p+21d1/bav6vptX9X1276q67d9Vddv+6qu3/ZVXb/tq7p+21d1/bav6vptn9t0/bjvZo+qdflmj6qF+WbP1Stz3fbLoWto2HP50pzTbk/d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",
      "brillig_names": [
        "discover_new_notes",
        "build_msg_block",
        "attach_len_to_msg_block",
        "debug_log_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "get_l1_to_l2_membership_witness",
        "notify_created_nullifier_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "directive_to_radix",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "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"
    },
    {
      "name": "_register_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "aztec_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14788743618517749904": {
            "error_kind": "string",
            "string": "Function _register_public can only be called internally"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_register_public"
      ]
    },
    {
      "name": "withdraw_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "withdrawNonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "burnNonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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BigHAgctDQgGACgGAgYtDgYIJAIABAAACscjAAAKqwAoCAIJLQ0JBicCCgQCADgJCgQ8DQQGIwAACsctDQgGACgGAgYtDgYICygAB4BcAAYkAgAGAAAK7ScCCAQAPAkBCC0IAQYAAAECAS0IAQcnAggEZQAQAQgBJwMHBAEAKAcCCC0MCAkuCoBFAAkAKAkCCS4KgEYACQAoCQIJLgqARwAJACgJAgkuCoBIAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAkAKAkCCS4KgFsACQAoCQIJLgqAWwAJACgJAgkuCoBbAAktDgcGJwIIBA4tCAAOLQwBDwAQAAgAJQAAI7otBAAALQwPBycCCQQOLQgADi0MAw8AEAAJACUAACO6LQQAAC0MDwgnAgoEDi0IAA4tDAUPABAACgAlAAAjui0EAAAtDA8JJwIKBCQnAgsEICcCDARELgiAXAAEIwAAD9QMOAQLDiQCAA4AAB6UIwAAD+YtDQYHLQ0HBgAoBgIGLQ4GBy4JgFIABgAoBgIGLgYABoBSJwIGBGQnAgoEDi0IAA4tDAcPLQwGEC4IgFwAEQAQAAoAJQAAJAAtBAAALQwPCC0MEAktDQgKACgKAgotDgoILQgBCicCCwQJABABCwEnAwoEAQAoCAILASCAUgACAAwAKAoCDkA/AA4ADAALLQ0KCAAoCAIILQ4ICicCDAQOLQgADi0MBw8tDAYQLgiAUwARABAADAAlAAAkAC0EAAAtDA8ILQwQCy0NCAYAKAYCBi0OBggHKAALgFQABicCDAQQDDgGDA4kAgAOAAAQ2iUAACHLACgIAgwAOAwGDi0NDgcnAg4EBAY4Cw4PBDgPDhACOAsQDAMwgFQADAAODygADIBUAA8kAgAPAAARGSUAACbXHAwOEAIcDBAPBBwMDw4CBTCAYAAOAA8nAhECAAo4EQ4QJAIAEAAAEVwGOA8OEwsoABOAYAASJAIAEgAAEVwlAAAm6Ro4Bw8QJwIHAgQMOA4HEScCDgIgJAIAEQAAEYgjAAARfS4IgFwABCMAABGoGDgQDwkMOA8OECQCABAAABGfJQAAJvstDAkEIwAAEagDMIBYAAwADw8oAAyAWAAQJAIAEAAAEcUlAAAm1xwMDxACHAwQDAQcDAwPAgw4DwcMJAIADAAAEfEjAAAR5i4IgFwACSMAABJKBTCAYAAPAAwnAhECAAo4EQ8QJAIAEAAAEiUGOAwPEwsoABOAYAASJAIAEgAAEiUlAAAm6ScCDwSAGDgPDBAMOAwODyQCAA8AABJBJQAAJvstDBAJIwAAEkoAOAQJEA44BBARJAIAEQAAEmElAAAnDScCCQQQDDgGCREkAgARAAASeCUAACHLLgQACIADKACABAQAESUAACMILgiABQAEACgEAgkAOAkGES0OEBENKAALgFUABiQCAAYAABLsIwAAErMtCAEGJwIIBAkAEAEIAScDBgQBACgEAggAKAoCCQAoBgILQD8ACwAJAAgtDAYMLgiAXAAPIwAAExMBKAALgF8ABg44CwYIJAIACAAAEwYlAAAnDS0MCgwtDAYPIwAAExMtDQwGACgGAgYtDgYMLQ0EBgAoBgIGLQ4GBC0IAQYAAAECAS0OBAYtCAEIAAABAgEtDg8IJwIKBAQGOA8KCwQ4CwoQAjgPEAkLKAAJgFwACiQCAAoAABSgIwAAE3AHKAAPgFQACwMwgFQACQAQDygACYBUABEkAgARAAATlSUAACbXJwIRBBAMOAsREiQCABIAABOsJQAAIcsAKAQCEQA4EQsSLQ0SCRwMEBICHAwSEQQcDBESAgUwgGAAEgARJwIUAgAKOBQSEyQCABMAABP9BjgREhYLKAAWgGAAFSQCABUAABP9JQAAJukaOAkREww4EgcJJAIACQAAFB8jAAAUFC4IgFwACiMAABQ/GDgTEQcMOBEOCSQCAAkAABQ2JQAAJvstDAcKIwAAFD8nAgkEEAw4CwkRJAIAEQAAFFYlAAAhyy4EAASAAygAgAQEABElAAAjCC4IgAUABwAoBwIJADgJCxEtDgoRLQ4HBgA4DxAEDjgPBAckAgAHAAAUlyUAACcNLQ4ECCMAABSgLQ0IBwcoAAeAVAAILQwIBCMAABS1DSgABIBXAAckAgAHAAAePCMAABTKJwIHAgMtCAEIJwIJBAkAEAEJAScDCAQBACgIAgktDAkKLgqAWwAKACgKAgouCoBbAAoAKAoCCi4KgFsACgAoCgIKLgqAWwAKACgKAgouCoBbAAoAKAoCCi4KgFsACgAoCgIKLQ4HCgAoCgIKLQ4OCi4IgFwABCMAABVFDDgEDQckAgAHAAAchiMAABVXLQ0GBy0NBwYAKAYCBi0OBgctDQwGACgGAgYtDgYMLQgBBgAAAQIBLQgBCCcCCQQhABABCQEnAwgEAQAoCAIJJwIKBCAAOAoJCi0MCQsMOAsKDRYMDQ0kAgANAAAVxS4KgFsACwAoCwILIwAAFaQtCAEJAAABAgEtDggJLQgBCCcCCgQJABABCgEnAwgEAQAoBwIKACgMAgsAKAgCDUA/AA0ACwAKLQ0IBwAoBwIHLQ4HCC0OCAYnAgcECC4IgFwABCMAABYdDDgEBwgkAgAIAAAbXiMAABYvLQ0JBi0NBgcAKAcCBy0OBwYtCAEHAAABAgEuCoBDAActCAEIAAABAgEuCoBdAAgtCAEJAAABAgEuCoBdAAknAgoEHigCAAsAAQAnAgwEDy4IgFwABCMAABaJDDgEDA0kAgANAAAapiMAABabLQ0JCgEoAAaAVgAMLQ0MCxwMCwYALQ0HCwQ4BgsHADgKBwYtDgYJLQ0IBwQ4BwsIADgGCAcvCIBDAAYcDAYIACwCAAkAAAAAAAAAAAAAAAAA//////////////////////////8OOAgJCiQCAAoAABcSJQAAJx84DAAGAAcnAgYCVCcCCAJpJwIJAk0nAgoCZScCCwJnJwIMAnInAg0CVycCDwJoJwIQAnsnAhECdycCEgJhJwITAjAnAhQCTCcCFQJvJwIWAn0nAhcCMicCGAJkJwIZAnMnAhoCMScCGwJ0LQgBHCcCHQQcABABHQEnAxwEAQAoHAIdLQwdHi0ODR4AKB4CHi0OCB4AKB4CHi0OGx4AKB4CHi0ODx4AKB4CHi0OGB4AKB4CHi0ODB4AKB4CHi0OEh4AKB4CHi0OER4AKB4CHi0ODh4AKB4CHi0OFB4AKB4CHi0OFx4AKB4CHi0OBh4AKB4CHi0OFR4AKB4CHi0OFB4AKB4CHi0OGh4AKB4CHi0ODh4AKB4CHi0OCR4AKB4CHi0OCh4AKB4CHi0OGR4AKB4CHi0OGR4AKB4CHi0OEh4AKB4CHi0OCx4AKB4CHi0OCh4AKB4CHi0ODh4AKB4CHi0OEB4AKB4CHi0OEx4AKB4CHi0OFh4nAggEAScCCgQDADgICgktCAEGABABCQEnAwYEAQAoBgIJLQ4ICQAoCQIJLQ4ICScCCQQDADgGCQgtDAgJLQ4HCQAoHAIHACgGAgotDQoJJwILBAIAOAoLCD47AAcACAAJABspAgAGADiWwlYtCAEHJwIIBAYAEAEIAScDBwQBACgHAggtDAgJLQ4BCQAoCQIJLQ4CCQAoCQIJLQ4DCQAoCQIJLQ4FCQAoCQIJLQ4GCS0IAQEnAgIEBgAQAQIBJwMBBAEAKAECAi0MAgMuCoBdAAMAKAMCAy4KgF0AAwAoAwIDLgqAXQADACgDAgMuCoBdAAMAKAMCAy4KgF0AAy0IAQIAAAECAS0OAQInAgEEBS4IgFwABCMAABmhDDgEAQMkAgADAAAaKyMAABmzLQ0CAycCBQQFBigFAgInAgcEAwA4BQcGLQgBBAAQAQYBJwMEBAEAKAQCBi0OBQYAKAYCBi0OBQYnAgcEAwA4BAcGACgDAgcuBAAHgAMuBAAGgAQuBAAFgAUlAAAnMQAoBAIGLQ0GBScCBwQCADgGBwM3DQADAAUmJwIFBAUMOAQFBiQCAAYAABpCJQAAIcsAKAcCBQA4BQQGLQ0GAy0NAgUnAggEBQw4BAgJJAIACQAAGmslAAAhyy4EAAWAAygAgAQEAAYlAAAjCC4IgAUABgAoBgIIADgIBAktDgMJLQ4GAgEoAASAXwADLQwDBCMAABmhLQ0JDQI4CgQPJwIRBCAMOA8REiQCABIAABrGJQAAIcsAKAYCEQA4EQ8SLQ0SEBwMEA8ALQ0HEAQ4DxARADgNEQ8tDg8JBDgQCw0tDg0HLQ0IDwMwgFcABAAQDygABIBXABEkAgARAAAbFSUAACbXJwISBCAMOBASEyQCABMAABssJQAAIcsAKAYCEgA4EhATLQ0TERwMERAABDgQDREAOA8RDS0ODQgBKAAEgF8ADS0MDQQjAAAWiS0NBgonAgwECAw4BAwNJAIADQAAG3klAAAhywAoCgIMADgMBA0tDQ0LHAwLCgAnAgwBAC0IAQsnAg0EBQAQAQ0BJwMLBAEAKAsCDScCDwQEQwOwAAqAWQAPAAwADQUwgFQABAAKLgiAXAAIIwAAG84NKAAIgFQADCQCAAwAABv0IwAAG+MBKAAEgF8ACC0MCAQjAAAWHS0NCQwAOAoIDQ44Cg0PJAIADwAAHA8lAAAnDScCEAQEDDgIEBEkAgARAAAcJiUAACHLACgLAhAAOBAIES0NEQ8nAhEEIAw4DRESJAIAEgAAHEslAAAhyy4EAAyAAygAgAQEACElAAAjCC4IgAUAEAAoEAIRADgRDRItDg8SLQ4QCQEoAAiAXwAMLQwMCCMAABvOBSgABIBUAActDQYJATCAVwAEAAonAg8ECAw4Bw8QJAIAEAAAHLElAAAhywAoCAIPADgPBxAtDRALASgAB4BfAA8OOAcPECQCABAAABzZJQAAJw0nAhEECAw4DxESJAIAEgAAHPAlAAAhywAoCAIRADgRDxItDRIQADgHDQ8OOAcPESQCABEAAB0VJQAAJw0nAhIECAw4DxITJAIAEwAAHSwlAAAhywAoCAISADgSDxMtDRMRASgAB4BYAA8OOAcPEiQCABIAAB1UJQAAJw0nAhIECAw4DxITJAIAEwAAHWslAAAhywAoCAISADgSDxMtDRMHHAwLDwQZKAAPgGAACxwMEA8EADgLDxAOOAsQEiQCABIAAB2iJQAAJw0ZKAAQgGAACxwMEQ8EADgLDxAOOAsQESQCABEAAB3GJQAAJw0ZKAAQgGAACxwMBw8EADgLDwcOOAsHECQCABAAAB3qJQAAJw0nAg8EEAw4Cg8QJAIAEAAAHgElAAAhyy4EAAmAAygAgAQEABElAAAjCC4IgAUACwAoCwIPADgPChAtDgcQLQ4LBgEoAASAXwAHLQwHBCMAABVFLQ0GBycCCQQQDDgECQokAgAKAAAeVyUAACHLLgQAB4ADKACABAQAESUAACMILgiABQAIACgIAgkAOAkECi4KgFwACi0OCAYBKAAEgF8ABy0MBwQjAAAUtS0NBg4BKAAEgFQADycCEQQgDDgEERIkAgASAAAetyUAACHLACgHAhEAOBEEEi0NEhAnAhIEZAw4DxITJAIAEwAAHtwlAAAhyy4EAA6AAygAgAQEAGUlAAAjCC4IgAUAEQAoEQISADgSDxMtDhATADgECg4nAhAEIAw4BBASJAIAEgAAHx4lAAAhywAoCAIQADgQBBItDRIPJwISBGQMOA4SEyQCABMAAB9DJQAAIcsuBAARgAMoAIAEBABlJQAAIwguCIAFABAAKBACEgA4Eg4TLQ4PEwA4BAwOJwIRBCAMOAQREiQCABIAAB+FJQAAIcsAKAkCEQA4EQQSLQ0SDycCEgRkDDgOEhMkAgATAAAfqiUAACHLLgQAEIADKACABAQAZSUAACMILgiABQARACgRAhIAOBIOEy0ODxMtDhEGASgABIBfAA4tDA4EIwAAD9QkAgAOAAAf8iMAACBHJwIPBAIMOAUPECQCABAAACAJJQAAIcsAKAkCDwA4DwUQLQ0QDicCDwQQLQgAEC0MCBEtDAoSLQwLEy0MDBQtDA4VABAADwAlAAAh3S0EAAAjAAAgRwEoAAWAXwAOLQwOBSMAAAkxKACABAR4AA0AAACABIADJACAAwAAIIAqAQABBfeh86+lrdTKPAEBAiYqAQABBb4eP/8+pPb6PAEBAiYlAAAgWC0IAQInAgMEBAAQAQMBJwMCBAEAKAICAy0MAwQuCoBdAAQAKAQCBC4KgF0ABAAoBAIELgqAXQAELQ0CAwAoAwIDLQ4DAi0IAQMnAgQEBQAQAQQBJwMDBAEAKAMCBC0MBAUuCoBdAAUAKAUCBS4KgF0ABQAoBQIFLgqAXQAFACgFAgUtDgEFLgiAWgAELQwCAS0MAwIuCIBcAAMmJQAAIFgtDQQFCygABYBaAAYkAgAGAAAhVScCBwQAPAkBBycCBQQGLQgABi0MAQctDAIILQwDCS0MBAoAEAAFACUAACd3LQQAAC0NAQUtDQIGLQ0DBy0OBQEtDgYCLQ4HAy4KgF4ABAEoAAaAXwACLQ0CASYqAQABBQ0KLvL2wvvvPAEBAiYqAQABBUSNqimioUC3PAEBAiYqAQABBeidCf6hES0OPAEBAiYlAAAgWC0NAwYtDQQHCygAB4BaAAgkAgAIAAAiAycCCQQAPAkBCQsoAAaAWAAHJAIABwAAIpQjAAAiGC0NAQYtDQIHLQ0DCC0NBAknAgsEAww4CAsMJAIADAAAIj8lAAAhyy4EAAaAAygAgAQEAAQlAAAjCC4IgAUACgAoCgILADgLCAwtDgUMASgACIBfAAUOOAgFBiQCAAYAACJ/JQAAJw0tDgoBLQ4HAi0OBQMtDgkEIwAAIwcnAgYEBy0IAActDAEILQwCCS0MAwotDAQLABAABgAlAAAndy0EAAAtDQEGLQ0CBy0NBAguBAAGgAMoAIAEBAAEJQAAIwguCIAFAAkAKAkCCgEoAAqAXAALLQ4FCy0OCQEtDgcCLgqAXwADLQ4IBCMAACMHJi4BgAOABgsAgAYAAoAHJACABwAAIyMjAAAjLi4AgAOABSMAACOVLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAAI4EuAYAKgAguAoAIgAsBAIAKAAKACgEAgAsAAoALIwAAI1AoAYAFBAABAwCABgACgAYjAAAjlSYqAQABBQ/0kvy25IIAPAEBAiYqAQABBQLcbieAdhKdPAEBAiYlAAAgWCcCAwEALQgBAicCBAQhABABBAEnAwIEAQAoAgIEJwIFBCBDA7AAAYBZAAUAAwAELQ0CAQAoAQIBLQ4BAi0MAgEmJQAAIFgtCAEFJwIGBBEAEAEGAScDBQQBACgFAgYnAgcEEAA4BwYHLQwGCAw4CAcJFgwJCSQCAAkAACRMLgqAXAAIACgIAggjAAAkKy0IAQYAAAECAS0OBQYMOAIDBSQCAAUAACTLIwAAJGsBKAADgFMABw44AwcIJAIACAAAJIUlAAAnDQw4AgcIJAIACAAAJKIjAAAkly4IgFMABSMAACTCAjgCAwcOOAMCCCQCAAgAACS5JQAAJtctDAcFIwAAJMItDAUEIwAAJNYuCIBcAAQjAAAk1gcoAASAVAACLQgBBQAAAQIBLQ4CBScCCAQEBjgECAkEOAkICgI4BAoHCygAB4BcAAgkAgAIAAAlNyMAACUUASgAAoBfAAcOOAIHCCQCAAgAACUuJQAAJw0tDgcFIwAAJTctDQUHLgiAXAACIwAAJUYMOAIHBSQCAAUAACVhIwAAJVgtDQYBLQwEAiYtCAEIAAABAgEuCoBcAAgFKAACgFQACScCCwQACygAC4BUAAokAgAKAAAlpwcoAAmAVAANCjgNAgwkAgAMAAAlpyUAACbpLgiAXAAFIwAAJbINKAAFgFQACiQCAAoAACYhIwAAJcctDQYFLQ0ICScCCgQQDDgCCgskAgALAAAl5iUAACHLLgQABYADKACABAQAESUAACMILgiABQAIACgIAgoAOAoCCy0OCQsBKAACgF8ABS0OCAYtDAUCIwAAJUYAOAkFCw44CQsMJAIADAAAJjglAAAnDQw4CwQMJAIADAAAJlUjAAAmSi4IgFsACiMAACaaADgDCwwOOAMMDSQCAA0AACZsJQAAJw0nAg0EZAw4DA0OJAIADgAAJoMlAAAhywAoAQINADgNDA4tDQ4LLQwLCiMAACaaLQ0ICxkoAAuAYAAMHAwKCwQAOAwLCg44DAoNJAIADQAAJsIlAAAnDS0OCggBKAAFgF8ACi0MCgUjAAAlsioBAAEFKIaSsEfc/UM8AQECJioBAAEFZGGIqMbPlMs8AQECJioBAAEFyW+TOxOd6RY8AQECJioBAAEFRafKcRlB5BU8AQECJioBAAEFWgLkG7UeqZ88AQECJgEAgAOABYAHLgCAA4AILgCABIAJCwCACIAHgAokAIAKAAAndi4BgAiABi4CgAaACQEAgAgAAoAIAQCACQACgAkjAAAnRSYlAAAgWC4IgFwABSMAACeHDSgABYBYAAYkAgAGAAAn8iMAACecLQ0BBS0NAgYtDQMHLQ0ECC0IAQknAgoEBQAQAQoBJwMJBAEAKAYCCicCCwQEACgJAgw/DwAKAAwtDQkGACgGAgYtDgYJLQ4FAS0OCQItDgcDLQ4IBCYtDQMGDDgFBgcBKAAFgF8ABiQCAAcAACgQIwAAKMEtDQEHLQ0CCC0NAwktDQQKJwIMBAQMOAUMDSQCAA0AACg3JQAAIcsAKAgCDAA4DAUNLQ0NCycCDQQDDDgFDQ4kAgAOAAAoXCUAACHLACgHAg0AOA0FDi0NDgwAOAsMDScCDAQEDDgFDA4kAgAOAAAohiUAACHLLgQACIADKACABAQABSUAACMILgiABQALACgLAgwAOAwFDi0ODQ4tDgcBLQ4LAi0OCQMtDgoEIwAAKMEtDAYFIwAAJ4c=",
      "debug_symbols": "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",
      "brillig_names": [
        "withdraw_public"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "1149705418984161792": {
            "error_kind": "string",
            "string": "Invalid nonce"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7069518359247663558": {
            "error_kind": "string",
            "string": "Function _claim_public can only be called internally"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8459146718181593566": {
            "error_kind": "string",
            "string": "L1 portal address cannot be zero"
          },
          "8606784891595333955": {
            "error_kind": "string",
            "string": "Token contract class cannot be zero"
          },
          "11430482739715627628": {
            "error_kind": "string",
            "string": "Function _log_claim can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14788743618517749904": {
            "error_kind": "string",
            "string": "Function _register_public can only be called internally"
          },
          "16541607464495309456": {
            "error_kind": "fmtstring",
            "length": 16,
            "item_types": []
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "register_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "eth_token",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "aztec_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "name",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          },
          {
            "name": "name_len",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "symbol",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          },
          {
            "name": "symbol_len",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "decimals",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "8998099065237381256": {
            "error_kind": "string",
            "string": "Expected address did not match supplized token address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17288131482828810359": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18159344801564042747": {
            "error_kind": "string",
            "string": "Token already registered"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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d1ehfHcVyndXoXx3Fcp3V6F8dxXKd1ehfHcVyndXoXx3tSHlUdSGdMZSbUj5xbUj5RfXjpRHUTvSGUu1I+UX11f77ibVQK3FUL67CuW7q1C+uwrlu2tQvrsG5btrBxIvbgcSL24HEi9uUOfdNajz7hrUeXcN6ry7BnXeXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXXux7+7+PUNLSF6PlpC8Hi0hvbtrCcnr0RKS16MZktejGdK7uwblu2tQ5901qPPuGtR5dw3qvLsGdd5dgzrvrkGdd9egzrtrUL67BuW7a1C+uwblu2tQvrsG5btrUL67BuW7a1C+uwblu2tQvrsG5btrUL67BuW7a1C+uwblu2tQvrsG5btrUL67BuW7a1C+uwblu2tQvrsG5btrUL67BuW7a1C+uwblu2tQvrsG5btrUL67BuW7a1C+u/Zi393kjVCDenfXoN7dQfnuWoN6d9eg3t11qHd3UL67BnXeXYM6765BnXfXoHx3Dcp316B8dw3Kd9egfHcdynfXoXx3Hcp316F8d/1AWos7lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765DnXfXoc6761Dn3XUo311PSJmZPSFlZnZDyszsUL67bkiZmd2QMjP7q313k2qg1mIo312H8t11KN9dh/LddSjfXYfy3XUo312H8t11KN9dh/LddSjfXYfy3XUo312H8t11KN9dh/LddSjfXYfy3XUo312H8t11KN9dh/LddSjfXYfy3XUo312H8t11KN9dh/LddSjfXYfy3XUo312H8t11KN9dh/LddSjfXYfy3XUo312H8t11qPPuOtR5dx3qvLveoNbiBrUWN6i1uEOtxR1qLYby3fUX++4mb1lf7LubVYPkge4dyQPdX+27u3/L2pE80L0DeaDTcQB5oM9qgNbisxqgtfisBogXn9UA8eKzGiBefFYDxIvPaoB48VkNEC8+qwHixT/+FVQ1UGsxku/u/FdQazGS7+78V1BrMZLv7vxXUGsx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QvnuKpTvrkL57iqU765C+e4qlO+uQvnuKpTvrkL57iqU765C+e4qlO+uQvnuKpTvrkL57iqU765C+e4qlO+uQvnuKpTvrkL57iqU765C+e4qlO+uQvnuKpTvrkL57iqU765C+e4qlO+uQvnuKpTvrkL57iqU765C+e4qlO+uQvnuKpTvrkL57iqU765C+e4qlO+uQvnuKpTvrkL57hqU765B+e4alO+uQfnu2oG0Fjco312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYPy3TUo312D8t01KN9dg/LdNSjfXYfy3XUo312H8t11KN9dP5DW4g7lu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW76y/23bUW/v5tPF9Gfa0mQFUToapJUNW8eC2O7VHNeZF8rebFa3GxZzW1fa2mQFVToappUNW8dC1OxxGea/HRv1TzWt/dtBooXgzlu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW761C+uw7lu+tQvrsO5bvrUL67DuW760i+u3wg+e7OaoDW4rMaoLX4rAZoLT6rAVqLz2qA1uKzGqC1+KwGaC0+qwFai89qoNZiJN/dWQ3UWozkuzurgVqLkXx3ZzVQazGS7+6sBmotRvLdndVArcVIvruzGqi1GMl3d1YDtRYj+e7OaqDWYiTf3VkN1FqM5Ls7q4Fai5F8d2c1UGsxku/urAZqLUby3Z3VQK3FSL67sxqotRjJd3dWA7UWI513d1YDtRYjnXd3VgO1FiOdd3dWA7UWI513d1YDtRYjnXd3VgO1FiOdd3dWA7UWI/nuzmqg1mIk391ZDdRajOS7O6uBWouRfHdnNVBrMZLv7qwGai1G8t2d1UCtxUi+u7MaqLUYyXd3VgO1FiP57s5qoNZiJN/dWQ3UWozkuzurgVqLkXx3ZzVQazGS7+6sBmotRvLdndVArcVIvruzGqi1GMl3d1YDtRYj+e7OaqDWYiTf3VkN1FqM5Ls7q4Fai5F8d2c1UGsxku/urAZqLUby3Z3VQK3FSL67sxqotRjJd3dWg7QWByjfXYDy3QUo312A8t2FA2ktDlC+uwDluwtQvrsA5bsLUL67AOW7C1C+uwDluwtQvrsA5bsLUL67AOW7C1C+uwDluwtQvrsA5bsLUL67AOW7C1C+uwDluwtQvrsA5bsLUL67AOW7C1C+uwDluwtQvrsA5bsLUL67AOW7C1C+uwDluwtQvrsA5bsLUL67AOW7C1C+uwDluwtQvrsA5bsLUL67AOW7C1C+uwDluwtQvrsA5bsLUL67AOW7C1C+uwDluwtQvrsA5bsLUL67AOW7C1C+uwDluwtQvrsA5bsLUL67AOW7C1C+uwDluwtQvrsA5bsLUL67AOW7C1C+uwDluwtQvrsA5bsLUL67AOW7C1C+uwDluwtQvrsA5bsLUL67AOW7C1C+uwDluwtQvrsA5bsLUL67AOW7C1C+uwDluwtQvrsA5bsLUL67AOW7C1C+uwDluwtQvrsA5bsLUL67COW7i1C+uwjlu4tQvrt4IK3FEcp3F6F8dxHKdxehfHcRyncXoXx3Ecp3F6F8dxHKdxehfHcRyncXoXx3Ecp3F6F8dxHKdxehfHcRyncXoXx3Ecp3F6F8dxHKdxehfHcRyncXoXx3Ecp3F6F8dxHKdxehfHcRyncXoXx3Ecp3F6F8dxHKdxehfHcRyncXoXx3Ecp3F6F8dxHKdxehfHcRyncXoXx3Ecp3F6F8dxHKdxehfHcRyncXoXx3Ecp3F6F8dxHKdxehfHcRyncXoXx3Ecp3F6F8dxHKdxehfHcRyncXoXx3Ecp3F6F8dxHKdxehfHcRyncXoXx3Ecp3F6F8dxHKdxehfHcRyncXoXx3Ecp3F6F8dxHKdxehfHcRyncXoXx3Ecp3F6F8dxHKdxehfHcRyncXoXx3Ecp3F6F8dxHKdxehfHcRyncXoXx3Ecp3F6F8dxHKdxehfHcRyneXoHx3Ccp3l6B8dwnKd5cOpLU4QfnuEpTvLkH57hKU7y5B+e4SlO8uQfnuEpTvLkH57hKU7y5B+e4SlO8uQfnuEpTvLkH57hKU7y5B+e4SlO8uQfnuEpTvLkH57hKU7y5B+e4SlO8uQfnuEpTvLkH57hKU7y5B+e4SlO8uQfnuEpTvLkH57hKU7y5B+e4SlO8uQfnuEpTvLkH57hKU7y5B+e4SlO8uQfnuEpTvLkH57hKU7y5B+e4SlO8uQfnuEpTvLkH57hKU7y5B+e4SlO8uQfnuEpTvLkH57hKU7y5B+e4SlO8uQfnuEpTvLkH57hKU7y5B+e4SlO8uQfnuEpTvLkH57hKU7y5B+e4SlO8uQfnuEpTvLkH57hKU7y5B+e4SlO8uQfnuEpTvLkH57hKU7y5B+e4SlO8uQfnuEpTvLkH57hKU7y5B+e4SlO8uQfnuEpTvLkH57hKU7y5B+e4MyndnUL47g/LdGZTvzg6ktdigfHcG5bszKN+dQfnuDMp3Z1C+O4Py3RmU786gfHcG5bszKN+dQfnuDMp3Z1C+O4Py3RmU786gfHcG5bszKN+dQfnuDMp3Z1C+O4Py3RmU786gfHcG5bszKN+dQfnuDMp3Z1C+O4Py3RmU786gfHcG5bszKN+dQfnuDMp3Z1C+O4Py3RmU786gfHcG5bszKN+dQfnuDMp3Z1C+O4Py3RmU786gfHcG5bszKN+dQfnuDMp3Z1C+O4Py3RmU786gfHcG5bszKN+dvdh311r4+7ex9fS1mgxVTYGqpkJV8+K1OLZHNd3C12o6UjWv9t1NqnnxWlzsWU1tX6uJUNUkqGoMqpqXrsXpOMJznzr612oKVDX1tdWEjz08DpBqUNVA8WIo351B+e4MyndnUL47g/LdGZTvzqB8dwbluzMo351B+e4MyndnUL47g/LdGZTvzqB8dwbluzMo351B+e4MyndnUL67DOW7y1C+uwzlu8tQvrt8IK3FGcp3l6F8dxnKd5ehfHcZyneXoXx3Gcp3l6F8dxnKd5ehfHcZyneXoXx3Gcp3l6F8dxnKd5ehfHcZyneXoXx3Gcp3l6F8dxnKd5ehfHcZyneXoXx3Gcp3l6F8dxnKd5ehfHcZyneXoXx3Gcp3l6F8dxnKd5ehfHcZyneXoXx3Gcp3l6F8dxnKd5ehfHcZyneXoXx3Gcp3l6F8dxnKd5ehfHcZyneXoXx3Gcp3l6F8dxnKd5ehfHcZyneXoXx3Gcp3l6F8dxnKd5ehfHcZyneXoc67y1Dn3WWo8+4y1Hl3Geq8uwx13l2GOu8uQ513l6HOu8tQ591lqPPuMtR5dxnqvLsMdd5dhjrvLkP57jKU7y5D+e4ylO8uQ/nuMpTvLkP57jKU7y5D+e4ylO8uQ/nuMpTvLkP57jKU7y5D+e4ylO8uQ/nuMpTvLkP57jKU7y5D+e4KlO+uQPnuCpTvrkD57sqBtBYXKN9dgfLdFSjfXYHy3RUo312B8t0VKN9dgfLdFSjfXYHy3RUo312B8t0VKN9dgfLdFSjfXYHy3RUo312B8t0VKN9dgfLdFSjfXYHy3RUo312B8t0VKN9dgfLdFSjfXYHy3RUo312B8t0VKN9dgfLdFSjfXYHy3RUo312B8t0VKN9dgfLdFSjfXYHy3RUo312B8t0VKN9dgfLdFSjfXYHy3RUo312B8t0VKN9dgfLdFSjfXYHy3RUo312B8t0VKN9dgfLdFSjfXYHy3RUo312B8t0VKN9dgfLdFSjfXYHy3RUo312B8t0VKN9dgfLdFSjfXYHy3RUo312B8t0VKN9dgfLdFSjfXYHy3RUo312B8t0VKN9dgfLdFSjfXYHy3RUo312B8t0VKN9dgfLdFSjfXYHy3RUo312B8t0VKN9dgfLdFSjfXYHy3RUo312F8t1VKN9dhfLdVSjfXT2Q1uIK5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu6tQvrsK5burUL67CuW7q1C+uwrlu2tQvrsG5btrUL67BuW7awfSWtygfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dw3Kd9egfHcNynfXoHx3Dcp316B8dx3Kd9ehfHcdynfXoXx3/UBaizuU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uQ/nuOpTvrkP57jqU765D+e46lO+uL/Dd5fr47fnn7qsJR3lUE44enz+OtQ1+XSz+/eNS6vO3qeTRX7beH385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",
      "brillig_names": [
        "discover_new_notes",
        "debug_log_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "attach_len_to_msg_block",
        "debug_log_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "storage_read",
        "debug_log_oracle_wrapper",
        "storage_read",
        "debug_log_oracle_wrapper",
        "build_msg_block",
        "get_l1_to_l2_membership_witness",
        "notify_created_nullifier_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "get_l1_token",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "parameters": [
          {
            "name": "aztec_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_l1_token"
      ]
    },
    {
      "name": "_claim_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "eth_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7069518359247663558": {
            "error_kind": "string",
            "string": "Function _claim_public can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_claim_public"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Beacon"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "target",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "overrides",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "minter",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "shield_gateway_beacon",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "private_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "shielded_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Portal"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "l1_portal",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "l1_tokens",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "l2_tokens",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token_contract_class_id",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "shield_gateway_beacon",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "eth_token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "aztec_token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::Register"
        },
        {
          "fields": [
            {
              "name": "token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "from",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "to",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "amount",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::Withdraw"
        },
        {
          "fields": [
            {
              "name": "eth_token",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
              }
            },
            {
              "name": "recipient",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "amount",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            },
            {
              "name": "message_leaf_index",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::Deposit"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "aztec_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::_register_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::_register_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "l1_portal",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "token_contract_class",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "shield_gateway_beacon",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::claim_shielded_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::claim_shielded_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::claim_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::claim_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::_claim_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::_claim_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "withdrawNonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "burnNonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::withdraw_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::withdraw_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::_log_claim_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::_log_claim_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "eth_token",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "aztec_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "name",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  },
                  {
                    "name": "name_len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "symbol",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  },
                  {
                    "name": "symbol_len",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "decimals",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Portal::register_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Portal::register_private_abi"
        }
      ]
    }
  },
  "file_map": {
    "109": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "114": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "118": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/dispatch/mod.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let name = function.name();\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_struct().map(|typ: (StructDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "119": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/events/mod.nr",
      "source": "use super::utils::compute_event_selector;\nuse protocol_types::meta::generate_serialize_to_fields;\n\ncomptime fn generate_event_interface(s: StructDefinition) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let (serialization_fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let content_len = serialization_fields.len();\n\n    let event_type_id = compute_event_selector(s);\n\n    quote {\n        impl aztec::event::event_interface::EventInterface<$content_len> for $name {\n            fn get_event_type_id() -> aztec::protocol_types::abis::event_selector::EventSelector {\n                aztec::protocol_types::traits::FromField::from_field($event_type_id)\n            }\n\n            fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n                _emit(self);\n            }\n        }\n    }\n}\n\npub comptime fn event(s: StructDefinition) -> Quoted {\n    let event_interface = generate_event_interface(s);\n    s.add_attribute(\"abi(events)\");\n    quote {\n        $event_interface\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "121": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "122": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "125": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_initializer, is_fn_internal,\n        is_fn_private, is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform note discovery, since they may need to access notes. This is slightly inefficient\n    // and could be improved by only doing it once we actually attempt to read any.\n    let note_discovery_call = if NOTES.len() > 0 {\n        create_note_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $note_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_unconstrained(f: FunctionDefinition) {\n    let context_creation = quote { let mut context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All unconstrained functions perform note discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let note_discovery_call = if NOTES.len() > 0 {\n        create_note_discovery_call()\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $note_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_return_public(true);\n    f.set_body(modified_body);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::discovery::discover_new_notes`, causing for new notes to be added to PXE and made\n/// available for the current execution.\ncomptime fn create_note_discovery_call() -> Quoted {\n    quote {\n        /// Safety: note discovery returns nothing and is performed solely for its side-effects. It is therefore always\n        /// safe to call.\n        unsafe {\n            dep::aztec::discovery::discover_new_notes(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            )\n        };\n    }\n}\n"
    },
    "126": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/mod.nr",
      "source": "pub mod dispatch;\npub mod functions;\npub mod utils;\npub mod notes;\npub mod storage;\npub mod events;\n\nuse functions::{stub_registry, utils::transform_unconstrained};\nuse notes::{generate_note_export, NOTES};\nuse storage::STORAGE_LAYOUT_NAME;\n\nuse dispatch::generate_public_dispatch;\nuse utils::{get_trait_impl_method, module_has_storage};\n\nuse crate::discovery::MAX_NOTE_PACKED_LEN;\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `process_log` and `sync_notes` functions PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n    let unconstrained_functions = m.functions().filter(|f: FunctionDefinition| {\n        f.is_unconstrained() & !f.has_named_attribute(\"test\") & !f.has_named_attribute(\"public\")\n    });\n    for f in unconstrained_functions {\n        transform_unconstrained(f);\n    }\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let process_log = generate_process_log();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $process_log\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    let mut max_note_packed_len: u32 = 0;\n    if notes.len() > 0 {\n        max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (StructDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The note discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_notes`, `do_process_log`\n            /// and `process_private_note_log`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_process_log() -> Quoted {\n    // This mandatory function processes a log emitted by the contract. This is currently used to process private logs\n    // and perform note discovery of either private notes or partial notes.\n    // The bulk of the work of this function is done by aztec::discovery::do_process_log, so all we need to do is call\n    // that function.\n\n    // We'll produce the entire body of the function in one go and then insert it into the function.\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        quote {\n            unconstrained fn process_log(\n                log_plaintext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                tx_hash: Field,\n                unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                first_nullifier_in_tx: Field,\n                recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                // Because this unconstrained function is injected after the contract is processed by the macros, it'll not\n                // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\n                // unconstrained execution context since it will not be available otherwise.\n                let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\n\n                // TODO(#10727): allow other contracts to process logs and deliver notes\n                let contract_address = context.this_address();\n\n                aztec::discovery::private_logs::do_process_log(\n                    contract_address,\n                    log_plaintext,\n                    tx_hash,\n                    unique_note_hashes_in_tx,\n                    first_nullifier_in_tx,\n                    recipient,\n                    _compute_note_hash_and_nullifier,\n                );\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            unconstrained fn process_log(\n                _log_plaintext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                _tx_hash: Field,\n                _unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                _first_nullifier_in_tx: Field,\n                _recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (StructDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    quote {\n        unconstrained fn sync_notes() {\n            aztec::oracle::note_discovery::sync_notes();\n        }\n    }\n}\n"
    },
    "127": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/notes/mod.nr",
      "source": "use crate::{note::note_getter_options::PropertySelector, prelude::Point};\nuse super::utils::AsStrQuote;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, derive_generators, Hash, Hasher, poseidon2::Poseidon2Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (StructDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: StructDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: StructDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: StructDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` implementation for a given partial note struct `s` and returns it as a quote.\n///\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field {\n///         ...\n///     }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n///         ...\n///     }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n///\n/// # On differences from `generate_note_hash_trait_impl`\n/// We use multi-scalar multiplication (MSM) instead of Poseidon2 here since this is a partial note and therefore\n/// does require MSM's additive homomorphism property (the property is used to add to the commitment in public).\n/// We don't use this implementation for standard notes as well because Poseidon2 is significantly cheaper\n/// constraints-wise.\n///\n/// # On including length in note hash preimage\n/// For a given commitment C = a*G1 + b*G2 + c*G3 we take an x-coordinate of C.x and use it as the hash.\n/// However, due to elliptic curve symmetry about the x-axis, for any x-coordinate,\n/// there are two points with that x-coordinate. This means -C has the same hash (x-coord) as C,\n/// and the tuple [-a, -b, -c] produces the same hash as [a, b, c].\n///\n/// This property makes the hash trivially not collision resistant without including the length.\n/// By including the length l, the commitment becomes:\n/// C = a*G1 + b*G2 + c*G3 + l*G_len\n///\n/// Since -l would be -3 (an extraordinarily large number that cannot be a valid preimage length),\n/// including the length protects against these collisions.\ncomptime fn generate_note_hash_trait_impl_for_partial_note(\n    s: StructDefinition,\n    indexed_fixed_fields: [(Quoted, Type, u32)],\n    indexed_nullable_fields: [(Quoted, Type, u32)],\n) -> Quoted {\n    let name = s.name();\n\n    // First we compute quotes for MSM\n    // `compute_note_hash()` is computed over all the fields so we need to merge fixed and nullable.\n    let merged_fields = indexed_fixed_fields.append(indexed_nullable_fields);\n    // Now we prefix each of the merged fields with `self.` since they refer to the struct members here.\n    let prefixed_merged_fields = merged_fields.map(|(name, typ, index): (Quoted, Type, u32)| {\n        (quote { self.$name }, typ, index)\n    });\n    let (new_generators_list, new_scalars_list, _, new_aux_vars) =\n        generate_multi_scalar_mul(prefixed_merged_fields);\n\n    let (g_slot, g_len) = generate_fixed_generators();\n    let new_generators = new_generators_list.push_back(g_slot).push_back(g_len).join(quote {,});\n\n    let merged_fields_len = merged_fields.len() + 1; // +1 for the storage slot appended below\n    let new_scalars = new_scalars_list\n        .push_back(quote { std::hash::from_field_unsafe(storage_slot) })\n        .push_back(quote { std::hash::from_field_unsafe($merged_fields_len) })\n        .join(quote {,});\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                $new_aux_vars\n                let point = std::embedded_curve_ops::multi_scalar_mul(\n                    [$new_generators],\n                    [$new_scalars]\n                );\n                point.x\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly in\n                // the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly in\n                // the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: StructDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: StructDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Number of fixed generators used to ensure that we don't have a collision of indices in derive_generators(...) in\n/// the generate_multi_scalar_mul(...) function. If the indices collided this could result in a critical vulnerability\n/// (e.g. in case of G_slot collision with other another note field an attacker could move a note to an arbitrary\n/// slot).\nglobal NUM_FIXED_GENERATORS: u32 = 2;\n\n/// Generates G_slot and G_len generator point quotes.\ncomptime fn generate_fixed_generators() -> (Quoted, Quoted) {\n    let generators: [Point; NUM_FIXED_GENERATORS] =\n        derive_generators(\"aztec_nr_generators\".as_bytes(), 0);\n\n    let g_slot_x = generators[0].x;\n    let g_slot_y = generators[0].y;\n    let g_len_x = generators[1].x;\n    let g_len_y = generators[1].y;\n\n    let g_slot = quote {\n        aztec::protocol_types::point::Point { x: $g_slot_x, y: $g_slot_y, is_infinite: false }\n    };\n    let g_len = quote {\n        aztec::protocol_types::point::Point { x: $g_len_x, y: $g_len_y, is_infinite: false }\n    };\n\n    (g_slot, g_len)\n}\n\n/// Generates quotes necessary for multi-scalar multiplication of `indexed_fields` (indexed struct fields). Returns\n/// a tuple containing quotes for generators, scalars, arguments and auxiliary variables. For more info on what are\n/// auxiliary variables and how they are used, see `generate_serialize_to_fields` function.\n///\n/// Example return values:\n/// generators_list: [aztec::generators::Ga1, aztec::generators::Ga2, aztec::generators::Ga3, aztec::generators::Ga4]\n/// scalars_list: [\n///     std::hash::from_field_unsafe(amount.lo as Field),\n///     std::hash::from_field_unsafe(amount.hi as Field),\n///     std::hash::from_field_unsafe(npk_m_hash as Field),\n///     std::hash::from_field_unsafe(randomness as Field)\n/// ]\n/// args_list: [amount: u128, npk_m_hash: Field, randomness: Field]\n/// aux_vars: []\ncomptime fn generate_multi_scalar_mul(\n    indexed_fields: [(Quoted, Type, u32)],\n) -> ([Quoted], [Quoted], [Quoted], Quoted) {\n    let mut generators_list = &[];\n    let mut scalars_list = &[];\n    let mut args_list = &[];\n    let mut aux_vars_list = &[];\n    for i in 0..indexed_fields.len() {\n        // Destructure tuple containing:\n        // - field_name: the name of the struct field/member (as a Quoted type)\n        // - typ: the type of the struct field/member (as a Type)\n        // - field_start_index: index where this field starts in the serialized note array (as u32)\n        let (field_name, typ, field_start_index) = indexed_fields[i];\n        // We add NUM_FIXED_GENERATORS to the start index to avoid collision with fixed generators.\n        let start_generator_index = NUM_FIXED_GENERATORS + field_start_index;\n        let (serialization_fields, aux_vars) =\n            generate_serialize_to_fields(field_name, typ, &[], true);\n        for j in 0..serialization_fields.len() {\n            let serialization_field = serialization_fields[j];\n            let generator_index = start_generator_index + j;\n\n            let generators: [Point; 1] =\n                derive_generators(\"aztec_nr_generators\".as_bytes(), generator_index);\n            let generator_x = generators[0].x;\n            let generator_y = generators[0].y;\n\n            generators_list = generators_list.push_back(\n                quote {\n                aztec::protocol_types::point::Point { x: $generator_x, y: $generator_y, is_infinite: false }\n                },\n            );\n            scalars_list = scalars_list.push_back(\n                quote { std::hash::from_field_unsafe($serialization_field) },\n            );\n        }\n        args_list = args_list.push_back(quote { $field_name: $typ });\n        aux_vars_list = aux_vars_list.append(aux_vars);\n    }\n\n    let aux_vars = if aux_vars_list.len() > 0 {\n        let joint = aux_vars_list.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n    (generators_list, scalars_list, args_list, aux_vars)\n}\n\n/// TODO: The macros shouldn't have a hard-coded opinion of a log layout; not even for partial notes.\n/// Since partial notes are about to be refactored, I won't tackle it yet.\n//\n/// Generates setup payload for a given note struct `s`. The setup payload contains log plaintext and hiding point.\n///\n/// # On including length in note hash preimage\n/// The hiding point is computed as a multi-scalar multiplication that includes the length of the preimage\n/// to protect against collisions due to elliptic curve symmetry.\n///\n/// When computing a note hash in the partial notes flow, we take the hiding point, add the nullable fields to it\n/// in public and then we take the x-coordinate of the point and use it as the note hash. E.g. for a given commitment\n/// C = a*G1 + b*G2 + c*G3 we take an x-coordinate of C.x. However, due to elliptic curve symmetry about the x-axis,\n/// for any x-coordinate, there are two points with that x-coordinate. This means -C has the same hash (x-coord) as C,\n/// and the tuple [-a, -b, -c] produces the same hash as [a, b, c].\n///\n/// This property makes the hash trivially not collision resistant without including the length.\n/// By including the length l, the commitment becomes:\n/// C = a*G1 + b*G2 + c*G3 + l*G_len\n///\n/// Since -l would be -3 (an extraordinarily large number that cannot be a valid preimage length),\n/// including the length protects against these collisions.\n///\n/// # Example function output\n/// ```\n/// struct TokenNoteSetupPayload {\n///     log_plaintext: [u8; 160],\n///     hiding_point: aztec::protocol_types::point::Point\n/// }\n///\n/// impl TokenNoteSetupPayload {\n///     fn new(mut self, npk_m_hash: Field, randomness: Field, storage_slot: Field) -> TokenNoteSetupPayload {\n///         let hiding_point = std::embedded_curve_ops::multi_scalar_mul(\n///             [\n///                 Point { x: 0x..., y: 0x... },\n///                 Point { x: 0x..., y: 0x... },\n///                 Point { x: 0x..., y: 0x... },\n///                 Point { x: 0x..., y: 0x... }\n///             ],\n///             [\n///                 std::hash::from_field_unsafe(npk_m_hash),\n///                 std::hash::from_field_unsafe(randomness),\n///                 std::hash::from_field_unsafe(storage_slot),\n///                 std::hash::from_field_unsafe(3)\n///             ]\n///         );\n///\n///         let let storage_slot_bytes = storage_slot.to_be_bytes();\n///         let let note_type_id_bytes = TokenNote::get_id().to_be_bytes();\n///\n///         for i in 0..32 {\n///             log_plaintext[i] = storage_slot_bytes[i];\n///             log_plaintext[32 + i] = note_type_id_bytes[i];\n///         }\n///\n///         let packed_note = [npk_m_hash as Field, randomness as Field];\n///\n///         for i in 0..packed_note.len() {\n///             let bytes: [u8; 32] = packed_note[i].to_be_bytes();\n///             for j in 0..32 {\n///                 log_plaintext[64 + i * 32 + j] = bytes[j];\n///             }\n///         }\n///\n///         TokenNoteSetupPayload {\n///             log_plaintext,\n///             hiding_point\n///         }\n///     }\n///\n///     fn encrypt_log(self, context: &mut PrivateContext, recipient_keys: aztec::protocol_types::public_keys::PublicKeys, recipient: aztec::protocol_types::address::AztecAddress) -> [Field; 17] {\n///\n///         let encrypted_log_bytes: [u8; 513] = aztec::encrypted_logs::log_assembly_strategies::default_aes128::partial_note::::compute_partial_public_log_payload(\n///             context.this_address(),\n///             self.log_plaintext,\n///             recipient,\n///             sender\n///         );\n///\n///         aztec::utils::bytes::be_bytes_31_to_fields(encrypted_log_bytes)\n///     }\n///\n/// impl aztec::protocol_types::traits::Empty for TokenNoteSetupPayload {\n///     fn empty() -> Self {\n///         Self { log_plaintext: [0; 160], hiding_point: aztec::protocol_types::point::Point::empty() }\n///     }\n/// }\n/// ```\ncomptime fn generate_setup_payload(\n    s: StructDefinition,\n    indexed_fixed_fields: [(Quoted, Type, u32)],\n    indexed_nullable_fields: [(Quoted, Type, u32)],\n    note_type_id: Field,\n) -> (Quoted, Quoted) {\n    let name = s.name();\n    let setup_payload_name = f\"{name}SetupPayload\".quoted_contents();\n\n    // First we get the MSM related quotes\n    let (new_generators_list, new_scalars_list, new_args_list, new_aux_vars) =\n        generate_multi_scalar_mul(indexed_fixed_fields);\n    let new_args = &[quote {mut self}]\n        .append(new_args_list)\n        .push_back(quote { storage_slot: Field })\n        .join(quote {,});\n\n    let (g_slot, g_len) = generate_fixed_generators();\n    let new_generators = new_generators_list.push_back(g_slot).push_back(g_len).join(quote {,});\n    let merged_fields_len = indexed_fixed_fields.len() + indexed_nullable_fields.len() + 1; // +1 for storage_slot\n    let new_scalars = new_scalars_list\n        .push_back(quote { std::hash::from_field_unsafe(storage_slot) })\n        .push_back(quote { std::hash::from_field_unsafe($merged_fields_len) })\n        .join(quote {,});\n\n    // Then the log plaintext ones\n    let log_plaintext_length = indexed_fixed_fields.len() * 32 + 64;\n    let setup_log_plaintext: Quoted = get_setup_log_plaintext_body(\n        s,\n        log_plaintext_length,\n        indexed_nullable_fields,\n        note_type_id,\n    );\n\n    // Then we compute values for `encrypt_log(...)` function.\n    // First, the length of the items that are broken into bytes:\n    let encrypted_log_bytes_length = 1 /* eph_pk_sign */\n        + 48 /* header_ciphertext */\n        + log_plaintext_length /* log_plaintext */\n        + 16\n        - (log_plaintext_length % 16); /* pkcs#7 aes padding */\n\n    // Each field contains 31 bytes so the length in fields is computed as ceil(encrypted_log_byte_length / 31)\n    // Recall: ceil(x / y) = (x + y - 1) // y (integer division).\n    let encrypted_log_fields_length = 1 /* tag */\n        + 1 /* eph_pk.x */\n        + (encrypted_log_bytes_length + 30) / 31;\n\n    (\n        quote {\n        pub struct $setup_payload_name {\n            pub log_plaintext: [u8; $log_plaintext_length],\n            pub hiding_point: aztec::protocol_types::point::Point\n        }\n\n        impl $setup_payload_name {\n            pub fn new($new_args) -> $setup_payload_name {\n                $new_aux_vars\n                let hiding_point = std::embedded_curve_ops::multi_scalar_mul(\n                    [$new_generators],\n                    [$new_scalars]\n                );\n                $setup_log_plaintext\n\n                $setup_payload_name {\n                    log_plaintext,\n                    hiding_point\n                }\n            }\n\n            pub fn encrypt_log(self, context: &mut aztec::prelude::PrivateContext, recipient: aztec::protocol_types::address::AztecAddress, sender: aztec::protocol_types::address::AztecAddress) -> [Field; $encrypted_log_fields_length] {\n                aztec::encrypted_logs::log_assembly_strategies::default_aes128::partial_note::compute_partial_public_log_payload(\n                    context.this_address(),\n                    self.log_plaintext,\n                    recipient,\n                    sender,\n                )\n            }\n        }\n\n        impl aztec::protocol_types::traits::Empty for $setup_payload_name {\n            fn empty() -> Self {\n                Self { log_plaintext: [0; $log_plaintext_length], hiding_point: aztec::protocol_types::traits::Empty::empty() }\n            }\n        }\n    },\n        setup_payload_name,\n    )\n}\n\n/// Generates setup log plaintext for a given note struct `s`. The setup log plaintext is computed by serializing\n/// storage slot from target function arguments, note type id from the note struct `s` and the fixed fields. The fixed\n/// fields are obtained by passing the whole note struct to the `generate_serialize_to_fields(...)` function but omitting the\n/// nullable fields.\ncomptime fn get_setup_log_plaintext_body(\n    s: StructDefinition,\n    log_plaintext_length: u32,\n    indexed_nullable_fields: [(Quoted, Type, u32)],\n    note_type_id: Field,\n) -> Quoted {\n    // Now we compute serialization of the fixed fields. We do that by passing the whole note struct\n    // to the generate_serialize_to_fields function but we omit the nullable fields.\n    let to_omit = indexed_nullable_fields.map(|(name, _, _): (Quoted, Type, u32)| name);\n    let (fields_list, aux_vars) =\n        generate_serialize_to_fields(quote { }, s.as_type(), to_omit, true);\n\n    // If there are `aux_vars` we need to join them with `;` and add a trailing `;` to the joined string.\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n    let fields = fields_list.join(quote {,});\n\n    quote {\n        let mut log_plaintext: [u8; $log_plaintext_length] = [0; $log_plaintext_length];\n\n        let storage_slot_bytes: [u8; 32] = storage_slot.to_be_bytes();\n        let note_type_id_bytes: [u8; 32] = $note_type_id.to_be_bytes();\n\n        for i in 0..32 {\n            log_plaintext[i] = storage_slot_bytes[i];\n            log_plaintext[32 + i] = note_type_id_bytes[i];\n        }\n\n        $aux_vars_for_serialization\n        let packed_note = [$fields];\n\n        for i in 0..packed_note.len() {\n            let bytes: [u8; 32] = packed_note[i].to_be_bytes();\n            for j in 0..32 {\n                log_plaintext[64 + i * 32 + j] = bytes[j];\n            }\n        }\n    }\n}\n\n/// Generates finalization payload for a given note struct `s`. The finalization payload contains log and note hash.\n///\n/// Example:\n/// ```\n/// struct TokenNoteFinalizationPayload {\n///     context: &mut aztec::prelude::PublicContext,\n///     hiding_point_slot: Field,\n///     setup_log_slot: Field,\n///     public_values: [Field; 2]\n/// }\n///\n/// impl TokenNoteFinalizationPayload {\n///     fn new(mut self, context: &mut aztec::prelude::PublicContext, slot: Field, amount: u128) -> TokenNoteFinalizationPayload {\n///         self.context = context;\n///         self.hiding_point_slot = slot;\n///         self.setup_log_slot = slot + aztec::protocol_types::point::POINT_LENGTH as Field;\n///         self.public_values = [amount.lo as Field, amount.hi as Field];\n///         self\n///     }\n///\n///     fn emit(self) {\n///         self.emit_note_hash();\n///         self.emit_log();\n///     }\n///\n///     fn emit_note_hash(self) {\n///         let hiding_point: aztec::prelude::Point = self.context.storage_read(self.hiding_point_slot);\n///         assert(!aztec::protocol_types::traits::is_empty(hiding_point), \"transfer not prepared\");\n///\n///         let finalization_hiding_point = std::embedded_curve_ops::multi_scalar_mul([aztec::generators::Ga3, aztec::generators::Ga4], [std::hash::from_field_unsafe(self.public_values[0]), std::hash::from_field_unsafe(self.public_values[1])]) + hiding_point;\n///\n///         let note_hash = finalization_hiding_point.x;\n///\n///         self.context.push_note_hash(note_hash);\n///\n///         // We reset public storage to zero to achieve the effect of transient storage - kernels will squash\n///         // the writes\n///         // self.context.storage_write(self.hiding_point_slot, [0; aztec::protocol_types::point::POINT_LENGTH]);\n///     }\n///\n///     fn emit_log(self) {\n///         let setup_log_fields: [Field; 8] = self.context.storage_read(self.setup_log_slot);\n///\n///         let mut finalization_log = [0; 11];\n///\n///         for i in 0..setup_log_fields.len() {\n///             finalization_log[i + 1] = setup_log_fields[i];\n///         }\n///\n///         for i in 0..self.public_values.len() {\n///            finalization_log[i + 1 + 8] = self.public_values[j];\n///         }\n///\n///         finalization_log[0] = aztec::protocol_types::utils::field::field_from_bytes([\n///                 (2 >> 8) as u8, 2 as u8, 0,\n///                 (8 >> 8) as u8, 8 as u8, 0,\n///                 (91 >> 8) as u8, 91 as u8,\n///                ], true);\n///\n///         self.context.emit_public_log(finalization_log);\n///\n///         // We reset public storage to zero to achieve the effect of transient storage - kernels will squash\n///         // the writes\n///         // self.context.storage_write(self.setup_log_slot, [0; 8]);\n///     }\n/// }\n///\n/// impl aztec::protocol_types::traits::Empty for TokenNoteFinalizationPayload {\n///     fn empty() -> Self {\n///         Self { context: &mut aztec::prelude::PublicContext::empty(), hiding_point_slot: 0, setup_log_slot: 0, public_values: [0, 0] }\n///     }\n/// }\n/// ```\ncomptime fn generate_finalization_payload(\n    s: StructDefinition,\n    indexed_fixed_fields: [(Quoted, Type, u32)],\n    indexed_nullable_fields: [(Quoted, Type, u32)],\n) -> (Quoted, Quoted) {\n    let name = s.name();\n    let finalization_payload_name = f\"{name}FinalizationPayload\".quoted_contents();\n\n    // We compute serialization of the nullable fields which are to be emitted as a public log. We do that by\n    // passing the whole note struct to the `generate_serialize_to_fields(...)` function but we omit the fixed fields.\n    let to_omit = indexed_fixed_fields.map(|(name, _, _): (Quoted, Type, u32)| name);\n    let (nullable_fields_list, aux_vars) =\n        generate_serialize_to_fields(quote { }, s.as_type(), to_omit, true);\n\n    // If there are `aux_vars` we need to join them with `;` and add a trailing `;` to the joined string.\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    // We compute the log length and we concatenate the fields into a single quote.\n    let public_values_length = nullable_fields_list.len();\n    let nullable_fields = nullable_fields_list.join(quote {,});\n\n    // Now we compute quotes relevant to the multi-scalar multiplication.\n    // Note 1: We ignore the `scalars_list` and `aux_vars` return values because it's not used by the `emit_note_hash`\n    // function. Instead, we use `public_values` (defined on the finalization payload struct) and the scalar list\n    // is computed in the for-loop below.\n    // Note 2: The `args_list` is not used for note hash MSM but instead for the `new` function.\n    let (generators_list, _, args_list, _) = generate_multi_scalar_mul(indexed_nullable_fields);\n\n    // We generate scalars_list manually as we need it to refer self.public_values\n    let mut scalars_list: [Quoted] = &[];\n    for i in 0..public_values_length {\n        scalars_list =\n            scalars_list.push_back(quote { std::hash::from_field_unsafe(self.public_values[$i]) });\n    }\n\n    let generators = generators_list.join(quote {,});\n    let scalars = scalars_list.join(quote {,});\n    let args = args_list.join(quote {,});\n\n    // Then we compute values for `encrypt_log(...)` function\n    let setup_log_plaintext_length = indexed_fixed_fields.len() * 32 + 64;\n\n    let setup_log_bytes_length = 1 /* eph_pk_sign */\n        + 48 /* header_ciphertext */\n        + setup_log_plaintext_length /* log_plaintext */\n        + 16\n        - (setup_log_plaintext_length % 16); /* pkcs#7 aes padding */\n\n    // Each field contains 31 bytes so the length in fields is computed as ceil(encrypted_log_byte_length / 31)\n    // Recall: ceil(x / y) = (x + y - 1) // y (integer division).\n    let setup_log_fields_length = 1 /* tag */\n        + 1 /* eph_pk.x */\n        + (setup_log_bytes_length + 30) / 31;\n\n    let finalization_log_fields_length =\n        1 /* some length encodings (see below) */ + setup_log_fields_length + public_values_length;\n\n    (\n        quote {\n        pub struct $finalization_payload_name {\n            pub context: &mut aztec::prelude::PublicContext,\n            pub hiding_point_slot: Field,\n            pub setup_log_slot: Field,\n            pub public_values: [Field; $public_values_length],\n        }\n\n        impl $finalization_payload_name {\n            pub fn new(mut self, context: &mut aztec::prelude::PublicContext, slot: Field, $args) -> $finalization_payload_name {\n                self.context = context;\n\n                self.hiding_point_slot = slot;\n                self.setup_log_slot = slot + aztec::protocol_types::point::POINT_LENGTH as Field;\n\n                $aux_vars_for_serialization\n                self.public_values = [$nullable_fields];\n\n                self\n            }\n\n            pub fn emit(self) {\n                self.emit_note_hash();\n                self.emit_log();\n            }\n\n            pub fn emit_note_hash(self) {\n                // Read the hiding point from \"transient\" storage and check it's not empty to ensure the transfer was prepared\n                let hiding_point: aztec::prelude::Point = self.context.storage_read(self.hiding_point_slot);\n                assert(!aztec::protocol_types::traits::is_empty(hiding_point), \"transfer not prepared\");\n\n                let finalization_hiding_point = std::embedded_curve_ops::multi_scalar_mul(\n                    [$generators],\n                    [$scalars]\n                ) + hiding_point;\n\n                let note_hash = finalization_hiding_point.x;\n\n                self.context.push_note_hash(note_hash);\n\n                // We reset public storage to zero to achieve the effect of transient storage - kernels will squash\n                // the writes\n                // TODO(#9376): Uncomment the following line.\n                // self.context.storage_write(self.hiding_point_slot, [0; aztec::protocol_types::point::POINT_LENGTH]);\n            }\n\n            pub fn emit_log(self) {\n                let max_log_len = aztec::protocol_types::constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS;\n                // Make sure we aren't overflowing the public log maximum\n                assert(\n                    $finalization_log_fields_length <= max_log_len,\n                    f\"finalization public log must not exceed {max_log_len} fields\",\n                );\n\n                // We load the setup log from storage\n                let setup_log_fields: [Field; $setup_log_fields_length] = self.context.storage_read(self.setup_log_slot);\n\n                // We append the public value to the log and emit it as unencrypted log\n                let mut finalization_log = [0; $finalization_log_fields_length];\n\n                // Populate the first field with number of public values and private values:\n                // Search the codebase for \"disgusting encoding\" to see other hardcoded instances of this encoding, that you might need to change if you ever find yourself here.\n                finalization_log[0] = aztec::protocol_types::utils::field::field_from_bytes([\n                    ($public_values_length >> 8) as u8,\n                    $public_values_length as u8,\n                    0,\n                    ($setup_log_fields_length >> 8) as u8,\n                    $setup_log_fields_length as u8,\n                ], true);\n                let mut offset = 1;\n\n                // Iterate over the partial log and copy it to the final log\n                for i in 0..setup_log_fields.len() {\n                    finalization_log[offset + i] = setup_log_fields[i];\n                }\n                offset += setup_log_fields.len();\n\n                // Iterate over the public values and append them to the log\n                for i in 0..self.public_values.len() {\n                    finalization_log[offset + i] = self.public_values[i];\n                }\n\n                // We emit the finalization log via the public logs stream\n                self.context.emit_public_log(finalization_log);\n\n                // We reset public storage to zero to achieve the effect of transient storage - kernels will squash\n                // the writes\n                // TODO(#9376): Uncomment the following line.\n                // self.context.storage_write(self.setup_log_slot, [0; $setup_log_field_length]);\n            }\n        }\n\n        impl aztec::protocol_types::traits::Empty for $finalization_payload_name {\n            fn empty() -> Self {\n                Self { context: &mut aztec::protocol_types::traits::Empty::empty(), public_values: [0; $public_values_length], hiding_point_slot: 0, setup_log_slot: 0 }\n            }\n        }\n    },\n        finalization_payload_name,\n    )\n}\n\n/// Generates `PartialNote` implementation for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// impl PartialNote<TokenNoteSetupPayload, TokenNoteFinalizationPayload> for TokenNote {\n///     fn setup_payload() -> TokenNoteSetupPayload {\n///         TokenNoteSetupPayload::empty()\n///     }\n///\n///     fn finalization_payload() -> TokenNoteFinalizationPayload {\n///         TokenNoteFinalizationPayload::empty()\n///     }\n/// }\n/// ```\ncomptime fn generate_partial_note_impl(\n    s: StructDefinition,\n    setup_payload_name: Quoted,\n    finalization_payload_name: Quoted,\n) -> Quoted {\n    let name = s.name();\n    quote {\n        impl aztec::note::note_interface::PartialNote<$setup_payload_name, $finalization_payload_name> for $name {\n            fn setup_payload() -> $setup_payload_name {\n                aztec::protocol_types::traits::Empty::empty()\n            }\n\n            fn finalization_payload() -> $finalization_payload_name {\n                aztec::protocol_types::traits::Empty::empty()\n            }\n        }\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: StructDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: StructDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - SetupPayload\n/// - FinalizationPayload\n/// - PartialNote trait implementation\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\n///\n/// `nullable_fields` are a list of quotes passed in as varargs which are used to identify which fields/struct members\n/// in the partial note are nullable.\n#[varargs]\npub comptime fn partial_note(s: StructDefinition, nullable_fields: [Quoted]) -> Quoted {\n    assert_has_owner(s);\n\n    // We separate struct members into fixed ones and nullable ones and we store info about the start index of each\n    // member in the packed note array.\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, nullable_fields);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let (setup_payload_impl, setup_payload_name) = generate_setup_payload(\n        s,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n        note_type_id,\n    );\n    let (finalization_payload_impl, finalization_payload_name) =\n        generate_finalization_payload(s, indexed_fixed_fields, indexed_nullable_fields);\n    let note_hash_impl = generate_note_hash_trait_impl_for_partial_note(\n        s,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n    let partial_note_impl =\n        generate_partial_note_impl(s, setup_payload_name, finalization_payload_name);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $setup_payload_impl\n        $finalization_payload_impl\n        $note_interface_impl\n        $note_hash_impl\n        $partial_note_impl\n        $packable_impl\n    }\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: StructDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: StructDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro and #[partial_note] macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: StructDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "128": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/storage/mod.nr",
      "source": "use std::{collections::umap::UHashMap, hash::{BuildHasherDefault, poseidon2::Poseidon2Hasher}};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: StructDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: StructDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_struct().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_struct().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_struct().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_struct().is_some() {\n        let (def, generics) = typ.as_struct().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_struct().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "129": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_struct().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_struct().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_struct().is_some() {\n        let (s, generics) = typ.as_struct().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: StructDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: StructDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\npub(crate) comptime fn is_note(typ: Type) -> bool {\n    typ.as_struct().map_or(false, |struc: (StructDefinition, [Type])| {\n        let (def, _) = struc;\n        def.has_named_attribute(\"note\")\n            | def.has_named_attribute(\"partial_note\")\n            | def.has_named_attribute(\"custom_note\")\n    })\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n"
    },
    "130": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/messaging.nr",
      "source": "use crate::{\n    hash::{compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness,\n};\n\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    merkle_tree::root::root_from_sibling_path,\n};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field,\n    leaf_index: Field,\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_l1_to_l2_message_hash(\n        portal_contract_address,\n        chain_id,\n        contract_address,\n        version,\n        content,\n        secret_hash,\n        leaf_index,\n    );\n\n    // We prove that `message_hash` is in the tree by showing the derivation of the tree root, using a merkle path we\n    // get from an oracle.\n    // Safety: The witness is only used as a \"magical value\" that makes the merkle proof below pass. Hence it's safe.\n    let (_leaf_index, sibling_path) =\n        unsafe { get_l1_to_l2_membership_witness(contract_address, message_hash, secret) };\n\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert_eq(root, l1_to_l2_root, \"Message not in state\");\n\n    compute_l1_to_l2_message_nullifier(message_hash, secret)\n}\n"
    },
    "140": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "143": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "146": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "147": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize, ToField}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "148": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "149": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "150": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\n}\n\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\n    let _ = store_in_execution_cache_oracle(values);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "151": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n    traits::{Deserialize, FromField},\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "152": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{address::AztecAddress, constants::L1_TO_L2_MSG_TREE_HEIGHT};\n\n/// Returns the leaf index and sibling path of an entry in the L1 to L2 messaging tree, which can then be used to prove\n/// its existence.\npub unconstrained fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field,\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {\n    let returned_message =\n        get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = array::subarray(returned_message, 1);\n\n    (leaf_index, sibling_path)\n}\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field,\n) -> [Field; L1_TO_L2_MSG_TREE_HEIGHT + 1] {}\n"
    },
    "155": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\n    }\n}\n"
    },
    "156": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::{\n    abis::validation_requests::{\n        key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n    },\n    traits::Deserialize,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "157": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        embedded_curve_add_unsafe(point1, point2)\n    } else {\n        // In a constrained context we need to do some black magic in order to satisfy the backend's\n        // expectations about the inputs to an `embedded_curve_add` opcode.\n        //\n        // TODO: document this better.\n        let x_coordinates_match = point1.x == point2.x;\n        let y_coordinates_match = point1.y == point2.y;\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n        result.is_infinite = x_coordinates_match;\n\n        // dbl if x_match, y_match\n        let double = embedded_curve_add_unsafe(point1, point1);\n        result = if double_predicate { double } else { result };\n\n        // infinity if x_match, !y_match\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "160": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr",
      "source": "use crate::discovery::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them\n/// available for later querying via the `get_notes` oracle.\npub unconstrained fn sync_notes() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emtitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "161": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n    traits::{Deserialize, FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    let _ = notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<RetrievedNote<Note>>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter TODO(benesjan): try removing this.\n) -> [Option<RetrievedNote<Note>>; S]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            placeholder_opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_indexed_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "163": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "165": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "172": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub unconstrained fn read(self) -> T {\n        WithHash::unconstrained_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub fn read(self) -> T {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "186": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/unencrypted_logs/unencrypted_event_emission.nr",
      "source": "use crate::{context::PublicContext, event::event_interface::EventInterface};\nuse protocol_types::traits::ToField;\n\nfn emit<Event, let N: u32>(context: &mut PublicContext, event: Event)\nwhere\n    Event: EventInterface<N>,\n{\n    let selector = Event::get_event_type_id();\n\n    let serialized_event = event.serialize();\n    let mut emitted_log = [0; N + 1];\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    for i in 0..serialized_event.len() {\n        emitted_log[i] = serialized_event[i];\n    }\n\n    emitted_log[serialized_event.len()] = selector.to_field();\n\n    context.emit_public_log(emitted_log);\n}\n\npub fn encode_event<Event, let N: u32>(\n    context: &mut PublicContext,\n) -> fn[(&mut PublicContext,)](Event) -> ()\nwhere\n    Event: EventInterface<N>,\n{\n    |e: Event| { emit(context, e); }\n}\n"
    },
    "187": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "189": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/utils/array/mod.nr",
      "source": "mod append;\nmod collapse;\nmod subarray;\nmod subbvec;\n\npub use append::append;\npub use collapse::collapse;\npub use subarray::subarray;\npub use subbvec::subbvec;\n\n// This will eventually be replaced by `BoundedVec::for_each`, once that's implemented.\npub unconstrained fn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..vec.len() {\n        f(vec.get_unchecked(i), i);\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "190": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "191": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "199": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UnconstrainedContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress,\n    block_header::BlockHeader,\n    hash::poseidon2_hash,\n    traits::{Packable, ToField},\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn unconstrained_public_storage_read(\n        context: UnconstrainedContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "215": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "217": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "24": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "253": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "260": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "261": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr",
      "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH,\n    traits::{Deserialize, Empty, Packable, Serialize, ToField},\n};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl Packable<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn pack(self) -> [Field; ETH_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "263": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "265": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "269": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_class_id.nr",
      "source": "use crate::constants::GENERATOR_INDEX__CONTRACT_LEAF;\nuse crate::traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField};\n\npub struct ContractClassId {\n    pub inner: Field,\n}\n\nimpl Eq for ContractClassId {\n    fn eq(self, other: ContractClassId) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl ToField for ContractClassId {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for ContractClassId {\n    fn from_field(value: Field) -> Self {\n        Self { inner: value }\n    }\n}\n\nimpl Serialize<1> for ContractClassId {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<1> for ContractClassId {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] }\n    }\n}\n\nimpl Empty for ContractClassId {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n// Implement the Packable trait so ContractClassId can be stored in contract's storage.\nimpl Packable<1> for ContractClassId {\n    fn pack(self) -> [Field; 1] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; 1]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl ContractClassId {\n    pub fn compute(\n        artifact_hash: Field,\n        private_functions_root: Field,\n        public_bytecode_commitment: Field,\n    ) -> Self {\n        let hash = crate::hash::poseidon2_hash_with_separator(\n            [artifact_hash, private_functions_root, public_bytecode_commitment],\n            GENERATOR_INDEX__CONTRACT_LEAF,\n        ); // TODO(@spalladino): Update generator index\n        ContractClassId::from_field(hash)\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "275": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "277": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "278": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "288": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "292": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_struct().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_struct().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_struct().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_struct().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: StructDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: StructDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: StructDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: StructDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "294": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "295": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "304": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "315": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "333": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "334": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "350": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "351": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "353": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "365": {
      "path": "/home/vscode/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "46": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "47": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "50": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "55": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/portal/src/encoding/deposit.nr",
      "source": "use aztec::{\n    protocol_types::{\n        address::{AztecAddress, EthAddress},\n        hash::sha256_to_field,\n        traits::{FromField, ToField},\n    },\n};\n\n// bytes4(keccak256(\"deposit(address,bytes32,uint256)\")) = 0xeb2243f8\nglobal DEPOSIT_SIGNATURE: [u8; 4] = [0xeb, 0x22, 0x43, 0xf8];\n\npub fn deposit_content_hash(\n    eth_token: EthAddress,\n    recipient: AztecAddress,\n    amount: Field,\n) -> Field {\n    let encoded = abi_encode_deposit(eth_token, recipient, amount);\n    let content_hash = sha256_to_field(encoded);\n    content_hash\n}\n\npub fn abi_encode_deposit(\n    eth_token: EthAddress,\n    recipient: AztecAddress,\n    amount: Field,\n) -> [u8; 100] {\n    // abi.encodeWithSignature(DEPOSIT_SIGNATURE, tokenAddr, recipient, amount)\n    // This encodes the following data:\n    // offset - data\n    // 0x00 - 4 bytes for the signature\n    // 0x04 - 32 bytes for the token address\n    // 0x24 - 32 bytes for the recipient\n    // 0x44 - 32 bytes for the amount\n    // Total: 100 bytes\n    let mut encoded = [0; 100];\n    for i in 0..4 {\n        encoded[i] = DEPOSIT_SIGNATURE[i];\n    }\n\n    let eth_token_bytes: [u8; 32] = eth_token.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = amount.to_be_bytes();\n\n    for i in 0..32 {\n        encoded[i + 0x4] = eth_token_bytes[i];\n        encoded[i + 0x24] = recipient_bytes[i];\n        encoded[i + 0x44] = amount_bytes[i];\n    }\n\n    encoded\n}\n\n// For testing purposes, enables printing the ABI-encoded data\npub unconstrained fn field_from_encoded_bytes(encoded: [u8; 100], offset: u8) -> Field {\n    let mut arr = [0; 31];\n    for i in 0..31 {\n        if offset + i >= 100 {\n            break;\n        }\n        arr[i] = encoded[offset + i];\n    }\n    aztec::protocol_types::utils::field::field_from_bytes(arr, true)\n}\n\n#[test]\nfn test_abi_encode_deposit() {\n    let eth_token = EthAddress::from_field(0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F);\n    let recipient = AztecAddress::from_field(\n        0x1e571fd19f8f3aab48fd795e1b39f72dd61f44735c88a7576721be8a5065f863,\n    );\n    let amount = 0x1234567890abcdef1234567890abcdef;\n    let encoded = abi_encode_deposit(eth_token, recipient, amount);\n\n    // abi.encodeWithSignature(\"deposit(address,bytes32,uint256)\", address(0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F), bytes32(hex\"1e571fd19f8f3aab48fd795e1b39f72dd61f44735c88a7576721be8a5065f863\"), 0x1234567890abcdef1234567890abcdef) =\n    // 0xeb2243f80000000000000000000000002458675deb5e0691da2d2ba8dcaf58cfd2c2651f1e571fd19f8f3aab48fd795e1b39f72dd61f44735c88a7576721be8a5065f863000000000000000000000000000000001234567890abcdef1234567890abcdef\n    let expected: [u8; 100] = [\n        0xeb, 0x22, 0x43, 0xf8, // Function selector - deposit(address,bytes32,uint256)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F\n        0x24, 0x58, 0x67, 0x5d, 0xeb, 0x5e, 0x06, 0x91, 0xda, 0x2d, 0x2b, 0xa8, 0xdc, 0xaf, 0x58,\n        0xcf, 0xd2, 0xc2, 0x65, 0x1f,\n        // Aztec Recipient Address\n        0x1e, 0x57, 0x1f, 0xd1, 0x9f, 0x8f, 0x3a, 0xab, 0x48, 0xfd, 0x79, 0x5e, 0x1b, 0x39, 0xf7,\n        0x2d, 0xd6, 0x1f, 0x44, 0x73, 0x5c, 0x88, 0xa7, 0x57, 0x67, 0x21, 0xbe, 0x8a, 0x50, 0x65,\n        0xf8, 0x63,\n        // Amount\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,\n        0xcd, 0xef,\n    ];\n\n    if encoded != expected {\n        std::println(f\"test_abi_encode_deposit: got: {encoded}\");\n        std::println(f\"test_abi_encode_deposit: expected: {expected}\");\n    }\n    assert_eq(encoded, expected);\n}\n\n#[test]\nfn test_deposit_content_hash() {\n    let content: [u8; 100] = [\n        0xeb, 0x22, 0x43, 0xf8, // Function selector - deposit(address,bytes32,uint256)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0x2458675Deb5E0691da2D2bA8dCaF58CFD2C2651F\n        0x24, 0x58, 0x67, 0x5d, 0xeb, 0x5e, 0x06, 0x91, 0xda, 0x2d, 0x2b, 0xa8, 0xdc, 0xaf, 0x58,\n        0xcf, 0xd2, 0xc2, 0x65, 0x1f,\n        // Aztec Recipient Address\n        0x1e, 0x57, 0x1f, 0xd1, 0x9f, 0x8f, 0x3a, 0xab, 0x48, 0xfd, 0x79, 0x5e, 0x1b, 0x39, 0xf7,\n        0x2d, 0xd6, 0x1f, 0x44, 0x73, 0x5c, 0x88, 0xa7, 0x57, 0x67, 0x21, 0xbe, 0x8a, 0x50, 0x65,\n        0xf8, 0x63,\n        // Amount\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,\n        0xcd, 0xef,\n    ];\n\n    // sha256(content) = 0x5a05320993a46599dc6c5605c5f2bf139d6fb5f3709e23c5af2b530f1e883aa8\n    // sha256_to_field uses the first 31 bytes of the hash\n    let expected: Field = 0x5a05320993a46599dc6c5605c5f2bf139d6fb5f3709e23c5af2b530f1e883a;\n    let content_hash = sha256_to_field(content);\n    if content_hash != expected {\n        std::println(f\"test_deposit_content_hash: got: {content_hash}\");\n        std::println(f\"test_deposit_content_hash: expected: {expected}\");\n    }\n    assert_eq(content_hash, expected);\n}\n"
    },
    "57": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/portal/src/encoding/register.nr",
      "source": "use aztec::{\n    protocol_types::{\n        address::EthAddress,\n        hash::sha256_to_field,\n        traits::{FromField, ToField},\n    },\n};\n\n// bytes4(keccak256(register(address,string,string,uint8))) = 0x611a7a19\ncomptime global REGISTER_SIGNATURE: [u8; 4] = [0x61, 0x1a, 0x7a, 0x19];\n\npub fn register_content_hash(\n    eth_token: EthAddress,\n    name: str<31>,\n    name_len: u8,\n    symbol: str<31>,\n    symbol_len: u8,\n    decimals: u8,\n) -> Field {\n    let encoded = abi_encode_register(eth_token, name, name_len, symbol, symbol_len, decimals);\n    let content_hash = sha256_to_field(encoded);\n\n    // Debug log the ABI-encoded data\n    // let field_array: [Field; 9] = aztec::utils::bytes::bytes_to_fields::<260, 9>(encoded);\n    // dep::aztec::oracle::debug_log::debug_log_format(\"ABI Encoded: {}\", field_array);\n    content_hash\n}\n\npub fn abi_encode_register(\n    eth_token: EthAddress,\n    name: str<31>,\n    name_len: u8,\n    symbol: str<31>,\n    symbol_len: u8,\n    decimals: u8,\n) -> [u8; 260] {\n    // abi.encodeWithSignature(REGISTER_SIGNATURE, tokenAddr, token.name(), token.symbol(), token.decimals())\n    // This encodes the following data:\n    // offset - data\n    // 0x00 - 4 bytes for the signature\n    // 0x04 - 32 bytes for the token address\n    // 0x24 - 32 bytes for the name offset\n    // 0x44 - 32 bytes for the symbol offset\n    // 0x64 - 32 bytes for the decimals\n    // 0x84 - 32 bytes for the name length\n    // 0xa4 - 32 bytes for the name // Limited to 31 bytes\n    // 0xc4 - 32 bytes for the symbol length\n    // 0xe4 - 32 bytes for the symbol // Limited to 31 bytes\n    // Total: 260 bytes\n    let mut encoded = [0; 260];\n\n    let eth_token_bytes: [u8; 32] = eth_token.to_field().to_be_bytes();\n    let decimals_bytes: [u8; 32] = decimals.to_field().to_be_bytes();\n\n    let name_len_bytes: [u8; 32] = name_len.to_field().to_be_bytes();\n    let symbol_len_bytes: [u8; 32] = symbol_len.to_field().to_be_bytes();\n\n    // Fixed offsets for name and symbol\n    // Offset for the name is 0x80 per the ABI encoding, but 0x84 in the raw data\n    let name_offset_bytes: [u8; 32] = 0x80.to_field().to_be_bytes();\n    // Offset for the symbol is 0xc0 per the ABI encoding, but 0xc4 in the raw data\n    let symbol_offset_bytes: [u8; 32] = 0xc0.to_field().to_be_bytes();\n\n    let name_bytes: [u8; 31] = name.as_bytes();\n    let symbol_bytes: [u8; 31] = symbol.as_bytes();\n\n    for i in 0..32 {\n        // First 4 bytes are the function signature\n        if i < 4 {\n            encoded[i] = REGISTER_SIGNATURE[i];\n        }\n\n        encoded[i + 0x4] = eth_token_bytes[i];\n        encoded[i + 0x24] = name_offset_bytes[i];\n        encoded[i + 0x44] = symbol_offset_bytes[i];\n        encoded[i + 0x64] = decimals_bytes[i];\n        encoded[i + 0x84] = name_len_bytes[i];\n        encoded[i + 0xc4] = symbol_len_bytes[i];\n\n        // Copy name & symbol\n        if i < name_len {\n            encoded[i + 0xa4] = name_bytes[i];\n        }\n        if i < symbol_len {\n            encoded[i + 0xe4] = symbol_bytes[i];\n        }\n    }\n\n    encoded\n}\n\nunconstrained fn pad_31<let N: u32>(s: str<N>) -> str<31> {\n    let mut padded = [0; 31];\n    let s = s.as_bytes();\n    for i in 0..31 {\n        if i < N {\n            padded[i] = s[i];\n        }\n    }\n    padded.as_str_unchecked()\n}\n\n#[test]\nunconstrained fn test_abi_encode_register() {\n    let eth_token = EthAddress::from_field(0xbbEda607223492F9dce036A21C459fE1dcab56c7);\n    let name = pad_31(\"Test Token\");\n    let symbol = pad_31(\"TT\");\n    let decimals = 18;\n    let encoded = abi_encode_register(eth_token, name, 10, symbol, 2, decimals);\n\n    // abi.encodeWithSignature(\"register(address,string,string,uint8)\", address(0xbbEda607223492F9dce036A21C459fE1dcab56c7), \"Test Token\", \"TT\", 18) =\n    // 0x611a7a19000000000000000000000000bbeda607223492f9dce036a21c459fe1dcab56c7000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000a5465737420546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000025454000000000000000000000000000000000000000000000000000000000000\n    let expected: [u8; 260] = [\n        0x61, 0x1a, 0x7a, 0x19, // Function selector - register(address,string,string,uint8)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0xbbEda607223492F9dce036A21C459fE1dcab56c7\n        0xbb, 0xed, 0xa6, 0x07, 0x22, 0x34, 0x92, 0xf9, 0xdc, 0xe0, 0x36, 0xa2, 0x1c, 0x45, 0x9f,\n        0xe1, 0xdc, 0xab, 0x56, 0xc7,\n        // Name Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x80,\n        // Symbol Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0xc0,\n        // Decimals: 18\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12,\n        // Name Length: 10\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x0a,\n        // Name: Test Token\n        0x54, 0x65, 0x73, 0x74, 0x20, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n        // Symbol Length: 2\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x02,\n        // Symbol: TT\n        0x54, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n\n    if encoded != expected {\n        std::println(f\"test_abi_encode_register: got: {encoded}\");\n        std::println(f\"test_abi_encode_register: expected: {expected}\");\n    }\n    assert_eq(encoded, expected);\n}\n\n#[test]\nunconstrained fn test_register_content_hash() {\n    let content: [u8; 260] = [\n        0x61, 0x1a, 0x7a, 0x19, // Function selector - register(address,string,string,uint8)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0xbbEda607223492F9dce036A21C459fE1dcab56c7\n        0xbb, 0xed, 0xa6, 0x07, 0x22, 0x34, 0x92, 0xf9, 0xdc, 0xe0, 0x36, 0xa2, 0x1c, 0x45, 0x9f,\n        0xe1, 0xdc, 0xab, 0x56, 0xc7,\n        // Name Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x80,\n        // Symbol Offset\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0xc0,\n        // Decimals: 18\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x12,\n        // Name Length: 10\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x0a,\n        // Name: Test Token\n        0x54, 0x65, 0x73, 0x74, 0x20, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n        // Symbol Length: 2\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x02,\n        // Symbol: TT\n        0x54, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    // sha256(content) = 0x0448b4e27885c9528619c3ccd291634a7aa4f66d562d479904429803f535d9f4\n    // sha256_to_field uses the first 31 bytes of the hash\n    let expected: Field = 0x0448b4e27885c9528619c3ccd291634a7aa4f66d562d479904429803f535d9;\n    let content_hash = sha256_to_field(content);\n    if content_hash != expected {\n        std::println(f\"test_register_content_hash: got: {content_hash}\");\n        std::println(f\"test_register_content_hash: expected: {expected}\");\n    }\n    assert_eq(content_hash, expected);\n}\n"
    },
    "58": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/portal/src/encoding/withdraw.nr",
      "source": "use aztec::protocol_types::{\n    address::EthAddress,\n    hash::sha256_to_field,\n    traits::{FromField, ToField},\n};\n\n// bytes4(keccak256(\"withdraw(address,address,uint256)\")) = 0xd9caed12\nglobal WITHDRAW_SIGNATURE: [u8; 4] = [0xd9, 0xca, 0xed, 0x12];\n\npub fn withdraw_content_hash(eth_token: EthAddress, recipient: EthAddress, amount: Field) -> Field {\n    let encoded = abi_encode_withdraw(eth_token, recipient, amount);\n    let content_hash = sha256_to_field(encoded);\n    content_hash\n}\n\npub fn abi_encode_withdraw(\n    eth_token: EthAddress,\n    recipient: EthAddress,\n    amount: Field,\n) -> [u8; 100] {\n    // abi.encodeWithSignature(WITHDRAW_SIGNATURE, tokenAddr, recipient, amount)\n    // This encodes the following data:\n    // offset - data\n    // 0x00 - 4 bytes for the signature\n    // 0x04 - 32 bytes for the token address\n    // 0x24 - 32 bytes for the recipient\n    // 0x44 - 32 bytes for the amount\n    // Total: 100 bytes\n    let mut encoded = [0; 100];\n    for i in 0..4 {\n        encoded[i] = WITHDRAW_SIGNATURE[i];\n    }\n\n    let eth_token_bytes: [u8; 32] = eth_token.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = amount.to_be_bytes();\n\n    for i in 0..32 {\n        encoded[i + 0x4] = eth_token_bytes[i];\n        encoded[i + 0x24] = recipient_bytes[i];\n        encoded[i + 0x44] = amount_bytes[i];\n    }\n\n    encoded\n}\n\n#[test]\nfn test_abi_encode_withdraw() {\n    let eth_token = EthAddress::from_field(0xbbEda607223492F9dce036A21C459fE1dcab56c7);\n    let recipient = EthAddress::from_field(0x52b1D2CEBF3C80813f82dC4B5F56fCB4e04aC439);\n    let amount = 0x1234567890abcdef;\n    let encoded = abi_encode_withdraw(eth_token, recipient, amount);\n\n    // abi.encodeWithSignature(\"withdraw(address,address,uint256)\", address(0xbbEda607223492F9dce036A21C459fE1dcab56c7), address(0x52b1D2CEBF3C80813f82dC4B5F56fCB4e04aC439), 0x1234567890abcdef) =\n    // 0xd9caed12000000000000000000000000bbeda607223492f9dce036a21c459fe1dcab56c700000000000000000000000052b1d2cebf3c80813f82dc4b5f56fcb4e04ac4390000000000000000000000000000000000000000000000001234567890abcdef\n    let expected: [u8; 100] = [\n        0xd9, 0xca, 0xed, 0x12, // Function selector - withdraw(address,address,uint256)\n        // Eth Token Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0xbbEda607223492F9dce036A21C459fE1dcab56c7\n        0xbb, 0xed, 0xa6, 0x07, 0x22, 0x34, 0x92, 0xf9, 0xdc, 0xe0, 0x36, 0xa2, 0x1c, 0x45, 0x9f,\n        0xe1, 0xdc, 0xab, 0x56, 0xc7,\n        // Recipient Address\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Padding\n        // Address: 0x52b1D2CEBF3C80813f82dC4B5F56fCB4e04aC439\n        0x52, 0xb1, 0xd2, 0xce, 0xbf, 0x3c, 0x80, 0x81, 0x3f, 0x82, 0xdc, 0x4b, 0x5f, 0x56, 0xfc,\n        0xb4, 0xe0, 0x4a, 0xc4, 0x39,\n        // Amount: 0x1234567890abcdef\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab,\n        0xcd, 0xef,\n    ];\n\n    assert_eq(encoded, expected);\n}\n"
    },
    "59": {
      "path": "/home/vscode/turnstile-contracts/aztec/contracts/portal/src/main.nr",
      "source": "mod constants;\nmod encoding;\n\nuse aztec::macros::aztec;\n\n#[aztec]\npub contract Portal {\n    use std::meta::derive;\n\n    use aztec::{\n        event::event_interface::EventInterface,\n        hash::hash_args,\n        macros::{\n            events::event,\n            functions::{\n                initialization_utils::compute_initialization_hash, initializer, internal, private,\n                public,\n            },\n            storage::storage,\n        },\n        protocol_types::{\n            address::{AztecAddress, EthAddress, PartialAddress},\n            contract_class_id::ContractClassId,\n            public_keys::PublicKeys,\n            traits::{FromField, Serialize, ToField},\n        },\n        state_vars::{Map, PublicImmutable},\n        unencrypted_logs::unencrypted_event_emission::encode_event,\n    };\n\n    use authwit::auth::assert_current_call_valid_authwit_public;\n\n    use token::Token;\n\n    use crate::{\n        constants::PUBLIC_NOT_SECRET_SECRET,\n        encoding::{\n            deposit::deposit_content_hash, register::register_content_hash,\n            withdraw::withdraw_content_hash,\n        },\n    };\n\n    #[storage]\n    struct Storage<Context> {\n        l1_portal: PublicImmutable<EthAddress, Context>,\n        l1_tokens: Map<EthAddress, PublicImmutable<AztecAddress, Context>, Context>,\n        l2_tokens: Map<AztecAddress, PublicImmutable<EthAddress, Context>, Context>,\n        token_contract_class_id: PublicImmutable<ContractClassId, Context>,\n        shield_gateway_beacon: PublicImmutable<AztecAddress, Context>,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Register {\n        eth_token: EthAddress,\n        aztec_token: AztecAddress,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Deposit {\n        eth_token: EthAddress,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Withdraw {\n        token: EthAddress,\n        from: AztecAddress,\n        to: EthAddress,\n        amount: u128,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(\n        l1_portal: Field,\n        token_contract_class: Field,\n        shield_gateway_beacon: AztecAddress,\n    ) {\n        assert(l1_portal != 0, \"L1 portal address cannot be zero\");\n        assert(token_contract_class != 0, \"Token contract class cannot be zero\");\n\n        storage.l1_portal.initialize(EthAddress::from_field(l1_portal));\n        storage.token_contract_class_id.initialize(ContractClassId::from_field(\n            token_contract_class,\n        ));\n        storage.shield_gateway_beacon.initialize(shield_gateway_beacon);\n    }\n\n    #[private]\n    fn register_private(\n        eth_token: Field,\n        aztec_token: AztecAddress,\n        name: str<31>,\n        name_len: u8,\n        symbol: str<31>,\n        symbol_len: u8,\n        decimals: u8,\n        message_leaf_index: Field,\n    ) {\n        aztec::oracle::debug_log::debug_log_format(\n            \"Registering L1 token {0} as L2 token {1}\",\n            [eth_token, aztec_token.to_field()],\n        );\n\n        let eth_token = EthAddress::from_field(eth_token);\n\n        assert(storage.l1_tokens.at(eth_token).read().is_zero(), \"Token already registered\");\n\n        // L1->L2 message content hash from token name, symbol, decimals\n        let content_hash =\n            register_content_hash(eth_token, name, name_len, symbol, symbol_len, decimals);\n        aztec::oracle::debug_log::debug_log_format(\"Register content hash: {0}\", [content_hash]);\n\n        // Set the shield gateway beacon\n        Token::at(aztec_token)\n            .set_shield_gateway_beacon(storage.shield_gateway_beacon.read())\n            .enqueue(&mut context);\n\n        // Ensure the supplied token address matches the expected address. This ensures its deployed with\n        // the correct code and initialization parameters.\n        let initializer = Token::interface().init(context.this_address(), name, symbol, decimals);\n        let args_hash = hash_args(initializer.args);\n        let init_hash = compute_initialization_hash(initializer.selector, args_hash);\n        let partial_address = PartialAddress::compute(\n            storage.token_contract_class_id.read(),\n            0x9876543210, // salt, hardcoded\n            init_hash,\n            AztecAddress::from_field(0),\n        );\n\n        let computed_address = AztecAddress::compute(PublicKeys::default(), partial_address);\n        // aztec::oracle::debug_log::debug_log_format(\n        //     \"Supplied Address: {0}, Computed address: {1}\",\n        //     [aztec_token.to_field(), computed_address.to_field()]\n        // );\n        // aztec::oracle::debug_log::debug_log_format(\"Gas left 4: {0}\", [context.l2_gas_left()]);\n        assert(\n            computed_address == aztec_token,\n            \"Expected address did not match supplized token address\",\n        );\n\n        // Consume the message\n        aztec::oracle::debug_log::debug_log_format(\n            \"Consuming message with leaf index {0}\",\n            [message_leaf_index],\n        );\n\n        let l1Portal = storage.l1_portal.read();\n        aztec::oracle::debug_log::debug_log_format(\"L1 Portal: {0}\", [l1Portal.to_field()]);\n\n        context.consume_l1_to_l2_message(\n            content_hash,\n            PUBLIC_NOT_SECRET_SECRET,\n            storage.l1_portal.read(),\n            message_leaf_index,\n        );\n\n        Portal::at(context.this_address())._register_public(aztec_token, eth_token).enqueue(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _register_public(aztec_token: AztecAddress, eth_token: EthAddress) {\n        // Initialize the token mappings\n        storage.l1_tokens.at(eth_token).initialize(aztec_token);\n        storage.l2_tokens.at(aztec_token).initialize(eth_token);\n        Register { eth_token, aztec_token }.emit(encode_event(&mut context));\n    }\n\n    #[private]\n    fn claim_public(\n        eth_token: Field,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        let eth_token = EthAddress::from_field(eth_token);\n\n        let content_hash = deposit_content_hash(eth_token, recipient, amount.to_field());\n        aztec::oracle::debug_log::debug_log_format(\"Deposit content hash: {0}\", [content_hash]);\n\n        // Consume the message\n        context.consume_l1_to_l2_message(\n            content_hash,\n            PUBLIC_NOT_SECRET_SECRET,\n            storage.l1_portal.read(),\n            message_leaf_index,\n        );\n\n        Portal::at(context.this_address())\n            ._claim_public(eth_token, recipient, amount, message_leaf_index)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _claim_public(\n        eth_token: EthAddress,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        Token::at(storage.l1_tokens.at(eth_token).read()).mint_public(recipient, amount).call(\n            &mut context,\n        );\n\n        Portal::at(context.this_address())\n            ._log_claim(eth_token, recipient, amount, message_leaf_index)\n            .call(&mut context);\n    }\n\n    #[private]\n    fn claim_shielded(\n        eth_token: Field,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        let eth_token = EthAddress::from_field(eth_token);\n\n        let content_hash = deposit_content_hash(eth_token, recipient, amount.to_field());\n        aztec::oracle::debug_log::debug_log_format(\"Deposit content hash: {0}\", [content_hash]);\n\n        // Consume the message\n        context.consume_l1_to_l2_message(\n            content_hash,\n            PUBLIC_NOT_SECRET_SECRET,\n            storage.l1_portal.read(),\n            message_leaf_index,\n        );\n\n        Token::at(storage.l1_tokens.at(eth_token).read()).mint_shielded(recipient, amount).call(\n            &mut context,\n        );\n\n        Portal::at(context.this_address())\n            ._log_claim(eth_token, recipient, amount, message_leaf_index)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _log_claim(\n        eth_token: EthAddress,\n        recipient: AztecAddress,\n        amount: u128,\n        message_leaf_index: Field,\n    ) {\n        Deposit { eth_token, recipient, amount, message_leaf_index }.emit(encode_event(\n            &mut context,\n        ));\n    }\n\n    #[public]\n    fn withdraw_public(\n        eth_token: EthAddress,\n        from: AztecAddress,\n        recipient: EthAddress,\n        amount: u128,\n        withdrawNonce: Field,\n        burnNonce: Field,\n    ) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(withdrawNonce == 0, \"Invalid nonce\");\n        }\n\n        // Burn the tokens\n        Token::at(storage.l1_tokens.at(eth_token).read()).burn_public(from, amount, burnNonce).call(\n            &mut context,\n        );\n\n        // Message the L1 Portal\n        let content_hash = withdraw_content_hash(eth_token, recipient, amount.to_field());\n        context.message_portal(storage.l1_portal.read(), content_hash);\n\n        aztec::oracle::debug_log::debug_log_format(\"Withdraw L2ToL1 Message {0}\", [content_hash]);\n\n        Withdraw { token: eth_token, from, to: recipient, amount }.emit(encode_event(&mut context));\n    }\n\n    unconstrained fn is_registered_l1(eth_token: Field) -> pub bool {\n        let eth_token = EthAddress::from_field(eth_token);\n        !storage.l1_tokens.at(eth_token).read().is_zero()\n    }\n\n    unconstrained fn is_registered_l2(aztec_token: AztecAddress) -> pub bool {\n        !storage.l2_tokens.at(aztec_token).read().is_zero()\n    }\n\n    unconstrained fn get_l2_token(eth_token: Field) -> pub AztecAddress {\n        let eth_token = EthAddress::from_field(eth_token);\n        storage.l1_tokens.at(eth_token).read()\n    }\n\n    unconstrained fn get_l1_token(aztec_token: AztecAddress) -> pub EthAddress {\n        storage.l2_tokens.at(aztec_token).read()\n    }\n\n    unconstrained fn get_l1_portal() -> pub EthAddress {\n        storage.l1_portal.read()\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "61": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/authwit/src/auth.nr",
      "source": "use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\nuse dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::ToField,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\nglobal IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "69": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T, let N: u32> CapsuleArray<T>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T) {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().unkonstrained().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n}\n"
    },
    "70": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.set_public_teardown_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "77": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, FromField, Hash, ToField},\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        execution_cache::store(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            enqueue_public_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.set_public_teardown_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            set_public_teardown_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "78": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, args);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, args);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "79": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "80": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "82": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/discovery/mod.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS, debug_log::debug_log,\n};\n\npub mod private_logs;\npub mod partial_notes;\npub mod nonce_discovery;\n\n/// We reserve two fields in the note private log that are not part of the note content: one for the storage slot, and\n/// one for the combined log and note type ID.\nglobal NOTE_PRIVATE_LOG_RESERVED_FIELDS: u32 = 2;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size and extra\n/// fields in the log (e.g. the combined log and note type ID).\n// TODO (#11634): we're assuming here that the entire log is plaintext, which is not true due to headers, encryption\n// padding, etc. Notes can't actually be this large.\npub global MAX_NOTE_PACKED_LEN: u32 = PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_PRIVATE_LOG_RESERVED_FIELDS;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of note discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note_content, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note_content */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the note discovery process, in which private and public logs are downloaded and inspected to find private\n/// notes, partial notes, and their completion. This is the mechanism via which PXE learns of new notes.\n///\n/// Receives the address of the contract on which discovery is performed (i.e. the contract that emitted the notes)\n/// along with its `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_notes<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing note discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "83": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/discovery/nonce_discovery.nr",
      "source": "use crate::{discovery::{ComputeNoteHashAndNullifier, MAX_NOTE_PACKED_LEN}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting note discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    array::for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n            // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n            // the note hash at the array index we're currently processing.\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes = compute_note_hash_and_nullifier(\n                packed_note_content,\n                storage_slot,\n                note_type_id,\n                contract_address,\n                candidate_nonce,\n            )\n                .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n            let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n            let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n            if unique_note_hash == expected_unique_note_hash {\n                // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n                // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n                // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n                // PXE may fail to realize that a given note has been nullified already, and calls to the application\n                // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n                // application already has more direct means of making a call to it fail the transaction.\n                discovered_notes.push(\n                    DiscoveredNoteInfo {\n                        nonce: candidate_nonce,\n                        note_hash: hashes.note_hash,\n                        inner_nullifier: hashes.inner_nullifier,\n                    },\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n"
    },
    "84": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    discovery::{\n        ComputeNoteHashAndNullifier,\n        nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n        private_logs::MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN,\n    },\n    oracle::note_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    traits::{Deserialize, Serialize, ToField},\n};\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\n// TODO(#11630): come up with some sort of slot allocation scheme.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = 77;\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    let mut i = &mut 0;\n    whyle(\n        || *i < pending_partial_notes.len(),\n        || {\n            let pending_partial_note: DeliveredPendingPartialNote = pending_partial_notes.get(*i);\n\n            let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n            if maybe_log.is_none() {\n                debug_log_format(\n                    \"Found no completion logs for partial note #{}\",\n                    [(*i) as Field],\n                );\n                *i += 1 as u32;\n                // Note that we're not removing the pending partial note from the PXE DB, so we will continue searching\n                // for this tagged log when performing note discovery in the future until we either find it or the entry\n                // is somehow removed from the PXE DB.\n            } else {\n                debug_log_format(\"Completion log found for partial note #{}\", [(*i) as Field]);\n                let log = maybe_log.unwrap();\n\n                // Public logs have an extra field at the beginning with the contract address, which we use to verify\n                // that we're getting the logs from the expected contract.\n                // TODO(#10273): improve how contract log siloing is handled\n                assert_eq(\n                    log.log_content.get(0),\n                    contract_address.to_field(),\n                    \"Got a public log emitted by a different contract\",\n                );\n\n                // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n                // private and public packed fields (i.e. the contents of the log sans the extra fields) to get the\n                // complete packed content.\n                let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                    array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n                let complete_packed_note_content = array::append(\n                    pending_partial_note.packed_private_note_content,\n                    packed_public_note_content,\n                );\n\n                let discovered_notes = attempt_note_nonce_discovery(\n                    log.unique_note_hashes_in_tx,\n                    log.first_nullifier_in_tx,\n                    compute_note_hash_and_nullifier,\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    pending_partial_note.note_type_id,\n                    complete_packed_note_content,\n                );\n\n                debug_log_format(\n                    \"Discovered {0} notes for partial note {1}\",\n                    [discovered_notes.len() as Field, (*i) as Field],\n                );\n\n                array::for_each_in_bounded_vec(\n                    discovered_notes,\n                    |discovered_note: DiscoveredNoteInfo, _| {\n                        // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                        // temporary node connectivity issue - is simply throwing good enough here?\n                        assert(\n                            deliver_note(\n                                contract_address,\n                                pending_partial_note.storage_slot,\n                                discovered_note.nonce,\n                                complete_packed_note_content,\n                                discovered_note.note_hash,\n                                discovered_note.inner_nullifier,\n                                log.tx_hash,\n                                pending_partial_note.recipient,\n                            ),\n                            \"Failed to deliver note\",\n                        );\n                    },\n                );\n\n                // Because there is only a single log for a given tag, once we've processed the tagged log then we\n                // simply delete the pending work entry, regardless of whether it was actually completed or not.\n                // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n                // being completed.\n                pending_partial_notes.remove(*i);\n            }\n        },\n    );\n}\n\n/// Custom version of a while loop, calls `body` repeatedly until `condition` returns false. To be removed once Noir\n/// supports looping in unconstrained code.\nfn whyle<Env, Env2>(condition: fn[Env]() -> bool, body: fn[Env2]() -> ()) {\n    if condition() {\n        body();\n        whyle(condition, body);\n    }\n}\n"
    },
    "85": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/discovery/private_logs.nr",
      "source": "use std::static_assert;\n\nuse crate::{\n    capsules::CapsuleArray,\n    oracle::note_discovery::{deliver_note, sync_notes},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\n    debug_log::{debug_log, debug_log_format},\n};\n\nuse crate::discovery::{\n    ComputeNoteHashAndNullifier,\n    MAX_NOTE_PACKED_LEN,\n    nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n    NOTE_PRIVATE_LOG_RESERVED_FIELDS,\n    partial_notes::{\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT, DeliveredPendingPartialNote,\n    },\n};\n\npub global PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN: u32 = 1;\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private log (i.e.\n/// the note completion log tag).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_NOTE_PACKED_LEN - PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN;\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    _contract_address: AztecAddress,\n    _compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually fetch tagged logs, decrypt and process them here, but for now we simply call the `syncNotes`\n    // oracle. This has PXE perform tag synchronization, log download, decryption, and finally calls to the the\n    // `process_log` contract function with the decrypted payload, which will in turn call `do_process_log` with a\n    // decrypted log, letting us continue the work outside of PXE.\n    sync_notes();\n}\n\n/// Processes a log's plaintext, searching for private notes or partial notes. Private notes result in nonce discovery\n/// being performed prior to delivery, which requires knowledge of the transaction hash in which the notes would've been\n/// created (typically the same transaction in which the log was emitted), along with the list of unique note hashes in\n/// said transaction and the `compute_note_hash_and_nullifier` function.\npub unconstrained fn do_process_log<Env>(\n    contract_address: AztecAddress,\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // The first thing to do is to determine what type of private log we're processing. We currently just have two log\n    // types: 0 for private notes and 1 for partial notes. This will likely be expanded and improved upon in the future\n    // to also handle events, etc.\n\n    let (storage_slot, note_type_id, log_type_id, log_payload) =\n        destructure_log_plaintext(log_plaintext);\n\n    if log_type_id == 0 {\n        debug_log(\"Processing private note log\");\n\n        process_private_note_log(\n            contract_address,\n            tx_hash,\n            unique_note_hashes_in_tx,\n            first_nullifier_in_tx,\n            recipient,\n            compute_note_hash_and_nullifier,\n            storage_slot,\n            note_type_id,\n            log_payload,\n        );\n    } else if log_type_id == 1 {\n        debug_log(\"Processing partial note private log\");\n\n        process_partial_note_private_log(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            log_payload,\n            recipient,\n        );\n    } else {\n        panic(f\"Unknown log type id {log_type_id}\");\n    }\n}\n\nunconstrained fn destructure_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    assert(log_plaintext.len() >= NOTE_PRIVATE_LOG_RESERVED_FIELDS);\n\n    // If NOTE_PRIVATE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\n    // `storage_slot` and `note_type_id` must be updated as well.\n    static_assert(\n        NOTE_PRIVATE_LOG_RESERVED_FIELDS == 2,\n        \"unexpected value for NOTE_PRIVATE_LOG_RESERVED_FIELDS\",\n    );\n    let storage_slot = log_plaintext.get(0);\n\n    // We currently identify log types by packing the log type ID and note type ID into a single field, called the\n    // combined type ID. We can do this because the note type ID is only 7 bits long, and so use an 8th bit to\n    // distinguish private note logs and partial note logs.\n    // This abuses the fact that the encoding of both of these logs is extremely similar, and will need improving and\n    // more formalization once we introduce other disimilar log types, such as events. Ideally we'd be able to leverage\n    // enums and tagged unions to achieve this goal.\n    let combined_type_id = log_plaintext.get(1);\n    let note_type_id = ((combined_type_id as u64) % 128) as Field;\n    let log_type_id = ((combined_type_id as u64) / 128) as Field;\n\n    let log_payload = array::subbvec(log_plaintext, NOTE_PRIVATE_LOG_RESERVED_FIELDS);\n\n    (storage_slot, note_type_id, log_type_id, log_payload)\n}\n\nunconstrained fn process_private_note_log<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note_content,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private log\",\n        [discovered_notes.len() as Field],\n    );\n\n    array::for_each_in_bounded_vec(\n        discovered_notes,\n        |discovered_note: DiscoveredNoteInfo, _| {\n            // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n            // issue, and we should perhaps not have marked the tag index as taken.\n            assert(\n                deliver_note(\n                    contract_address,\n                    storage_slot,\n                    discovered_note.nonce,\n                    packed_note_content,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    tx_hash,\n                    recipient,\n                ),\n                \"Failed to deliver note\",\n            );\n        },\n    );\n}\n\nunconstrained fn process_partial_note_private_log(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    log_payload: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    recipient: AztecAddress,\n) {\n    // We store the information of the partial note we found so that we can later search for the public log that will\n    // complete it. The tag is the first value in the payload, with the packed note content taking up the rest of it.\n    static_assert(\n        PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN == 1,\n        \"unexpected value for PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN\",\n    );\n\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag: log_payload.get(0),\n        storage_slot,\n        note_type_id,\n        packed_private_note_content: array::subbvec(log_payload, 1),\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n"
    },
    "97": {
      "path": "/home/vscode/nargo/github.com/AztecProtocol/aztec-packages/v0.80.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    }
  }
}
